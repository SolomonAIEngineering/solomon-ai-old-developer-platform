
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model VirtualProfile
 * 
 */
export type VirtualProfile = $Result.DefaultSelection<Prisma.$VirtualProfilePayload>
/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model CommunityProfile
 * 
 */
export type CommunityProfile = $Result.DefaultSelection<Prisma.$CommunityProfilePayload>
/**
 * Model Topic
 * 
 */
export type Topic = $Result.DefaultSelection<Prisma.$TopicPayload>
/**
 * Model Publication
 * 
 */
export type Publication = $Result.DefaultSelection<Prisma.$PublicationPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model PollPost
 * 
 */
export type PollPost = $Result.DefaultSelection<Prisma.$PollPostPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model CommentReply
 * 
 */
export type CommentReply = $Result.DefaultSelection<Prisma.$CommentReplyPayload>
/**
 * Model Reaction
 * 
 */
export type Reaction = $Result.DefaultSelection<Prisma.$ReactionPayload>
/**
 * Model Bookmark
 * 
 */
export type Bookmark = $Result.DefaultSelection<Prisma.$BookmarkPayload>
/**
 * Model Block
 * 
 */
export type Block = $Result.DefaultSelection<Prisma.$BlockPayload>
/**
 * Model Follow
 * 
 */
export type Follow = $Result.DefaultSelection<Prisma.$FollowPayload>
/**
 * Model UserTag
 * 
 */
export type UserTag = $Result.DefaultSelection<Prisma.$UserTagPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Space
 * 
 */
export type Space = $Result.DefaultSelection<Prisma.$SpacePayload>
/**
 * Model Channel
 * 
 */
export type Channel = $Result.DefaultSelection<Prisma.$ChannelPayload>
/**
 * Model Thread
 * 
 */
export type Thread = $Result.DefaultSelection<Prisma.$ThreadPayload>
/**
 * Model Note
 * 
 */
export type Note = $Result.DefaultSelection<Prisma.$NotePayload>
/**
 * Model SpaceMember
 * 
 */
export type SpaceMember = $Result.DefaultSelection<Prisma.$SpaceMemberPayload>
/**
 * Model ChannelMember
 * 
 */
export type ChannelMember = $Result.DefaultSelection<Prisma.$ChannelMemberPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MediaType: {
  MEDIA_TYPE_UNSPECIFIED: 'MEDIA_TYPE_UNSPECIFIED',
  MEDIA_TYPE_IMAGE: 'MEDIA_TYPE_IMAGE',
  MEDIA_TYPE_VIDEO: 'MEDIA_TYPE_VIDEO',
  MEDIA_TYPE_AUDIO: 'MEDIA_TYPE_AUDIO',
  MEDIA_TYPE_DOCUMENT: 'MEDIA_TYPE_DOCUMENT',
  MEDIA_TYPE_SPREADSHEET: 'MEDIA_TYPE_SPREADSHEET',
  MEDIA_TYPE_PRESENTATION: 'MEDIA_TYPE_PRESENTATION',
  MEDIA_TYPE_PDF: 'MEDIA_TYPE_PDF',
  MEDIA_TYPE_CODE: 'MEDIA_TYPE_CODE',
  MEDIA_TYPE_ZIP: 'MEDIA_TYPE_ZIP',
  MEDIA_TYPE_3D: 'MEDIA_TYPE_3D',
  MEDIA_TYPE_AR: 'MEDIA_TYPE_AR',
  MEDIA_TYPE_CAD: 'MEDIA_TYPE_CAD',
  MEDIA_TYPE_VECTOR: 'MEDIA_TYPE_VECTOR'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const PostStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED',
  HIDDEN: 'HIDDEN'
};

export type PostStatus = (typeof PostStatus)[keyof typeof PostStatus]


export const PostType: {
  POST_TYPE_UNSPECIFIED: 'POST_TYPE_UNSPECIFIED',
  POST: 'POST',
  REPOST: 'REPOST',
  QUESTION: 'QUESTION',
  ACHIEVEMENT: 'ACHIEVEMENT',
  ANNOUNCEMENT: 'ANNOUNCEMENT',
  POLL: 'POLL',
  ARTICLE: 'ARTICLE',
  SHORT_STORY: 'SHORT_STORY'
};

export type PostType = (typeof PostType)[keyof typeof PostType]


export const Category: {
  CATEGORY_UNSPECIFIED: 'CATEGORY_UNSPECIFIED',
  WORLD: 'WORLD',
  BUSINESS: 'BUSINESS',
  ECONOMICS: 'ECONOMICS',
  FOREIGN_POLICY: 'FOREIGN_POLICY',
  POLITICS: 'POLITICS',
  TECHNOLOGY: 'TECHNOLOGY',
  OTHER: 'OTHER'
};

export type Category = (typeof Category)[keyof typeof Category]


export const ThreadParticipantType: {
  THREAD_PARTICIPANT_TYPE_UNSPECIFIED: 'THREAD_PARTICIPANT_TYPE_UNSPECIFIED',
  PARENT: 'PARENT',
  PARTICIPANT: 'PARTICIPANT'
};

export type ThreadParticipantType = (typeof ThreadParticipantType)[keyof typeof ThreadParticipantType]


export const AccountType: {
  ACCOUNT_TYPE_UNSPECIFIED: 'ACCOUNT_TYPE_UNSPECIFIED',
  USER: 'USER',
  COMMUNITY: 'COMMUNITY'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const Visibility: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE',
  FOLLOWERS_ONLY: 'FOLLOWERS_ONLY',
  COMMUNITY_ONLY: 'COMMUNITY_ONLY',
  RESTRICTED: 'RESTRICTED',
  ORGANIZATION: 'ORGANIZATION'
};

export type Visibility = (typeof Visibility)[keyof typeof Visibility]


export const ReactionType: {
  UNSPECIFIED: 'UNSPECIFIED',
  LIKE: 'LIKE',
  LOVE: 'LOVE',
  HAHA: 'HAHA',
  WOW: 'WOW',
  SAD: 'SAD',
  ANGRY: 'ANGRY',
  DISLIKE: 'DISLIKE',
  CELEBRATE: 'CELEBRATE'
};

export type ReactionType = (typeof ReactionType)[keyof typeof ReactionType]


export const ReportReason: {
  SPAM: 'SPAM',
  HARASSMENT: 'HARASSMENT',
  HATE_SPEECH: 'HATE_SPEECH',
  MISINFORMATION: 'MISINFORMATION',
  VIOLENCE: 'VIOLENCE',
  ADULT_CONTENT: 'ADULT_CONTENT',
  OTHER: 'OTHER'
};

export type ReportReason = (typeof ReportReason)[keyof typeof ReportReason]


export const ReportStatus: {
  PENDING: 'PENDING',
  INVESTIGATING: 'INVESTIGATING',
  RESOLVED: 'RESOLVED',
  DISMISSED: 'DISMISSED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const NotificationType: {
  FOLLOW: 'FOLLOW',
  LIKE: 'LIKE',
  COMMENT: 'COMMENT',
  MENTION: 'MENTION',
  POST: 'POST',
  REPORT_UPDATE: 'REPORT_UPDATE',
  COMMUNITY_INVITE: 'COMMUNITY_INVITE',
  COMMUNITY_UPDATE: 'COMMUNITY_UPDATE'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const SpaceType: {
  SPACE_TYPE_UNSPECIFIED: 'SPACE_TYPE_UNSPECIFIED',
  TEAM: 'TEAM',
  PROJECT: 'PROJECT',
  DEPARTMENT: 'DEPARTMENT',
  ANNOUNCEMENT: 'ANNOUNCEMENT',
  KNOWLEDGE_BASE: 'KNOWLEDGE_BASE',
  SOCIAL: 'SOCIAL',
  LEARNING: 'LEARNING',
  INNOVATION: 'INNOVATION'
};

export type SpaceType = (typeof SpaceType)[keyof typeof SpaceType]


export const AccessLevel: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE',
  RESTRICTED: 'RESTRICTED',
  ORGANIZATION: 'ORGANIZATION'
};

export type AccessLevel = (typeof AccessLevel)[keyof typeof AccessLevel]

}

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type PostStatus = $Enums.PostStatus

export const PostStatus: typeof $Enums.PostStatus

export type PostType = $Enums.PostType

export const PostType: typeof $Enums.PostType

export type Category = $Enums.Category

export const Category: typeof $Enums.Category

export type ThreadParticipantType = $Enums.ThreadParticipantType

export const ThreadParticipantType: typeof $Enums.ThreadParticipantType

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type Visibility = $Enums.Visibility

export const Visibility: typeof $Enums.Visibility

export type ReactionType = $Enums.ReactionType

export const ReactionType: typeof $Enums.ReactionType

export type ReportReason = $Enums.ReportReason

export const ReportReason: typeof $Enums.ReportReason

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type SpaceType = $Enums.SpaceType

export const SpaceType: typeof $Enums.SpaceType

export type AccessLevel = $Enums.AccessLevel

export const AccessLevel: typeof $Enums.AccessLevel

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more VirtualProfiles
 * const virtualProfiles = await prisma.virtualProfile.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more VirtualProfiles
   * const virtualProfiles = await prisma.virtualProfile.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.virtualProfile`: Exposes CRUD operations for the **VirtualProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VirtualProfiles
    * const virtualProfiles = await prisma.virtualProfile.findMany()
    * ```
    */
  get virtualProfile(): Prisma.VirtualProfileDelegate<ExtArgs>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs>;

  /**
   * `prisma.communityProfile`: Exposes CRUD operations for the **CommunityProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityProfiles
    * const communityProfiles = await prisma.communityProfile.findMany()
    * ```
    */
  get communityProfile(): Prisma.CommunityProfileDelegate<ExtArgs>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **Topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topic.findMany()
    * ```
    */
  get topic(): Prisma.TopicDelegate<ExtArgs>;

  /**
   * `prisma.publication`: Exposes CRUD operations for the **Publication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publications
    * const publications = await prisma.publication.findMany()
    * ```
    */
  get publication(): Prisma.PublicationDelegate<ExtArgs>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs>;

  /**
   * `prisma.pollPost`: Exposes CRUD operations for the **PollPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PollPosts
    * const pollPosts = await prisma.pollPost.findMany()
    * ```
    */
  get pollPost(): Prisma.PollPostDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.commentReply`: Exposes CRUD operations for the **CommentReply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentReplies
    * const commentReplies = await prisma.commentReply.findMany()
    * ```
    */
  get commentReply(): Prisma.CommentReplyDelegate<ExtArgs>;

  /**
   * `prisma.reaction`: Exposes CRUD operations for the **Reaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reactions
    * const reactions = await prisma.reaction.findMany()
    * ```
    */
  get reaction(): Prisma.ReactionDelegate<ExtArgs>;

  /**
   * `prisma.bookmark`: Exposes CRUD operations for the **Bookmark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookmarks
    * const bookmarks = await prisma.bookmark.findMany()
    * ```
    */
  get bookmark(): Prisma.BookmarkDelegate<ExtArgs>;

  /**
   * `prisma.block`: Exposes CRUD operations for the **Block** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.block.findMany()
    * ```
    */
  get block(): Prisma.BlockDelegate<ExtArgs>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.FollowDelegate<ExtArgs>;

  /**
   * `prisma.userTag`: Exposes CRUD operations for the **UserTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTags
    * const userTags = await prisma.userTag.findMany()
    * ```
    */
  get userTag(): Prisma.UserTagDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.space`: Exposes CRUD operations for the **Space** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spaces
    * const spaces = await prisma.space.findMany()
    * ```
    */
  get space(): Prisma.SpaceDelegate<ExtArgs>;

  /**
   * `prisma.channel`: Exposes CRUD operations for the **Channel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channel.findMany()
    * ```
    */
  get channel(): Prisma.ChannelDelegate<ExtArgs>;

  /**
   * `prisma.thread`: Exposes CRUD operations for the **Thread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Threads
    * const threads = await prisma.thread.findMany()
    * ```
    */
  get thread(): Prisma.ThreadDelegate<ExtArgs>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.note.findMany()
    * ```
    */
  get note(): Prisma.NoteDelegate<ExtArgs>;

  /**
   * `prisma.spaceMember`: Exposes CRUD operations for the **SpaceMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpaceMembers
    * const spaceMembers = await prisma.spaceMember.findMany()
    * ```
    */
  get spaceMember(): Prisma.SpaceMemberDelegate<ExtArgs>;

  /**
   * `prisma.channelMember`: Exposes CRUD operations for the **ChannelMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChannelMembers
    * const channelMembers = await prisma.channelMember.findMany()
    * ```
    */
  get channelMember(): Prisma.ChannelMemberDelegate<ExtArgs>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.21.1
   * Query Engine version: bf0e5e8a04cada8225617067eaa03d041e2bba36
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    VirtualProfile: 'VirtualProfile',
    UserProfile: 'UserProfile',
    CommunityProfile: 'CommunityProfile',
    Topic: 'Topic',
    Publication: 'Publication',
    Media: 'Media',
    Post: 'Post',
    PollPost: 'PollPost',
    Comment: 'Comment',
    CommentReply: 'CommentReply',
    Reaction: 'Reaction',
    Bookmark: 'Bookmark',
    Block: 'Block',
    Follow: 'Follow',
    UserTag: 'UserTag',
    Report: 'Report',
    Notification: 'Notification',
    Space: 'Space',
    Channel: 'Channel',
    Thread: 'Thread',
    Note: 'Note',
    SpaceMember: 'SpaceMember',
    ChannelMember: 'ChannelMember',
    File: 'File'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "virtualProfile" | "userProfile" | "communityProfile" | "topic" | "publication" | "media" | "post" | "pollPost" | "comment" | "commentReply" | "reaction" | "bookmark" | "block" | "follow" | "userTag" | "report" | "notification" | "space" | "channel" | "thread" | "note" | "spaceMember" | "channelMember" | "file"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      VirtualProfile: {
        payload: Prisma.$VirtualProfilePayload<ExtArgs>
        fields: Prisma.VirtualProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VirtualProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VirtualProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualProfilePayload>
          }
          findFirst: {
            args: Prisma.VirtualProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VirtualProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualProfilePayload>
          }
          findMany: {
            args: Prisma.VirtualProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualProfilePayload>[]
          }
          create: {
            args: Prisma.VirtualProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualProfilePayload>
          }
          createMany: {
            args: Prisma.VirtualProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VirtualProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualProfilePayload>[]
          }
          delete: {
            args: Prisma.VirtualProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualProfilePayload>
          }
          update: {
            args: Prisma.VirtualProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualProfilePayload>
          }
          deleteMany: {
            args: Prisma.VirtualProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VirtualProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VirtualProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualProfilePayload>
          }
          aggregate: {
            args: Prisma.VirtualProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVirtualProfile>
          }
          groupBy: {
            args: Prisma.VirtualProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<VirtualProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.VirtualProfileCountArgs<ExtArgs>
            result: $Utils.Optional<VirtualProfileCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      CommunityProfile: {
        payload: Prisma.$CommunityProfilePayload<ExtArgs>
        fields: Prisma.CommunityProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityProfilePayload>
          }
          findFirst: {
            args: Prisma.CommunityProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityProfilePayload>
          }
          findMany: {
            args: Prisma.CommunityProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityProfilePayload>[]
          }
          create: {
            args: Prisma.CommunityProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityProfilePayload>
          }
          createMany: {
            args: Prisma.CommunityProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityProfilePayload>[]
          }
          delete: {
            args: Prisma.CommunityProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityProfilePayload>
          }
          update: {
            args: Prisma.CommunityProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityProfilePayload>
          }
          deleteMany: {
            args: Prisma.CommunityProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommunityProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityProfilePayload>
          }
          aggregate: {
            args: Prisma.CommunityProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunityProfile>
          }
          groupBy: {
            args: Prisma.CommunityProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityProfileCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityProfileCountAggregateOutputType> | number
          }
        }
      }
      Topic: {
        payload: Prisma.$TopicPayload<ExtArgs>
        fields: Prisma.TopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findFirst: {
            args: Prisma.TopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findMany: {
            args: Prisma.TopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          create: {
            args: Prisma.TopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          createMany: {
            args: Prisma.TopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          delete: {
            args: Prisma.TopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          update: {
            args: Prisma.TopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          deleteMany: {
            args: Prisma.TopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          aggregate: {
            args: Prisma.TopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopic>
          }
          groupBy: {
            args: Prisma.TopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicCountArgs<ExtArgs>
            result: $Utils.Optional<TopicCountAggregateOutputType> | number
          }
        }
      }
      Publication: {
        payload: Prisma.$PublicationPayload<ExtArgs>
        fields: Prisma.PublicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PublicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PublicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          findFirst: {
            args: Prisma.PublicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PublicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          findMany: {
            args: Prisma.PublicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>[]
          }
          create: {
            args: Prisma.PublicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          createMany: {
            args: Prisma.PublicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PublicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>[]
          }
          delete: {
            args: Prisma.PublicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          update: {
            args: Prisma.PublicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          deleteMany: {
            args: Prisma.PublicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PublicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PublicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          aggregate: {
            args: Prisma.PublicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublication>
          }
          groupBy: {
            args: Prisma.PublicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PublicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PublicationCountArgs<ExtArgs>
            result: $Utils.Optional<PublicationCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      PollPost: {
        payload: Prisma.$PollPostPayload<ExtArgs>
        fields: Prisma.PollPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PollPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PollPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload>
          }
          findFirst: {
            args: Prisma.PollPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PollPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload>
          }
          findMany: {
            args: Prisma.PollPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload>[]
          }
          create: {
            args: Prisma.PollPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload>
          }
          createMany: {
            args: Prisma.PollPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PollPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload>[]
          }
          delete: {
            args: Prisma.PollPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload>
          }
          update: {
            args: Prisma.PollPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload>
          }
          deleteMany: {
            args: Prisma.PollPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PollPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PollPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload>
          }
          aggregate: {
            args: Prisma.PollPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePollPost>
          }
          groupBy: {
            args: Prisma.PollPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PollPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PollPostCountArgs<ExtArgs>
            result: $Utils.Optional<PollPostCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      CommentReply: {
        payload: Prisma.$CommentReplyPayload<ExtArgs>
        fields: Prisma.CommentReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentReplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentReplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          findFirst: {
            args: Prisma.CommentReplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentReplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          findMany: {
            args: Prisma.CommentReplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>[]
          }
          create: {
            args: Prisma.CommentReplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          createMany: {
            args: Prisma.CommentReplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentReplyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>[]
          }
          delete: {
            args: Prisma.CommentReplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          update: {
            args: Prisma.CommentReplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          deleteMany: {
            args: Prisma.CommentReplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentReplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentReplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          aggregate: {
            args: Prisma.CommentReplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentReply>
          }
          groupBy: {
            args: Prisma.CommentReplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentReplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentReplyCountArgs<ExtArgs>
            result: $Utils.Optional<CommentReplyCountAggregateOutputType> | number
          }
        }
      }
      Reaction: {
        payload: Prisma.$ReactionPayload<ExtArgs>
        fields: Prisma.ReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          findFirst: {
            args: Prisma.ReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          findMany: {
            args: Prisma.ReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>[]
          }
          create: {
            args: Prisma.ReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          createMany: {
            args: Prisma.ReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>[]
          }
          delete: {
            args: Prisma.ReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          update: {
            args: Prisma.ReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          deleteMany: {
            args: Prisma.ReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          aggregate: {
            args: Prisma.ReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReaction>
          }
          groupBy: {
            args: Prisma.ReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReactionCountArgs<ExtArgs>
            result: $Utils.Optional<ReactionCountAggregateOutputType> | number
          }
        }
      }
      Bookmark: {
        payload: Prisma.$BookmarkPayload<ExtArgs>
        fields: Prisma.BookmarkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookmarkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookmarkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          findFirst: {
            args: Prisma.BookmarkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookmarkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          findMany: {
            args: Prisma.BookmarkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>[]
          }
          create: {
            args: Prisma.BookmarkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          createMany: {
            args: Prisma.BookmarkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookmarkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>[]
          }
          delete: {
            args: Prisma.BookmarkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          update: {
            args: Prisma.BookmarkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          deleteMany: {
            args: Prisma.BookmarkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookmarkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookmarkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          aggregate: {
            args: Prisma.BookmarkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookmark>
          }
          groupBy: {
            args: Prisma.BookmarkGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookmarkGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookmarkCountArgs<ExtArgs>
            result: $Utils.Optional<BookmarkCountAggregateOutputType> | number
          }
        }
      }
      Block: {
        payload: Prisma.$BlockPayload<ExtArgs>
        fields: Prisma.BlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findFirst: {
            args: Prisma.BlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findMany: {
            args: Prisma.BlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          create: {
            args: Prisma.BlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          createMany: {
            args: Prisma.BlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          delete: {
            args: Prisma.BlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          update: {
            args: Prisma.BlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          deleteMany: {
            args: Prisma.BlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          aggregate: {
            args: Prisma.BlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlock>
          }
          groupBy: {
            args: Prisma.BlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockCountArgs<ExtArgs>
            result: $Utils.Optional<BlockCountAggregateOutputType> | number
          }
        }
      }
      Follow: {
        payload: Prisma.$FollowPayload<ExtArgs>
        fields: Prisma.FollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findFirst: {
            args: Prisma.FollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findMany: {
            args: Prisma.FollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          create: {
            args: Prisma.FollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          createMany: {
            args: Prisma.FollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          delete: {
            args: Prisma.FollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          update: {
            args: Prisma.FollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          deleteMany: {
            args: Prisma.FollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollow>
          }
          groupBy: {
            args: Prisma.FollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowCountArgs<ExtArgs>
            result: $Utils.Optional<FollowCountAggregateOutputType> | number
          }
        }
      }
      UserTag: {
        payload: Prisma.$UserTagPayload<ExtArgs>
        fields: Prisma.UserTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          findFirst: {
            args: Prisma.UserTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          findMany: {
            args: Prisma.UserTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>[]
          }
          create: {
            args: Prisma.UserTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          createMany: {
            args: Prisma.UserTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>[]
          }
          delete: {
            args: Prisma.UserTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          update: {
            args: Prisma.UserTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          deleteMany: {
            args: Prisma.UserTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          aggregate: {
            args: Prisma.UserTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTag>
          }
          groupBy: {
            args: Prisma.UserTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTagCountArgs<ExtArgs>
            result: $Utils.Optional<UserTagCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Space: {
        payload: Prisma.$SpacePayload<ExtArgs>
        fields: Prisma.SpaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          findFirst: {
            args: Prisma.SpaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          findMany: {
            args: Prisma.SpaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>[]
          }
          create: {
            args: Prisma.SpaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          createMany: {
            args: Prisma.SpaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>[]
          }
          delete: {
            args: Prisma.SpaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          update: {
            args: Prisma.SpaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          deleteMany: {
            args: Prisma.SpaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          aggregate: {
            args: Prisma.SpaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpace>
          }
          groupBy: {
            args: Prisma.SpaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpaceCountArgs<ExtArgs>
            result: $Utils.Optional<SpaceCountAggregateOutputType> | number
          }
        }
      }
      Channel: {
        payload: Prisma.$ChannelPayload<ExtArgs>
        fields: Prisma.ChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findFirst: {
            args: Prisma.ChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findMany: {
            args: Prisma.ChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          create: {
            args: Prisma.ChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          createMany: {
            args: Prisma.ChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          delete: {
            args: Prisma.ChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          update: {
            args: Prisma.ChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          deleteMany: {
            args: Prisma.ChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          aggregate: {
            args: Prisma.ChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannel>
          }
          groupBy: {
            args: Prisma.ChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelCountAggregateOutputType> | number
          }
        }
      }
      Thread: {
        payload: Prisma.$ThreadPayload<ExtArgs>
        fields: Prisma.ThreadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThreadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThreadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          findFirst: {
            args: Prisma.ThreadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThreadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          findMany: {
            args: Prisma.ThreadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>[]
          }
          create: {
            args: Prisma.ThreadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          createMany: {
            args: Prisma.ThreadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ThreadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>[]
          }
          delete: {
            args: Prisma.ThreadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          update: {
            args: Prisma.ThreadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          deleteMany: {
            args: Prisma.ThreadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ThreadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ThreadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          aggregate: {
            args: Prisma.ThreadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThread>
          }
          groupBy: {
            args: Prisma.ThreadGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThreadGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThreadCountArgs<ExtArgs>
            result: $Utils.Optional<ThreadCountAggregateOutputType> | number
          }
        }
      }
      Note: {
        payload: Prisma.$NotePayload<ExtArgs>
        fields: Prisma.NoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findFirst: {
            args: Prisma.NoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findMany: {
            args: Prisma.NoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          create: {
            args: Prisma.NoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          createMany: {
            args: Prisma.NoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          delete: {
            args: Prisma.NoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          update: {
            args: Prisma.NoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          deleteMany: {
            args: Prisma.NoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          aggregate: {
            args: Prisma.NoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNote>
          }
          groupBy: {
            args: Prisma.NoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteCountArgs<ExtArgs>
            result: $Utils.Optional<NoteCountAggregateOutputType> | number
          }
        }
      }
      SpaceMember: {
        payload: Prisma.$SpaceMemberPayload<ExtArgs>
        fields: Prisma.SpaceMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpaceMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpaceMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload>
          }
          findFirst: {
            args: Prisma.SpaceMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpaceMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload>
          }
          findMany: {
            args: Prisma.SpaceMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload>[]
          }
          create: {
            args: Prisma.SpaceMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload>
          }
          createMany: {
            args: Prisma.SpaceMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpaceMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload>[]
          }
          delete: {
            args: Prisma.SpaceMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload>
          }
          update: {
            args: Prisma.SpaceMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload>
          }
          deleteMany: {
            args: Prisma.SpaceMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpaceMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpaceMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload>
          }
          aggregate: {
            args: Prisma.SpaceMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpaceMember>
          }
          groupBy: {
            args: Prisma.SpaceMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpaceMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpaceMemberCountArgs<ExtArgs>
            result: $Utils.Optional<SpaceMemberCountAggregateOutputType> | number
          }
        }
      }
      ChannelMember: {
        payload: Prisma.$ChannelMemberPayload<ExtArgs>
        fields: Prisma.ChannelMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload>
          }
          findFirst: {
            args: Prisma.ChannelMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload>
          }
          findMany: {
            args: Prisma.ChannelMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload>[]
          }
          create: {
            args: Prisma.ChannelMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload>
          }
          createMany: {
            args: Prisma.ChannelMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChannelMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload>[]
          }
          delete: {
            args: Prisma.ChannelMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload>
          }
          update: {
            args: Prisma.ChannelMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload>
          }
          deleteMany: {
            args: Prisma.ChannelMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload>
          }
          aggregate: {
            args: Prisma.ChannelMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannelMember>
          }
          groupBy: {
            args: Prisma.ChannelMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelMemberCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type VirtualProfileCountOutputType
   */

  export type VirtualProfileCountOutputType = {
    userProfile: number
    communityProfile: number
  }

  export type VirtualProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | VirtualProfileCountOutputTypeCountUserProfileArgs
    communityProfile?: boolean | VirtualProfileCountOutputTypeCountCommunityProfileArgs
  }

  // Custom InputTypes
  /**
   * VirtualProfileCountOutputType without action
   */
  export type VirtualProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualProfileCountOutputType
     */
    select?: VirtualProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VirtualProfileCountOutputType without action
   */
  export type VirtualProfileCountOutputTypeCountUserProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
  }

  /**
   * VirtualProfileCountOutputType without action
   */
  export type VirtualProfileCountOutputTypeCountCommunityProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityProfileWhereInput
  }


  /**
   * Count Type UserProfileCountOutputType
   */

  export type UserProfileCountOutputType = {
    bookmarks: number
    tags: number
    adminPublications: number
    editorPublications: number
    blockedBy: number
    blocking: number
    followers: number
    following: number
    posts: number
    comments: number
    reactions: number
    notifications: number
    reportsSubmitted: number
    reportedContent: number
    moderatedCommunities: number
  }

  export type UserProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookmarks?: boolean | UserProfileCountOutputTypeCountBookmarksArgs
    tags?: boolean | UserProfileCountOutputTypeCountTagsArgs
    adminPublications?: boolean | UserProfileCountOutputTypeCountAdminPublicationsArgs
    editorPublications?: boolean | UserProfileCountOutputTypeCountEditorPublicationsArgs
    blockedBy?: boolean | UserProfileCountOutputTypeCountBlockedByArgs
    blocking?: boolean | UserProfileCountOutputTypeCountBlockingArgs
    followers?: boolean | UserProfileCountOutputTypeCountFollowersArgs
    following?: boolean | UserProfileCountOutputTypeCountFollowingArgs
    posts?: boolean | UserProfileCountOutputTypeCountPostsArgs
    comments?: boolean | UserProfileCountOutputTypeCountCommentsArgs
    reactions?: boolean | UserProfileCountOutputTypeCountReactionsArgs
    notifications?: boolean | UserProfileCountOutputTypeCountNotificationsArgs
    reportsSubmitted?: boolean | UserProfileCountOutputTypeCountReportsSubmittedArgs
    reportedContent?: boolean | UserProfileCountOutputTypeCountReportedContentArgs
    moderatedCommunities?: boolean | UserProfileCountOutputTypeCountModeratedCommunitiesArgs
  }

  // Custom InputTypes
  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileCountOutputType
     */
    select?: UserProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountBookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTagWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountAdminPublicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountEditorPublicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountBlockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountBlockingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountFollowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountReportsSubmittedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountReportedContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountModeratedCommunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityProfileWhereInput
  }


  /**
   * Count Type CommunityProfileCountOutputType
   */

  export type CommunityProfileCountOutputType = {
    topics: number
    posts: number
    moderators: number
  }

  export type CommunityProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | CommunityProfileCountOutputTypeCountTopicsArgs
    posts?: boolean | CommunityProfileCountOutputTypeCountPostsArgs
    moderators?: boolean | CommunityProfileCountOutputTypeCountModeratorsArgs
  }

  // Custom InputTypes
  /**
   * CommunityProfileCountOutputType without action
   */
  export type CommunityProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityProfileCountOutputType
     */
    select?: CommunityProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommunityProfileCountOutputType without action
   */
  export type CommunityProfileCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }

  /**
   * CommunityProfileCountOutputType without action
   */
  export type CommunityProfileCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * CommunityProfileCountOutputType without action
   */
  export type CommunityProfileCountOutputTypeCountModeratorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
  }


  /**
   * Count Type PublicationCountOutputType
   */

  export type PublicationCountOutputType = {
    bookmarks: number
    admins: number
    editors: number
    posts: number
  }

  export type PublicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookmarks?: boolean | PublicationCountOutputTypeCountBookmarksArgs
    admins?: boolean | PublicationCountOutputTypeCountAdminsArgs
    editors?: boolean | PublicationCountOutputTypeCountEditorsArgs
    posts?: boolean | PublicationCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * PublicationCountOutputType without action
   */
  export type PublicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationCountOutputType
     */
    select?: PublicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PublicationCountOutputType without action
   */
  export type PublicationCountOutputTypeCountBookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkWhereInput
  }

  /**
   * PublicationCountOutputType without action
   */
  export type PublicationCountOutputTypeCountAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
  }

  /**
   * PublicationCountOutputType without action
   */
  export type PublicationCountOutputTypeCountEditorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
  }

  /**
   * PublicationCountOutputType without action
   */
  export type PublicationCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type MediaCountOutputType
   */

  export type MediaCountOutputType = {
    commentReplies: number
    posts: number
    comments: number
    pollPosts: number
    notes: number
  }

  export type MediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commentReplies?: boolean | MediaCountOutputTypeCountCommentRepliesArgs
    posts?: boolean | MediaCountOutputTypeCountPostsArgs
    comments?: boolean | MediaCountOutputTypeCountCommentsArgs
    pollPosts?: boolean | MediaCountOutputTypeCountPollPostsArgs
    notes?: boolean | MediaCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes
  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCountOutputType
     */
    select?: MediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountCommentRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReplyWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountPollPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollPostWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    files: number
    comments: number
    reactions: number
    bookmarks: number
    publications: number
    reports: number
    notes: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | PostCountOutputTypeCountFilesArgs
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
    reactions?: boolean | PostCountOutputTypeCountReactionsArgs
    bookmarks?: boolean | PostCountOutputTypeCountBookmarksArgs
    publications?: boolean | PostCountOutputTypeCountPublicationsArgs
    reports?: boolean | PostCountOutputTypeCountReportsArgs
    notes?: boolean | PostCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountBookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountPublicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }


  /**
   * Count Type PollPostCountOutputType
   */

  export type PollPostCountOutputType = {
    comments: number
  }

  export type PollPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PollPostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * PollPostCountOutputType without action
   */
  export type PollPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPostCountOutputType
     */
    select?: PollPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PollPostCountOutputType without action
   */
  export type PollPostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
    notes: number
    Report: number
    Reaction: number
    UserProfile: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
    notes?: boolean | CommentCountOutputTypeCountNotesArgs
    Report?: boolean | CommentCountOutputTypeCountReportArgs
    Reaction?: boolean | CommentCountOutputTypeCountReactionArgs
    UserProfile?: boolean | CommentCountOutputTypeCountUserProfileArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReplyWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountReactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountUserProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
  }


  /**
   * Count Type BookmarkCountOutputType
   */

  export type BookmarkCountOutputType = {
    publications: number
    users: number
    posts: number
  }

  export type BookmarkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publications?: boolean | BookmarkCountOutputTypeCountPublicationsArgs
    users?: boolean | BookmarkCountOutputTypeCountUsersArgs
    posts?: boolean | BookmarkCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * BookmarkCountOutputType without action
   */
  export type BookmarkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkCountOutputType
     */
    select?: BookmarkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookmarkCountOutputType without action
   */
  export type BookmarkCountOutputTypeCountPublicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationWhereInput
  }

  /**
   * BookmarkCountOutputType without action
   */
  export type BookmarkCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
  }

  /**
   * BookmarkCountOutputType without action
   */
  export type BookmarkCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type SpaceCountOutputType
   */

  export type SpaceCountOutputType = {
    members: number
    channels: number
    posts: number
    files: number
    childSpaces: number
  }

  export type SpaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | SpaceCountOutputTypeCountMembersArgs
    channels?: boolean | SpaceCountOutputTypeCountChannelsArgs
    posts?: boolean | SpaceCountOutputTypeCountPostsArgs
    files?: boolean | SpaceCountOutputTypeCountFilesArgs
    childSpaces?: boolean | SpaceCountOutputTypeCountChildSpacesArgs
  }

  // Custom InputTypes
  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceCountOutputType
     */
    select?: SpaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceMemberWhereInput
  }

  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeCountChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
  }

  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeCountChildSpacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceWhereInput
  }


  /**
   * Count Type ChannelCountOutputType
   */

  export type ChannelCountOutputType = {
    posts: number
    files: number
    members: number
  }

  export type ChannelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | ChannelCountOutputTypeCountPostsArgs
    files?: boolean | ChannelCountOutputTypeCountFilesArgs
    members?: boolean | ChannelCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCountOutputType
     */
    select?: ChannelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelMemberWhereInput
  }


  /**
   * Count Type ThreadCountOutputType
   */

  export type ThreadCountOutputType = {
    posts: number
    pollPosts: number
  }

  export type ThreadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | ThreadCountOutputTypeCountPostsArgs
    pollPosts?: boolean | ThreadCountOutputTypeCountPollPostsArgs
  }

  // Custom InputTypes
  /**
   * ThreadCountOutputType without action
   */
  export type ThreadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadCountOutputType
     */
    select?: ThreadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ThreadCountOutputType without action
   */
  export type ThreadCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * ThreadCountOutputType without action
   */
  export type ThreadCountOutputTypeCountPollPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollPostWhereInput
  }


  /**
   * Count Type FileCountOutputType
   */

  export type FileCountOutputType = {
    posts: number
  }

  export type FileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | FileCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCountOutputType
     */
    select?: FileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Models
   */

  /**
   * Model VirtualProfile
   */

  export type AggregateVirtualProfile = {
    _count: VirtualProfileCountAggregateOutputType | null
    _min: VirtualProfileMinAggregateOutputType | null
    _max: VirtualProfileMaxAggregateOutputType | null
  }

  export type VirtualProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    profileType: string | null
    activated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VirtualProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    profileType: string | null
    activated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VirtualProfileCountAggregateOutputType = {
    id: number
    userId: number
    profileType: number
    activated: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VirtualProfileMinAggregateInputType = {
    id?: true
    userId?: true
    profileType?: true
    activated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VirtualProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    profileType?: true
    activated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VirtualProfileCountAggregateInputType = {
    id?: true
    userId?: true
    profileType?: true
    activated?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VirtualProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VirtualProfile to aggregate.
     */
    where?: VirtualProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualProfiles to fetch.
     */
    orderBy?: VirtualProfileOrderByWithRelationInput | VirtualProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VirtualProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VirtualProfiles
    **/
    _count?: true | VirtualProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VirtualProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VirtualProfileMaxAggregateInputType
  }

  export type GetVirtualProfileAggregateType<T extends VirtualProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateVirtualProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVirtualProfile[P]>
      : GetScalarType<T[P], AggregateVirtualProfile[P]>
  }




  export type VirtualProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VirtualProfileWhereInput
    orderBy?: VirtualProfileOrderByWithAggregationInput | VirtualProfileOrderByWithAggregationInput[]
    by: VirtualProfileScalarFieldEnum[] | VirtualProfileScalarFieldEnum
    having?: VirtualProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VirtualProfileCountAggregateInputType | true
    _min?: VirtualProfileMinAggregateInputType
    _max?: VirtualProfileMaxAggregateInputType
  }

  export type VirtualProfileGroupByOutputType = {
    id: string
    userId: string | null
    profileType: string | null
    activated: boolean | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: VirtualProfileCountAggregateOutputType | null
    _min: VirtualProfileMinAggregateOutputType | null
    _max: VirtualProfileMaxAggregateOutputType | null
  }

  type GetVirtualProfileGroupByPayload<T extends VirtualProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VirtualProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VirtualProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VirtualProfileGroupByOutputType[P]>
            : GetScalarType<T[P], VirtualProfileGroupByOutputType[P]>
        }
      >
    >


  export type VirtualProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileType?: boolean
    activated?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userProfile?: boolean | VirtualProfile$userProfileArgs<ExtArgs>
    communityProfile?: boolean | VirtualProfile$communityProfileArgs<ExtArgs>
    _count?: boolean | VirtualProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["virtualProfile"]>

  export type VirtualProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileType?: boolean
    activated?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["virtualProfile"]>

  export type VirtualProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    profileType?: boolean
    activated?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VirtualProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | VirtualProfile$userProfileArgs<ExtArgs>
    communityProfile?: boolean | VirtualProfile$communityProfileArgs<ExtArgs>
    _count?: boolean | VirtualProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VirtualProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VirtualProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VirtualProfile"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>[]
      communityProfile: Prisma.$CommunityProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      profileType: string | null
      activated: boolean | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["virtualProfile"]>
    composites: {}
  }

  type VirtualProfileGetPayload<S extends boolean | null | undefined | VirtualProfileDefaultArgs> = $Result.GetResult<Prisma.$VirtualProfilePayload, S>

  type VirtualProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VirtualProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VirtualProfileCountAggregateInputType | true
    }

  export interface VirtualProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VirtualProfile'], meta: { name: 'VirtualProfile' } }
    /**
     * Find zero or one VirtualProfile that matches the filter.
     * @param {VirtualProfileFindUniqueArgs} args - Arguments to find a VirtualProfile
     * @example
     * // Get one VirtualProfile
     * const virtualProfile = await prisma.virtualProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VirtualProfileFindUniqueArgs>(args: SelectSubset<T, VirtualProfileFindUniqueArgs<ExtArgs>>): Prisma__VirtualProfileClient<$Result.GetResult<Prisma.$VirtualProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VirtualProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VirtualProfileFindUniqueOrThrowArgs} args - Arguments to find a VirtualProfile
     * @example
     * // Get one VirtualProfile
     * const virtualProfile = await prisma.virtualProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VirtualProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, VirtualProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VirtualProfileClient<$Result.GetResult<Prisma.$VirtualProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VirtualProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualProfileFindFirstArgs} args - Arguments to find a VirtualProfile
     * @example
     * // Get one VirtualProfile
     * const virtualProfile = await prisma.virtualProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VirtualProfileFindFirstArgs>(args?: SelectSubset<T, VirtualProfileFindFirstArgs<ExtArgs>>): Prisma__VirtualProfileClient<$Result.GetResult<Prisma.$VirtualProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VirtualProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualProfileFindFirstOrThrowArgs} args - Arguments to find a VirtualProfile
     * @example
     * // Get one VirtualProfile
     * const virtualProfile = await prisma.virtualProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VirtualProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, VirtualProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__VirtualProfileClient<$Result.GetResult<Prisma.$VirtualProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VirtualProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VirtualProfiles
     * const virtualProfiles = await prisma.virtualProfile.findMany()
     * 
     * // Get first 10 VirtualProfiles
     * const virtualProfiles = await prisma.virtualProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const virtualProfileWithIdOnly = await prisma.virtualProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VirtualProfileFindManyArgs>(args?: SelectSubset<T, VirtualProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VirtualProfile.
     * @param {VirtualProfileCreateArgs} args - Arguments to create a VirtualProfile.
     * @example
     * // Create one VirtualProfile
     * const VirtualProfile = await prisma.virtualProfile.create({
     *   data: {
     *     // ... data to create a VirtualProfile
     *   }
     * })
     * 
     */
    create<T extends VirtualProfileCreateArgs>(args: SelectSubset<T, VirtualProfileCreateArgs<ExtArgs>>): Prisma__VirtualProfileClient<$Result.GetResult<Prisma.$VirtualProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VirtualProfiles.
     * @param {VirtualProfileCreateManyArgs} args - Arguments to create many VirtualProfiles.
     * @example
     * // Create many VirtualProfiles
     * const virtualProfile = await prisma.virtualProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VirtualProfileCreateManyArgs>(args?: SelectSubset<T, VirtualProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VirtualProfiles and returns the data saved in the database.
     * @param {VirtualProfileCreateManyAndReturnArgs} args - Arguments to create many VirtualProfiles.
     * @example
     * // Create many VirtualProfiles
     * const virtualProfile = await prisma.virtualProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VirtualProfiles and only return the `id`
     * const virtualProfileWithIdOnly = await prisma.virtualProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VirtualProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, VirtualProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VirtualProfile.
     * @param {VirtualProfileDeleteArgs} args - Arguments to delete one VirtualProfile.
     * @example
     * // Delete one VirtualProfile
     * const VirtualProfile = await prisma.virtualProfile.delete({
     *   where: {
     *     // ... filter to delete one VirtualProfile
     *   }
     * })
     * 
     */
    delete<T extends VirtualProfileDeleteArgs>(args: SelectSubset<T, VirtualProfileDeleteArgs<ExtArgs>>): Prisma__VirtualProfileClient<$Result.GetResult<Prisma.$VirtualProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VirtualProfile.
     * @param {VirtualProfileUpdateArgs} args - Arguments to update one VirtualProfile.
     * @example
     * // Update one VirtualProfile
     * const virtualProfile = await prisma.virtualProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VirtualProfileUpdateArgs>(args: SelectSubset<T, VirtualProfileUpdateArgs<ExtArgs>>): Prisma__VirtualProfileClient<$Result.GetResult<Prisma.$VirtualProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VirtualProfiles.
     * @param {VirtualProfileDeleteManyArgs} args - Arguments to filter VirtualProfiles to delete.
     * @example
     * // Delete a few VirtualProfiles
     * const { count } = await prisma.virtualProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VirtualProfileDeleteManyArgs>(args?: SelectSubset<T, VirtualProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VirtualProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VirtualProfiles
     * const virtualProfile = await prisma.virtualProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VirtualProfileUpdateManyArgs>(args: SelectSubset<T, VirtualProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VirtualProfile.
     * @param {VirtualProfileUpsertArgs} args - Arguments to update or create a VirtualProfile.
     * @example
     * // Update or create a VirtualProfile
     * const virtualProfile = await prisma.virtualProfile.upsert({
     *   create: {
     *     // ... data to create a VirtualProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VirtualProfile we want to update
     *   }
     * })
     */
    upsert<T extends VirtualProfileUpsertArgs>(args: SelectSubset<T, VirtualProfileUpsertArgs<ExtArgs>>): Prisma__VirtualProfileClient<$Result.GetResult<Prisma.$VirtualProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VirtualProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualProfileCountArgs} args - Arguments to filter VirtualProfiles to count.
     * @example
     * // Count the number of VirtualProfiles
     * const count = await prisma.virtualProfile.count({
     *   where: {
     *     // ... the filter for the VirtualProfiles we want to count
     *   }
     * })
    **/
    count<T extends VirtualProfileCountArgs>(
      args?: Subset<T, VirtualProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VirtualProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VirtualProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VirtualProfileAggregateArgs>(args: Subset<T, VirtualProfileAggregateArgs>): Prisma.PrismaPromise<GetVirtualProfileAggregateType<T>>

    /**
     * Group by VirtualProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VirtualProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VirtualProfileGroupByArgs['orderBy'] }
        : { orderBy?: VirtualProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VirtualProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVirtualProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VirtualProfile model
   */
  readonly fields: VirtualProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VirtualProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VirtualProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends VirtualProfile$userProfileArgs<ExtArgs> = {}>(args?: Subset<T, VirtualProfile$userProfileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany"> | Null>
    communityProfile<T extends VirtualProfile$communityProfileArgs<ExtArgs> = {}>(args?: Subset<T, VirtualProfile$communityProfileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityProfilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VirtualProfile model
   */ 
  interface VirtualProfileFieldRefs {
    readonly id: FieldRef<"VirtualProfile", 'String'>
    readonly userId: FieldRef<"VirtualProfile", 'String'>
    readonly profileType: FieldRef<"VirtualProfile", 'String'>
    readonly activated: FieldRef<"VirtualProfile", 'Boolean'>
    readonly metadata: FieldRef<"VirtualProfile", 'Json'>
    readonly createdAt: FieldRef<"VirtualProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"VirtualProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VirtualProfile findUnique
   */
  export type VirtualProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualProfile
     */
    select?: VirtualProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualProfileInclude<ExtArgs> | null
    /**
     * Filter, which VirtualProfile to fetch.
     */
    where: VirtualProfileWhereUniqueInput
  }

  /**
   * VirtualProfile findUniqueOrThrow
   */
  export type VirtualProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualProfile
     */
    select?: VirtualProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualProfileInclude<ExtArgs> | null
    /**
     * Filter, which VirtualProfile to fetch.
     */
    where: VirtualProfileWhereUniqueInput
  }

  /**
   * VirtualProfile findFirst
   */
  export type VirtualProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualProfile
     */
    select?: VirtualProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualProfileInclude<ExtArgs> | null
    /**
     * Filter, which VirtualProfile to fetch.
     */
    where?: VirtualProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualProfiles to fetch.
     */
    orderBy?: VirtualProfileOrderByWithRelationInput | VirtualProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VirtualProfiles.
     */
    cursor?: VirtualProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VirtualProfiles.
     */
    distinct?: VirtualProfileScalarFieldEnum | VirtualProfileScalarFieldEnum[]
  }

  /**
   * VirtualProfile findFirstOrThrow
   */
  export type VirtualProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualProfile
     */
    select?: VirtualProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualProfileInclude<ExtArgs> | null
    /**
     * Filter, which VirtualProfile to fetch.
     */
    where?: VirtualProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualProfiles to fetch.
     */
    orderBy?: VirtualProfileOrderByWithRelationInput | VirtualProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VirtualProfiles.
     */
    cursor?: VirtualProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VirtualProfiles.
     */
    distinct?: VirtualProfileScalarFieldEnum | VirtualProfileScalarFieldEnum[]
  }

  /**
   * VirtualProfile findMany
   */
  export type VirtualProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualProfile
     */
    select?: VirtualProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualProfileInclude<ExtArgs> | null
    /**
     * Filter, which VirtualProfiles to fetch.
     */
    where?: VirtualProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualProfiles to fetch.
     */
    orderBy?: VirtualProfileOrderByWithRelationInput | VirtualProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VirtualProfiles.
     */
    cursor?: VirtualProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualProfiles.
     */
    skip?: number
    distinct?: VirtualProfileScalarFieldEnum | VirtualProfileScalarFieldEnum[]
  }

  /**
   * VirtualProfile create
   */
  export type VirtualProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualProfile
     */
    select?: VirtualProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a VirtualProfile.
     */
    data: XOR<VirtualProfileCreateInput, VirtualProfileUncheckedCreateInput>
  }

  /**
   * VirtualProfile createMany
   */
  export type VirtualProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VirtualProfiles.
     */
    data: VirtualProfileCreateManyInput | VirtualProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VirtualProfile createManyAndReturn
   */
  export type VirtualProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualProfile
     */
    select?: VirtualProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VirtualProfiles.
     */
    data: VirtualProfileCreateManyInput | VirtualProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VirtualProfile update
   */
  export type VirtualProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualProfile
     */
    select?: VirtualProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a VirtualProfile.
     */
    data: XOR<VirtualProfileUpdateInput, VirtualProfileUncheckedUpdateInput>
    /**
     * Choose, which VirtualProfile to update.
     */
    where: VirtualProfileWhereUniqueInput
  }

  /**
   * VirtualProfile updateMany
   */
  export type VirtualProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VirtualProfiles.
     */
    data: XOR<VirtualProfileUpdateManyMutationInput, VirtualProfileUncheckedUpdateManyInput>
    /**
     * Filter which VirtualProfiles to update
     */
    where?: VirtualProfileWhereInput
  }

  /**
   * VirtualProfile upsert
   */
  export type VirtualProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualProfile
     */
    select?: VirtualProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the VirtualProfile to update in case it exists.
     */
    where: VirtualProfileWhereUniqueInput
    /**
     * In case the VirtualProfile found by the `where` argument doesn't exist, create a new VirtualProfile with this data.
     */
    create: XOR<VirtualProfileCreateInput, VirtualProfileUncheckedCreateInput>
    /**
     * In case the VirtualProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VirtualProfileUpdateInput, VirtualProfileUncheckedUpdateInput>
  }

  /**
   * VirtualProfile delete
   */
  export type VirtualProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualProfile
     */
    select?: VirtualProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualProfileInclude<ExtArgs> | null
    /**
     * Filter which VirtualProfile to delete.
     */
    where: VirtualProfileWhereUniqueInput
  }

  /**
   * VirtualProfile deleteMany
   */
  export type VirtualProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VirtualProfiles to delete
     */
    where?: VirtualProfileWhereInput
  }

  /**
   * VirtualProfile.userProfile
   */
  export type VirtualProfile$userProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    cursor?: UserProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * VirtualProfile.communityProfile
   */
  export type VirtualProfile$communityProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityProfile
     */
    select?: CommunityProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityProfileInclude<ExtArgs> | null
    where?: CommunityProfileWhereInput
    orderBy?: CommunityProfileOrderByWithRelationInput | CommunityProfileOrderByWithRelationInput[]
    cursor?: CommunityProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityProfileScalarFieldEnum | CommunityProfileScalarFieldEnum[]
  }

  /**
   * VirtualProfile without action
   */
  export type VirtualProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualProfile
     */
    select?: VirtualProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileAvgAggregateOutputType = {
    followersCount: number | null
    followingCount: number | null
  }

  export type UserProfileSumAggregateOutputType = {
    followersCount: number | null
    followingCount: number | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    virtualProfileId: string | null
    name: string | null
    profileImageUrl: string | null
    bio: string | null
    private: boolean | null
    followersCount: number | null
    followingCount: number | null
    newsFeedTimelineId: string | null
    personalFeedTimelineId: string | null
    notificationFeedTimelineId: string | null
    algoliaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    virtualProfileId: string | null
    name: string | null
    profileImageUrl: string | null
    bio: string | null
    private: boolean | null
    followersCount: number | null
    followingCount: number | null
    newsFeedTimelineId: string | null
    personalFeedTimelineId: string | null
    notificationFeedTimelineId: string | null
    algoliaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    virtualProfileId: number
    name: number
    profileImageUrl: number
    bio: number
    private: number
    followersCount: number
    followingCount: number
    newsFeedTimelineId: number
    personalFeedTimelineId: number
    notificationFeedTimelineId: number
    algoliaId: number
    metadata: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProfileAvgAggregateInputType = {
    followersCount?: true
    followingCount?: true
  }

  export type UserProfileSumAggregateInputType = {
    followersCount?: true
    followingCount?: true
  }

  export type UserProfileMinAggregateInputType = {
    id?: true
    virtualProfileId?: true
    name?: true
    profileImageUrl?: true
    bio?: true
    private?: true
    followersCount?: true
    followingCount?: true
    newsFeedTimelineId?: true
    personalFeedTimelineId?: true
    notificationFeedTimelineId?: true
    algoliaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    virtualProfileId?: true
    name?: true
    profileImageUrl?: true
    bio?: true
    private?: true
    followersCount?: true
    followingCount?: true
    newsFeedTimelineId?: true
    personalFeedTimelineId?: true
    notificationFeedTimelineId?: true
    algoliaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    virtualProfileId?: true
    name?: true
    profileImageUrl?: true
    bio?: true
    private?: true
    followersCount?: true
    followingCount?: true
    newsFeedTimelineId?: true
    personalFeedTimelineId?: true
    notificationFeedTimelineId?: true
    algoliaId?: true
    metadata?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _avg?: UserProfileAvgAggregateInputType
    _sum?: UserProfileSumAggregateInputType
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: string
    virtualProfileId: string
    name: string | null
    profileImageUrl: string | null
    bio: string | null
    private: boolean | null
    followersCount: number
    followingCount: number
    newsFeedTimelineId: string | null
    personalFeedTimelineId: string | null
    notificationFeedTimelineId: string | null
    algoliaId: string | null
    metadata: JsonValue | null
    settings: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    virtualProfileId?: boolean
    name?: boolean
    profileImageUrl?: boolean
    bio?: boolean
    private?: boolean
    followersCount?: boolean
    followingCount?: boolean
    newsFeedTimelineId?: boolean
    personalFeedTimelineId?: boolean
    notificationFeedTimelineId?: boolean
    algoliaId?: boolean
    metadata?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    virtualProfile?: boolean | VirtualProfileDefaultArgs<ExtArgs>
    bookmarks?: boolean | UserProfile$bookmarksArgs<ExtArgs>
    tags?: boolean | UserProfile$tagsArgs<ExtArgs>
    adminPublications?: boolean | UserProfile$adminPublicationsArgs<ExtArgs>
    editorPublications?: boolean | UserProfile$editorPublicationsArgs<ExtArgs>
    blockedBy?: boolean | UserProfile$blockedByArgs<ExtArgs>
    blocking?: boolean | UserProfile$blockingArgs<ExtArgs>
    followers?: boolean | UserProfile$followersArgs<ExtArgs>
    following?: boolean | UserProfile$followingArgs<ExtArgs>
    posts?: boolean | UserProfile$postsArgs<ExtArgs>
    comments?: boolean | UserProfile$commentsArgs<ExtArgs>
    reactions?: boolean | UserProfile$reactionsArgs<ExtArgs>
    notifications?: boolean | UserProfile$notificationsArgs<ExtArgs>
    reportsSubmitted?: boolean | UserProfile$reportsSubmittedArgs<ExtArgs>
    reportedContent?: boolean | UserProfile$reportedContentArgs<ExtArgs>
    moderatedCommunities?: boolean | UserProfile$moderatedCommunitiesArgs<ExtArgs>
    _count?: boolean | UserProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    virtualProfileId?: boolean
    name?: boolean
    profileImageUrl?: boolean
    bio?: boolean
    private?: boolean
    followersCount?: boolean
    followingCount?: boolean
    newsFeedTimelineId?: boolean
    personalFeedTimelineId?: boolean
    notificationFeedTimelineId?: boolean
    algoliaId?: boolean
    metadata?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    virtualProfile?: boolean | VirtualProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    virtualProfileId?: boolean
    name?: boolean
    profileImageUrl?: boolean
    bio?: boolean
    private?: boolean
    followersCount?: boolean
    followingCount?: boolean
    newsFeedTimelineId?: boolean
    personalFeedTimelineId?: boolean
    notificationFeedTimelineId?: boolean
    algoliaId?: boolean
    metadata?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    virtualProfile?: boolean | VirtualProfileDefaultArgs<ExtArgs>
    bookmarks?: boolean | UserProfile$bookmarksArgs<ExtArgs>
    tags?: boolean | UserProfile$tagsArgs<ExtArgs>
    adminPublications?: boolean | UserProfile$adminPublicationsArgs<ExtArgs>
    editorPublications?: boolean | UserProfile$editorPublicationsArgs<ExtArgs>
    blockedBy?: boolean | UserProfile$blockedByArgs<ExtArgs>
    blocking?: boolean | UserProfile$blockingArgs<ExtArgs>
    followers?: boolean | UserProfile$followersArgs<ExtArgs>
    following?: boolean | UserProfile$followingArgs<ExtArgs>
    posts?: boolean | UserProfile$postsArgs<ExtArgs>
    comments?: boolean | UserProfile$commentsArgs<ExtArgs>
    reactions?: boolean | UserProfile$reactionsArgs<ExtArgs>
    notifications?: boolean | UserProfile$notificationsArgs<ExtArgs>
    reportsSubmitted?: boolean | UserProfile$reportsSubmittedArgs<ExtArgs>
    reportedContent?: boolean | UserProfile$reportedContentArgs<ExtArgs>
    moderatedCommunities?: boolean | UserProfile$moderatedCommunitiesArgs<ExtArgs>
    _count?: boolean | UserProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    virtualProfile?: boolean | VirtualProfileDefaultArgs<ExtArgs>
  }

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      virtualProfile: Prisma.$VirtualProfilePayload<ExtArgs>
      bookmarks: Prisma.$BookmarkPayload<ExtArgs>[]
      tags: Prisma.$UserTagPayload<ExtArgs>[]
      adminPublications: Prisma.$PublicationPayload<ExtArgs>[]
      editorPublications: Prisma.$PublicationPayload<ExtArgs>[]
      blockedBy: Prisma.$BlockPayload<ExtArgs>[]
      blocking: Prisma.$BlockPayload<ExtArgs>[]
      followers: Prisma.$FollowPayload<ExtArgs>[]
      following: Prisma.$FollowPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      reactions: Prisma.$ReactionPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      reportsSubmitted: Prisma.$ReportPayload<ExtArgs>[]
      reportedContent: Prisma.$ReportPayload<ExtArgs>[]
      moderatedCommunities: Prisma.$CommunityProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      virtualProfileId: string
      name: string | null
      profileImageUrl: string | null
      bio: string | null
      private: boolean | null
      followersCount: number
      followingCount: number
      newsFeedTimelineId: string | null
      personalFeedTimelineId: string | null
      notificationFeedTimelineId: string | null
      algoliaId: string | null
      metadata: Prisma.JsonValue | null
      settings: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    virtualProfile<T extends VirtualProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VirtualProfileDefaultArgs<ExtArgs>>): Prisma__VirtualProfileClient<$Result.GetResult<Prisma.$VirtualProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bookmarks<T extends UserProfile$bookmarksArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$bookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findMany"> | Null>
    tags<T extends UserProfile$tagsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findMany"> | Null>
    adminPublications<T extends UserProfile$adminPublicationsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$adminPublicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findMany"> | Null>
    editorPublications<T extends UserProfile$editorPublicationsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$editorPublicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findMany"> | Null>
    blockedBy<T extends UserProfile$blockedByArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$blockedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany"> | Null>
    blocking<T extends UserProfile$blockingArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$blockingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany"> | Null>
    followers<T extends UserProfile$followersArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany"> | Null>
    following<T extends UserProfile$followingArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$followingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends UserProfile$postsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends UserProfile$commentsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    reactions<T extends UserProfile$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends UserProfile$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    reportsSubmitted<T extends UserProfile$reportsSubmittedArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$reportsSubmittedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    reportedContent<T extends UserProfile$reportedContentArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$reportedContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    moderatedCommunities<T extends UserProfile$moderatedCommunitiesArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$moderatedCommunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityProfilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */ 
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly virtualProfileId: FieldRef<"UserProfile", 'String'>
    readonly name: FieldRef<"UserProfile", 'String'>
    readonly profileImageUrl: FieldRef<"UserProfile", 'String'>
    readonly bio: FieldRef<"UserProfile", 'String'>
    readonly private: FieldRef<"UserProfile", 'Boolean'>
    readonly followersCount: FieldRef<"UserProfile", 'Int'>
    readonly followingCount: FieldRef<"UserProfile", 'Int'>
    readonly newsFeedTimelineId: FieldRef<"UserProfile", 'String'>
    readonly personalFeedTimelineId: FieldRef<"UserProfile", 'String'>
    readonly notificationFeedTimelineId: FieldRef<"UserProfile", 'String'>
    readonly algoliaId: FieldRef<"UserProfile", 'String'>
    readonly metadata: FieldRef<"UserProfile", 'Json'>
    readonly settings: FieldRef<"UserProfile", 'Json'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
  }

  /**
   * UserProfile.bookmarks
   */
  export type UserProfile$bookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    where?: BookmarkWhereInput
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    cursor?: BookmarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * UserProfile.tags
   */
  export type UserProfile$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    where?: UserTagWhereInput
    orderBy?: UserTagOrderByWithRelationInput | UserTagOrderByWithRelationInput[]
    cursor?: UserTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTagScalarFieldEnum | UserTagScalarFieldEnum[]
  }

  /**
   * UserProfile.adminPublications
   */
  export type UserProfile$adminPublicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    where?: PublicationWhereInput
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    cursor?: PublicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }

  /**
   * UserProfile.editorPublications
   */
  export type UserProfile$editorPublicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    where?: PublicationWhereInput
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    cursor?: PublicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }

  /**
   * UserProfile.blockedBy
   */
  export type UserProfile$blockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * UserProfile.blocking
   */
  export type UserProfile$blockingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * UserProfile.followers
   */
  export type UserProfile$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * UserProfile.following
   */
  export type UserProfile$followingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * UserProfile.posts
   */
  export type UserProfile$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * UserProfile.comments
   */
  export type UserProfile$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * UserProfile.reactions
   */
  export type UserProfile$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    cursor?: ReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * UserProfile.notifications
   */
  export type UserProfile$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * UserProfile.reportsSubmitted
   */
  export type UserProfile$reportsSubmittedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * UserProfile.reportedContent
   */
  export type UserProfile$reportedContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * UserProfile.moderatedCommunities
   */
  export type UserProfile$moderatedCommunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityProfile
     */
    select?: CommunityProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityProfileInclude<ExtArgs> | null
    where?: CommunityProfileWhereInput
    orderBy?: CommunityProfileOrderByWithRelationInput | CommunityProfileOrderByWithRelationInput[]
    cursor?: CommunityProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityProfileScalarFieldEnum | CommunityProfileScalarFieldEnum[]
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model CommunityProfile
   */

  export type AggregateCommunityProfile = {
    _count: CommunityProfileCountAggregateOutputType | null
    _avg: CommunityProfileAvgAggregateOutputType | null
    _sum: CommunityProfileSumAggregateOutputType | null
    _min: CommunityProfileMinAggregateOutputType | null
    _max: CommunityProfileMaxAggregateOutputType | null
  }

  export type CommunityProfileAvgAggregateOutputType = {
    followers: number | null
  }

  export type CommunityProfileSumAggregateOutputType = {
    followers: number | null
  }

  export type CommunityProfileMinAggregateOutputType = {
    id: string | null
    virtualProfileId: string | null
    name: string | null
    description: string | null
    communityRules: string | null
    profileImageUrl: string | null
    private: boolean | null
    visible: boolean | null
    followers: number | null
    newsFeedTimelineId: string | null
    personalFeedTimelineId: string | null
    notificationFeedTimelineId: string | null
    algoliaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityProfileMaxAggregateOutputType = {
    id: string | null
    virtualProfileId: string | null
    name: string | null
    description: string | null
    communityRules: string | null
    profileImageUrl: string | null
    private: boolean | null
    visible: boolean | null
    followers: number | null
    newsFeedTimelineId: string | null
    personalFeedTimelineId: string | null
    notificationFeedTimelineId: string | null
    algoliaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityProfileCountAggregateOutputType = {
    id: number
    virtualProfileId: number
    name: number
    description: number
    communityRules: number
    profileImageUrl: number
    private: number
    visible: number
    followers: number
    newsFeedTimelineId: number
    personalFeedTimelineId: number
    notificationFeedTimelineId: number
    algoliaId: number
    metadata: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommunityProfileAvgAggregateInputType = {
    followers?: true
  }

  export type CommunityProfileSumAggregateInputType = {
    followers?: true
  }

  export type CommunityProfileMinAggregateInputType = {
    id?: true
    virtualProfileId?: true
    name?: true
    description?: true
    communityRules?: true
    profileImageUrl?: true
    private?: true
    visible?: true
    followers?: true
    newsFeedTimelineId?: true
    personalFeedTimelineId?: true
    notificationFeedTimelineId?: true
    algoliaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityProfileMaxAggregateInputType = {
    id?: true
    virtualProfileId?: true
    name?: true
    description?: true
    communityRules?: true
    profileImageUrl?: true
    private?: true
    visible?: true
    followers?: true
    newsFeedTimelineId?: true
    personalFeedTimelineId?: true
    notificationFeedTimelineId?: true
    algoliaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityProfileCountAggregateInputType = {
    id?: true
    virtualProfileId?: true
    name?: true
    description?: true
    communityRules?: true
    profileImageUrl?: true
    private?: true
    visible?: true
    followers?: true
    newsFeedTimelineId?: true
    personalFeedTimelineId?: true
    notificationFeedTimelineId?: true
    algoliaId?: true
    metadata?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommunityProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityProfile to aggregate.
     */
    where?: CommunityProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityProfiles to fetch.
     */
    orderBy?: CommunityProfileOrderByWithRelationInput | CommunityProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityProfiles
    **/
    _count?: true | CommunityProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityProfileMaxAggregateInputType
  }

  export type GetCommunityProfileAggregateType<T extends CommunityProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityProfile[P]>
      : GetScalarType<T[P], AggregateCommunityProfile[P]>
  }




  export type CommunityProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityProfileWhereInput
    orderBy?: CommunityProfileOrderByWithAggregationInput | CommunityProfileOrderByWithAggregationInput[]
    by: CommunityProfileScalarFieldEnum[] | CommunityProfileScalarFieldEnum
    having?: CommunityProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityProfileCountAggregateInputType | true
    _avg?: CommunityProfileAvgAggregateInputType
    _sum?: CommunityProfileSumAggregateInputType
    _min?: CommunityProfileMinAggregateInputType
    _max?: CommunityProfileMaxAggregateInputType
  }

  export type CommunityProfileGroupByOutputType = {
    id: string
    virtualProfileId: string
    name: string | null
    description: string | null
    communityRules: string | null
    profileImageUrl: string | null
    private: boolean | null
    visible: boolean | null
    followers: number
    newsFeedTimelineId: string | null
    personalFeedTimelineId: string | null
    notificationFeedTimelineId: string | null
    algoliaId: string | null
    metadata: JsonValue | null
    settings: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CommunityProfileCountAggregateOutputType | null
    _avg: CommunityProfileAvgAggregateOutputType | null
    _sum: CommunityProfileSumAggregateOutputType | null
    _min: CommunityProfileMinAggregateOutputType | null
    _max: CommunityProfileMaxAggregateOutputType | null
  }

  type GetCommunityProfileGroupByPayload<T extends CommunityProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityProfileGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityProfileGroupByOutputType[P]>
        }
      >
    >


  export type CommunityProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    virtualProfileId?: boolean
    name?: boolean
    description?: boolean
    communityRules?: boolean
    profileImageUrl?: boolean
    private?: boolean
    visible?: boolean
    followers?: boolean
    newsFeedTimelineId?: boolean
    personalFeedTimelineId?: boolean
    notificationFeedTimelineId?: boolean
    algoliaId?: boolean
    metadata?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    virtualProfile?: boolean | VirtualProfileDefaultArgs<ExtArgs>
    topics?: boolean | CommunityProfile$topicsArgs<ExtArgs>
    posts?: boolean | CommunityProfile$postsArgs<ExtArgs>
    moderators?: boolean | CommunityProfile$moderatorsArgs<ExtArgs>
    _count?: boolean | CommunityProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityProfile"]>

  export type CommunityProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    virtualProfileId?: boolean
    name?: boolean
    description?: boolean
    communityRules?: boolean
    profileImageUrl?: boolean
    private?: boolean
    visible?: boolean
    followers?: boolean
    newsFeedTimelineId?: boolean
    personalFeedTimelineId?: boolean
    notificationFeedTimelineId?: boolean
    algoliaId?: boolean
    metadata?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    virtualProfile?: boolean | VirtualProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityProfile"]>

  export type CommunityProfileSelectScalar = {
    id?: boolean
    virtualProfileId?: boolean
    name?: boolean
    description?: boolean
    communityRules?: boolean
    profileImageUrl?: boolean
    private?: boolean
    visible?: boolean
    followers?: boolean
    newsFeedTimelineId?: boolean
    personalFeedTimelineId?: boolean
    notificationFeedTimelineId?: boolean
    algoliaId?: boolean
    metadata?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommunityProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    virtualProfile?: boolean | VirtualProfileDefaultArgs<ExtArgs>
    topics?: boolean | CommunityProfile$topicsArgs<ExtArgs>
    posts?: boolean | CommunityProfile$postsArgs<ExtArgs>
    moderators?: boolean | CommunityProfile$moderatorsArgs<ExtArgs>
    _count?: boolean | CommunityProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommunityProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    virtualProfile?: boolean | VirtualProfileDefaultArgs<ExtArgs>
  }

  export type $CommunityProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityProfile"
    objects: {
      virtualProfile: Prisma.$VirtualProfilePayload<ExtArgs>
      topics: Prisma.$TopicPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      moderators: Prisma.$UserProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      virtualProfileId: string
      name: string | null
      description: string | null
      communityRules: string | null
      profileImageUrl: string | null
      private: boolean | null
      visible: boolean | null
      followers: number
      newsFeedTimelineId: string | null
      personalFeedTimelineId: string | null
      notificationFeedTimelineId: string | null
      algoliaId: string | null
      metadata: Prisma.JsonValue | null
      settings: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["communityProfile"]>
    composites: {}
  }

  type CommunityProfileGetPayload<S extends boolean | null | undefined | CommunityProfileDefaultArgs> = $Result.GetResult<Prisma.$CommunityProfilePayload, S>

  type CommunityProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunityProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommunityProfileCountAggregateInputType | true
    }

  export interface CommunityProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityProfile'], meta: { name: 'CommunityProfile' } }
    /**
     * Find zero or one CommunityProfile that matches the filter.
     * @param {CommunityProfileFindUniqueArgs} args - Arguments to find a CommunityProfile
     * @example
     * // Get one CommunityProfile
     * const communityProfile = await prisma.communityProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityProfileFindUniqueArgs>(args: SelectSubset<T, CommunityProfileFindUniqueArgs<ExtArgs>>): Prisma__CommunityProfileClient<$Result.GetResult<Prisma.$CommunityProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommunityProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommunityProfileFindUniqueOrThrowArgs} args - Arguments to find a CommunityProfile
     * @example
     * // Get one CommunityProfile
     * const communityProfile = await prisma.communityProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityProfileClient<$Result.GetResult<Prisma.$CommunityProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommunityProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityProfileFindFirstArgs} args - Arguments to find a CommunityProfile
     * @example
     * // Get one CommunityProfile
     * const communityProfile = await prisma.communityProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityProfileFindFirstArgs>(args?: SelectSubset<T, CommunityProfileFindFirstArgs<ExtArgs>>): Prisma__CommunityProfileClient<$Result.GetResult<Prisma.$CommunityProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommunityProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityProfileFindFirstOrThrowArgs} args - Arguments to find a CommunityProfile
     * @example
     * // Get one CommunityProfile
     * const communityProfile = await prisma.communityProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityProfileClient<$Result.GetResult<Prisma.$CommunityProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommunityProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityProfiles
     * const communityProfiles = await prisma.communityProfile.findMany()
     * 
     * // Get first 10 CommunityProfiles
     * const communityProfiles = await prisma.communityProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityProfileWithIdOnly = await prisma.communityProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityProfileFindManyArgs>(args?: SelectSubset<T, CommunityProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommunityProfile.
     * @param {CommunityProfileCreateArgs} args - Arguments to create a CommunityProfile.
     * @example
     * // Create one CommunityProfile
     * const CommunityProfile = await prisma.communityProfile.create({
     *   data: {
     *     // ... data to create a CommunityProfile
     *   }
     * })
     * 
     */
    create<T extends CommunityProfileCreateArgs>(args: SelectSubset<T, CommunityProfileCreateArgs<ExtArgs>>): Prisma__CommunityProfileClient<$Result.GetResult<Prisma.$CommunityProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommunityProfiles.
     * @param {CommunityProfileCreateManyArgs} args - Arguments to create many CommunityProfiles.
     * @example
     * // Create many CommunityProfiles
     * const communityProfile = await prisma.communityProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityProfileCreateManyArgs>(args?: SelectSubset<T, CommunityProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommunityProfiles and returns the data saved in the database.
     * @param {CommunityProfileCreateManyAndReturnArgs} args - Arguments to create many CommunityProfiles.
     * @example
     * // Create many CommunityProfiles
     * const communityProfile = await prisma.communityProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommunityProfiles and only return the `id`
     * const communityProfileWithIdOnly = await prisma.communityProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CommunityProfile.
     * @param {CommunityProfileDeleteArgs} args - Arguments to delete one CommunityProfile.
     * @example
     * // Delete one CommunityProfile
     * const CommunityProfile = await prisma.communityProfile.delete({
     *   where: {
     *     // ... filter to delete one CommunityProfile
     *   }
     * })
     * 
     */
    delete<T extends CommunityProfileDeleteArgs>(args: SelectSubset<T, CommunityProfileDeleteArgs<ExtArgs>>): Prisma__CommunityProfileClient<$Result.GetResult<Prisma.$CommunityProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommunityProfile.
     * @param {CommunityProfileUpdateArgs} args - Arguments to update one CommunityProfile.
     * @example
     * // Update one CommunityProfile
     * const communityProfile = await prisma.communityProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityProfileUpdateArgs>(args: SelectSubset<T, CommunityProfileUpdateArgs<ExtArgs>>): Prisma__CommunityProfileClient<$Result.GetResult<Prisma.$CommunityProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommunityProfiles.
     * @param {CommunityProfileDeleteManyArgs} args - Arguments to filter CommunityProfiles to delete.
     * @example
     * // Delete a few CommunityProfiles
     * const { count } = await prisma.communityProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityProfileDeleteManyArgs>(args?: SelectSubset<T, CommunityProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityProfiles
     * const communityProfile = await prisma.communityProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityProfileUpdateManyArgs>(args: SelectSubset<T, CommunityProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityProfile.
     * @param {CommunityProfileUpsertArgs} args - Arguments to update or create a CommunityProfile.
     * @example
     * // Update or create a CommunityProfile
     * const communityProfile = await prisma.communityProfile.upsert({
     *   create: {
     *     // ... data to create a CommunityProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityProfile we want to update
     *   }
     * })
     */
    upsert<T extends CommunityProfileUpsertArgs>(args: SelectSubset<T, CommunityProfileUpsertArgs<ExtArgs>>): Prisma__CommunityProfileClient<$Result.GetResult<Prisma.$CommunityProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CommunityProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityProfileCountArgs} args - Arguments to filter CommunityProfiles to count.
     * @example
     * // Count the number of CommunityProfiles
     * const count = await prisma.communityProfile.count({
     *   where: {
     *     // ... the filter for the CommunityProfiles we want to count
     *   }
     * })
    **/
    count<T extends CommunityProfileCountArgs>(
      args?: Subset<T, CommunityProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityProfileAggregateArgs>(args: Subset<T, CommunityProfileAggregateArgs>): Prisma.PrismaPromise<GetCommunityProfileAggregateType<T>>

    /**
     * Group by CommunityProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityProfileGroupByArgs['orderBy'] }
        : { orderBy?: CommunityProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityProfile model
   */
  readonly fields: CommunityProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    virtualProfile<T extends VirtualProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VirtualProfileDefaultArgs<ExtArgs>>): Prisma__VirtualProfileClient<$Result.GetResult<Prisma.$VirtualProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    topics<T extends CommunityProfile$topicsArgs<ExtArgs> = {}>(args?: Subset<T, CommunityProfile$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends CommunityProfile$postsArgs<ExtArgs> = {}>(args?: Subset<T, CommunityProfile$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    moderators<T extends CommunityProfile$moderatorsArgs<ExtArgs> = {}>(args?: Subset<T, CommunityProfile$moderatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunityProfile model
   */ 
  interface CommunityProfileFieldRefs {
    readonly id: FieldRef<"CommunityProfile", 'String'>
    readonly virtualProfileId: FieldRef<"CommunityProfile", 'String'>
    readonly name: FieldRef<"CommunityProfile", 'String'>
    readonly description: FieldRef<"CommunityProfile", 'String'>
    readonly communityRules: FieldRef<"CommunityProfile", 'String'>
    readonly profileImageUrl: FieldRef<"CommunityProfile", 'String'>
    readonly private: FieldRef<"CommunityProfile", 'Boolean'>
    readonly visible: FieldRef<"CommunityProfile", 'Boolean'>
    readonly followers: FieldRef<"CommunityProfile", 'Int'>
    readonly newsFeedTimelineId: FieldRef<"CommunityProfile", 'String'>
    readonly personalFeedTimelineId: FieldRef<"CommunityProfile", 'String'>
    readonly notificationFeedTimelineId: FieldRef<"CommunityProfile", 'String'>
    readonly algoliaId: FieldRef<"CommunityProfile", 'String'>
    readonly metadata: FieldRef<"CommunityProfile", 'Json'>
    readonly settings: FieldRef<"CommunityProfile", 'Json'>
    readonly createdAt: FieldRef<"CommunityProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"CommunityProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommunityProfile findUnique
   */
  export type CommunityProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityProfile
     */
    select?: CommunityProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityProfileInclude<ExtArgs> | null
    /**
     * Filter, which CommunityProfile to fetch.
     */
    where: CommunityProfileWhereUniqueInput
  }

  /**
   * CommunityProfile findUniqueOrThrow
   */
  export type CommunityProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityProfile
     */
    select?: CommunityProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityProfileInclude<ExtArgs> | null
    /**
     * Filter, which CommunityProfile to fetch.
     */
    where: CommunityProfileWhereUniqueInput
  }

  /**
   * CommunityProfile findFirst
   */
  export type CommunityProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityProfile
     */
    select?: CommunityProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityProfileInclude<ExtArgs> | null
    /**
     * Filter, which CommunityProfile to fetch.
     */
    where?: CommunityProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityProfiles to fetch.
     */
    orderBy?: CommunityProfileOrderByWithRelationInput | CommunityProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityProfiles.
     */
    cursor?: CommunityProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityProfiles.
     */
    distinct?: CommunityProfileScalarFieldEnum | CommunityProfileScalarFieldEnum[]
  }

  /**
   * CommunityProfile findFirstOrThrow
   */
  export type CommunityProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityProfile
     */
    select?: CommunityProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityProfileInclude<ExtArgs> | null
    /**
     * Filter, which CommunityProfile to fetch.
     */
    where?: CommunityProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityProfiles to fetch.
     */
    orderBy?: CommunityProfileOrderByWithRelationInput | CommunityProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityProfiles.
     */
    cursor?: CommunityProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityProfiles.
     */
    distinct?: CommunityProfileScalarFieldEnum | CommunityProfileScalarFieldEnum[]
  }

  /**
   * CommunityProfile findMany
   */
  export type CommunityProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityProfile
     */
    select?: CommunityProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityProfileInclude<ExtArgs> | null
    /**
     * Filter, which CommunityProfiles to fetch.
     */
    where?: CommunityProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityProfiles to fetch.
     */
    orderBy?: CommunityProfileOrderByWithRelationInput | CommunityProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityProfiles.
     */
    cursor?: CommunityProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityProfiles.
     */
    skip?: number
    distinct?: CommunityProfileScalarFieldEnum | CommunityProfileScalarFieldEnum[]
  }

  /**
   * CommunityProfile create
   */
  export type CommunityProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityProfile
     */
    select?: CommunityProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityProfile.
     */
    data: XOR<CommunityProfileCreateInput, CommunityProfileUncheckedCreateInput>
  }

  /**
   * CommunityProfile createMany
   */
  export type CommunityProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityProfiles.
     */
    data: CommunityProfileCreateManyInput | CommunityProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityProfile createManyAndReturn
   */
  export type CommunityProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityProfile
     */
    select?: CommunityProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CommunityProfiles.
     */
    data: CommunityProfileCreateManyInput | CommunityProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommunityProfile update
   */
  export type CommunityProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityProfile
     */
    select?: CommunityProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityProfile.
     */
    data: XOR<CommunityProfileUpdateInput, CommunityProfileUncheckedUpdateInput>
    /**
     * Choose, which CommunityProfile to update.
     */
    where: CommunityProfileWhereUniqueInput
  }

  /**
   * CommunityProfile updateMany
   */
  export type CommunityProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityProfiles.
     */
    data: XOR<CommunityProfileUpdateManyMutationInput, CommunityProfileUncheckedUpdateManyInput>
    /**
     * Filter which CommunityProfiles to update
     */
    where?: CommunityProfileWhereInput
  }

  /**
   * CommunityProfile upsert
   */
  export type CommunityProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityProfile
     */
    select?: CommunityProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityProfile to update in case it exists.
     */
    where: CommunityProfileWhereUniqueInput
    /**
     * In case the CommunityProfile found by the `where` argument doesn't exist, create a new CommunityProfile with this data.
     */
    create: XOR<CommunityProfileCreateInput, CommunityProfileUncheckedCreateInput>
    /**
     * In case the CommunityProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityProfileUpdateInput, CommunityProfileUncheckedUpdateInput>
  }

  /**
   * CommunityProfile delete
   */
  export type CommunityProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityProfile
     */
    select?: CommunityProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityProfileInclude<ExtArgs> | null
    /**
     * Filter which CommunityProfile to delete.
     */
    where: CommunityProfileWhereUniqueInput
  }

  /**
   * CommunityProfile deleteMany
   */
  export type CommunityProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityProfiles to delete
     */
    where?: CommunityProfileWhereInput
  }

  /**
   * CommunityProfile.topics
   */
  export type CommunityProfile$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * CommunityProfile.posts
   */
  export type CommunityProfile$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * CommunityProfile.moderators
   */
  export type CommunityProfile$moderatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    cursor?: UserProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * CommunityProfile without action
   */
  export type CommunityProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityProfile
     */
    select?: CommunityProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityProfileInclude<ExtArgs> | null
  }


  /**
   * Model Topic
   */

  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  export type TopicMinAggregateOutputType = {
    id: string | null
    communityProfileId: string | null
    topicName: string | null
    description: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicMaxAggregateOutputType = {
    id: string | null
    communityProfileId: string | null
    topicName: string | null
    description: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicCountAggregateOutputType = {
    id: number
    communityProfileId: number
    topicName: number
    description: number
    imageUrl: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TopicMinAggregateInputType = {
    id?: true
    communityProfileId?: true
    topicName?: true
    description?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicMaxAggregateInputType = {
    id?: true
    communityProfileId?: true
    topicName?: true
    description?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicCountAggregateInputType = {
    id?: true
    communityProfileId?: true
    topicName?: true
    description?: true
    imageUrl?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topic to aggregate.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Topics
    **/
    _count?: true | TopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMaxAggregateInputType
  }

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
        [P in keyof T & keyof AggregateTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>
  }




  export type TopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithAggregationInput | TopicOrderByWithAggregationInput[]
    by: TopicScalarFieldEnum[] | TopicScalarFieldEnum
    having?: TopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicCountAggregateInputType | true
    _min?: TopicMinAggregateInputType
    _max?: TopicMaxAggregateInputType
  }

  export type TopicGroupByOutputType = {
    id: string
    communityProfileId: string
    topicName: string | null
    description: string | null
    imageUrl: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TopicCountAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
        }
      >
    >


  export type TopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityProfileId?: boolean
    topicName?: boolean
    description?: boolean
    imageUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    communityProfile?: boolean | CommunityProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityProfileId?: boolean
    topicName?: boolean
    description?: boolean
    imageUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    communityProfile?: boolean | CommunityProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectScalar = {
    id?: boolean
    communityProfileId?: boolean
    topicName?: boolean
    description?: boolean
    imageUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    communityProfile?: boolean | CommunityProfileDefaultArgs<ExtArgs>
  }
  export type TopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    communityProfile?: boolean | CommunityProfileDefaultArgs<ExtArgs>
  }

  export type $TopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Topic"
    objects: {
      communityProfile: Prisma.$CommunityProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      communityProfileId: string
      topicName: string | null
      description: string | null
      imageUrl: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["topic"]>
    composites: {}
  }

  type TopicGetPayload<S extends boolean | null | undefined | TopicDefaultArgs> = $Result.GetResult<Prisma.$TopicPayload, S>

  type TopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TopicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TopicCountAggregateInputType | true
    }

  export interface TopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Topic'], meta: { name: 'Topic' } }
    /**
     * Find zero or one Topic that matches the filter.
     * @param {TopicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicFindUniqueArgs>(args: SelectSubset<T, TopicFindUniqueArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Topic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TopicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicFindFirstArgs>(args?: SelectSubset<T, TopicFindFirstArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Topic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicFindManyArgs>(args?: SelectSubset<T, TopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Topic.
     * @param {TopicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     * 
     */
    create<T extends TopicCreateArgs>(args: SelectSubset<T, TopicCreateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Topics.
     * @param {TopicCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicCreateManyArgs>(args?: SelectSubset<T, TopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Topics and returns the data saved in the database.
     * @param {TopicCreateManyAndReturnArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Topic.
     * @param {TopicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     * 
     */
    delete<T extends TopicDeleteArgs>(args: SelectSubset<T, TopicDeleteArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Topic.
     * @param {TopicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicUpdateArgs>(args: SelectSubset<T, TopicUpdateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Topics.
     * @param {TopicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicDeleteManyArgs>(args?: SelectSubset<T, TopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicUpdateManyArgs>(args: SelectSubset<T, TopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Topic.
     * @param {TopicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
     */
    upsert<T extends TopicUpsertArgs>(args: SelectSubset<T, TopicUpsertArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends TopicCountArgs>(
      args?: Subset<T, TopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicAggregateArgs>(args: Subset<T, TopicAggregateArgs>): Prisma.PrismaPromise<GetTopicAggregateType<T>>

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs['orderBy'] }
        : { orderBy?: TopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Topic model
   */
  readonly fields: TopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    communityProfile<T extends CommunityProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityProfileDefaultArgs<ExtArgs>>): Prisma__CommunityProfileClient<$Result.GetResult<Prisma.$CommunityProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Topic model
   */ 
  interface TopicFieldRefs {
    readonly id: FieldRef<"Topic", 'String'>
    readonly communityProfileId: FieldRef<"Topic", 'String'>
    readonly topicName: FieldRef<"Topic", 'String'>
    readonly description: FieldRef<"Topic", 'String'>
    readonly imageUrl: FieldRef<"Topic", 'String'>
    readonly metadata: FieldRef<"Topic", 'Json'>
    readonly createdAt: FieldRef<"Topic", 'DateTime'>
    readonly updatedAt: FieldRef<"Topic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Topic findUnique
   */
  export type TopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findUniqueOrThrow
   */
  export type TopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findFirst
   */
  export type TopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findFirstOrThrow
   */
  export type TopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findMany
   */
  export type TopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic create
   */
  export type TopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to create a Topic.
     */
    data: XOR<TopicCreateInput, TopicUncheckedCreateInput>
  }

  /**
   * Topic createMany
   */
  export type TopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Topic createManyAndReturn
   */
  export type TopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Topic update
   */
  export type TopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to update a Topic.
     */
    data: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
    /**
     * Choose, which Topic to update.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic updateMany
   */
  export type TopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
  }

  /**
   * Topic upsert
   */
  export type TopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The filter to search for the Topic to update in case it exists.
     */
    where: TopicWhereUniqueInput
    /**
     * In case the Topic found by the `where` argument doesn't exist, create a new Topic with this data.
     */
    create: XOR<TopicCreateInput, TopicUncheckedCreateInput>
    /**
     * In case the Topic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
  }

  /**
   * Topic delete
   */
  export type TopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter which Topic to delete.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic deleteMany
   */
  export type TopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicWhereInput
  }

  /**
   * Topic without action
   */
  export type TopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
  }


  /**
   * Model Publication
   */

  export type AggregatePublication = {
    _count: PublicationCountAggregateOutputType | null
    _min: PublicationMinAggregateOutputType | null
    _max: PublicationMaxAggregateOutputType | null
  }

  export type PublicationMinAggregateOutputType = {
    id: string | null
    publicationName: string | null
    description: string | null
    type: string | null
    adminBackendPlatformUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PublicationMaxAggregateOutputType = {
    id: string | null
    publicationName: string | null
    description: string | null
    type: string | null
    adminBackendPlatformUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PublicationCountAggregateOutputType = {
    id: number
    publicationName: number
    description: number
    type: number
    postIds: number
    subjects: number
    tags: number
    adminBackendPlatformUserId: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PublicationMinAggregateInputType = {
    id?: true
    publicationName?: true
    description?: true
    type?: true
    adminBackendPlatformUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PublicationMaxAggregateInputType = {
    id?: true
    publicationName?: true
    description?: true
    type?: true
    adminBackendPlatformUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PublicationCountAggregateInputType = {
    id?: true
    publicationName?: true
    description?: true
    type?: true
    postIds?: true
    subjects?: true
    tags?: true
    adminBackendPlatformUserId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PublicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Publication to aggregate.
     */
    where?: PublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Publications
    **/
    _count?: true | PublicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicationMaxAggregateInputType
  }

  export type GetPublicationAggregateType<T extends PublicationAggregateArgs> = {
        [P in keyof T & keyof AggregatePublication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublication[P]>
      : GetScalarType<T[P], AggregatePublication[P]>
  }




  export type PublicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationWhereInput
    orderBy?: PublicationOrderByWithAggregationInput | PublicationOrderByWithAggregationInput[]
    by: PublicationScalarFieldEnum[] | PublicationScalarFieldEnum
    having?: PublicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicationCountAggregateInputType | true
    _min?: PublicationMinAggregateInputType
    _max?: PublicationMaxAggregateInputType
  }

  export type PublicationGroupByOutputType = {
    id: string
    publicationName: string | null
    description: string | null
    type: string | null
    postIds: string[]
    subjects: string[]
    tags: string[]
    adminBackendPlatformUserId: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PublicationCountAggregateOutputType | null
    _min: PublicationMinAggregateOutputType | null
    _max: PublicationMaxAggregateOutputType | null
  }

  type GetPublicationGroupByPayload<T extends PublicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicationGroupByOutputType[P]>
            : GetScalarType<T[P], PublicationGroupByOutputType[P]>
        }
      >
    >


  export type PublicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicationName?: boolean
    description?: boolean
    type?: boolean
    postIds?: boolean
    subjects?: boolean
    tags?: boolean
    adminBackendPlatformUserId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookmarks?: boolean | Publication$bookmarksArgs<ExtArgs>
    admins?: boolean | Publication$adminsArgs<ExtArgs>
    editors?: boolean | Publication$editorsArgs<ExtArgs>
    posts?: boolean | Publication$postsArgs<ExtArgs>
    _count?: boolean | PublicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication"]>

  export type PublicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicationName?: boolean
    description?: boolean
    type?: boolean
    postIds?: boolean
    subjects?: boolean
    tags?: boolean
    adminBackendPlatformUserId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["publication"]>

  export type PublicationSelectScalar = {
    id?: boolean
    publicationName?: boolean
    description?: boolean
    type?: boolean
    postIds?: boolean
    subjects?: boolean
    tags?: boolean
    adminBackendPlatformUserId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PublicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookmarks?: boolean | Publication$bookmarksArgs<ExtArgs>
    admins?: boolean | Publication$adminsArgs<ExtArgs>
    editors?: boolean | Publication$editorsArgs<ExtArgs>
    posts?: boolean | Publication$postsArgs<ExtArgs>
    _count?: boolean | PublicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PublicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PublicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Publication"
    objects: {
      bookmarks: Prisma.$BookmarkPayload<ExtArgs>[]
      admins: Prisma.$UserProfilePayload<ExtArgs>[]
      editors: Prisma.$UserProfilePayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      publicationName: string | null
      description: string | null
      type: string | null
      postIds: string[]
      subjects: string[]
      tags: string[]
      adminBackendPlatformUserId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["publication"]>
    composites: {}
  }

  type PublicationGetPayload<S extends boolean | null | undefined | PublicationDefaultArgs> = $Result.GetResult<Prisma.$PublicationPayload, S>

  type PublicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PublicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PublicationCountAggregateInputType | true
    }

  export interface PublicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Publication'], meta: { name: 'Publication' } }
    /**
     * Find zero or one Publication that matches the filter.
     * @param {PublicationFindUniqueArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PublicationFindUniqueArgs>(args: SelectSubset<T, PublicationFindUniqueArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Publication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PublicationFindUniqueOrThrowArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PublicationFindUniqueOrThrowArgs>(args: SelectSubset<T, PublicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Publication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationFindFirstArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PublicationFindFirstArgs>(args?: SelectSubset<T, PublicationFindFirstArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Publication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationFindFirstOrThrowArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PublicationFindFirstOrThrowArgs>(args?: SelectSubset<T, PublicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Publications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publications
     * const publications = await prisma.publication.findMany()
     * 
     * // Get first 10 Publications
     * const publications = await prisma.publication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publicationWithIdOnly = await prisma.publication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PublicationFindManyArgs>(args?: SelectSubset<T, PublicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Publication.
     * @param {PublicationCreateArgs} args - Arguments to create a Publication.
     * @example
     * // Create one Publication
     * const Publication = await prisma.publication.create({
     *   data: {
     *     // ... data to create a Publication
     *   }
     * })
     * 
     */
    create<T extends PublicationCreateArgs>(args: SelectSubset<T, PublicationCreateArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Publications.
     * @param {PublicationCreateManyArgs} args - Arguments to create many Publications.
     * @example
     * // Create many Publications
     * const publication = await prisma.publication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PublicationCreateManyArgs>(args?: SelectSubset<T, PublicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Publications and returns the data saved in the database.
     * @param {PublicationCreateManyAndReturnArgs} args - Arguments to create many Publications.
     * @example
     * // Create many Publications
     * const publication = await prisma.publication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Publications and only return the `id`
     * const publicationWithIdOnly = await prisma.publication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PublicationCreateManyAndReturnArgs>(args?: SelectSubset<T, PublicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Publication.
     * @param {PublicationDeleteArgs} args - Arguments to delete one Publication.
     * @example
     * // Delete one Publication
     * const Publication = await prisma.publication.delete({
     *   where: {
     *     // ... filter to delete one Publication
     *   }
     * })
     * 
     */
    delete<T extends PublicationDeleteArgs>(args: SelectSubset<T, PublicationDeleteArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Publication.
     * @param {PublicationUpdateArgs} args - Arguments to update one Publication.
     * @example
     * // Update one Publication
     * const publication = await prisma.publication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PublicationUpdateArgs>(args: SelectSubset<T, PublicationUpdateArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Publications.
     * @param {PublicationDeleteManyArgs} args - Arguments to filter Publications to delete.
     * @example
     * // Delete a few Publications
     * const { count } = await prisma.publication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PublicationDeleteManyArgs>(args?: SelectSubset<T, PublicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publications
     * const publication = await prisma.publication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PublicationUpdateManyArgs>(args: SelectSubset<T, PublicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Publication.
     * @param {PublicationUpsertArgs} args - Arguments to update or create a Publication.
     * @example
     * // Update or create a Publication
     * const publication = await prisma.publication.upsert({
     *   create: {
     *     // ... data to create a Publication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publication we want to update
     *   }
     * })
     */
    upsert<T extends PublicationUpsertArgs>(args: SelectSubset<T, PublicationUpsertArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationCountArgs} args - Arguments to filter Publications to count.
     * @example
     * // Count the number of Publications
     * const count = await prisma.publication.count({
     *   where: {
     *     // ... the filter for the Publications we want to count
     *   }
     * })
    **/
    count<T extends PublicationCountArgs>(
      args?: Subset<T, PublicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicationAggregateArgs>(args: Subset<T, PublicationAggregateArgs>): Prisma.PrismaPromise<GetPublicationAggregateType<T>>

    /**
     * Group by Publication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicationGroupByArgs['orderBy'] }
        : { orderBy?: PublicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Publication model
   */
  readonly fields: PublicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Publication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PublicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookmarks<T extends Publication$bookmarksArgs<ExtArgs> = {}>(args?: Subset<T, Publication$bookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findMany"> | Null>
    admins<T extends Publication$adminsArgs<ExtArgs> = {}>(args?: Subset<T, Publication$adminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany"> | Null>
    editors<T extends Publication$editorsArgs<ExtArgs> = {}>(args?: Subset<T, Publication$editorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends Publication$postsArgs<ExtArgs> = {}>(args?: Subset<T, Publication$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Publication model
   */ 
  interface PublicationFieldRefs {
    readonly id: FieldRef<"Publication", 'String'>
    readonly publicationName: FieldRef<"Publication", 'String'>
    readonly description: FieldRef<"Publication", 'String'>
    readonly type: FieldRef<"Publication", 'String'>
    readonly postIds: FieldRef<"Publication", 'String[]'>
    readonly subjects: FieldRef<"Publication", 'String[]'>
    readonly tags: FieldRef<"Publication", 'String[]'>
    readonly adminBackendPlatformUserId: FieldRef<"Publication", 'String'>
    readonly metadata: FieldRef<"Publication", 'Json'>
    readonly createdAt: FieldRef<"Publication", 'DateTime'>
    readonly updatedAt: FieldRef<"Publication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Publication findUnique
   */
  export type PublicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publication to fetch.
     */
    where: PublicationWhereUniqueInput
  }

  /**
   * Publication findUniqueOrThrow
   */
  export type PublicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publication to fetch.
     */
    where: PublicationWhereUniqueInput
  }

  /**
   * Publication findFirst
   */
  export type PublicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publication to fetch.
     */
    where?: PublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Publications.
     */
    cursor?: PublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Publications.
     */
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }

  /**
   * Publication findFirstOrThrow
   */
  export type PublicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publication to fetch.
     */
    where?: PublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Publications.
     */
    cursor?: PublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Publications.
     */
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }

  /**
   * Publication findMany
   */
  export type PublicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publications to fetch.
     */
    where?: PublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Publications.
     */
    cursor?: PublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }

  /**
   * Publication create
   */
  export type PublicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Publication.
     */
    data: XOR<PublicationCreateInput, PublicationUncheckedCreateInput>
  }

  /**
   * Publication createMany
   */
  export type PublicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Publications.
     */
    data: PublicationCreateManyInput | PublicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Publication createManyAndReturn
   */
  export type PublicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Publications.
     */
    data: PublicationCreateManyInput | PublicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Publication update
   */
  export type PublicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Publication.
     */
    data: XOR<PublicationUpdateInput, PublicationUncheckedUpdateInput>
    /**
     * Choose, which Publication to update.
     */
    where: PublicationWhereUniqueInput
  }

  /**
   * Publication updateMany
   */
  export type PublicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Publications.
     */
    data: XOR<PublicationUpdateManyMutationInput, PublicationUncheckedUpdateManyInput>
    /**
     * Filter which Publications to update
     */
    where?: PublicationWhereInput
  }

  /**
   * Publication upsert
   */
  export type PublicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Publication to update in case it exists.
     */
    where: PublicationWhereUniqueInput
    /**
     * In case the Publication found by the `where` argument doesn't exist, create a new Publication with this data.
     */
    create: XOR<PublicationCreateInput, PublicationUncheckedCreateInput>
    /**
     * In case the Publication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublicationUpdateInput, PublicationUncheckedUpdateInput>
  }

  /**
   * Publication delete
   */
  export type PublicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter which Publication to delete.
     */
    where: PublicationWhereUniqueInput
  }

  /**
   * Publication deleteMany
   */
  export type PublicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Publications to delete
     */
    where?: PublicationWhereInput
  }

  /**
   * Publication.bookmarks
   */
  export type Publication$bookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    where?: BookmarkWhereInput
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    cursor?: BookmarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Publication.admins
   */
  export type Publication$adminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    cursor?: UserProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * Publication.editors
   */
  export type Publication$editorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    cursor?: UserProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * Publication.posts
   */
  export type Publication$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Publication without action
   */
  export type PublicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    mediaType: $Enums.MediaType | null
    status: string | null
    fileContent: string | null
    fileName: string | null
    transcription: string | null
    extractedText: string | null
    createdAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    mediaType: $Enums.MediaType | null
    status: string | null
    fileContent: string | null
    fileName: string | null
    transcription: string | null
    extractedText: string | null
    createdAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    mediaType: number
    status: number
    fileContent: number
    fileName: number
    transcription: number
    extractedText: number
    createdAt: number
    _all: number
  }


  export type MediaMinAggregateInputType = {
    id?: true
    mediaType?: true
    status?: true
    fileContent?: true
    fileName?: true
    transcription?: true
    extractedText?: true
    createdAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    mediaType?: true
    status?: true
    fileContent?: true
    fileName?: true
    transcription?: true
    extractedText?: true
    createdAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    mediaType?: true
    status?: true
    fileContent?: true
    fileName?: true
    transcription?: true
    extractedText?: true
    createdAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    mediaType: $Enums.MediaType
    status: string
    fileContent: string | null
    fileName: string
    transcription: string | null
    extractedText: string | null
    createdAt: Date
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mediaType?: boolean
    status?: boolean
    fileContent?: boolean
    fileName?: boolean
    transcription?: boolean
    extractedText?: boolean
    createdAt?: boolean
    commentReplies?: boolean | Media$commentRepliesArgs<ExtArgs>
    posts?: boolean | Media$postsArgs<ExtArgs>
    comments?: boolean | Media$commentsArgs<ExtArgs>
    pollPosts?: boolean | Media$pollPostsArgs<ExtArgs>
    notes?: boolean | Media$notesArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mediaType?: boolean
    status?: boolean
    fileContent?: boolean
    fileName?: boolean
    transcription?: boolean
    extractedText?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    mediaType?: boolean
    status?: boolean
    fileContent?: boolean
    fileName?: boolean
    transcription?: boolean
    extractedText?: boolean
    createdAt?: boolean
  }

  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commentReplies?: boolean | Media$commentRepliesArgs<ExtArgs>
    posts?: boolean | Media$postsArgs<ExtArgs>
    comments?: boolean | Media$commentsArgs<ExtArgs>
    pollPosts?: boolean | Media$pollPostsArgs<ExtArgs>
    notes?: boolean | Media$notesArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      commentReplies: Prisma.$CommentReplyPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      pollPosts: Prisma.$PollPostPayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mediaType: $Enums.MediaType
      status: string
      fileContent: string | null
      fileName: string
      transcription: string | null
      extractedText: string | null
      createdAt: Date
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    commentReplies<T extends Media$commentRepliesArgs<ExtArgs> = {}>(args?: Subset<T, Media$commentRepliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends Media$postsArgs<ExtArgs> = {}>(args?: Subset<T, Media$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends Media$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Media$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    pollPosts<T extends Media$pollPostsArgs<ExtArgs> = {}>(args?: Subset<T, Media$pollPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "findMany"> | Null>
    notes<T extends Media$notesArgs<ExtArgs> = {}>(args?: Subset<T, Media$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */ 
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly mediaType: FieldRef<"Media", 'MediaType'>
    readonly status: FieldRef<"Media", 'String'>
    readonly fileContent: FieldRef<"Media", 'String'>
    readonly fileName: FieldRef<"Media", 'String'>
    readonly transcription: FieldRef<"Media", 'String'>
    readonly extractedText: FieldRef<"Media", 'String'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
  }

  /**
   * Media.commentReplies
   */
  export type Media$commentRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    where?: CommentReplyWhereInput
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    cursor?: CommentReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentReplyScalarFieldEnum | CommentReplyScalarFieldEnum[]
  }

  /**
   * Media.posts
   */
  export type Media$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Media.comments
   */
  export type Media$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Media.pollPosts
   */
  export type Media$pollPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    where?: PollPostWhereInput
    orderBy?: PollPostOrderByWithRelationInput | PollPostOrderByWithRelationInput[]
    cursor?: PollPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PollPostScalarFieldEnum | PollPostScalarFieldEnum[]
  }

  /**
   * Media.notes
   */
  export type Media$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    profileId: number | null
    affinityScore: number | null
    qualityScore: number | null
    viewCount: number | null
    version: number | null
  }

  export type PostSumAggregateOutputType = {
    profileId: number | null
    affinityScore: number | null
    qualityScore: number | null
    viewCount: number | null
    version: number | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    authorId: string | null
    communityId: string | null
    parentSpaceId: string | null
    title: string | null
    content: string | null
    description: string | null
    status: $Enums.PostStatus | null
    workflowStatus: string | null
    assignedTo: string | null
    contentFormat: string | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
    postType: $Enums.PostType | null
    category: $Enums.Category | null
    threadParticipantType: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string | null
    profileId: number | null
    authorUsername: string | null
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType | null
    topicName: string | null
    mediaId: string | null
    backgroundImageUrl: string | null
    affinityScore: number | null
    qualityScore: number | null
    viewCount: number | null
    readingTime: string | null
    aiGeneratedQuestionResponse: string | null
    threadId: string | null
    spaceId: string | null
    channelId: string | null
    visibility: $Enums.Visibility | null
    isPinned: boolean | null
    isArchived: boolean | null
    version: number | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    authorId: string | null
    communityId: string | null
    parentSpaceId: string | null
    title: string | null
    content: string | null
    description: string | null
    status: $Enums.PostStatus | null
    workflowStatus: string | null
    assignedTo: string | null
    contentFormat: string | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
    postType: $Enums.PostType | null
    category: $Enums.Category | null
    threadParticipantType: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string | null
    profileId: number | null
    authorUsername: string | null
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType | null
    topicName: string | null
    mediaId: string | null
    backgroundImageUrl: string | null
    affinityScore: number | null
    qualityScore: number | null
    viewCount: number | null
    readingTime: string | null
    aiGeneratedQuestionResponse: string | null
    threadId: string | null
    spaceId: string | null
    channelId: string | null
    visibility: $Enums.Visibility | null
    isPinned: boolean | null
    isArchived: boolean | null
    version: number | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    authorId: number
    communityId: number
    parentSpaceId: number
    title: number
    content: number
    description: number
    status: number
    workflowStatus: number
    assignedTo: number
    contentFormat: number
    createdAt: number
    updatedAt: number
    publishedAt: number
    postType: number
    category: number
    threadParticipantType: number
    backendPlatformUserId: number
    profileId: number
    authorUsername: number
    authorProfileImage: number
    authorAccountType: number
    tags: number
    mentions: number
    hashtags: number
    topicName: number
    mediaId: number
    backgroundImageUrl: number
    affinityScore: number
    qualityScore: number
    viewCount: number
    userIdToAffinityScoreMap: number
    userIdToReportsMap: number
    userIdToReactionMap: number
    insights: number
    readingTime: number
    aiGeneratedQuestionResponse: number
    aiAnalysis: number
    searchMetadata: number
    metadata: number
    threadId: number
    spaceId: number
    channelId: number
    extra: number
    visibility: number
    isPinned: number
    isArchived: number
    workflow: number
    version: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    profileId?: true
    affinityScore?: true
    qualityScore?: true
    viewCount?: true
    version?: true
  }

  export type PostSumAggregateInputType = {
    profileId?: true
    affinityScore?: true
    qualityScore?: true
    viewCount?: true
    version?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    authorId?: true
    communityId?: true
    parentSpaceId?: true
    title?: true
    content?: true
    description?: true
    status?: true
    workflowStatus?: true
    assignedTo?: true
    contentFormat?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    postType?: true
    category?: true
    threadParticipantType?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    topicName?: true
    mediaId?: true
    backgroundImageUrl?: true
    affinityScore?: true
    qualityScore?: true
    viewCount?: true
    readingTime?: true
    aiGeneratedQuestionResponse?: true
    threadId?: true
    spaceId?: true
    channelId?: true
    visibility?: true
    isPinned?: true
    isArchived?: true
    version?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    authorId?: true
    communityId?: true
    parentSpaceId?: true
    title?: true
    content?: true
    description?: true
    status?: true
    workflowStatus?: true
    assignedTo?: true
    contentFormat?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    postType?: true
    category?: true
    threadParticipantType?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    topicName?: true
    mediaId?: true
    backgroundImageUrl?: true
    affinityScore?: true
    qualityScore?: true
    viewCount?: true
    readingTime?: true
    aiGeneratedQuestionResponse?: true
    threadId?: true
    spaceId?: true
    channelId?: true
    visibility?: true
    isPinned?: true
    isArchived?: true
    version?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    authorId?: true
    communityId?: true
    parentSpaceId?: true
    title?: true
    content?: true
    description?: true
    status?: true
    workflowStatus?: true
    assignedTo?: true
    contentFormat?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    postType?: true
    category?: true
    threadParticipantType?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    tags?: true
    mentions?: true
    hashtags?: true
    topicName?: true
    mediaId?: true
    backgroundImageUrl?: true
    affinityScore?: true
    qualityScore?: true
    viewCount?: true
    userIdToAffinityScoreMap?: true
    userIdToReportsMap?: true
    userIdToReactionMap?: true
    insights?: true
    readingTime?: true
    aiGeneratedQuestionResponse?: true
    aiAnalysis?: true
    searchMetadata?: true
    metadata?: true
    threadId?: true
    spaceId?: true
    channelId?: true
    extra?: true
    visibility?: true
    isPinned?: true
    isArchived?: true
    workflow?: true
    version?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    authorId: string
    communityId: string | null
    parentSpaceId: string | null
    title: string | null
    content: string
    description: string | null
    status: $Enums.PostStatus
    workflowStatus: string | null
    assignedTo: string | null
    contentFormat: string
    createdAt: Date
    updatedAt: Date
    publishedAt: Date | null
    postType: $Enums.PostType
    category: $Enums.Category | null
    threadParticipantType: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType
    tags: string[]
    mentions: string[]
    hashtags: string[]
    topicName: string | null
    mediaId: string | null
    backgroundImageUrl: string | null
    affinityScore: number
    qualityScore: number
    viewCount: number
    userIdToAffinityScoreMap: JsonValue | null
    userIdToReportsMap: JsonValue | null
    userIdToReactionMap: JsonValue | null
    insights: JsonValue | null
    readingTime: string | null
    aiGeneratedQuestionResponse: string | null
    aiAnalysis: JsonValue | null
    searchMetadata: JsonValue | null
    metadata: JsonValue | null
    threadId: string | null
    spaceId: string | null
    channelId: string | null
    extra: JsonValue | null
    visibility: $Enums.Visibility
    isPinned: boolean
    isArchived: boolean
    workflow: JsonValue | null
    version: number
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    communityId?: boolean
    parentSpaceId?: boolean
    title?: boolean
    content?: boolean
    description?: boolean
    status?: boolean
    workflowStatus?: boolean
    assignedTo?: boolean
    contentFormat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    postType?: boolean
    category?: boolean
    threadParticipantType?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUsername?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    tags?: boolean
    mentions?: boolean
    hashtags?: boolean
    topicName?: boolean
    mediaId?: boolean
    backgroundImageUrl?: boolean
    affinityScore?: boolean
    qualityScore?: boolean
    viewCount?: boolean
    userIdToAffinityScoreMap?: boolean
    userIdToReportsMap?: boolean
    userIdToReactionMap?: boolean
    insights?: boolean
    readingTime?: boolean
    aiGeneratedQuestionResponse?: boolean
    aiAnalysis?: boolean
    searchMetadata?: boolean
    metadata?: boolean
    threadId?: boolean
    spaceId?: boolean
    channelId?: boolean
    extra?: boolean
    visibility?: boolean
    isPinned?: boolean
    isArchived?: boolean
    workflow?: boolean
    version?: boolean
    media?: boolean | Post$mediaArgs<ExtArgs>
    files?: boolean | Post$filesArgs<ExtArgs>
    author?: boolean | UserProfileDefaultArgs<ExtArgs>
    community?: boolean | Post$communityArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    reactions?: boolean | Post$reactionsArgs<ExtArgs>
    bookmarks?: boolean | Post$bookmarksArgs<ExtArgs>
    publications?: boolean | Post$publicationsArgs<ExtArgs>
    reports?: boolean | Post$reportsArgs<ExtArgs>
    notes?: boolean | Post$notesArgs<ExtArgs>
    thread?: boolean | Post$threadArgs<ExtArgs>
    space?: boolean | Post$spaceArgs<ExtArgs>
    channel?: boolean | Post$channelArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    communityId?: boolean
    parentSpaceId?: boolean
    title?: boolean
    content?: boolean
    description?: boolean
    status?: boolean
    workflowStatus?: boolean
    assignedTo?: boolean
    contentFormat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    postType?: boolean
    category?: boolean
    threadParticipantType?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUsername?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    tags?: boolean
    mentions?: boolean
    hashtags?: boolean
    topicName?: boolean
    mediaId?: boolean
    backgroundImageUrl?: boolean
    affinityScore?: boolean
    qualityScore?: boolean
    viewCount?: boolean
    userIdToAffinityScoreMap?: boolean
    userIdToReportsMap?: boolean
    userIdToReactionMap?: boolean
    insights?: boolean
    readingTime?: boolean
    aiGeneratedQuestionResponse?: boolean
    aiAnalysis?: boolean
    searchMetadata?: boolean
    metadata?: boolean
    threadId?: boolean
    spaceId?: boolean
    channelId?: boolean
    extra?: boolean
    visibility?: boolean
    isPinned?: boolean
    isArchived?: boolean
    workflow?: boolean
    version?: boolean
    media?: boolean | Post$mediaArgs<ExtArgs>
    author?: boolean | UserProfileDefaultArgs<ExtArgs>
    community?: boolean | Post$communityArgs<ExtArgs>
    thread?: boolean | Post$threadArgs<ExtArgs>
    space?: boolean | Post$spaceArgs<ExtArgs>
    channel?: boolean | Post$channelArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    authorId?: boolean
    communityId?: boolean
    parentSpaceId?: boolean
    title?: boolean
    content?: boolean
    description?: boolean
    status?: boolean
    workflowStatus?: boolean
    assignedTo?: boolean
    contentFormat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    postType?: boolean
    category?: boolean
    threadParticipantType?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUsername?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    tags?: boolean
    mentions?: boolean
    hashtags?: boolean
    topicName?: boolean
    mediaId?: boolean
    backgroundImageUrl?: boolean
    affinityScore?: boolean
    qualityScore?: boolean
    viewCount?: boolean
    userIdToAffinityScoreMap?: boolean
    userIdToReportsMap?: boolean
    userIdToReactionMap?: boolean
    insights?: boolean
    readingTime?: boolean
    aiGeneratedQuestionResponse?: boolean
    aiAnalysis?: boolean
    searchMetadata?: boolean
    metadata?: boolean
    threadId?: boolean
    spaceId?: boolean
    channelId?: boolean
    extra?: boolean
    visibility?: boolean
    isPinned?: boolean
    isArchived?: boolean
    workflow?: boolean
    version?: boolean
  }

  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | Post$mediaArgs<ExtArgs>
    files?: boolean | Post$filesArgs<ExtArgs>
    author?: boolean | UserProfileDefaultArgs<ExtArgs>
    community?: boolean | Post$communityArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    reactions?: boolean | Post$reactionsArgs<ExtArgs>
    bookmarks?: boolean | Post$bookmarksArgs<ExtArgs>
    publications?: boolean | Post$publicationsArgs<ExtArgs>
    reports?: boolean | Post$reportsArgs<ExtArgs>
    notes?: boolean | Post$notesArgs<ExtArgs>
    thread?: boolean | Post$threadArgs<ExtArgs>
    space?: boolean | Post$spaceArgs<ExtArgs>
    channel?: boolean | Post$channelArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | Post$mediaArgs<ExtArgs>
    author?: boolean | UserProfileDefaultArgs<ExtArgs>
    community?: boolean | Post$communityArgs<ExtArgs>
    thread?: boolean | Post$threadArgs<ExtArgs>
    space?: boolean | Post$spaceArgs<ExtArgs>
    channel?: boolean | Post$channelArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs> | null
      files: Prisma.$FilePayload<ExtArgs>[]
      author: Prisma.$UserProfilePayload<ExtArgs>
      community: Prisma.$CommunityProfilePayload<ExtArgs> | null
      comments: Prisma.$CommentPayload<ExtArgs>[]
      reactions: Prisma.$ReactionPayload<ExtArgs>[]
      bookmarks: Prisma.$BookmarkPayload<ExtArgs>[]
      publications: Prisma.$PublicationPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
      thread: Prisma.$ThreadPayload<ExtArgs> | null
      space: Prisma.$SpacePayload<ExtArgs> | null
      channel: Prisma.$ChannelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authorId: string
      communityId: string | null
      parentSpaceId: string | null
      title: string | null
      content: string
      description: string | null
      status: $Enums.PostStatus
      workflowStatus: string | null
      assignedTo: string | null
      contentFormat: string
      createdAt: Date
      updatedAt: Date
      publishedAt: Date | null
      postType: $Enums.PostType
      category: $Enums.Category | null
      threadParticipantType: $Enums.ThreadParticipantType | null
      backendPlatformUserId: string
      profileId: number
      authorUsername: string
      authorProfileImage: string | null
      authorAccountType: $Enums.AccountType
      tags: string[]
      mentions: string[]
      hashtags: string[]
      topicName: string | null
      mediaId: string | null
      backgroundImageUrl: string | null
      affinityScore: number
      qualityScore: number
      viewCount: number
      userIdToAffinityScoreMap: Prisma.JsonValue | null
      userIdToReportsMap: Prisma.JsonValue | null
      userIdToReactionMap: Prisma.JsonValue | null
      insights: Prisma.JsonValue | null
      readingTime: string | null
      aiGeneratedQuestionResponse: string | null
      aiAnalysis: Prisma.JsonValue | null
      searchMetadata: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      threadId: string | null
      spaceId: string | null
      channelId: string | null
      extra: Prisma.JsonValue | null
      visibility: $Enums.Visibility
      isPinned: boolean
      isArchived: boolean
      workflow: Prisma.JsonValue | null
      version: number
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends Post$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Post$mediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    files<T extends Post$filesArgs<ExtArgs> = {}>(args?: Subset<T, Post$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany"> | Null>
    author<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    community<T extends Post$communityArgs<ExtArgs> = {}>(args?: Subset<T, Post$communityArgs<ExtArgs>>): Prisma__CommunityProfileClient<$Result.GetResult<Prisma.$CommunityProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    reactions<T extends Post$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, Post$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany"> | Null>
    bookmarks<T extends Post$bookmarksArgs<ExtArgs> = {}>(args?: Subset<T, Post$bookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findMany"> | Null>
    publications<T extends Post$publicationsArgs<ExtArgs> = {}>(args?: Subset<T, Post$publicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends Post$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Post$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    notes<T extends Post$notesArgs<ExtArgs> = {}>(args?: Subset<T, Post$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany"> | Null>
    thread<T extends Post$threadArgs<ExtArgs> = {}>(args?: Subset<T, Post$threadArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    space<T extends Post$spaceArgs<ExtArgs> = {}>(args?: Subset<T, Post$spaceArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    channel<T extends Post$channelArgs<ExtArgs> = {}>(args?: Subset<T, Post$channelArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */ 
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly authorId: FieldRef<"Post", 'String'>
    readonly communityId: FieldRef<"Post", 'String'>
    readonly parentSpaceId: FieldRef<"Post", 'String'>
    readonly title: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly description: FieldRef<"Post", 'String'>
    readonly status: FieldRef<"Post", 'PostStatus'>
    readonly workflowStatus: FieldRef<"Post", 'String'>
    readonly assignedTo: FieldRef<"Post", 'String'>
    readonly contentFormat: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
    readonly publishedAt: FieldRef<"Post", 'DateTime'>
    readonly postType: FieldRef<"Post", 'PostType'>
    readonly category: FieldRef<"Post", 'Category'>
    readonly threadParticipantType: FieldRef<"Post", 'ThreadParticipantType'>
    readonly backendPlatformUserId: FieldRef<"Post", 'String'>
    readonly profileId: FieldRef<"Post", 'Int'>
    readonly authorUsername: FieldRef<"Post", 'String'>
    readonly authorProfileImage: FieldRef<"Post", 'String'>
    readonly authorAccountType: FieldRef<"Post", 'AccountType'>
    readonly tags: FieldRef<"Post", 'String[]'>
    readonly mentions: FieldRef<"Post", 'String[]'>
    readonly hashtags: FieldRef<"Post", 'String[]'>
    readonly topicName: FieldRef<"Post", 'String'>
    readonly mediaId: FieldRef<"Post", 'String'>
    readonly backgroundImageUrl: FieldRef<"Post", 'String'>
    readonly affinityScore: FieldRef<"Post", 'Int'>
    readonly qualityScore: FieldRef<"Post", 'Int'>
    readonly viewCount: FieldRef<"Post", 'Int'>
    readonly userIdToAffinityScoreMap: FieldRef<"Post", 'Json'>
    readonly userIdToReportsMap: FieldRef<"Post", 'Json'>
    readonly userIdToReactionMap: FieldRef<"Post", 'Json'>
    readonly insights: FieldRef<"Post", 'Json'>
    readonly readingTime: FieldRef<"Post", 'String'>
    readonly aiGeneratedQuestionResponse: FieldRef<"Post", 'String'>
    readonly aiAnalysis: FieldRef<"Post", 'Json'>
    readonly searchMetadata: FieldRef<"Post", 'Json'>
    readonly metadata: FieldRef<"Post", 'Json'>
    readonly threadId: FieldRef<"Post", 'String'>
    readonly spaceId: FieldRef<"Post", 'String'>
    readonly channelId: FieldRef<"Post", 'String'>
    readonly extra: FieldRef<"Post", 'Json'>
    readonly visibility: FieldRef<"Post", 'Visibility'>
    readonly isPinned: FieldRef<"Post", 'Boolean'>
    readonly isArchived: FieldRef<"Post", 'Boolean'>
    readonly workflow: FieldRef<"Post", 'Json'>
    readonly version: FieldRef<"Post", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }

  /**
   * Post.media
   */
  export type Post$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Post.files
   */
  export type Post$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Post.community
   */
  export type Post$communityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityProfile
     */
    select?: CommunityProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityProfileInclude<ExtArgs> | null
    where?: CommunityProfileWhereInput
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post.reactions
   */
  export type Post$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    cursor?: ReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Post.bookmarks
   */
  export type Post$bookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    where?: BookmarkWhereInput
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    cursor?: BookmarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Post.publications
   */
  export type Post$publicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    where?: PublicationWhereInput
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    cursor?: PublicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }

  /**
   * Post.reports
   */
  export type Post$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Post.notes
   */
  export type Post$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Post.thread
   */
  export type Post$threadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    where?: ThreadWhereInput
  }

  /**
   * Post.space
   */
  export type Post$spaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    where?: SpaceWhereInput
  }

  /**
   * Post.channel
   */
  export type Post$channelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model PollPost
   */

  export type AggregatePollPost = {
    _count: PollPostCountAggregateOutputType | null
    _avg: PollPostAvgAggregateOutputType | null
    _sum: PollPostSumAggregateOutputType | null
    _min: PollPostMinAggregateOutputType | null
    _max: PollPostMaxAggregateOutputType | null
  }

  export type PollPostAvgAggregateOutputType = {
    profileId: number | null
  }

  export type PollPostSumAggregateOutputType = {
    profileId: number | null
  }

  export type PollPostMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    action: $Enums.PostType | null
    content: string | null
    title: string | null
    pollEndDate: Date | null
    topicName: string | null
    backendPlatformUserId: string | null
    profileId: number | null
    mediaId: string | null
    threadId: string | null
  }

  export type PollPostMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    action: $Enums.PostType | null
    content: string | null
    title: string | null
    pollEndDate: Date | null
    topicName: string | null
    backendPlatformUserId: string | null
    profileId: number | null
    mediaId: string | null
    threadId: string | null
  }

  export type PollPostCountAggregateOutputType = {
    id: number
    createdAt: number
    action: number
    content: number
    title: number
    pollOptions: number
    pollDistribution: number
    userIdToPollResponsesMap: number
    pollEndDate: number
    mentions: number
    hashtags: number
    tags: number
    topicName: number
    backendPlatformUserId: number
    profileId: number
    mediaId: number
    threadId: number
    extra: number
    searchMetadata: number
    aiAnalysis: number
    _all: number
  }


  export type PollPostAvgAggregateInputType = {
    profileId?: true
  }

  export type PollPostSumAggregateInputType = {
    profileId?: true
  }

  export type PollPostMinAggregateInputType = {
    id?: true
    createdAt?: true
    action?: true
    content?: true
    title?: true
    pollEndDate?: true
    topicName?: true
    backendPlatformUserId?: true
    profileId?: true
    mediaId?: true
    threadId?: true
  }

  export type PollPostMaxAggregateInputType = {
    id?: true
    createdAt?: true
    action?: true
    content?: true
    title?: true
    pollEndDate?: true
    topicName?: true
    backendPlatformUserId?: true
    profileId?: true
    mediaId?: true
    threadId?: true
  }

  export type PollPostCountAggregateInputType = {
    id?: true
    createdAt?: true
    action?: true
    content?: true
    title?: true
    pollOptions?: true
    pollDistribution?: true
    userIdToPollResponsesMap?: true
    pollEndDate?: true
    mentions?: true
    hashtags?: true
    tags?: true
    topicName?: true
    backendPlatformUserId?: true
    profileId?: true
    mediaId?: true
    threadId?: true
    extra?: true
    searchMetadata?: true
    aiAnalysis?: true
    _all?: true
  }

  export type PollPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PollPost to aggregate.
     */
    where?: PollPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollPosts to fetch.
     */
    orderBy?: PollPostOrderByWithRelationInput | PollPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PollPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PollPosts
    **/
    _count?: true | PollPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PollPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PollPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PollPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PollPostMaxAggregateInputType
  }

  export type GetPollPostAggregateType<T extends PollPostAggregateArgs> = {
        [P in keyof T & keyof AggregatePollPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePollPost[P]>
      : GetScalarType<T[P], AggregatePollPost[P]>
  }




  export type PollPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollPostWhereInput
    orderBy?: PollPostOrderByWithAggregationInput | PollPostOrderByWithAggregationInput[]
    by: PollPostScalarFieldEnum[] | PollPostScalarFieldEnum
    having?: PollPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PollPostCountAggregateInputType | true
    _avg?: PollPostAvgAggregateInputType
    _sum?: PollPostSumAggregateInputType
    _min?: PollPostMinAggregateInputType
    _max?: PollPostMaxAggregateInputType
  }

  export type PollPostGroupByOutputType = {
    id: string
    createdAt: Date
    action: $Enums.PostType
    content: string
    title: string | null
    pollOptions: string[]
    pollDistribution: JsonValue | null
    userIdToPollResponsesMap: JsonValue | null
    pollEndDate: Date
    mentions: string[]
    hashtags: string[]
    tags: string[]
    topicName: string | null
    backendPlatformUserId: string
    profileId: number
    mediaId: string | null
    threadId: string | null
    extra: JsonValue | null
    searchMetadata: JsonValue | null
    aiAnalysis: JsonValue | null
    _count: PollPostCountAggregateOutputType | null
    _avg: PollPostAvgAggregateOutputType | null
    _sum: PollPostSumAggregateOutputType | null
    _min: PollPostMinAggregateOutputType | null
    _max: PollPostMaxAggregateOutputType | null
  }

  type GetPollPostGroupByPayload<T extends PollPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PollPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PollPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PollPostGroupByOutputType[P]>
            : GetScalarType<T[P], PollPostGroupByOutputType[P]>
        }
      >
    >


  export type PollPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    action?: boolean
    content?: boolean
    title?: boolean
    pollOptions?: boolean
    pollDistribution?: boolean
    userIdToPollResponsesMap?: boolean
    pollEndDate?: boolean
    mentions?: boolean
    hashtags?: boolean
    tags?: boolean
    topicName?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    mediaId?: boolean
    threadId?: boolean
    extra?: boolean
    searchMetadata?: boolean
    aiAnalysis?: boolean
    media?: boolean | PollPost$mediaArgs<ExtArgs>
    comments?: boolean | PollPost$commentsArgs<ExtArgs>
    thread?: boolean | PollPost$threadArgs<ExtArgs>
    _count?: boolean | PollPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pollPost"]>

  export type PollPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    action?: boolean
    content?: boolean
    title?: boolean
    pollOptions?: boolean
    pollDistribution?: boolean
    userIdToPollResponsesMap?: boolean
    pollEndDate?: boolean
    mentions?: boolean
    hashtags?: boolean
    tags?: boolean
    topicName?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    mediaId?: boolean
    threadId?: boolean
    extra?: boolean
    searchMetadata?: boolean
    aiAnalysis?: boolean
    media?: boolean | PollPost$mediaArgs<ExtArgs>
    thread?: boolean | PollPost$threadArgs<ExtArgs>
  }, ExtArgs["result"]["pollPost"]>

  export type PollPostSelectScalar = {
    id?: boolean
    createdAt?: boolean
    action?: boolean
    content?: boolean
    title?: boolean
    pollOptions?: boolean
    pollDistribution?: boolean
    userIdToPollResponsesMap?: boolean
    pollEndDate?: boolean
    mentions?: boolean
    hashtags?: boolean
    tags?: boolean
    topicName?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    mediaId?: boolean
    threadId?: boolean
    extra?: boolean
    searchMetadata?: boolean
    aiAnalysis?: boolean
  }

  export type PollPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | PollPost$mediaArgs<ExtArgs>
    comments?: boolean | PollPost$commentsArgs<ExtArgs>
    thread?: boolean | PollPost$threadArgs<ExtArgs>
    _count?: boolean | PollPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PollPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | PollPost$mediaArgs<ExtArgs>
    thread?: boolean | PollPost$threadArgs<ExtArgs>
  }

  export type $PollPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PollPost"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs> | null
      comments: Prisma.$CommentPayload<ExtArgs>[]
      thread: Prisma.$ThreadPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      action: $Enums.PostType
      content: string
      title: string | null
      pollOptions: string[]
      pollDistribution: Prisma.JsonValue | null
      userIdToPollResponsesMap: Prisma.JsonValue | null
      pollEndDate: Date
      mentions: string[]
      hashtags: string[]
      tags: string[]
      topicName: string | null
      backendPlatformUserId: string
      profileId: number
      mediaId: string | null
      threadId: string | null
      extra: Prisma.JsonValue | null
      searchMetadata: Prisma.JsonValue | null
      aiAnalysis: Prisma.JsonValue | null
    }, ExtArgs["result"]["pollPost"]>
    composites: {}
  }

  type PollPostGetPayload<S extends boolean | null | undefined | PollPostDefaultArgs> = $Result.GetResult<Prisma.$PollPostPayload, S>

  type PollPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PollPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PollPostCountAggregateInputType | true
    }

  export interface PollPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PollPost'], meta: { name: 'PollPost' } }
    /**
     * Find zero or one PollPost that matches the filter.
     * @param {PollPostFindUniqueArgs} args - Arguments to find a PollPost
     * @example
     * // Get one PollPost
     * const pollPost = await prisma.pollPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PollPostFindUniqueArgs>(args: SelectSubset<T, PollPostFindUniqueArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PollPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PollPostFindUniqueOrThrowArgs} args - Arguments to find a PollPost
     * @example
     * // Get one PollPost
     * const pollPost = await prisma.pollPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PollPostFindUniqueOrThrowArgs>(args: SelectSubset<T, PollPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PollPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollPostFindFirstArgs} args - Arguments to find a PollPost
     * @example
     * // Get one PollPost
     * const pollPost = await prisma.pollPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PollPostFindFirstArgs>(args?: SelectSubset<T, PollPostFindFirstArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PollPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollPostFindFirstOrThrowArgs} args - Arguments to find a PollPost
     * @example
     * // Get one PollPost
     * const pollPost = await prisma.pollPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PollPostFindFirstOrThrowArgs>(args?: SelectSubset<T, PollPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PollPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PollPosts
     * const pollPosts = await prisma.pollPost.findMany()
     * 
     * // Get first 10 PollPosts
     * const pollPosts = await prisma.pollPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pollPostWithIdOnly = await prisma.pollPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PollPostFindManyArgs>(args?: SelectSubset<T, PollPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PollPost.
     * @param {PollPostCreateArgs} args - Arguments to create a PollPost.
     * @example
     * // Create one PollPost
     * const PollPost = await prisma.pollPost.create({
     *   data: {
     *     // ... data to create a PollPost
     *   }
     * })
     * 
     */
    create<T extends PollPostCreateArgs>(args: SelectSubset<T, PollPostCreateArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PollPosts.
     * @param {PollPostCreateManyArgs} args - Arguments to create many PollPosts.
     * @example
     * // Create many PollPosts
     * const pollPost = await prisma.pollPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PollPostCreateManyArgs>(args?: SelectSubset<T, PollPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PollPosts and returns the data saved in the database.
     * @param {PollPostCreateManyAndReturnArgs} args - Arguments to create many PollPosts.
     * @example
     * // Create many PollPosts
     * const pollPost = await prisma.pollPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PollPosts and only return the `id`
     * const pollPostWithIdOnly = await prisma.pollPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PollPostCreateManyAndReturnArgs>(args?: SelectSubset<T, PollPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PollPost.
     * @param {PollPostDeleteArgs} args - Arguments to delete one PollPost.
     * @example
     * // Delete one PollPost
     * const PollPost = await prisma.pollPost.delete({
     *   where: {
     *     // ... filter to delete one PollPost
     *   }
     * })
     * 
     */
    delete<T extends PollPostDeleteArgs>(args: SelectSubset<T, PollPostDeleteArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PollPost.
     * @param {PollPostUpdateArgs} args - Arguments to update one PollPost.
     * @example
     * // Update one PollPost
     * const pollPost = await prisma.pollPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PollPostUpdateArgs>(args: SelectSubset<T, PollPostUpdateArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PollPosts.
     * @param {PollPostDeleteManyArgs} args - Arguments to filter PollPosts to delete.
     * @example
     * // Delete a few PollPosts
     * const { count } = await prisma.pollPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PollPostDeleteManyArgs>(args?: SelectSubset<T, PollPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PollPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PollPosts
     * const pollPost = await prisma.pollPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PollPostUpdateManyArgs>(args: SelectSubset<T, PollPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PollPost.
     * @param {PollPostUpsertArgs} args - Arguments to update or create a PollPost.
     * @example
     * // Update or create a PollPost
     * const pollPost = await prisma.pollPost.upsert({
     *   create: {
     *     // ... data to create a PollPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PollPost we want to update
     *   }
     * })
     */
    upsert<T extends PollPostUpsertArgs>(args: SelectSubset<T, PollPostUpsertArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PollPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollPostCountArgs} args - Arguments to filter PollPosts to count.
     * @example
     * // Count the number of PollPosts
     * const count = await prisma.pollPost.count({
     *   where: {
     *     // ... the filter for the PollPosts we want to count
     *   }
     * })
    **/
    count<T extends PollPostCountArgs>(
      args?: Subset<T, PollPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PollPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PollPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PollPostAggregateArgs>(args: Subset<T, PollPostAggregateArgs>): Prisma.PrismaPromise<GetPollPostAggregateType<T>>

    /**
     * Group by PollPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PollPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PollPostGroupByArgs['orderBy'] }
        : { orderBy?: PollPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PollPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPollPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PollPost model
   */
  readonly fields: PollPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PollPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PollPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends PollPost$mediaArgs<ExtArgs> = {}>(args?: Subset<T, PollPost$mediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comments<T extends PollPost$commentsArgs<ExtArgs> = {}>(args?: Subset<T, PollPost$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    thread<T extends PollPost$threadArgs<ExtArgs> = {}>(args?: Subset<T, PollPost$threadArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PollPost model
   */ 
  interface PollPostFieldRefs {
    readonly id: FieldRef<"PollPost", 'String'>
    readonly createdAt: FieldRef<"PollPost", 'DateTime'>
    readonly action: FieldRef<"PollPost", 'PostType'>
    readonly content: FieldRef<"PollPost", 'String'>
    readonly title: FieldRef<"PollPost", 'String'>
    readonly pollOptions: FieldRef<"PollPost", 'String[]'>
    readonly pollDistribution: FieldRef<"PollPost", 'Json'>
    readonly userIdToPollResponsesMap: FieldRef<"PollPost", 'Json'>
    readonly pollEndDate: FieldRef<"PollPost", 'DateTime'>
    readonly mentions: FieldRef<"PollPost", 'String[]'>
    readonly hashtags: FieldRef<"PollPost", 'String[]'>
    readonly tags: FieldRef<"PollPost", 'String[]'>
    readonly topicName: FieldRef<"PollPost", 'String'>
    readonly backendPlatformUserId: FieldRef<"PollPost", 'String'>
    readonly profileId: FieldRef<"PollPost", 'Int'>
    readonly mediaId: FieldRef<"PollPost", 'String'>
    readonly threadId: FieldRef<"PollPost", 'String'>
    readonly extra: FieldRef<"PollPost", 'Json'>
    readonly searchMetadata: FieldRef<"PollPost", 'Json'>
    readonly aiAnalysis: FieldRef<"PollPost", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * PollPost findUnique
   */
  export type PollPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * Filter, which PollPost to fetch.
     */
    where: PollPostWhereUniqueInput
  }

  /**
   * PollPost findUniqueOrThrow
   */
  export type PollPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * Filter, which PollPost to fetch.
     */
    where: PollPostWhereUniqueInput
  }

  /**
   * PollPost findFirst
   */
  export type PollPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * Filter, which PollPost to fetch.
     */
    where?: PollPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollPosts to fetch.
     */
    orderBy?: PollPostOrderByWithRelationInput | PollPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PollPosts.
     */
    cursor?: PollPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PollPosts.
     */
    distinct?: PollPostScalarFieldEnum | PollPostScalarFieldEnum[]
  }

  /**
   * PollPost findFirstOrThrow
   */
  export type PollPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * Filter, which PollPost to fetch.
     */
    where?: PollPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollPosts to fetch.
     */
    orderBy?: PollPostOrderByWithRelationInput | PollPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PollPosts.
     */
    cursor?: PollPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PollPosts.
     */
    distinct?: PollPostScalarFieldEnum | PollPostScalarFieldEnum[]
  }

  /**
   * PollPost findMany
   */
  export type PollPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * Filter, which PollPosts to fetch.
     */
    where?: PollPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollPosts to fetch.
     */
    orderBy?: PollPostOrderByWithRelationInput | PollPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PollPosts.
     */
    cursor?: PollPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollPosts.
     */
    skip?: number
    distinct?: PollPostScalarFieldEnum | PollPostScalarFieldEnum[]
  }

  /**
   * PollPost create
   */
  export type PollPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * The data needed to create a PollPost.
     */
    data: XOR<PollPostCreateInput, PollPostUncheckedCreateInput>
  }

  /**
   * PollPost createMany
   */
  export type PollPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PollPosts.
     */
    data: PollPostCreateManyInput | PollPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PollPost createManyAndReturn
   */
  export type PollPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PollPosts.
     */
    data: PollPostCreateManyInput | PollPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PollPost update
   */
  export type PollPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * The data needed to update a PollPost.
     */
    data: XOR<PollPostUpdateInput, PollPostUncheckedUpdateInput>
    /**
     * Choose, which PollPost to update.
     */
    where: PollPostWhereUniqueInput
  }

  /**
   * PollPost updateMany
   */
  export type PollPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PollPosts.
     */
    data: XOR<PollPostUpdateManyMutationInput, PollPostUncheckedUpdateManyInput>
    /**
     * Filter which PollPosts to update
     */
    where?: PollPostWhereInput
  }

  /**
   * PollPost upsert
   */
  export type PollPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * The filter to search for the PollPost to update in case it exists.
     */
    where: PollPostWhereUniqueInput
    /**
     * In case the PollPost found by the `where` argument doesn't exist, create a new PollPost with this data.
     */
    create: XOR<PollPostCreateInput, PollPostUncheckedCreateInput>
    /**
     * In case the PollPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PollPostUpdateInput, PollPostUncheckedUpdateInput>
  }

  /**
   * PollPost delete
   */
  export type PollPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * Filter which PollPost to delete.
     */
    where: PollPostWhereUniqueInput
  }

  /**
   * PollPost deleteMany
   */
  export type PollPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PollPosts to delete
     */
    where?: PollPostWhereInput
  }

  /**
   * PollPost.media
   */
  export type PollPost$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * PollPost.comments
   */
  export type PollPost$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * PollPost.thread
   */
  export type PollPost$threadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    where?: ThreadWhereInput
  }

  /**
   * PollPost without action
   */
  export type PollPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    profileId: number | null
    affinityScore: number | null
    qualityScore: number | null
  }

  export type CommentSumAggregateOutputType = {
    profileId: number | null
    affinityScore: number | null
    qualityScore: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
    backendPlatformUserId: string | null
    profileId: number | null
    authorUsername: string | null
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType | null
    affinityScore: number | null
    qualityScore: number | null
    mediaId: string | null
    postId: string | null
    pollPostId: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
    backendPlatformUserId: string | null
    profileId: number | null
    authorUsername: string | null
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType | null
    affinityScore: number | null
    qualityScore: number | null
    mediaId: string | null
    postId: string | null
    pollPostId: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    authorId: number
    content: number
    createdAt: number
    backendPlatformUserId: number
    profileId: number
    authorUsername: number
    authorProfileImage: number
    authorAccountType: number
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap: number
    userIdToReportsMap: number
    userIdToReactionMap: number
    mentions: number
    hashtags: number
    mediaId: number
    postId: number
    pollPostId: number
    extra: number
    aiAnalysis: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    profileId?: true
    affinityScore?: true
    qualityScore?: true
  }

  export type CommentSumAggregateInputType = {
    profileId?: true
    affinityScore?: true
    qualityScore?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    createdAt?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    affinityScore?: true
    qualityScore?: true
    mediaId?: true
    postId?: true
    pollPostId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    createdAt?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    affinityScore?: true
    qualityScore?: true
    mediaId?: true
    postId?: true
    pollPostId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    createdAt?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    affinityScore?: true
    qualityScore?: true
    userIdToAffinityScoreMap?: true
    userIdToReportsMap?: true
    userIdToReactionMap?: true
    mentions?: true
    hashtags?: true
    mediaId?: true
    postId?: true
    pollPostId?: true
    extra?: true
    aiAnalysis?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    authorId: string
    content: string
    createdAt: Date
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap: JsonValue | null
    userIdToReportsMap: JsonValue | null
    userIdToReactionMap: JsonValue | null
    mentions: string[]
    hashtags: string[]
    mediaId: string | null
    postId: string
    pollPostId: string | null
    extra: JsonValue | null
    aiAnalysis: JsonValue | null
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUsername?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    affinityScore?: boolean
    qualityScore?: boolean
    userIdToAffinityScoreMap?: boolean
    userIdToReportsMap?: boolean
    userIdToReactionMap?: boolean
    mentions?: boolean
    hashtags?: boolean
    mediaId?: boolean
    postId?: boolean
    pollPostId?: boolean
    extra?: boolean
    aiAnalysis?: boolean
    media?: boolean | Comment$mediaArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    notes?: boolean | Comment$notesArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    pollPost?: boolean | Comment$pollPostArgs<ExtArgs>
    Report?: boolean | Comment$ReportArgs<ExtArgs>
    Reaction?: boolean | Comment$ReactionArgs<ExtArgs>
    UserProfile?: boolean | Comment$UserProfileArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUsername?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    affinityScore?: boolean
    qualityScore?: boolean
    userIdToAffinityScoreMap?: boolean
    userIdToReportsMap?: boolean
    userIdToReactionMap?: boolean
    mentions?: boolean
    hashtags?: boolean
    mediaId?: boolean
    postId?: boolean
    pollPostId?: boolean
    extra?: boolean
    aiAnalysis?: boolean
    media?: boolean | Comment$mediaArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    pollPost?: boolean | Comment$pollPostArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUsername?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    affinityScore?: boolean
    qualityScore?: boolean
    userIdToAffinityScoreMap?: boolean
    userIdToReportsMap?: boolean
    userIdToReactionMap?: boolean
    mentions?: boolean
    hashtags?: boolean
    mediaId?: boolean
    postId?: boolean
    pollPostId?: boolean
    extra?: boolean
    aiAnalysis?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | Comment$mediaArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    notes?: boolean | Comment$notesArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    pollPost?: boolean | Comment$pollPostArgs<ExtArgs>
    Report?: boolean | Comment$ReportArgs<ExtArgs>
    Reaction?: boolean | Comment$ReactionArgs<ExtArgs>
    UserProfile?: boolean | Comment$UserProfileArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | Comment$mediaArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    pollPost?: boolean | Comment$pollPostArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs> | null
      replies: Prisma.$CommentReplyPayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
      post: Prisma.$PostPayload<ExtArgs>
      pollPost: Prisma.$PollPostPayload<ExtArgs> | null
      Report: Prisma.$ReportPayload<ExtArgs>[]
      Reaction: Prisma.$ReactionPayload<ExtArgs>[]
      UserProfile: Prisma.$UserProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authorId: string
      content: string
      createdAt: Date
      backendPlatformUserId: string
      profileId: number
      authorUsername: string
      authorProfileImage: string | null
      authorAccountType: $Enums.AccountType
      affinityScore: number
      qualityScore: number
      userIdToAffinityScoreMap: Prisma.JsonValue | null
      userIdToReportsMap: Prisma.JsonValue | null
      userIdToReactionMap: Prisma.JsonValue | null
      mentions: string[]
      hashtags: string[]
      mediaId: string | null
      postId: string
      pollPostId: string | null
      extra: Prisma.JsonValue | null
      aiAnalysis: Prisma.JsonValue | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends Comment$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Comment$mediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findMany"> | Null>
    notes<T extends Comment$notesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany"> | Null>
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pollPost<T extends Comment$pollPostArgs<ExtArgs> = {}>(args?: Subset<T, Comment$pollPostArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Report<T extends Comment$ReportArgs<ExtArgs> = {}>(args?: Subset<T, Comment$ReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    Reaction<T extends Comment$ReactionArgs<ExtArgs> = {}>(args?: Subset<T, Comment$ReactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany"> | Null>
    UserProfile<T extends Comment$UserProfileArgs<ExtArgs> = {}>(args?: Subset<T, Comment$UserProfileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly backendPlatformUserId: FieldRef<"Comment", 'String'>
    readonly profileId: FieldRef<"Comment", 'Int'>
    readonly authorUsername: FieldRef<"Comment", 'String'>
    readonly authorProfileImage: FieldRef<"Comment", 'String'>
    readonly authorAccountType: FieldRef<"Comment", 'AccountType'>
    readonly affinityScore: FieldRef<"Comment", 'Int'>
    readonly qualityScore: FieldRef<"Comment", 'Int'>
    readonly userIdToAffinityScoreMap: FieldRef<"Comment", 'Json'>
    readonly userIdToReportsMap: FieldRef<"Comment", 'Json'>
    readonly userIdToReactionMap: FieldRef<"Comment", 'Json'>
    readonly mentions: FieldRef<"Comment", 'String[]'>
    readonly hashtags: FieldRef<"Comment", 'String[]'>
    readonly mediaId: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly pollPostId: FieldRef<"Comment", 'String'>
    readonly extra: FieldRef<"Comment", 'Json'>
    readonly aiAnalysis: FieldRef<"Comment", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment.media
   */
  export type Comment$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    where?: CommentReplyWhereInput
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    cursor?: CommentReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentReplyScalarFieldEnum | CommentReplyScalarFieldEnum[]
  }

  /**
   * Comment.notes
   */
  export type Comment$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Comment.pollPost
   */
  export type Comment$pollPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    where?: PollPostWhereInput
  }

  /**
   * Comment.Report
   */
  export type Comment$ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Comment.Reaction
   */
  export type Comment$ReactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    cursor?: ReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Comment.UserProfile
   */
  export type Comment$UserProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    cursor?: UserProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model CommentReply
   */

  export type AggregateCommentReply = {
    _count: CommentReplyCountAggregateOutputType | null
    _avg: CommentReplyAvgAggregateOutputType | null
    _sum: CommentReplySumAggregateOutputType | null
    _min: CommentReplyMinAggregateOutputType | null
    _max: CommentReplyMaxAggregateOutputType | null
  }

  export type CommentReplyAvgAggregateOutputType = {
    profileId: number | null
    affinityScore: number | null
    qualityScore: number | null
  }

  export type CommentReplySumAggregateOutputType = {
    profileId: number | null
    affinityScore: number | null
    qualityScore: number | null
  }

  export type CommentReplyMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    backendPlatformUserId: string | null
    profileId: number | null
    authorUsername: string | null
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType | null
    affinityScore: number | null
    qualityScore: number | null
    mediaId: string | null
    commentId: string | null
  }

  export type CommentReplyMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    backendPlatformUserId: string | null
    profileId: number | null
    authorUsername: string | null
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType | null
    affinityScore: number | null
    qualityScore: number | null
    mediaId: string | null
    commentId: string | null
  }

  export type CommentReplyCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    backendPlatformUserId: number
    profileId: number
    authorUsername: number
    authorProfileImage: number
    authorAccountType: number
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap: number
    userIdToReportsMap: number
    userIdToReactionMap: number
    mentions: number
    hashtags: number
    mediaId: number
    commentId: number
    extra: number
    aiAnalysis: number
    _all: number
  }


  export type CommentReplyAvgAggregateInputType = {
    profileId?: true
    affinityScore?: true
    qualityScore?: true
  }

  export type CommentReplySumAggregateInputType = {
    profileId?: true
    affinityScore?: true
    qualityScore?: true
  }

  export type CommentReplyMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    affinityScore?: true
    qualityScore?: true
    mediaId?: true
    commentId?: true
  }

  export type CommentReplyMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    affinityScore?: true
    qualityScore?: true
    mediaId?: true
    commentId?: true
  }

  export type CommentReplyCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    affinityScore?: true
    qualityScore?: true
    userIdToAffinityScoreMap?: true
    userIdToReportsMap?: true
    userIdToReactionMap?: true
    mentions?: true
    hashtags?: true
    mediaId?: true
    commentId?: true
    extra?: true
    aiAnalysis?: true
    _all?: true
  }

  export type CommentReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentReply to aggregate.
     */
    where?: CommentReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReplies to fetch.
     */
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentReplies
    **/
    _count?: true | CommentReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentReplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentReplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentReplyMaxAggregateInputType
  }

  export type GetCommentReplyAggregateType<T extends CommentReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentReply[P]>
      : GetScalarType<T[P], AggregateCommentReply[P]>
  }




  export type CommentReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReplyWhereInput
    orderBy?: CommentReplyOrderByWithAggregationInput | CommentReplyOrderByWithAggregationInput[]
    by: CommentReplyScalarFieldEnum[] | CommentReplyScalarFieldEnum
    having?: CommentReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentReplyCountAggregateInputType | true
    _avg?: CommentReplyAvgAggregateInputType
    _sum?: CommentReplySumAggregateInputType
    _min?: CommentReplyMinAggregateInputType
    _max?: CommentReplyMaxAggregateInputType
  }

  export type CommentReplyGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap: JsonValue | null
    userIdToReportsMap: JsonValue | null
    userIdToReactionMap: JsonValue | null
    mentions: string[]
    hashtags: string[]
    mediaId: string | null
    commentId: string
    extra: JsonValue | null
    aiAnalysis: JsonValue | null
    _count: CommentReplyCountAggregateOutputType | null
    _avg: CommentReplyAvgAggregateOutputType | null
    _sum: CommentReplySumAggregateOutputType | null
    _min: CommentReplyMinAggregateOutputType | null
    _max: CommentReplyMaxAggregateOutputType | null
  }

  type GetCommentReplyGroupByPayload<T extends CommentReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentReplyGroupByOutputType[P]>
            : GetScalarType<T[P], CommentReplyGroupByOutputType[P]>
        }
      >
    >


  export type CommentReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUsername?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    affinityScore?: boolean
    qualityScore?: boolean
    userIdToAffinityScoreMap?: boolean
    userIdToReportsMap?: boolean
    userIdToReactionMap?: boolean
    mentions?: boolean
    hashtags?: boolean
    mediaId?: boolean
    commentId?: boolean
    extra?: boolean
    aiAnalysis?: boolean
    media?: boolean | CommentReply$mediaArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentReply"]>

  export type CommentReplySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUsername?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    affinityScore?: boolean
    qualityScore?: boolean
    userIdToAffinityScoreMap?: boolean
    userIdToReportsMap?: boolean
    userIdToReactionMap?: boolean
    mentions?: boolean
    hashtags?: boolean
    mediaId?: boolean
    commentId?: boolean
    extra?: boolean
    aiAnalysis?: boolean
    media?: boolean | CommentReply$mediaArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentReply"]>

  export type CommentReplySelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUsername?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    affinityScore?: boolean
    qualityScore?: boolean
    userIdToAffinityScoreMap?: boolean
    userIdToReportsMap?: boolean
    userIdToReactionMap?: boolean
    mentions?: boolean
    hashtags?: boolean
    mediaId?: boolean
    commentId?: boolean
    extra?: boolean
    aiAnalysis?: boolean
  }

  export type CommentReplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | CommentReply$mediaArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }
  export type CommentReplyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | CommentReply$mediaArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }

  export type $CommentReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommentReply"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs> | null
      comment: Prisma.$CommentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      backendPlatformUserId: string
      profileId: number
      authorUsername: string
      authorProfileImage: string | null
      authorAccountType: $Enums.AccountType
      affinityScore: number
      qualityScore: number
      userIdToAffinityScoreMap: Prisma.JsonValue | null
      userIdToReportsMap: Prisma.JsonValue | null
      userIdToReactionMap: Prisma.JsonValue | null
      mentions: string[]
      hashtags: string[]
      mediaId: string | null
      commentId: string
      extra: Prisma.JsonValue | null
      aiAnalysis: Prisma.JsonValue | null
    }, ExtArgs["result"]["commentReply"]>
    composites: {}
  }

  type CommentReplyGetPayload<S extends boolean | null | undefined | CommentReplyDefaultArgs> = $Result.GetResult<Prisma.$CommentReplyPayload, S>

  type CommentReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentReplyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentReplyCountAggregateInputType | true
    }

  export interface CommentReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentReply'], meta: { name: 'CommentReply' } }
    /**
     * Find zero or one CommentReply that matches the filter.
     * @param {CommentReplyFindUniqueArgs} args - Arguments to find a CommentReply
     * @example
     * // Get one CommentReply
     * const commentReply = await prisma.commentReply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentReplyFindUniqueArgs>(args: SelectSubset<T, CommentReplyFindUniqueArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommentReply that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentReplyFindUniqueOrThrowArgs} args - Arguments to find a CommentReply
     * @example
     * // Get one CommentReply
     * const commentReply = await prisma.commentReply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentReplyFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentReplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommentReply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyFindFirstArgs} args - Arguments to find a CommentReply
     * @example
     * // Get one CommentReply
     * const commentReply = await prisma.commentReply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentReplyFindFirstArgs>(args?: SelectSubset<T, CommentReplyFindFirstArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommentReply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyFindFirstOrThrowArgs} args - Arguments to find a CommentReply
     * @example
     * // Get one CommentReply
     * const commentReply = await prisma.commentReply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentReplyFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentReplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommentReplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentReplies
     * const commentReplies = await prisma.commentReply.findMany()
     * 
     * // Get first 10 CommentReplies
     * const commentReplies = await prisma.commentReply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentReplyWithIdOnly = await prisma.commentReply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentReplyFindManyArgs>(args?: SelectSubset<T, CommentReplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommentReply.
     * @param {CommentReplyCreateArgs} args - Arguments to create a CommentReply.
     * @example
     * // Create one CommentReply
     * const CommentReply = await prisma.commentReply.create({
     *   data: {
     *     // ... data to create a CommentReply
     *   }
     * })
     * 
     */
    create<T extends CommentReplyCreateArgs>(args: SelectSubset<T, CommentReplyCreateArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommentReplies.
     * @param {CommentReplyCreateManyArgs} args - Arguments to create many CommentReplies.
     * @example
     * // Create many CommentReplies
     * const commentReply = await prisma.commentReply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentReplyCreateManyArgs>(args?: SelectSubset<T, CommentReplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommentReplies and returns the data saved in the database.
     * @param {CommentReplyCreateManyAndReturnArgs} args - Arguments to create many CommentReplies.
     * @example
     * // Create many CommentReplies
     * const commentReply = await prisma.commentReply.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommentReplies and only return the `id`
     * const commentReplyWithIdOnly = await prisma.commentReply.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentReplyCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentReplyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CommentReply.
     * @param {CommentReplyDeleteArgs} args - Arguments to delete one CommentReply.
     * @example
     * // Delete one CommentReply
     * const CommentReply = await prisma.commentReply.delete({
     *   where: {
     *     // ... filter to delete one CommentReply
     *   }
     * })
     * 
     */
    delete<T extends CommentReplyDeleteArgs>(args: SelectSubset<T, CommentReplyDeleteArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommentReply.
     * @param {CommentReplyUpdateArgs} args - Arguments to update one CommentReply.
     * @example
     * // Update one CommentReply
     * const commentReply = await prisma.commentReply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentReplyUpdateArgs>(args: SelectSubset<T, CommentReplyUpdateArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommentReplies.
     * @param {CommentReplyDeleteManyArgs} args - Arguments to filter CommentReplies to delete.
     * @example
     * // Delete a few CommentReplies
     * const { count } = await prisma.commentReply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentReplyDeleteManyArgs>(args?: SelectSubset<T, CommentReplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentReplies
     * const commentReply = await prisma.commentReply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentReplyUpdateManyArgs>(args: SelectSubset<T, CommentReplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommentReply.
     * @param {CommentReplyUpsertArgs} args - Arguments to update or create a CommentReply.
     * @example
     * // Update or create a CommentReply
     * const commentReply = await prisma.commentReply.upsert({
     *   create: {
     *     // ... data to create a CommentReply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentReply we want to update
     *   }
     * })
     */
    upsert<T extends CommentReplyUpsertArgs>(args: SelectSubset<T, CommentReplyUpsertArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CommentReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyCountArgs} args - Arguments to filter CommentReplies to count.
     * @example
     * // Count the number of CommentReplies
     * const count = await prisma.commentReply.count({
     *   where: {
     *     // ... the filter for the CommentReplies we want to count
     *   }
     * })
    **/
    count<T extends CommentReplyCountArgs>(
      args?: Subset<T, CommentReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentReplyAggregateArgs>(args: Subset<T, CommentReplyAggregateArgs>): Prisma.PrismaPromise<GetCommentReplyAggregateType<T>>

    /**
     * Group by CommentReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentReplyGroupByArgs['orderBy'] }
        : { orderBy?: CommentReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommentReply model
   */
  readonly fields: CommentReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentReply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends CommentReply$mediaArgs<ExtArgs> = {}>(args?: Subset<T, CommentReply$mediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommentReply model
   */ 
  interface CommentReplyFieldRefs {
    readonly id: FieldRef<"CommentReply", 'String'>
    readonly content: FieldRef<"CommentReply", 'String'>
    readonly createdAt: FieldRef<"CommentReply", 'DateTime'>
    readonly backendPlatformUserId: FieldRef<"CommentReply", 'String'>
    readonly profileId: FieldRef<"CommentReply", 'Int'>
    readonly authorUsername: FieldRef<"CommentReply", 'String'>
    readonly authorProfileImage: FieldRef<"CommentReply", 'String'>
    readonly authorAccountType: FieldRef<"CommentReply", 'AccountType'>
    readonly affinityScore: FieldRef<"CommentReply", 'Int'>
    readonly qualityScore: FieldRef<"CommentReply", 'Int'>
    readonly userIdToAffinityScoreMap: FieldRef<"CommentReply", 'Json'>
    readonly userIdToReportsMap: FieldRef<"CommentReply", 'Json'>
    readonly userIdToReactionMap: FieldRef<"CommentReply", 'Json'>
    readonly mentions: FieldRef<"CommentReply", 'String[]'>
    readonly hashtags: FieldRef<"CommentReply", 'String[]'>
    readonly mediaId: FieldRef<"CommentReply", 'String'>
    readonly commentId: FieldRef<"CommentReply", 'String'>
    readonly extra: FieldRef<"CommentReply", 'Json'>
    readonly aiAnalysis: FieldRef<"CommentReply", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * CommentReply findUnique
   */
  export type CommentReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which CommentReply to fetch.
     */
    where: CommentReplyWhereUniqueInput
  }

  /**
   * CommentReply findUniqueOrThrow
   */
  export type CommentReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which CommentReply to fetch.
     */
    where: CommentReplyWhereUniqueInput
  }

  /**
   * CommentReply findFirst
   */
  export type CommentReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which CommentReply to fetch.
     */
    where?: CommentReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReplies to fetch.
     */
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentReplies.
     */
    cursor?: CommentReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentReplies.
     */
    distinct?: CommentReplyScalarFieldEnum | CommentReplyScalarFieldEnum[]
  }

  /**
   * CommentReply findFirstOrThrow
   */
  export type CommentReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which CommentReply to fetch.
     */
    where?: CommentReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReplies to fetch.
     */
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentReplies.
     */
    cursor?: CommentReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentReplies.
     */
    distinct?: CommentReplyScalarFieldEnum | CommentReplyScalarFieldEnum[]
  }

  /**
   * CommentReply findMany
   */
  export type CommentReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which CommentReplies to fetch.
     */
    where?: CommentReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReplies to fetch.
     */
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentReplies.
     */
    cursor?: CommentReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReplies.
     */
    skip?: number
    distinct?: CommentReplyScalarFieldEnum | CommentReplyScalarFieldEnum[]
  }

  /**
   * CommentReply create
   */
  export type CommentReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentReply.
     */
    data: XOR<CommentReplyCreateInput, CommentReplyUncheckedCreateInput>
  }

  /**
   * CommentReply createMany
   */
  export type CommentReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommentReplies.
     */
    data: CommentReplyCreateManyInput | CommentReplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommentReply createManyAndReturn
   */
  export type CommentReplyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CommentReplies.
     */
    data: CommentReplyCreateManyInput | CommentReplyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentReply update
   */
  export type CommentReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentReply.
     */
    data: XOR<CommentReplyUpdateInput, CommentReplyUncheckedUpdateInput>
    /**
     * Choose, which CommentReply to update.
     */
    where: CommentReplyWhereUniqueInput
  }

  /**
   * CommentReply updateMany
   */
  export type CommentReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommentReplies.
     */
    data: XOR<CommentReplyUpdateManyMutationInput, CommentReplyUncheckedUpdateManyInput>
    /**
     * Filter which CommentReplies to update
     */
    where?: CommentReplyWhereInput
  }

  /**
   * CommentReply upsert
   */
  export type CommentReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentReply to update in case it exists.
     */
    where: CommentReplyWhereUniqueInput
    /**
     * In case the CommentReply found by the `where` argument doesn't exist, create a new CommentReply with this data.
     */
    create: XOR<CommentReplyCreateInput, CommentReplyUncheckedCreateInput>
    /**
     * In case the CommentReply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentReplyUpdateInput, CommentReplyUncheckedUpdateInput>
  }

  /**
   * CommentReply delete
   */
  export type CommentReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter which CommentReply to delete.
     */
    where: CommentReplyWhereUniqueInput
  }

  /**
   * CommentReply deleteMany
   */
  export type CommentReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentReplies to delete
     */
    where?: CommentReplyWhereInput
  }

  /**
   * CommentReply.media
   */
  export type CommentReply$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * CommentReply without action
   */
  export type CommentReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
  }


  /**
   * Model Reaction
   */

  export type AggregateReaction = {
    _count: ReactionCountAggregateOutputType | null
    _min: ReactionMinAggregateOutputType | null
    _max: ReactionMaxAggregateOutputType | null
  }

  export type ReactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    postId: string | null
    commentId: string | null
    type: $Enums.ReactionType | null
    createdAt: Date | null
  }

  export type ReactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    postId: string | null
    commentId: string | null
    type: $Enums.ReactionType | null
    createdAt: Date | null
  }

  export type ReactionCountAggregateOutputType = {
    id: number
    userId: number
    postId: number
    commentId: number
    type: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ReactionMinAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
    type?: true
    createdAt?: true
  }

  export type ReactionMaxAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
    type?: true
    createdAt?: true
  }

  export type ReactionCountAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
    commentId?: true
    type?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reaction to aggregate.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reactions
    **/
    _count?: true | ReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReactionMaxAggregateInputType
  }

  export type GetReactionAggregateType<T extends ReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReaction[P]>
      : GetScalarType<T[P], AggregateReaction[P]>
  }




  export type ReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithAggregationInput | ReactionOrderByWithAggregationInput[]
    by: ReactionScalarFieldEnum[] | ReactionScalarFieldEnum
    having?: ReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReactionCountAggregateInputType | true
    _min?: ReactionMinAggregateInputType
    _max?: ReactionMaxAggregateInputType
  }

  export type ReactionGroupByOutputType = {
    id: string
    userId: string
    postId: string | null
    commentId: string | null
    type: $Enums.ReactionType
    metadata: JsonValue | null
    createdAt: Date
    _count: ReactionCountAggregateOutputType | null
    _min: ReactionMinAggregateOutputType | null
    _max: ReactionMaxAggregateOutputType | null
  }

  type GetReactionGroupByPayload<T extends ReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReactionGroupByOutputType[P]>
            : GetScalarType<T[P], ReactionGroupByOutputType[P]>
        }
      >
    >


  export type ReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    postId?: boolean
    commentId?: boolean
    type?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    post?: boolean | Reaction$postArgs<ExtArgs>
    comment?: boolean | Reaction$commentArgs<ExtArgs>
  }, ExtArgs["result"]["reaction"]>

  export type ReactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    postId?: boolean
    commentId?: boolean
    type?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    post?: boolean | Reaction$postArgs<ExtArgs>
    comment?: boolean | Reaction$commentArgs<ExtArgs>
  }, ExtArgs["result"]["reaction"]>

  export type ReactionSelectScalar = {
    id?: boolean
    userId?: boolean
    postId?: boolean
    commentId?: boolean
    type?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    post?: boolean | Reaction$postArgs<ExtArgs>
    comment?: boolean | Reaction$commentArgs<ExtArgs>
  }
  export type ReactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    post?: boolean | Reaction$postArgs<ExtArgs>
    comment?: boolean | Reaction$commentArgs<ExtArgs>
  }

  export type $ReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reaction"
    objects: {
      user: Prisma.$UserProfilePayload<ExtArgs>
      post: Prisma.$PostPayload<ExtArgs> | null
      comment: Prisma.$CommentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      postId: string | null
      commentId: string | null
      type: $Enums.ReactionType
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["reaction"]>
    composites: {}
  }

  type ReactionGetPayload<S extends boolean | null | undefined | ReactionDefaultArgs> = $Result.GetResult<Prisma.$ReactionPayload, S>

  type ReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReactionCountAggregateInputType | true
    }

  export interface ReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reaction'], meta: { name: 'Reaction' } }
    /**
     * Find zero or one Reaction that matches the filter.
     * @param {ReactionFindUniqueArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReactionFindUniqueArgs>(args: SelectSubset<T, ReactionFindUniqueArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReactionFindUniqueOrThrowArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindFirstArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReactionFindFirstArgs>(args?: SelectSubset<T, ReactionFindFirstArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindFirstOrThrowArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reactions
     * const reactions = await prisma.reaction.findMany()
     * 
     * // Get first 10 Reactions
     * const reactions = await prisma.reaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reactionWithIdOnly = await prisma.reaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReactionFindManyArgs>(args?: SelectSubset<T, ReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reaction.
     * @param {ReactionCreateArgs} args - Arguments to create a Reaction.
     * @example
     * // Create one Reaction
     * const Reaction = await prisma.reaction.create({
     *   data: {
     *     // ... data to create a Reaction
     *   }
     * })
     * 
     */
    create<T extends ReactionCreateArgs>(args: SelectSubset<T, ReactionCreateArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reactions.
     * @param {ReactionCreateManyArgs} args - Arguments to create many Reactions.
     * @example
     * // Create many Reactions
     * const reaction = await prisma.reaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReactionCreateManyArgs>(args?: SelectSubset<T, ReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reactions and returns the data saved in the database.
     * @param {ReactionCreateManyAndReturnArgs} args - Arguments to create many Reactions.
     * @example
     * // Create many Reactions
     * const reaction = await prisma.reaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reactions and only return the `id`
     * const reactionWithIdOnly = await prisma.reaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReactionCreateManyAndReturnArgs>(args?: SelectSubset<T, ReactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Reaction.
     * @param {ReactionDeleteArgs} args - Arguments to delete one Reaction.
     * @example
     * // Delete one Reaction
     * const Reaction = await prisma.reaction.delete({
     *   where: {
     *     // ... filter to delete one Reaction
     *   }
     * })
     * 
     */
    delete<T extends ReactionDeleteArgs>(args: SelectSubset<T, ReactionDeleteArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reaction.
     * @param {ReactionUpdateArgs} args - Arguments to update one Reaction.
     * @example
     * // Update one Reaction
     * const reaction = await prisma.reaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReactionUpdateArgs>(args: SelectSubset<T, ReactionUpdateArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reactions.
     * @param {ReactionDeleteManyArgs} args - Arguments to filter Reactions to delete.
     * @example
     * // Delete a few Reactions
     * const { count } = await prisma.reaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReactionDeleteManyArgs>(args?: SelectSubset<T, ReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reactions
     * const reaction = await prisma.reaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReactionUpdateManyArgs>(args: SelectSubset<T, ReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reaction.
     * @param {ReactionUpsertArgs} args - Arguments to update or create a Reaction.
     * @example
     * // Update or create a Reaction
     * const reaction = await prisma.reaction.upsert({
     *   create: {
     *     // ... data to create a Reaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reaction we want to update
     *   }
     * })
     */
    upsert<T extends ReactionUpsertArgs>(args: SelectSubset<T, ReactionUpsertArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionCountArgs} args - Arguments to filter Reactions to count.
     * @example
     * // Count the number of Reactions
     * const count = await prisma.reaction.count({
     *   where: {
     *     // ... the filter for the Reactions we want to count
     *   }
     * })
    **/
    count<T extends ReactionCountArgs>(
      args?: Subset<T, ReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReactionAggregateArgs>(args: Subset<T, ReactionAggregateArgs>): Prisma.PrismaPromise<GetReactionAggregateType<T>>

    /**
     * Group by Reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReactionGroupByArgs['orderBy'] }
        : { orderBy?: ReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reaction model
   */
  readonly fields: ReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    post<T extends Reaction$postArgs<ExtArgs> = {}>(args?: Subset<T, Reaction$postArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comment<T extends Reaction$commentArgs<ExtArgs> = {}>(args?: Subset<T, Reaction$commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reaction model
   */ 
  interface ReactionFieldRefs {
    readonly id: FieldRef<"Reaction", 'String'>
    readonly userId: FieldRef<"Reaction", 'String'>
    readonly postId: FieldRef<"Reaction", 'String'>
    readonly commentId: FieldRef<"Reaction", 'String'>
    readonly type: FieldRef<"Reaction", 'ReactionType'>
    readonly metadata: FieldRef<"Reaction", 'Json'>
    readonly createdAt: FieldRef<"Reaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reaction findUnique
   */
  export type ReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction findUniqueOrThrow
   */
  export type ReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction findFirst
   */
  export type ReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reactions.
     */
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction findFirstOrThrow
   */
  export type ReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reactions.
     */
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction findMany
   */
  export type ReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reactions to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction create
   */
  export type ReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Reaction.
     */
    data: XOR<ReactionCreateInput, ReactionUncheckedCreateInput>
  }

  /**
   * Reaction createMany
   */
  export type ReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reactions.
     */
    data: ReactionCreateManyInput | ReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reaction createManyAndReturn
   */
  export type ReactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reactions.
     */
    data: ReactionCreateManyInput | ReactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reaction update
   */
  export type ReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Reaction.
     */
    data: XOR<ReactionUpdateInput, ReactionUncheckedUpdateInput>
    /**
     * Choose, which Reaction to update.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction updateMany
   */
  export type ReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reactions.
     */
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyInput>
    /**
     * Filter which Reactions to update
     */
    where?: ReactionWhereInput
  }

  /**
   * Reaction upsert
   */
  export type ReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Reaction to update in case it exists.
     */
    where: ReactionWhereUniqueInput
    /**
     * In case the Reaction found by the `where` argument doesn't exist, create a new Reaction with this data.
     */
    create: XOR<ReactionCreateInput, ReactionUncheckedCreateInput>
    /**
     * In case the Reaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReactionUpdateInput, ReactionUncheckedUpdateInput>
  }

  /**
   * Reaction delete
   */
  export type ReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter which Reaction to delete.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction deleteMany
   */
  export type ReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reactions to delete
     */
    where?: ReactionWhereInput
  }

  /**
   * Reaction.post
   */
  export type Reaction$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
  }

  /**
   * Reaction.comment
   */
  export type Reaction$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Reaction without action
   */
  export type ReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
  }


  /**
   * Model Bookmark
   */

  export type AggregateBookmark = {
    _count: BookmarkCountAggregateOutputType | null
    _min: BookmarkMinAggregateOutputType | null
    _max: BookmarkMaxAggregateOutputType | null
  }

  export type BookmarkMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookmarkMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookmarkCountAggregateOutputType = {
    id: number
    postIds: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookmarkMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookmarkMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookmarkCountAggregateInputType = {
    id?: true
    postIds?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookmarkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookmark to aggregate.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookmarks
    **/
    _count?: true | BookmarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookmarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookmarkMaxAggregateInputType
  }

  export type GetBookmarkAggregateType<T extends BookmarkAggregateArgs> = {
        [P in keyof T & keyof AggregateBookmark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookmark[P]>
      : GetScalarType<T[P], AggregateBookmark[P]>
  }




  export type BookmarkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkWhereInput
    orderBy?: BookmarkOrderByWithAggregationInput | BookmarkOrderByWithAggregationInput[]
    by: BookmarkScalarFieldEnum[] | BookmarkScalarFieldEnum
    having?: BookmarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookmarkCountAggregateInputType | true
    _min?: BookmarkMinAggregateInputType
    _max?: BookmarkMaxAggregateInputType
  }

  export type BookmarkGroupByOutputType = {
    id: string
    postIds: string[]
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: BookmarkCountAggregateOutputType | null
    _min: BookmarkMinAggregateOutputType | null
    _max: BookmarkMaxAggregateOutputType | null
  }

  type GetBookmarkGroupByPayload<T extends BookmarkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookmarkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookmarkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookmarkGroupByOutputType[P]>
            : GetScalarType<T[P], BookmarkGroupByOutputType[P]>
        }
      >
    >


  export type BookmarkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postIds?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publications?: boolean | Bookmark$publicationsArgs<ExtArgs>
    users?: boolean | Bookmark$usersArgs<ExtArgs>
    posts?: boolean | Bookmark$postsArgs<ExtArgs>
    _count?: boolean | BookmarkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmark"]>

  export type BookmarkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postIds?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bookmark"]>

  export type BookmarkSelectScalar = {
    id?: boolean
    postIds?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookmarkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publications?: boolean | Bookmark$publicationsArgs<ExtArgs>
    users?: boolean | Bookmark$usersArgs<ExtArgs>
    posts?: boolean | Bookmark$postsArgs<ExtArgs>
    _count?: boolean | BookmarkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookmarkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BookmarkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bookmark"
    objects: {
      publications: Prisma.$PublicationPayload<ExtArgs>[]
      users: Prisma.$UserProfilePayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postIds: string[]
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bookmark"]>
    composites: {}
  }

  type BookmarkGetPayload<S extends boolean | null | undefined | BookmarkDefaultArgs> = $Result.GetResult<Prisma.$BookmarkPayload, S>

  type BookmarkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookmarkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookmarkCountAggregateInputType | true
    }

  export interface BookmarkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bookmark'], meta: { name: 'Bookmark' } }
    /**
     * Find zero or one Bookmark that matches the filter.
     * @param {BookmarkFindUniqueArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookmarkFindUniqueArgs>(args: SelectSubset<T, BookmarkFindUniqueArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bookmark that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookmarkFindUniqueOrThrowArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookmarkFindUniqueOrThrowArgs>(args: SelectSubset<T, BookmarkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bookmark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkFindFirstArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookmarkFindFirstArgs>(args?: SelectSubset<T, BookmarkFindFirstArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bookmark that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkFindFirstOrThrowArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookmarkFindFirstOrThrowArgs>(args?: SelectSubset<T, BookmarkFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookmarks
     * const bookmarks = await prisma.bookmark.findMany()
     * 
     * // Get first 10 Bookmarks
     * const bookmarks = await prisma.bookmark.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookmarkWithIdOnly = await prisma.bookmark.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookmarkFindManyArgs>(args?: SelectSubset<T, BookmarkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bookmark.
     * @param {BookmarkCreateArgs} args - Arguments to create a Bookmark.
     * @example
     * // Create one Bookmark
     * const Bookmark = await prisma.bookmark.create({
     *   data: {
     *     // ... data to create a Bookmark
     *   }
     * })
     * 
     */
    create<T extends BookmarkCreateArgs>(args: SelectSubset<T, BookmarkCreateArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookmarks.
     * @param {BookmarkCreateManyArgs} args - Arguments to create many Bookmarks.
     * @example
     * // Create many Bookmarks
     * const bookmark = await prisma.bookmark.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookmarkCreateManyArgs>(args?: SelectSubset<T, BookmarkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookmarks and returns the data saved in the database.
     * @param {BookmarkCreateManyAndReturnArgs} args - Arguments to create many Bookmarks.
     * @example
     * // Create many Bookmarks
     * const bookmark = await prisma.bookmark.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookmarks and only return the `id`
     * const bookmarkWithIdOnly = await prisma.bookmark.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookmarkCreateManyAndReturnArgs>(args?: SelectSubset<T, BookmarkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bookmark.
     * @param {BookmarkDeleteArgs} args - Arguments to delete one Bookmark.
     * @example
     * // Delete one Bookmark
     * const Bookmark = await prisma.bookmark.delete({
     *   where: {
     *     // ... filter to delete one Bookmark
     *   }
     * })
     * 
     */
    delete<T extends BookmarkDeleteArgs>(args: SelectSubset<T, BookmarkDeleteArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bookmark.
     * @param {BookmarkUpdateArgs} args - Arguments to update one Bookmark.
     * @example
     * // Update one Bookmark
     * const bookmark = await prisma.bookmark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookmarkUpdateArgs>(args: SelectSubset<T, BookmarkUpdateArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookmarks.
     * @param {BookmarkDeleteManyArgs} args - Arguments to filter Bookmarks to delete.
     * @example
     * // Delete a few Bookmarks
     * const { count } = await prisma.bookmark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookmarkDeleteManyArgs>(args?: SelectSubset<T, BookmarkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookmarks
     * const bookmark = await prisma.bookmark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookmarkUpdateManyArgs>(args: SelectSubset<T, BookmarkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bookmark.
     * @param {BookmarkUpsertArgs} args - Arguments to update or create a Bookmark.
     * @example
     * // Update or create a Bookmark
     * const bookmark = await prisma.bookmark.upsert({
     *   create: {
     *     // ... data to create a Bookmark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bookmark we want to update
     *   }
     * })
     */
    upsert<T extends BookmarkUpsertArgs>(args: SelectSubset<T, BookmarkUpsertArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkCountArgs} args - Arguments to filter Bookmarks to count.
     * @example
     * // Count the number of Bookmarks
     * const count = await prisma.bookmark.count({
     *   where: {
     *     // ... the filter for the Bookmarks we want to count
     *   }
     * })
    **/
    count<T extends BookmarkCountArgs>(
      args?: Subset<T, BookmarkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookmarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bookmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookmarkAggregateArgs>(args: Subset<T, BookmarkAggregateArgs>): Prisma.PrismaPromise<GetBookmarkAggregateType<T>>

    /**
     * Group by Bookmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookmarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookmarkGroupByArgs['orderBy'] }
        : { orderBy?: BookmarkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookmarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookmarkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bookmark model
   */
  readonly fields: BookmarkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bookmark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookmarkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    publications<T extends Bookmark$publicationsArgs<ExtArgs> = {}>(args?: Subset<T, Bookmark$publicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Bookmark$usersArgs<ExtArgs> = {}>(args?: Subset<T, Bookmark$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends Bookmark$postsArgs<ExtArgs> = {}>(args?: Subset<T, Bookmark$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bookmark model
   */ 
  interface BookmarkFieldRefs {
    readonly id: FieldRef<"Bookmark", 'String'>
    readonly postIds: FieldRef<"Bookmark", 'String[]'>
    readonly metadata: FieldRef<"Bookmark", 'Json'>
    readonly createdAt: FieldRef<"Bookmark", 'DateTime'>
    readonly updatedAt: FieldRef<"Bookmark", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bookmark findUnique
   */
  export type BookmarkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark findUniqueOrThrow
   */
  export type BookmarkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark findFirst
   */
  export type BookmarkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookmarks.
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookmarks.
     */
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Bookmark findFirstOrThrow
   */
  export type BookmarkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookmarks.
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookmarks.
     */
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Bookmark findMany
   */
  export type BookmarkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmarks to fetch.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookmarks.
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Bookmark create
   */
  export type BookmarkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * The data needed to create a Bookmark.
     */
    data: XOR<BookmarkCreateInput, BookmarkUncheckedCreateInput>
  }

  /**
   * Bookmark createMany
   */
  export type BookmarkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookmarks.
     */
    data: BookmarkCreateManyInput | BookmarkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bookmark createManyAndReturn
   */
  export type BookmarkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookmarks.
     */
    data: BookmarkCreateManyInput | BookmarkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bookmark update
   */
  export type BookmarkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * The data needed to update a Bookmark.
     */
    data: XOR<BookmarkUpdateInput, BookmarkUncheckedUpdateInput>
    /**
     * Choose, which Bookmark to update.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark updateMany
   */
  export type BookmarkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookmarks.
     */
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyInput>
    /**
     * Filter which Bookmarks to update
     */
    where?: BookmarkWhereInput
  }

  /**
   * Bookmark upsert
   */
  export type BookmarkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * The filter to search for the Bookmark to update in case it exists.
     */
    where: BookmarkWhereUniqueInput
    /**
     * In case the Bookmark found by the `where` argument doesn't exist, create a new Bookmark with this data.
     */
    create: XOR<BookmarkCreateInput, BookmarkUncheckedCreateInput>
    /**
     * In case the Bookmark was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookmarkUpdateInput, BookmarkUncheckedUpdateInput>
  }

  /**
   * Bookmark delete
   */
  export type BookmarkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter which Bookmark to delete.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark deleteMany
   */
  export type BookmarkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookmarks to delete
     */
    where?: BookmarkWhereInput
  }

  /**
   * Bookmark.publications
   */
  export type Bookmark$publicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    where?: PublicationWhereInput
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    cursor?: PublicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }

  /**
   * Bookmark.users
   */
  export type Bookmark$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    cursor?: UserProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * Bookmark.posts
   */
  export type Bookmark$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Bookmark without action
   */
  export type BookmarkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
  }


  /**
   * Model Block
   */

  export type AggregateBlock = {
    _count: BlockCountAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  export type BlockMinAggregateOutputType = {
    id: string | null
    profileBlockingId: string | null
    profileBlockedId: string | null
    profileBlockingType: string | null
    profileBlockedType: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type BlockMaxAggregateOutputType = {
    id: string | null
    profileBlockingId: string | null
    profileBlockedId: string | null
    profileBlockingType: string | null
    profileBlockedType: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type BlockCountAggregateOutputType = {
    id: number
    profileBlockingId: number
    profileBlockedId: number
    profileBlockingType: number
    profileBlockedType: number
    reason: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type BlockMinAggregateInputType = {
    id?: true
    profileBlockingId?: true
    profileBlockedId?: true
    profileBlockingType?: true
    profileBlockedType?: true
    reason?: true
    createdAt?: true
  }

  export type BlockMaxAggregateInputType = {
    id?: true
    profileBlockingId?: true
    profileBlockedId?: true
    profileBlockingType?: true
    profileBlockedType?: true
    reason?: true
    createdAt?: true
  }

  export type BlockCountAggregateInputType = {
    id?: true
    profileBlockingId?: true
    profileBlockedId?: true
    profileBlockingType?: true
    profileBlockedType?: true
    reason?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type BlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Block to aggregate.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blocks
    **/
    _count?: true | BlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockMaxAggregateInputType
  }

  export type GetBlockAggregateType<T extends BlockAggregateArgs> = {
        [P in keyof T & keyof AggregateBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlock[P]>
      : GetScalarType<T[P], AggregateBlock[P]>
  }




  export type BlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithAggregationInput | BlockOrderByWithAggregationInput[]
    by: BlockScalarFieldEnum[] | BlockScalarFieldEnum
    having?: BlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockCountAggregateInputType | true
    _min?: BlockMinAggregateInputType
    _max?: BlockMaxAggregateInputType
  }

  export type BlockGroupByOutputType = {
    id: string
    profileBlockingId: string
    profileBlockedId: string
    profileBlockingType: string
    profileBlockedType: string
    reason: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: BlockCountAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  type GetBlockGroupByPayload<T extends BlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockGroupByOutputType[P]>
            : GetScalarType<T[P], BlockGroupByOutputType[P]>
        }
      >
    >


  export type BlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileBlockingId?: boolean
    profileBlockedId?: boolean
    profileBlockingType?: boolean
    profileBlockedType?: boolean
    reason?: boolean
    metadata?: boolean
    createdAt?: boolean
    blockingProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    blockedProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileBlockingId?: boolean
    profileBlockedId?: boolean
    profileBlockingType?: boolean
    profileBlockedType?: boolean
    reason?: boolean
    metadata?: boolean
    createdAt?: boolean
    blockingProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    blockedProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectScalar = {
    id?: boolean
    profileBlockingId?: boolean
    profileBlockedId?: boolean
    profileBlockingType?: boolean
    profileBlockedType?: boolean
    reason?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type BlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blockingProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    blockedProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type BlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blockingProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    blockedProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $BlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Block"
    objects: {
      blockingProfile: Prisma.$UserProfilePayload<ExtArgs>
      blockedProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileBlockingId: string
      profileBlockedId: string
      profileBlockingType: string
      profileBlockedType: string
      reason: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["block"]>
    composites: {}
  }

  type BlockGetPayload<S extends boolean | null | undefined | BlockDefaultArgs> = $Result.GetResult<Prisma.$BlockPayload, S>

  type BlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockCountAggregateInputType | true
    }

  export interface BlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Block'], meta: { name: 'Block' } }
    /**
     * Find zero or one Block that matches the filter.
     * @param {BlockFindUniqueArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockFindUniqueArgs>(args: SelectSubset<T, BlockFindUniqueArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Block that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockFindUniqueOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Block that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockFindFirstArgs>(args?: SelectSubset<T, BlockFindFirstArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Block that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.block.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.block.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockWithIdOnly = await prisma.block.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockFindManyArgs>(args?: SelectSubset<T, BlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Block.
     * @param {BlockCreateArgs} args - Arguments to create a Block.
     * @example
     * // Create one Block
     * const Block = await prisma.block.create({
     *   data: {
     *     // ... data to create a Block
     *   }
     * })
     * 
     */
    create<T extends BlockCreateArgs>(args: SelectSubset<T, BlockCreateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Blocks.
     * @param {BlockCreateManyArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockCreateManyArgs>(args?: SelectSubset<T, BlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blocks and returns the data saved in the database.
     * @param {BlockCreateManyAndReturnArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blocks and only return the `id`
     * const blockWithIdOnly = await prisma.block.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Block.
     * @param {BlockDeleteArgs} args - Arguments to delete one Block.
     * @example
     * // Delete one Block
     * const Block = await prisma.block.delete({
     *   where: {
     *     // ... filter to delete one Block
     *   }
     * })
     * 
     */
    delete<T extends BlockDeleteArgs>(args: SelectSubset<T, BlockDeleteArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Block.
     * @param {BlockUpdateArgs} args - Arguments to update one Block.
     * @example
     * // Update one Block
     * const block = await prisma.block.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockUpdateArgs>(args: SelectSubset<T, BlockUpdateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Blocks.
     * @param {BlockDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.block.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockDeleteManyArgs>(args?: SelectSubset<T, BlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockUpdateManyArgs>(args: SelectSubset<T, BlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Block.
     * @param {BlockUpsertArgs} args - Arguments to update or create a Block.
     * @example
     * // Update or create a Block
     * const block = await prisma.block.upsert({
     *   create: {
     *     // ... data to create a Block
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Block we want to update
     *   }
     * })
     */
    upsert<T extends BlockUpsertArgs>(args: SelectSubset<T, BlockUpsertArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.block.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends BlockCountArgs>(
      args?: Subset<T, BlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockAggregateArgs>(args: Subset<T, BlockAggregateArgs>): Prisma.PrismaPromise<GetBlockAggregateType<T>>

    /**
     * Group by Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockGroupByArgs['orderBy'] }
        : { orderBy?: BlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Block model
   */
  readonly fields: BlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Block.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blockingProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    blockedProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Block model
   */ 
  interface BlockFieldRefs {
    readonly id: FieldRef<"Block", 'String'>
    readonly profileBlockingId: FieldRef<"Block", 'String'>
    readonly profileBlockedId: FieldRef<"Block", 'String'>
    readonly profileBlockingType: FieldRef<"Block", 'String'>
    readonly profileBlockedType: FieldRef<"Block", 'String'>
    readonly reason: FieldRef<"Block", 'String'>
    readonly metadata: FieldRef<"Block", 'Json'>
    readonly createdAt: FieldRef<"Block", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Block findUnique
   */
  export type BlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findUniqueOrThrow
   */
  export type BlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findFirst
   */
  export type BlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findFirstOrThrow
   */
  export type BlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findMany
   */
  export type BlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Blocks to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block create
   */
  export type BlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to create a Block.
     */
    data: XOR<BlockCreateInput, BlockUncheckedCreateInput>
  }

  /**
   * Block createMany
   */
  export type BlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Block createManyAndReturn
   */
  export type BlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Block update
   */
  export type BlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to update a Block.
     */
    data: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
    /**
     * Choose, which Block to update.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block updateMany
   */
  export type BlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlockWhereInput
  }

  /**
   * Block upsert
   */
  export type BlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The filter to search for the Block to update in case it exists.
     */
    where: BlockWhereUniqueInput
    /**
     * In case the Block found by the `where` argument doesn't exist, create a new Block with this data.
     */
    create: XOR<BlockCreateInput, BlockUncheckedCreateInput>
    /**
     * In case the Block was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
  }

  /**
   * Block delete
   */
  export type BlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter which Block to delete.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block deleteMany
   */
  export type BlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blocks to delete
     */
    where?: BlockWhereInput
  }

  /**
   * Block without action
   */
  export type BlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
  }


  /**
   * Model Follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  export type FollowMinAggregateOutputType = {
    id: string | null
    profileFollowingId: string | null
    profileFollowedId: string | null
    targetFollowerType: string | null
    requestApproved: boolean | null
    createdAt: Date | null
    approvedAt: Date | null
  }

  export type FollowMaxAggregateOutputType = {
    id: string | null
    profileFollowingId: string | null
    profileFollowedId: string | null
    targetFollowerType: string | null
    requestApproved: boolean | null
    createdAt: Date | null
    approvedAt: Date | null
  }

  export type FollowCountAggregateOutputType = {
    id: number
    profileFollowingId: number
    profileFollowedId: number
    targetFollowerType: number
    requestApproved: number
    metadata: number
    createdAt: number
    approvedAt: number
    _all: number
  }


  export type FollowMinAggregateInputType = {
    id?: true
    profileFollowingId?: true
    profileFollowedId?: true
    targetFollowerType?: true
    requestApproved?: true
    createdAt?: true
    approvedAt?: true
  }

  export type FollowMaxAggregateInputType = {
    id?: true
    profileFollowingId?: true
    profileFollowedId?: true
    targetFollowerType?: true
    requestApproved?: true
    createdAt?: true
    approvedAt?: true
  }

  export type FollowCountAggregateInputType = {
    id?: true
    profileFollowingId?: true
    profileFollowedId?: true
    targetFollowerType?: true
    requestApproved?: true
    metadata?: true
    createdAt?: true
    approvedAt?: true
    _all?: true
  }

  export type FollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follow to aggregate.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Follows
    **/
    _count?: true | FollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowMaxAggregateInputType
  }

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
        [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>
  }




  export type FollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithAggregationInput | FollowOrderByWithAggregationInput[]
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum
    having?: FollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowCountAggregateInputType | true
    _min?: FollowMinAggregateInputType
    _max?: FollowMaxAggregateInputType
  }

  export type FollowGroupByOutputType = {
    id: string
    profileFollowingId: string
    profileFollowedId: string
    targetFollowerType: string
    requestApproved: boolean
    metadata: JsonValue | null
    createdAt: Date
    approvedAt: Date | null
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  type GetFollowGroupByPayload<T extends FollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>
        }
      >
    >


  export type FollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileFollowingId?: boolean
    profileFollowedId?: boolean
    targetFollowerType?: boolean
    requestApproved?: boolean
    metadata?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    followingProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    followedProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileFollowingId?: boolean
    profileFollowedId?: boolean
    targetFollowerType?: boolean
    requestApproved?: boolean
    metadata?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    followingProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    followedProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectScalar = {
    id?: boolean
    profileFollowingId?: boolean
    profileFollowedId?: boolean
    targetFollowerType?: boolean
    requestApproved?: boolean
    metadata?: boolean
    createdAt?: boolean
    approvedAt?: boolean
  }

  export type FollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    followingProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    followedProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type FollowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    followingProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    followedProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $FollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Follow"
    objects: {
      followingProfile: Prisma.$UserProfilePayload<ExtArgs>
      followedProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileFollowingId: string
      profileFollowedId: string
      targetFollowerType: string
      requestApproved: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      approvedAt: Date | null
    }, ExtArgs["result"]["follow"]>
    composites: {}
  }

  type FollowGetPayload<S extends boolean | null | undefined | FollowDefaultArgs> = $Result.GetResult<Prisma.$FollowPayload, S>

  type FollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FollowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FollowCountAggregateInputType | true
    }

  export interface FollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follow'], meta: { name: 'Follow' } }
    /**
     * Find zero or one Follow that matches the filter.
     * @param {FollowFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowFindUniqueArgs>(args: SelectSubset<T, FollowFindUniqueArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Follow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FollowFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowFindFirstArgs>(args?: SelectSubset<T, FollowFindFirstArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followWithIdOnly = await prisma.follow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowFindManyArgs>(args?: SelectSubset<T, FollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Follow.
     * @param {FollowCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     * 
     */
    create<T extends FollowCreateArgs>(args: SelectSubset<T, FollowCreateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Follows.
     * @param {FollowCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowCreateManyArgs>(args?: SelectSubset<T, FollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Follows and returns the data saved in the database.
     * @param {FollowCreateManyAndReturnArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Follows and only return the `id`
     * const followWithIdOnly = await prisma.follow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Follow.
     * @param {FollowDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     * 
     */
    delete<T extends FollowDeleteArgs>(args: SelectSubset<T, FollowDeleteArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Follow.
     * @param {FollowUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpdateArgs>(args: SelectSubset<T, FollowUpdateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Follows.
     * @param {FollowDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowDeleteManyArgs>(args?: SelectSubset<T, FollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpdateManyArgs>(args: SelectSubset<T, FollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Follow.
     * @param {FollowUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpsertArgs>(args: SelectSubset<T, FollowUpsertArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends FollowCountArgs>(
      args?: Subset<T, FollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowAggregateArgs>(args: Subset<T, FollowAggregateArgs>): Prisma.PrismaPromise<GetFollowAggregateType<T>>

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowGroupByArgs['orderBy'] }
        : { orderBy?: FollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Follow model
   */
  readonly fields: FollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    followingProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    followedProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Follow model
   */ 
  interface FollowFieldRefs {
    readonly id: FieldRef<"Follow", 'String'>
    readonly profileFollowingId: FieldRef<"Follow", 'String'>
    readonly profileFollowedId: FieldRef<"Follow", 'String'>
    readonly targetFollowerType: FieldRef<"Follow", 'String'>
    readonly requestApproved: FieldRef<"Follow", 'Boolean'>
    readonly metadata: FieldRef<"Follow", 'Json'>
    readonly createdAt: FieldRef<"Follow", 'DateTime'>
    readonly approvedAt: FieldRef<"Follow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Follow findUnique
   */
  export type FollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findUniqueOrThrow
   */
  export type FollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findFirst
   */
  export type FollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findFirstOrThrow
   */
  export type FollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findMany
   */
  export type FollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow create
   */
  export type FollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to create a Follow.
     */
    data: XOR<FollowCreateInput, FollowUncheckedCreateInput>
  }

  /**
   * Follow createMany
   */
  export type FollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Follow createManyAndReturn
   */
  export type FollowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow update
   */
  export type FollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to update a Follow.
     */
    data: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
    /**
     * Choose, which Follow to update.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow updateMany
   */
  export type FollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
  }

  /**
   * Follow upsert
   */
  export type FollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The filter to search for the Follow to update in case it exists.
     */
    where: FollowWhereUniqueInput
    /**
     * In case the Follow found by the `where` argument doesn't exist, create a new Follow with this data.
     */
    create: XOR<FollowCreateInput, FollowUncheckedCreateInput>
    /**
     * In case the Follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
  }

  /**
   * Follow delete
   */
  export type FollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter which Follow to delete.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow deleteMany
   */
  export type FollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowWhereInput
  }

  /**
   * Follow without action
   */
  export type FollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
  }


  /**
   * Model UserTag
   */

  export type AggregateUserTag = {
    _count: UserTagCountAggregateOutputType | null
    _min: UserTagMinAggregateOutputType | null
    _max: UserTagMaxAggregateOutputType | null
  }

  export type UserTagMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    tagName: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTagMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    tagName: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTagCountAggregateOutputType = {
    id: number
    userProfileId: number
    tagName: number
    description: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserTagMinAggregateInputType = {
    id?: true
    userProfileId?: true
    tagName?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTagMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    tagName?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTagCountAggregateInputType = {
    id?: true
    userProfileId?: true
    tagName?: true
    description?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTag to aggregate.
     */
    where?: UserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagOrderByWithRelationInput | UserTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTags
    **/
    _count?: true | UserTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTagMaxAggregateInputType
  }

  export type GetUserTagAggregateType<T extends UserTagAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTag[P]>
      : GetScalarType<T[P], AggregateUserTag[P]>
  }




  export type UserTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTagWhereInput
    orderBy?: UserTagOrderByWithAggregationInput | UserTagOrderByWithAggregationInput[]
    by: UserTagScalarFieldEnum[] | UserTagScalarFieldEnum
    having?: UserTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTagCountAggregateInputType | true
    _min?: UserTagMinAggregateInputType
    _max?: UserTagMaxAggregateInputType
  }

  export type UserTagGroupByOutputType = {
    id: string
    userProfileId: string
    tagName: string | null
    description: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserTagCountAggregateOutputType | null
    _min: UserTagMinAggregateOutputType | null
    _max: UserTagMaxAggregateOutputType | null
  }

  type GetUserTagGroupByPayload<T extends UserTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTagGroupByOutputType[P]>
            : GetScalarType<T[P], UserTagGroupByOutputType[P]>
        }
      >
    >


  export type UserTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    tagName?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTag"]>

  export type UserTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    tagName?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTag"]>

  export type UserTagSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    tagName?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type UserTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $UserTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTag"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      tagName: string | null
      description: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userTag"]>
    composites: {}
  }

  type UserTagGetPayload<S extends boolean | null | undefined | UserTagDefaultArgs> = $Result.GetResult<Prisma.$UserTagPayload, S>

  type UserTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserTagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserTagCountAggregateInputType | true
    }

  export interface UserTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTag'], meta: { name: 'UserTag' } }
    /**
     * Find zero or one UserTag that matches the filter.
     * @param {UserTagFindUniqueArgs} args - Arguments to find a UserTag
     * @example
     * // Get one UserTag
     * const userTag = await prisma.userTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTagFindUniqueArgs>(args: SelectSubset<T, UserTagFindUniqueArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserTag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserTagFindUniqueOrThrowArgs} args - Arguments to find a UserTag
     * @example
     * // Get one UserTag
     * const userTag = await prisma.userTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTagFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagFindFirstArgs} args - Arguments to find a UserTag
     * @example
     * // Get one UserTag
     * const userTag = await prisma.userTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTagFindFirstArgs>(args?: SelectSubset<T, UserTagFindFirstArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagFindFirstOrThrowArgs} args - Arguments to find a UserTag
     * @example
     * // Get one UserTag
     * const userTag = await prisma.userTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTagFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTags
     * const userTags = await prisma.userTag.findMany()
     * 
     * // Get first 10 UserTags
     * const userTags = await prisma.userTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTagWithIdOnly = await prisma.userTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTagFindManyArgs>(args?: SelectSubset<T, UserTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserTag.
     * @param {UserTagCreateArgs} args - Arguments to create a UserTag.
     * @example
     * // Create one UserTag
     * const UserTag = await prisma.userTag.create({
     *   data: {
     *     // ... data to create a UserTag
     *   }
     * })
     * 
     */
    create<T extends UserTagCreateArgs>(args: SelectSubset<T, UserTagCreateArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserTags.
     * @param {UserTagCreateManyArgs} args - Arguments to create many UserTags.
     * @example
     * // Create many UserTags
     * const userTag = await prisma.userTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTagCreateManyArgs>(args?: SelectSubset<T, UserTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTags and returns the data saved in the database.
     * @param {UserTagCreateManyAndReturnArgs} args - Arguments to create many UserTags.
     * @example
     * // Create many UserTags
     * const userTag = await prisma.userTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTags and only return the `id`
     * const userTagWithIdOnly = await prisma.userTag.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTagCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserTag.
     * @param {UserTagDeleteArgs} args - Arguments to delete one UserTag.
     * @example
     * // Delete one UserTag
     * const UserTag = await prisma.userTag.delete({
     *   where: {
     *     // ... filter to delete one UserTag
     *   }
     * })
     * 
     */
    delete<T extends UserTagDeleteArgs>(args: SelectSubset<T, UserTagDeleteArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserTag.
     * @param {UserTagUpdateArgs} args - Arguments to update one UserTag.
     * @example
     * // Update one UserTag
     * const userTag = await prisma.userTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTagUpdateArgs>(args: SelectSubset<T, UserTagUpdateArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserTags.
     * @param {UserTagDeleteManyArgs} args - Arguments to filter UserTags to delete.
     * @example
     * // Delete a few UserTags
     * const { count } = await prisma.userTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTagDeleteManyArgs>(args?: SelectSubset<T, UserTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTags
     * const userTag = await prisma.userTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTagUpdateManyArgs>(args: SelectSubset<T, UserTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTag.
     * @param {UserTagUpsertArgs} args - Arguments to update or create a UserTag.
     * @example
     * // Update or create a UserTag
     * const userTag = await prisma.userTag.upsert({
     *   create: {
     *     // ... data to create a UserTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTag we want to update
     *   }
     * })
     */
    upsert<T extends UserTagUpsertArgs>(args: SelectSubset<T, UserTagUpsertArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagCountArgs} args - Arguments to filter UserTags to count.
     * @example
     * // Count the number of UserTags
     * const count = await prisma.userTag.count({
     *   where: {
     *     // ... the filter for the UserTags we want to count
     *   }
     * })
    **/
    count<T extends UserTagCountArgs>(
      args?: Subset<T, UserTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTagAggregateArgs>(args: Subset<T, UserTagAggregateArgs>): Prisma.PrismaPromise<GetUserTagAggregateType<T>>

    /**
     * Group by UserTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTagGroupByArgs['orderBy'] }
        : { orderBy?: UserTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTag model
   */
  readonly fields: UserTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTag model
   */ 
  interface UserTagFieldRefs {
    readonly id: FieldRef<"UserTag", 'String'>
    readonly userProfileId: FieldRef<"UserTag", 'String'>
    readonly tagName: FieldRef<"UserTag", 'String'>
    readonly description: FieldRef<"UserTag", 'String'>
    readonly metadata: FieldRef<"UserTag", 'Json'>
    readonly createdAt: FieldRef<"UserTag", 'DateTime'>
    readonly updatedAt: FieldRef<"UserTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserTag findUnique
   */
  export type UserTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter, which UserTag to fetch.
     */
    where: UserTagWhereUniqueInput
  }

  /**
   * UserTag findUniqueOrThrow
   */
  export type UserTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter, which UserTag to fetch.
     */
    where: UserTagWhereUniqueInput
  }

  /**
   * UserTag findFirst
   */
  export type UserTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter, which UserTag to fetch.
     */
    where?: UserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagOrderByWithRelationInput | UserTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTags.
     */
    cursor?: UserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTags.
     */
    distinct?: UserTagScalarFieldEnum | UserTagScalarFieldEnum[]
  }

  /**
   * UserTag findFirstOrThrow
   */
  export type UserTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter, which UserTag to fetch.
     */
    where?: UserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagOrderByWithRelationInput | UserTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTags.
     */
    cursor?: UserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTags.
     */
    distinct?: UserTagScalarFieldEnum | UserTagScalarFieldEnum[]
  }

  /**
   * UserTag findMany
   */
  export type UserTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where?: UserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagOrderByWithRelationInput | UserTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTags.
     */
    cursor?: UserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    distinct?: UserTagScalarFieldEnum | UserTagScalarFieldEnum[]
  }

  /**
   * UserTag create
   */
  export type UserTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTag.
     */
    data: XOR<UserTagCreateInput, UserTagUncheckedCreateInput>
  }

  /**
   * UserTag createMany
   */
  export type UserTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTags.
     */
    data: UserTagCreateManyInput | UserTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTag createManyAndReturn
   */
  export type UserTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserTags.
     */
    data: UserTagCreateManyInput | UserTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTag update
   */
  export type UserTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTag.
     */
    data: XOR<UserTagUpdateInput, UserTagUncheckedUpdateInput>
    /**
     * Choose, which UserTag to update.
     */
    where: UserTagWhereUniqueInput
  }

  /**
   * UserTag updateMany
   */
  export type UserTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTags.
     */
    data: XOR<UserTagUpdateManyMutationInput, UserTagUncheckedUpdateManyInput>
    /**
     * Filter which UserTags to update
     */
    where?: UserTagWhereInput
  }

  /**
   * UserTag upsert
   */
  export type UserTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTag to update in case it exists.
     */
    where: UserTagWhereUniqueInput
    /**
     * In case the UserTag found by the `where` argument doesn't exist, create a new UserTag with this data.
     */
    create: XOR<UserTagCreateInput, UserTagUncheckedCreateInput>
    /**
     * In case the UserTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTagUpdateInput, UserTagUncheckedUpdateInput>
  }

  /**
   * UserTag delete
   */
  export type UserTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter which UserTag to delete.
     */
    where: UserTagWhereUniqueInput
  }

  /**
   * UserTag deleteMany
   */
  export type UserTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTags to delete
     */
    where?: UserTagWhereInput
  }

  /**
   * UserTag without action
   */
  export type UserTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    submitterId: string | null
    postId: string | null
    commentId: string | null
    userId: string | null
    reason: $Enums.ReportReason | null
    description: string | null
    status: $Enums.ReportStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    submitterId: string | null
    postId: string | null
    commentId: string | null
    userId: string | null
    reason: $Enums.ReportReason | null
    description: string | null
    status: $Enums.ReportStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    submitterId: number
    postId: number
    commentId: number
    userId: number
    reason: number
    description: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    resolvedAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    submitterId?: true
    postId?: true
    commentId?: true
    userId?: true
    reason?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    submitterId?: true
    postId?: true
    commentId?: true
    userId?: true
    reason?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    submitterId?: true
    postId?: true
    commentId?: true
    userId?: true
    reason?: true
    description?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    submitterId: string
    postId: string | null
    commentId: string | null
    userId: string | null
    reason: $Enums.ReportReason
    description: string | null
    status: $Enums.ReportStatus
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    resolvedAt: Date | null
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    submitterId?: boolean
    postId?: boolean
    commentId?: boolean
    userId?: boolean
    reason?: boolean
    description?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    submitter?: boolean | UserProfileDefaultArgs<ExtArgs>
    reportedUser?: boolean | Report$reportedUserArgs<ExtArgs>
    reportedPost?: boolean | Report$reportedPostArgs<ExtArgs>
    reportedComment?: boolean | Report$reportedCommentArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    submitterId?: boolean
    postId?: boolean
    commentId?: boolean
    userId?: boolean
    reason?: boolean
    description?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    submitter?: boolean | UserProfileDefaultArgs<ExtArgs>
    reportedUser?: boolean | Report$reportedUserArgs<ExtArgs>
    reportedPost?: boolean | Report$reportedPostArgs<ExtArgs>
    reportedComment?: boolean | Report$reportedCommentArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    submitterId?: boolean
    postId?: boolean
    commentId?: boolean
    userId?: boolean
    reason?: boolean
    description?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submitter?: boolean | UserProfileDefaultArgs<ExtArgs>
    reportedUser?: boolean | Report$reportedUserArgs<ExtArgs>
    reportedPost?: boolean | Report$reportedPostArgs<ExtArgs>
    reportedComment?: boolean | Report$reportedCommentArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submitter?: boolean | UserProfileDefaultArgs<ExtArgs>
    reportedUser?: boolean | Report$reportedUserArgs<ExtArgs>
    reportedPost?: boolean | Report$reportedPostArgs<ExtArgs>
    reportedComment?: boolean | Report$reportedCommentArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      submitter: Prisma.$UserProfilePayload<ExtArgs>
      reportedUser: Prisma.$UserProfilePayload<ExtArgs> | null
      reportedPost: Prisma.$PostPayload<ExtArgs> | null
      reportedComment: Prisma.$CommentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      submitterId: string
      postId: string | null
      commentId: string | null
      userId: string | null
      reason: $Enums.ReportReason
      description: string | null
      status: $Enums.ReportStatus
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      resolvedAt: Date | null
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    submitter<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reportedUser<T extends Report$reportedUserArgs<ExtArgs> = {}>(args?: Subset<T, Report$reportedUserArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reportedPost<T extends Report$reportedPostArgs<ExtArgs> = {}>(args?: Subset<T, Report$reportedPostArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reportedComment<T extends Report$reportedCommentArgs<ExtArgs> = {}>(args?: Subset<T, Report$reportedCommentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly submitterId: FieldRef<"Report", 'String'>
    readonly postId: FieldRef<"Report", 'String'>
    readonly commentId: FieldRef<"Report", 'String'>
    readonly userId: FieldRef<"Report", 'String'>
    readonly reason: FieldRef<"Report", 'ReportReason'>
    readonly description: FieldRef<"Report", 'String'>
    readonly status: FieldRef<"Report", 'ReportStatus'>
    readonly metadata: FieldRef<"Report", 'Json'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly updatedAt: FieldRef<"Report", 'DateTime'>
    readonly resolvedAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report.reportedUser
   */
  export type Report$reportedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * Report.reportedPost
   */
  export type Report$reportedPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
  }

  /**
   * Report.reportedComment
   */
  export type Report$reportedCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    content: number
    isRead: number
    metadata: number
    createdAt: number
    readAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    content?: true
    isRead?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    content?: true
    isRead?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    content?: true
    isRead?: true
    metadata?: true
    createdAt?: true
    readAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead: boolean
    metadata: JsonValue | null
    createdAt: Date
    readAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      title: string
      content: string
      isRead: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      readAt: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Space
   */

  export type AggregateSpace = {
    _count: SpaceCountAggregateOutputType | null
    _min: SpaceMinAggregateOutputType | null
    _max: SpaceMaxAggregateOutputType | null
  }

  export type SpaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.SpaceType | null
    createdAt: Date | null
    updatedAt: Date | null
    spaceType: string | null
    status: string | null
    visibility: $Enums.Visibility | null
    parentSpaceId: string | null
    isPrivate: boolean | null
    accessLevel: $Enums.AccessLevel | null
  }

  export type SpaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.SpaceType | null
    createdAt: Date | null
    updatedAt: Date | null
    spaceType: string | null
    status: string | null
    visibility: $Enums.Visibility | null
    parentSpaceId: string | null
    isPrivate: boolean | null
    accessLevel: $Enums.AccessLevel | null
  }

  export type SpaceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    createdAt: number
    updatedAt: number
    spaceType: number
    status: number
    visibility: number
    parentSpaceId: number
    isPrivate: number
    metadata: number
    settings: number
    accessLevel: number
    searchMetadata: number
    tags: number
    _all: number
  }


  export type SpaceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    spaceType?: true
    status?: true
    visibility?: true
    parentSpaceId?: true
    isPrivate?: true
    accessLevel?: true
  }

  export type SpaceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    spaceType?: true
    status?: true
    visibility?: true
    parentSpaceId?: true
    isPrivate?: true
    accessLevel?: true
  }

  export type SpaceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    spaceType?: true
    status?: true
    visibility?: true
    parentSpaceId?: true
    isPrivate?: true
    metadata?: true
    settings?: true
    accessLevel?: true
    searchMetadata?: true
    tags?: true
    _all?: true
  }

  export type SpaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Space to aggregate.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Spaces
    **/
    _count?: true | SpaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpaceMaxAggregateInputType
  }

  export type GetSpaceAggregateType<T extends SpaceAggregateArgs> = {
        [P in keyof T & keyof AggregateSpace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpace[P]>
      : GetScalarType<T[P], AggregateSpace[P]>
  }




  export type SpaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceWhereInput
    orderBy?: SpaceOrderByWithAggregationInput | SpaceOrderByWithAggregationInput[]
    by: SpaceScalarFieldEnum[] | SpaceScalarFieldEnum
    having?: SpaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpaceCountAggregateInputType | true
    _min?: SpaceMinAggregateInputType
    _max?: SpaceMaxAggregateInputType
  }

  export type SpaceGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: $Enums.SpaceType
    createdAt: Date
    updatedAt: Date
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    parentSpaceId: string | null
    isPrivate: boolean
    metadata: JsonValue | null
    settings: JsonValue | null
    accessLevel: $Enums.AccessLevel
    searchMetadata: JsonValue | null
    tags: string[]
    _count: SpaceCountAggregateOutputType | null
    _min: SpaceMinAggregateOutputType | null
    _max: SpaceMaxAggregateOutputType | null
  }

  type GetSpaceGroupByPayload<T extends SpaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpaceGroupByOutputType[P]>
            : GetScalarType<T[P], SpaceGroupByOutputType[P]>
        }
      >
    >


  export type SpaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    spaceType?: boolean
    status?: boolean
    visibility?: boolean
    parentSpaceId?: boolean
    isPrivate?: boolean
    metadata?: boolean
    settings?: boolean
    accessLevel?: boolean
    searchMetadata?: boolean
    tags?: boolean
    members?: boolean | Space$membersArgs<ExtArgs>
    channels?: boolean | Space$channelsArgs<ExtArgs>
    posts?: boolean | Space$postsArgs<ExtArgs>
    files?: boolean | Space$filesArgs<ExtArgs>
    parentSpace?: boolean | Space$parentSpaceArgs<ExtArgs>
    childSpaces?: boolean | Space$childSpacesArgs<ExtArgs>
    _count?: boolean | SpaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["space"]>

  export type SpaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    spaceType?: boolean
    status?: boolean
    visibility?: boolean
    parentSpaceId?: boolean
    isPrivate?: boolean
    metadata?: boolean
    settings?: boolean
    accessLevel?: boolean
    searchMetadata?: boolean
    tags?: boolean
    parentSpace?: boolean | Space$parentSpaceArgs<ExtArgs>
  }, ExtArgs["result"]["space"]>

  export type SpaceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    spaceType?: boolean
    status?: boolean
    visibility?: boolean
    parentSpaceId?: boolean
    isPrivate?: boolean
    metadata?: boolean
    settings?: boolean
    accessLevel?: boolean
    searchMetadata?: boolean
    tags?: boolean
  }

  export type SpaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Space$membersArgs<ExtArgs>
    channels?: boolean | Space$channelsArgs<ExtArgs>
    posts?: boolean | Space$postsArgs<ExtArgs>
    files?: boolean | Space$filesArgs<ExtArgs>
    parentSpace?: boolean | Space$parentSpaceArgs<ExtArgs>
    childSpaces?: boolean | Space$childSpacesArgs<ExtArgs>
    _count?: boolean | SpaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentSpace?: boolean | Space$parentSpaceArgs<ExtArgs>
  }

  export type $SpacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Space"
    objects: {
      members: Prisma.$SpaceMemberPayload<ExtArgs>[]
      channels: Prisma.$ChannelPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      parentSpace: Prisma.$SpacePayload<ExtArgs> | null
      childSpaces: Prisma.$SpacePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: $Enums.SpaceType
      createdAt: Date
      updatedAt: Date
      spaceType: string
      status: string
      visibility: $Enums.Visibility
      parentSpaceId: string | null
      isPrivate: boolean
      metadata: Prisma.JsonValue | null
      settings: Prisma.JsonValue | null
      accessLevel: $Enums.AccessLevel
      searchMetadata: Prisma.JsonValue | null
      tags: string[]
    }, ExtArgs["result"]["space"]>
    composites: {}
  }

  type SpaceGetPayload<S extends boolean | null | undefined | SpaceDefaultArgs> = $Result.GetResult<Prisma.$SpacePayload, S>

  type SpaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpaceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpaceCountAggregateInputType | true
    }

  export interface SpaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Space'], meta: { name: 'Space' } }
    /**
     * Find zero or one Space that matches the filter.
     * @param {SpaceFindUniqueArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpaceFindUniqueArgs>(args: SelectSubset<T, SpaceFindUniqueArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Space that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpaceFindUniqueOrThrowArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpaceFindUniqueOrThrowArgs>(args: SelectSubset<T, SpaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Space that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindFirstArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpaceFindFirstArgs>(args?: SelectSubset<T, SpaceFindFirstArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Space that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindFirstOrThrowArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpaceFindFirstOrThrowArgs>(args?: SelectSubset<T, SpaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Spaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spaces
     * const spaces = await prisma.space.findMany()
     * 
     * // Get first 10 Spaces
     * const spaces = await prisma.space.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spaceWithIdOnly = await prisma.space.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpaceFindManyArgs>(args?: SelectSubset<T, SpaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Space.
     * @param {SpaceCreateArgs} args - Arguments to create a Space.
     * @example
     * // Create one Space
     * const Space = await prisma.space.create({
     *   data: {
     *     // ... data to create a Space
     *   }
     * })
     * 
     */
    create<T extends SpaceCreateArgs>(args: SelectSubset<T, SpaceCreateArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Spaces.
     * @param {SpaceCreateManyArgs} args - Arguments to create many Spaces.
     * @example
     * // Create many Spaces
     * const space = await prisma.space.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpaceCreateManyArgs>(args?: SelectSubset<T, SpaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Spaces and returns the data saved in the database.
     * @param {SpaceCreateManyAndReturnArgs} args - Arguments to create many Spaces.
     * @example
     * // Create many Spaces
     * const space = await prisma.space.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Spaces and only return the `id`
     * const spaceWithIdOnly = await prisma.space.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpaceCreateManyAndReturnArgs>(args?: SelectSubset<T, SpaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Space.
     * @param {SpaceDeleteArgs} args - Arguments to delete one Space.
     * @example
     * // Delete one Space
     * const Space = await prisma.space.delete({
     *   where: {
     *     // ... filter to delete one Space
     *   }
     * })
     * 
     */
    delete<T extends SpaceDeleteArgs>(args: SelectSubset<T, SpaceDeleteArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Space.
     * @param {SpaceUpdateArgs} args - Arguments to update one Space.
     * @example
     * // Update one Space
     * const space = await prisma.space.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpaceUpdateArgs>(args: SelectSubset<T, SpaceUpdateArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Spaces.
     * @param {SpaceDeleteManyArgs} args - Arguments to filter Spaces to delete.
     * @example
     * // Delete a few Spaces
     * const { count } = await prisma.space.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpaceDeleteManyArgs>(args?: SelectSubset<T, SpaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spaces
     * const space = await prisma.space.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpaceUpdateManyArgs>(args: SelectSubset<T, SpaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Space.
     * @param {SpaceUpsertArgs} args - Arguments to update or create a Space.
     * @example
     * // Update or create a Space
     * const space = await prisma.space.upsert({
     *   create: {
     *     // ... data to create a Space
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Space we want to update
     *   }
     * })
     */
    upsert<T extends SpaceUpsertArgs>(args: SelectSubset<T, SpaceUpsertArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Spaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceCountArgs} args - Arguments to filter Spaces to count.
     * @example
     * // Count the number of Spaces
     * const count = await prisma.space.count({
     *   where: {
     *     // ... the filter for the Spaces we want to count
     *   }
     * })
    **/
    count<T extends SpaceCountArgs>(
      args?: Subset<T, SpaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Space.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpaceAggregateArgs>(args: Subset<T, SpaceAggregateArgs>): Prisma.PrismaPromise<GetSpaceAggregateType<T>>

    /**
     * Group by Space.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpaceGroupByArgs['orderBy'] }
        : { orderBy?: SpaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Space model
   */
  readonly fields: SpaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Space.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Space$membersArgs<ExtArgs> = {}>(args?: Subset<T, Space$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "findMany"> | Null>
    channels<T extends Space$channelsArgs<ExtArgs> = {}>(args?: Subset<T, Space$channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends Space$postsArgs<ExtArgs> = {}>(args?: Subset<T, Space$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    files<T extends Space$filesArgs<ExtArgs> = {}>(args?: Subset<T, Space$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany"> | Null>
    parentSpace<T extends Space$parentSpaceArgs<ExtArgs> = {}>(args?: Subset<T, Space$parentSpaceArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    childSpaces<T extends Space$childSpacesArgs<ExtArgs> = {}>(args?: Subset<T, Space$childSpacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Space model
   */ 
  interface SpaceFieldRefs {
    readonly id: FieldRef<"Space", 'String'>
    readonly name: FieldRef<"Space", 'String'>
    readonly description: FieldRef<"Space", 'String'>
    readonly type: FieldRef<"Space", 'SpaceType'>
    readonly createdAt: FieldRef<"Space", 'DateTime'>
    readonly updatedAt: FieldRef<"Space", 'DateTime'>
    readonly spaceType: FieldRef<"Space", 'String'>
    readonly status: FieldRef<"Space", 'String'>
    readonly visibility: FieldRef<"Space", 'Visibility'>
    readonly parentSpaceId: FieldRef<"Space", 'String'>
    readonly isPrivate: FieldRef<"Space", 'Boolean'>
    readonly metadata: FieldRef<"Space", 'Json'>
    readonly settings: FieldRef<"Space", 'Json'>
    readonly accessLevel: FieldRef<"Space", 'AccessLevel'>
    readonly searchMetadata: FieldRef<"Space", 'Json'>
    readonly tags: FieldRef<"Space", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Space findUnique
   */
  export type SpaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space findUniqueOrThrow
   */
  export type SpaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space findFirst
   */
  export type SpaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spaces.
     */
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space findFirstOrThrow
   */
  export type SpaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spaces.
     */
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space findMany
   */
  export type SpaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Spaces to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space create
   */
  export type SpaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Space.
     */
    data: XOR<SpaceCreateInput, SpaceUncheckedCreateInput>
  }

  /**
   * Space createMany
   */
  export type SpaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Spaces.
     */
    data: SpaceCreateManyInput | SpaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Space createManyAndReturn
   */
  export type SpaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Spaces.
     */
    data: SpaceCreateManyInput | SpaceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Space update
   */
  export type SpaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Space.
     */
    data: XOR<SpaceUpdateInput, SpaceUncheckedUpdateInput>
    /**
     * Choose, which Space to update.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space updateMany
   */
  export type SpaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Spaces.
     */
    data: XOR<SpaceUpdateManyMutationInput, SpaceUncheckedUpdateManyInput>
    /**
     * Filter which Spaces to update
     */
    where?: SpaceWhereInput
  }

  /**
   * Space upsert
   */
  export type SpaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Space to update in case it exists.
     */
    where: SpaceWhereUniqueInput
    /**
     * In case the Space found by the `where` argument doesn't exist, create a new Space with this data.
     */
    create: XOR<SpaceCreateInput, SpaceUncheckedCreateInput>
    /**
     * In case the Space was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpaceUpdateInput, SpaceUncheckedUpdateInput>
  }

  /**
   * Space delete
   */
  export type SpaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter which Space to delete.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space deleteMany
   */
  export type SpaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spaces to delete
     */
    where?: SpaceWhereInput
  }

  /**
   * Space.members
   */
  export type Space$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    where?: SpaceMemberWhereInput
    orderBy?: SpaceMemberOrderByWithRelationInput | SpaceMemberOrderByWithRelationInput[]
    cursor?: SpaceMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpaceMemberScalarFieldEnum | SpaceMemberScalarFieldEnum[]
  }

  /**
   * Space.channels
   */
  export type Space$channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Space.posts
   */
  export type Space$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Space.files
   */
  export type Space$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Space.parentSpace
   */
  export type Space$parentSpaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    where?: SpaceWhereInput
  }

  /**
   * Space.childSpaces
   */
  export type Space$childSpacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    where?: SpaceWhereInput
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    cursor?: SpaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space without action
   */
  export type SpaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
  }


  /**
   * Model Channel
   */

  export type AggregateChannel = {
    _count: ChannelCountAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  export type ChannelMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    spaceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    isPrivate: boolean | null
  }

  export type ChannelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    spaceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    isPrivate: boolean | null
  }

  export type ChannelCountAggregateOutputType = {
    id: number
    name: number
    description: number
    spaceId: number
    createdAt: number
    updatedAt: number
    status: number
    pinnedPosts: number
    isPrivate: number
    metadata: number
    settings: number
    _all: number
  }


  export type ChannelMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    spaceId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    isPrivate?: true
  }

  export type ChannelMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    spaceId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    isPrivate?: true
  }

  export type ChannelCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    spaceId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    pinnedPosts?: true
    isPrivate?: true
    metadata?: true
    settings?: true
    _all?: true
  }

  export type ChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channel to aggregate.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Channels
    **/
    _count?: true | ChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMaxAggregateInputType
  }

  export type GetChannelAggregateType<T extends ChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannel[P]>
      : GetScalarType<T[P], AggregateChannel[P]>
  }




  export type ChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithAggregationInput | ChannelOrderByWithAggregationInput[]
    by: ChannelScalarFieldEnum[] | ChannelScalarFieldEnum
    having?: ChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCountAggregateInputType | true
    _min?: ChannelMinAggregateInputType
    _max?: ChannelMaxAggregateInputType
  }

  export type ChannelGroupByOutputType = {
    id: string
    name: string
    description: string | null
    spaceId: string
    createdAt: Date
    updatedAt: Date
    status: string
    pinnedPosts: string[]
    isPrivate: boolean
    metadata: JsonValue | null
    settings: JsonValue | null
    _count: ChannelCountAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  type GetChannelGroupByPayload<T extends ChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelGroupByOutputType[P]>
        }
      >
    >


  export type ChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    spaceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    pinnedPosts?: boolean
    isPrivate?: boolean
    metadata?: boolean
    settings?: boolean
    space?: boolean | SpaceDefaultArgs<ExtArgs>
    posts?: boolean | Channel$postsArgs<ExtArgs>
    files?: boolean | Channel$filesArgs<ExtArgs>
    members?: boolean | Channel$membersArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type ChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    spaceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    pinnedPosts?: boolean
    isPrivate?: boolean
    metadata?: boolean
    settings?: boolean
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type ChannelSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    spaceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    pinnedPosts?: boolean
    isPrivate?: boolean
    metadata?: boolean
    settings?: boolean
  }

  export type ChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    space?: boolean | SpaceDefaultArgs<ExtArgs>
    posts?: boolean | Channel$postsArgs<ExtArgs>
    files?: boolean | Channel$filesArgs<ExtArgs>
    members?: boolean | Channel$membersArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }

  export type $ChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Channel"
    objects: {
      space: Prisma.$SpacePayload<ExtArgs>
      posts: Prisma.$PostPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      members: Prisma.$ChannelMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      spaceId: string
      createdAt: Date
      updatedAt: Date
      status: string
      pinnedPosts: string[]
      isPrivate: boolean
      metadata: Prisma.JsonValue | null
      settings: Prisma.JsonValue | null
    }, ExtArgs["result"]["channel"]>
    composites: {}
  }

  type ChannelGetPayload<S extends boolean | null | undefined | ChannelDefaultArgs> = $Result.GetResult<Prisma.$ChannelPayload, S>

  type ChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelCountAggregateInputType | true
    }

  export interface ChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Channel'], meta: { name: 'Channel' } }
    /**
     * Find zero or one Channel that matches the filter.
     * @param {ChannelFindUniqueArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelFindUniqueArgs>(args: SelectSubset<T, ChannelFindUniqueArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Channel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelFindUniqueOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Channel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelFindFirstArgs>(args?: SelectSubset<T, ChannelFindFirstArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Channel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channels
     * const channels = await prisma.channel.findMany()
     * 
     * // Get first 10 Channels
     * const channels = await prisma.channel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelWithIdOnly = await prisma.channel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelFindManyArgs>(args?: SelectSubset<T, ChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Channel.
     * @param {ChannelCreateArgs} args - Arguments to create a Channel.
     * @example
     * // Create one Channel
     * const Channel = await prisma.channel.create({
     *   data: {
     *     // ... data to create a Channel
     *   }
     * })
     * 
     */
    create<T extends ChannelCreateArgs>(args: SelectSubset<T, ChannelCreateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Channels.
     * @param {ChannelCreateManyArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelCreateManyArgs>(args?: SelectSubset<T, ChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Channels and returns the data saved in the database.
     * @param {ChannelCreateManyAndReturnArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Channels and only return the `id`
     * const channelWithIdOnly = await prisma.channel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, ChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Channel.
     * @param {ChannelDeleteArgs} args - Arguments to delete one Channel.
     * @example
     * // Delete one Channel
     * const Channel = await prisma.channel.delete({
     *   where: {
     *     // ... filter to delete one Channel
     *   }
     * })
     * 
     */
    delete<T extends ChannelDeleteArgs>(args: SelectSubset<T, ChannelDeleteArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Channel.
     * @param {ChannelUpdateArgs} args - Arguments to update one Channel.
     * @example
     * // Update one Channel
     * const channel = await prisma.channel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelUpdateArgs>(args: SelectSubset<T, ChannelUpdateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Channels.
     * @param {ChannelDeleteManyArgs} args - Arguments to filter Channels to delete.
     * @example
     * // Delete a few Channels
     * const { count } = await prisma.channel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelDeleteManyArgs>(args?: SelectSubset<T, ChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelUpdateManyArgs>(args: SelectSubset<T, ChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Channel.
     * @param {ChannelUpsertArgs} args - Arguments to update or create a Channel.
     * @example
     * // Update or create a Channel
     * const channel = await prisma.channel.upsert({
     *   create: {
     *     // ... data to create a Channel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channel we want to update
     *   }
     * })
     */
    upsert<T extends ChannelUpsertArgs>(args: SelectSubset<T, ChannelUpsertArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCountArgs} args - Arguments to filter Channels to count.
     * @example
     * // Count the number of Channels
     * const count = await prisma.channel.count({
     *   where: {
     *     // ... the filter for the Channels we want to count
     *   }
     * })
    **/
    count<T extends ChannelCountArgs>(
      args?: Subset<T, ChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelAggregateArgs>(args: Subset<T, ChannelAggregateArgs>): Prisma.PrismaPromise<GetChannelAggregateType<T>>

    /**
     * Group by Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelGroupByArgs['orderBy'] }
        : { orderBy?: ChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Channel model
   */
  readonly fields: ChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Channel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    space<T extends SpaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpaceDefaultArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    posts<T extends Channel$postsArgs<ExtArgs> = {}>(args?: Subset<T, Channel$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    files<T extends Channel$filesArgs<ExtArgs> = {}>(args?: Subset<T, Channel$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany"> | Null>
    members<T extends Channel$membersArgs<ExtArgs> = {}>(args?: Subset<T, Channel$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Channel model
   */ 
  interface ChannelFieldRefs {
    readonly id: FieldRef<"Channel", 'String'>
    readonly name: FieldRef<"Channel", 'String'>
    readonly description: FieldRef<"Channel", 'String'>
    readonly spaceId: FieldRef<"Channel", 'String'>
    readonly createdAt: FieldRef<"Channel", 'DateTime'>
    readonly updatedAt: FieldRef<"Channel", 'DateTime'>
    readonly status: FieldRef<"Channel", 'String'>
    readonly pinnedPosts: FieldRef<"Channel", 'String[]'>
    readonly isPrivate: FieldRef<"Channel", 'Boolean'>
    readonly metadata: FieldRef<"Channel", 'Json'>
    readonly settings: FieldRef<"Channel", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Channel findUnique
   */
  export type ChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findUniqueOrThrow
   */
  export type ChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findFirst
   */
  export type ChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findFirstOrThrow
   */
  export type ChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findMany
   */
  export type ChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channels to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel create
   */
  export type ChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a Channel.
     */
    data: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
  }

  /**
   * Channel createMany
   */
  export type ChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Channels.
     */
    data: ChannelCreateManyInput | ChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Channel createManyAndReturn
   */
  export type ChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Channels.
     */
    data: ChannelCreateManyInput | ChannelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Channel update
   */
  export type ChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a Channel.
     */
    data: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
    /**
     * Choose, which Channel to update.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel updateMany
   */
  export type ChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Channels.
     */
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyInput>
    /**
     * Filter which Channels to update
     */
    where?: ChannelWhereInput
  }

  /**
   * Channel upsert
   */
  export type ChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the Channel to update in case it exists.
     */
    where: ChannelWhereUniqueInput
    /**
     * In case the Channel found by the `where` argument doesn't exist, create a new Channel with this data.
     */
    create: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
    /**
     * In case the Channel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
  }

  /**
   * Channel delete
   */
  export type ChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter which Channel to delete.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel deleteMany
   */
  export type ChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channels to delete
     */
    where?: ChannelWhereInput
  }

  /**
   * Channel.posts
   */
  export type Channel$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Channel.files
   */
  export type Channel$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Channel.members
   */
  export type Channel$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    where?: ChannelMemberWhereInput
    orderBy?: ChannelMemberOrderByWithRelationInput | ChannelMemberOrderByWithRelationInput[]
    cursor?: ChannelMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelMemberScalarFieldEnum | ChannelMemberScalarFieldEnum[]
  }

  /**
   * Channel without action
   */
  export type ChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
  }


  /**
   * Model Thread
   */

  export type AggregateThread = {
    _count: ThreadCountAggregateOutputType | null
    _min: ThreadMinAggregateOutputType | null
    _max: ThreadMaxAggregateOutputType | null
  }

  export type ThreadMinAggregateOutputType = {
    id: string | null
    parentPostId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    isLocked: boolean | null
  }

  export type ThreadMaxAggregateOutputType = {
    id: string | null
    parentPostId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    isLocked: boolean | null
  }

  export type ThreadCountAggregateOutputType = {
    id: number
    postIds: number
    parentPostId: number
    createdAt: number
    updatedAt: number
    metadata: number
    status: number
    isLocked: number
    _all: number
  }


  export type ThreadMinAggregateInputType = {
    id?: true
    parentPostId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    isLocked?: true
  }

  export type ThreadMaxAggregateInputType = {
    id?: true
    parentPostId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    isLocked?: true
  }

  export type ThreadCountAggregateInputType = {
    id?: true
    postIds?: true
    parentPostId?: true
    createdAt?: true
    updatedAt?: true
    metadata?: true
    status?: true
    isLocked?: true
    _all?: true
  }

  export type ThreadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Thread to aggregate.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Threads
    **/
    _count?: true | ThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThreadMaxAggregateInputType
  }

  export type GetThreadAggregateType<T extends ThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThread[P]>
      : GetScalarType<T[P], AggregateThread[P]>
  }




  export type ThreadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreadWhereInput
    orderBy?: ThreadOrderByWithAggregationInput | ThreadOrderByWithAggregationInput[]
    by: ThreadScalarFieldEnum[] | ThreadScalarFieldEnum
    having?: ThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThreadCountAggregateInputType | true
    _min?: ThreadMinAggregateInputType
    _max?: ThreadMaxAggregateInputType
  }

  export type ThreadGroupByOutputType = {
    id: string
    postIds: string[]
    parentPostId: string
    createdAt: Date
    updatedAt: Date
    metadata: JsonValue | null
    status: string
    isLocked: boolean
    _count: ThreadCountAggregateOutputType | null
    _min: ThreadMinAggregateOutputType | null
    _max: ThreadMaxAggregateOutputType | null
  }

  type GetThreadGroupByPayload<T extends ThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadGroupByOutputType[P]>
        }
      >
    >


  export type ThreadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postIds?: boolean
    parentPostId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    status?: boolean
    isLocked?: boolean
    posts?: boolean | Thread$postsArgs<ExtArgs>
    pollPosts?: boolean | Thread$pollPostsArgs<ExtArgs>
    _count?: boolean | ThreadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["thread"]>

  export type ThreadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postIds?: boolean
    parentPostId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    status?: boolean
    isLocked?: boolean
  }, ExtArgs["result"]["thread"]>

  export type ThreadSelectScalar = {
    id?: boolean
    postIds?: boolean
    parentPostId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    status?: boolean
    isLocked?: boolean
  }

  export type ThreadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Thread$postsArgs<ExtArgs>
    pollPosts?: boolean | Thread$pollPostsArgs<ExtArgs>
    _count?: boolean | ThreadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ThreadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ThreadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Thread"
    objects: {
      posts: Prisma.$PostPayload<ExtArgs>[]
      pollPosts: Prisma.$PollPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postIds: string[]
      parentPostId: string
      createdAt: Date
      updatedAt: Date
      metadata: Prisma.JsonValue | null
      status: string
      isLocked: boolean
    }, ExtArgs["result"]["thread"]>
    composites: {}
  }

  type ThreadGetPayload<S extends boolean | null | undefined | ThreadDefaultArgs> = $Result.GetResult<Prisma.$ThreadPayload, S>

  type ThreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ThreadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ThreadCountAggregateInputType | true
    }

  export interface ThreadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Thread'], meta: { name: 'Thread' } }
    /**
     * Find zero or one Thread that matches the filter.
     * @param {ThreadFindUniqueArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadFindUniqueArgs>(args: SelectSubset<T, ThreadFindUniqueArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Thread that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ThreadFindUniqueOrThrowArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadFindUniqueOrThrowArgs>(args: SelectSubset<T, ThreadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Thread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindFirstArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadFindFirstArgs>(args?: SelectSubset<T, ThreadFindFirstArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Thread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindFirstOrThrowArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadFindFirstOrThrowArgs>(args?: SelectSubset<T, ThreadFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Threads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Threads
     * const threads = await prisma.thread.findMany()
     * 
     * // Get first 10 Threads
     * const threads = await prisma.thread.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const threadWithIdOnly = await prisma.thread.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ThreadFindManyArgs>(args?: SelectSubset<T, ThreadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Thread.
     * @param {ThreadCreateArgs} args - Arguments to create a Thread.
     * @example
     * // Create one Thread
     * const Thread = await prisma.thread.create({
     *   data: {
     *     // ... data to create a Thread
     *   }
     * })
     * 
     */
    create<T extends ThreadCreateArgs>(args: SelectSubset<T, ThreadCreateArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Threads.
     * @param {ThreadCreateManyArgs} args - Arguments to create many Threads.
     * @example
     * // Create many Threads
     * const thread = await prisma.thread.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThreadCreateManyArgs>(args?: SelectSubset<T, ThreadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Threads and returns the data saved in the database.
     * @param {ThreadCreateManyAndReturnArgs} args - Arguments to create many Threads.
     * @example
     * // Create many Threads
     * const thread = await prisma.thread.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Threads and only return the `id`
     * const threadWithIdOnly = await prisma.thread.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ThreadCreateManyAndReturnArgs>(args?: SelectSubset<T, ThreadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Thread.
     * @param {ThreadDeleteArgs} args - Arguments to delete one Thread.
     * @example
     * // Delete one Thread
     * const Thread = await prisma.thread.delete({
     *   where: {
     *     // ... filter to delete one Thread
     *   }
     * })
     * 
     */
    delete<T extends ThreadDeleteArgs>(args: SelectSubset<T, ThreadDeleteArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Thread.
     * @param {ThreadUpdateArgs} args - Arguments to update one Thread.
     * @example
     * // Update one Thread
     * const thread = await prisma.thread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThreadUpdateArgs>(args: SelectSubset<T, ThreadUpdateArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Threads.
     * @param {ThreadDeleteManyArgs} args - Arguments to filter Threads to delete.
     * @example
     * // Delete a few Threads
     * const { count } = await prisma.thread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThreadDeleteManyArgs>(args?: SelectSubset<T, ThreadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Threads
     * const thread = await prisma.thread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThreadUpdateManyArgs>(args: SelectSubset<T, ThreadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Thread.
     * @param {ThreadUpsertArgs} args - Arguments to update or create a Thread.
     * @example
     * // Update or create a Thread
     * const thread = await prisma.thread.upsert({
     *   create: {
     *     // ... data to create a Thread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Thread we want to update
     *   }
     * })
     */
    upsert<T extends ThreadUpsertArgs>(args: SelectSubset<T, ThreadUpsertArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadCountArgs} args - Arguments to filter Threads to count.
     * @example
     * // Count the number of Threads
     * const count = await prisma.thread.count({
     *   where: {
     *     // ... the filter for the Threads we want to count
     *   }
     * })
    **/
    count<T extends ThreadCountArgs>(
      args?: Subset<T, ThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Thread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThreadAggregateArgs>(args: Subset<T, ThreadAggregateArgs>): Prisma.PrismaPromise<GetThreadAggregateType<T>>

    /**
     * Group by Thread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadGroupByArgs['orderBy'] }
        : { orderBy?: ThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Thread model
   */
  readonly fields: ThreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Thread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Thread$postsArgs<ExtArgs> = {}>(args?: Subset<T, Thread$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    pollPosts<T extends Thread$pollPostsArgs<ExtArgs> = {}>(args?: Subset<T, Thread$pollPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Thread model
   */ 
  interface ThreadFieldRefs {
    readonly id: FieldRef<"Thread", 'String'>
    readonly postIds: FieldRef<"Thread", 'String[]'>
    readonly parentPostId: FieldRef<"Thread", 'String'>
    readonly createdAt: FieldRef<"Thread", 'DateTime'>
    readonly updatedAt: FieldRef<"Thread", 'DateTime'>
    readonly metadata: FieldRef<"Thread", 'Json'>
    readonly status: FieldRef<"Thread", 'String'>
    readonly isLocked: FieldRef<"Thread", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Thread findUnique
   */
  export type ThreadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Thread to fetch.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread findUniqueOrThrow
   */
  export type ThreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Thread to fetch.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread findFirst
   */
  export type ThreadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Thread to fetch.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Threads.
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Threads.
     */
    distinct?: ThreadScalarFieldEnum | ThreadScalarFieldEnum[]
  }

  /**
   * Thread findFirstOrThrow
   */
  export type ThreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Thread to fetch.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Threads.
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Threads.
     */
    distinct?: ThreadScalarFieldEnum | ThreadScalarFieldEnum[]
  }

  /**
   * Thread findMany
   */
  export type ThreadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Threads to fetch.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Threads.
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    distinct?: ThreadScalarFieldEnum | ThreadScalarFieldEnum[]
  }

  /**
   * Thread create
   */
  export type ThreadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * The data needed to create a Thread.
     */
    data: XOR<ThreadCreateInput, ThreadUncheckedCreateInput>
  }

  /**
   * Thread createMany
   */
  export type ThreadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Threads.
     */
    data: ThreadCreateManyInput | ThreadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Thread createManyAndReturn
   */
  export type ThreadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Threads.
     */
    data: ThreadCreateManyInput | ThreadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Thread update
   */
  export type ThreadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * The data needed to update a Thread.
     */
    data: XOR<ThreadUpdateInput, ThreadUncheckedUpdateInput>
    /**
     * Choose, which Thread to update.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread updateMany
   */
  export type ThreadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Threads.
     */
    data: XOR<ThreadUpdateManyMutationInput, ThreadUncheckedUpdateManyInput>
    /**
     * Filter which Threads to update
     */
    where?: ThreadWhereInput
  }

  /**
   * Thread upsert
   */
  export type ThreadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * The filter to search for the Thread to update in case it exists.
     */
    where: ThreadWhereUniqueInput
    /**
     * In case the Thread found by the `where` argument doesn't exist, create a new Thread with this data.
     */
    create: XOR<ThreadCreateInput, ThreadUncheckedCreateInput>
    /**
     * In case the Thread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadUpdateInput, ThreadUncheckedUpdateInput>
  }

  /**
   * Thread delete
   */
  export type ThreadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter which Thread to delete.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread deleteMany
   */
  export type ThreadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Threads to delete
     */
    where?: ThreadWhereInput
  }

  /**
   * Thread.posts
   */
  export type Thread$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Thread.pollPosts
   */
  export type Thread$pollPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    where?: PollPostWhereInput
    orderBy?: PollPostOrderByWithRelationInput | PollPostOrderByWithRelationInput[]
    cursor?: PollPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PollPostScalarFieldEnum | PollPostScalarFieldEnum[]
  }

  /**
   * Thread without action
   */
  export type ThreadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
  }


  /**
   * Model Note
   */

  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null
    _avg: NoteAvgAggregateOutputType | null
    _sum: NoteSumAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  export type NoteAvgAggregateOutputType = {
    profileId: number | null
  }

  export type NoteSumAggregateOutputType = {
    profileId: number | null
  }

  export type NoteMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    authorId: string | null
    backendPlatformUserId: string | null
    profileId: number | null
    authorUserName: string | null
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType | null
    mediaId: string | null
    postId: string | null
    commentId: string | null
  }

  export type NoteMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    authorId: string | null
    backendPlatformUserId: string | null
    profileId: number | null
    authorUserName: string | null
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType | null
    mediaId: string | null
    postId: string | null
    commentId: string | null
  }

  export type NoteCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    authorId: number
    backendPlatformUserId: number
    profileId: number
    authorUserName: number
    authorProfileImage: number
    authorAccountType: number
    mentions: number
    hashtags: number
    mediaId: number
    postId: number
    commentId: number
    searchMetadata: number
    aiAnalysis: number
    _all: number
  }


  export type NoteAvgAggregateInputType = {
    profileId?: true
  }

  export type NoteSumAggregateInputType = {
    profileId?: true
  }

  export type NoteMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    authorId?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUserName?: true
    authorProfileImage?: true
    authorAccountType?: true
    mediaId?: true
    postId?: true
    commentId?: true
  }

  export type NoteMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    authorId?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUserName?: true
    authorProfileImage?: true
    authorAccountType?: true
    mediaId?: true
    postId?: true
    commentId?: true
  }

  export type NoteCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    authorId?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUserName?: true
    authorProfileImage?: true
    authorAccountType?: true
    mentions?: true
    hashtags?: true
    mediaId?: true
    postId?: true
    commentId?: true
    searchMetadata?: true
    aiAnalysis?: true
    _all?: true
  }

  export type NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note to aggregate.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteMaxAggregateInputType
  }

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>
  }




  export type NoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithAggregationInput | NoteOrderByWithAggregationInput[]
    by: NoteScalarFieldEnum[] | NoteScalarFieldEnum
    having?: NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteCountAggregateInputType | true
    _avg?: NoteAvgAggregateInputType
    _sum?: NoteSumAggregateInputType
    _min?: NoteMinAggregateInputType
    _max?: NoteMaxAggregateInputType
  }

  export type NoteGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType
    mentions: string[]
    hashtags: string[]
    mediaId: string | null
    postId: string
    commentId: string | null
    searchMetadata: JsonValue | null
    aiAnalysis: JsonValue | null
    _count: NoteCountAggregateOutputType | null
    _avg: NoteAvgAggregateOutputType | null
    _sum: NoteSumAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  type GetNoteGroupByPayload<T extends NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteGroupByOutputType[P]>
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
        }
      >
    >


  export type NoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    authorId?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUserName?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    mentions?: boolean
    hashtags?: boolean
    mediaId?: boolean
    postId?: boolean
    commentId?: boolean
    searchMetadata?: boolean
    aiAnalysis?: boolean
    media?: boolean | Note$mediaArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    comment?: boolean | Note$commentArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    authorId?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUserName?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    mentions?: boolean
    hashtags?: boolean
    mediaId?: boolean
    postId?: boolean
    commentId?: boolean
    searchMetadata?: boolean
    aiAnalysis?: boolean
    media?: boolean | Note$mediaArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    comment?: boolean | Note$commentArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    authorId?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUserName?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    mentions?: boolean
    hashtags?: boolean
    mediaId?: boolean
    postId?: boolean
    commentId?: boolean
    searchMetadata?: boolean
    aiAnalysis?: boolean
  }

  export type NoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | Note$mediaArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    comment?: boolean | Note$commentArgs<ExtArgs>
  }
  export type NoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | Note$mediaArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    comment?: boolean | Note$commentArgs<ExtArgs>
  }

  export type $NotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Note"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs> | null
      post: Prisma.$PostPayload<ExtArgs>
      comment: Prisma.$CommentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      authorId: string
      backendPlatformUserId: string
      profileId: number
      authorUserName: string
      authorProfileImage: string | null
      authorAccountType: $Enums.AccountType
      mentions: string[]
      hashtags: string[]
      mediaId: string | null
      postId: string
      commentId: string | null
      searchMetadata: Prisma.JsonValue | null
      aiAnalysis: Prisma.JsonValue | null
    }, ExtArgs["result"]["note"]>
    composites: {}
  }

  type NoteGetPayload<S extends boolean | null | undefined | NoteDefaultArgs> = $Result.GetResult<Prisma.$NotePayload, S>

  type NoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NoteCountAggregateInputType | true
    }

  export interface NoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Note'], meta: { name: 'Note' } }
    /**
     * Find zero or one Note that matches the filter.
     * @param {NoteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteFindUniqueArgs>(args: SelectSubset<T, NoteFindUniqueArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Note that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NoteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteFindFirstArgs>(args?: SelectSubset<T, NoteFindFirstArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteWithIdOnly = await prisma.note.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteFindManyArgs>(args?: SelectSubset<T, NoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Note.
     * @param {NoteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     * 
     */
    create<T extends NoteCreateArgs>(args: SelectSubset<T, NoteCreateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notes.
     * @param {NoteCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteCreateManyArgs>(args?: SelectSubset<T, NoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notes and returns the data saved in the database.
     * @param {NoteCreateManyAndReturnArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notes and only return the `id`
     * const noteWithIdOnly = await prisma.note.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoteCreateManyAndReturnArgs>(args?: SelectSubset<T, NoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Note.
     * @param {NoteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     * 
     */
    delete<T extends NoteDeleteArgs>(args: SelectSubset<T, NoteDeleteArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Note.
     * @param {NoteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteUpdateArgs>(args: SelectSubset<T, NoteUpdateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notes.
     * @param {NoteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteDeleteManyArgs>(args?: SelectSubset<T, NoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteUpdateManyArgs>(args: SelectSubset<T, NoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Note.
     * @param {NoteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
     */
    upsert<T extends NoteUpsertArgs>(args: SelectSubset<T, NoteUpsertArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NoteCountArgs>(
      args?: Subset<T, NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteAggregateArgs>(args: Subset<T, NoteAggregateArgs>): Prisma.PrismaPromise<GetNoteAggregateType<T>>

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteGroupByArgs['orderBy'] }
        : { orderBy?: NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Note model
   */
  readonly fields: NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends Note$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Note$mediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comment<T extends Note$commentArgs<ExtArgs> = {}>(args?: Subset<T, Note$commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Note model
   */ 
  interface NoteFieldRefs {
    readonly id: FieldRef<"Note", 'String'>
    readonly content: FieldRef<"Note", 'String'>
    readonly createdAt: FieldRef<"Note", 'DateTime'>
    readonly authorId: FieldRef<"Note", 'String'>
    readonly backendPlatformUserId: FieldRef<"Note", 'String'>
    readonly profileId: FieldRef<"Note", 'Int'>
    readonly authorUserName: FieldRef<"Note", 'String'>
    readonly authorProfileImage: FieldRef<"Note", 'String'>
    readonly authorAccountType: FieldRef<"Note", 'AccountType'>
    readonly mentions: FieldRef<"Note", 'String[]'>
    readonly hashtags: FieldRef<"Note", 'String[]'>
    readonly mediaId: FieldRef<"Note", 'String'>
    readonly postId: FieldRef<"Note", 'String'>
    readonly commentId: FieldRef<"Note", 'String'>
    readonly searchMetadata: FieldRef<"Note", 'Json'>
    readonly aiAnalysis: FieldRef<"Note", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Note findUnique
   */
  export type NoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findUniqueOrThrow
   */
  export type NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findFirst
   */
  export type NoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findFirstOrThrow
   */
  export type NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findMany
   */
  export type NoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note create
   */
  export type NoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Note.
     */
    data: XOR<NoteCreateInput, NoteUncheckedCreateInput>
  }

  /**
   * Note createMany
   */
  export type NoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Note createManyAndReturn
   */
  export type NoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Note update
   */
  export type NoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Note.
     */
    data: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
    /**
     * Choose, which Note to update.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note updateMany
   */
  export type NoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
  }

  /**
   * Note upsert
   */
  export type NoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Note to update in case it exists.
     */
    where: NoteWhereUniqueInput
    /**
     * In case the Note found by the `where` argument doesn't exist, create a new Note with this data.
     */
    create: XOR<NoteCreateInput, NoteUncheckedCreateInput>
    /**
     * In case the Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
  }

  /**
   * Note delete
   */
  export type NoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter which Note to delete.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note deleteMany
   */
  export type NoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NoteWhereInput
  }

  /**
   * Note.media
   */
  export type Note$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Note.comment
   */
  export type Note$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Note without action
   */
  export type NoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
  }


  /**
   * Model SpaceMember
   */

  export type AggregateSpaceMember = {
    _count: SpaceMemberCountAggregateOutputType | null
    _min: SpaceMemberMinAggregateOutputType | null
    _max: SpaceMemberMaxAggregateOutputType | null
  }

  export type SpaceMemberMinAggregateOutputType = {
    id: string | null
    spaceId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    status: string | null
  }

  export type SpaceMemberMaxAggregateOutputType = {
    id: string | null
    spaceId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    status: string | null
  }

  export type SpaceMemberCountAggregateOutputType = {
    id: number
    spaceId: number
    userId: number
    role: number
    joinedAt: number
    status: number
    permissions: number
    _all: number
  }


  export type SpaceMemberMinAggregateInputType = {
    id?: true
    spaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    status?: true
  }

  export type SpaceMemberMaxAggregateInputType = {
    id?: true
    spaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    status?: true
  }

  export type SpaceMemberCountAggregateInputType = {
    id?: true
    spaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    status?: true
    permissions?: true
    _all?: true
  }

  export type SpaceMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpaceMember to aggregate.
     */
    where?: SpaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceMembers to fetch.
     */
    orderBy?: SpaceMemberOrderByWithRelationInput | SpaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpaceMembers
    **/
    _count?: true | SpaceMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpaceMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpaceMemberMaxAggregateInputType
  }

  export type GetSpaceMemberAggregateType<T extends SpaceMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateSpaceMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpaceMember[P]>
      : GetScalarType<T[P], AggregateSpaceMember[P]>
  }




  export type SpaceMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceMemberWhereInput
    orderBy?: SpaceMemberOrderByWithAggregationInput | SpaceMemberOrderByWithAggregationInput[]
    by: SpaceMemberScalarFieldEnum[] | SpaceMemberScalarFieldEnum
    having?: SpaceMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpaceMemberCountAggregateInputType | true
    _min?: SpaceMemberMinAggregateInputType
    _max?: SpaceMemberMaxAggregateInputType
  }

  export type SpaceMemberGroupByOutputType = {
    id: string
    spaceId: string
    userId: string
    role: string
    joinedAt: Date
    status: string
    permissions: string[]
    _count: SpaceMemberCountAggregateOutputType | null
    _min: SpaceMemberMinAggregateOutputType | null
    _max: SpaceMemberMaxAggregateOutputType | null
  }

  type GetSpaceMemberGroupByPayload<T extends SpaceMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpaceMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpaceMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpaceMemberGroupByOutputType[P]>
            : GetScalarType<T[P], SpaceMemberGroupByOutputType[P]>
        }
      >
    >


  export type SpaceMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    status?: boolean
    permissions?: boolean
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spaceMember"]>

  export type SpaceMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    status?: boolean
    permissions?: boolean
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spaceMember"]>

  export type SpaceMemberSelectScalar = {
    id?: boolean
    spaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    status?: boolean
    permissions?: boolean
  }

  export type SpaceMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }
  export type SpaceMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }

  export type $SpaceMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpaceMember"
    objects: {
      space: Prisma.$SpacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      spaceId: string
      userId: string
      role: string
      joinedAt: Date
      status: string
      permissions: string[]
    }, ExtArgs["result"]["spaceMember"]>
    composites: {}
  }

  type SpaceMemberGetPayload<S extends boolean | null | undefined | SpaceMemberDefaultArgs> = $Result.GetResult<Prisma.$SpaceMemberPayload, S>

  type SpaceMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpaceMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpaceMemberCountAggregateInputType | true
    }

  export interface SpaceMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpaceMember'], meta: { name: 'SpaceMember' } }
    /**
     * Find zero or one SpaceMember that matches the filter.
     * @param {SpaceMemberFindUniqueArgs} args - Arguments to find a SpaceMember
     * @example
     * // Get one SpaceMember
     * const spaceMember = await prisma.spaceMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpaceMemberFindUniqueArgs>(args: SelectSubset<T, SpaceMemberFindUniqueArgs<ExtArgs>>): Prisma__SpaceMemberClient<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SpaceMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpaceMemberFindUniqueOrThrowArgs} args - Arguments to find a SpaceMember
     * @example
     * // Get one SpaceMember
     * const spaceMember = await prisma.spaceMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpaceMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, SpaceMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpaceMemberClient<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SpaceMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceMemberFindFirstArgs} args - Arguments to find a SpaceMember
     * @example
     * // Get one SpaceMember
     * const spaceMember = await prisma.spaceMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpaceMemberFindFirstArgs>(args?: SelectSubset<T, SpaceMemberFindFirstArgs<ExtArgs>>): Prisma__SpaceMemberClient<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SpaceMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceMemberFindFirstOrThrowArgs} args - Arguments to find a SpaceMember
     * @example
     * // Get one SpaceMember
     * const spaceMember = await prisma.spaceMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpaceMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, SpaceMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpaceMemberClient<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpaceMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpaceMembers
     * const spaceMembers = await prisma.spaceMember.findMany()
     * 
     * // Get first 10 SpaceMembers
     * const spaceMembers = await prisma.spaceMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spaceMemberWithIdOnly = await prisma.spaceMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpaceMemberFindManyArgs>(args?: SelectSubset<T, SpaceMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SpaceMember.
     * @param {SpaceMemberCreateArgs} args - Arguments to create a SpaceMember.
     * @example
     * // Create one SpaceMember
     * const SpaceMember = await prisma.spaceMember.create({
     *   data: {
     *     // ... data to create a SpaceMember
     *   }
     * })
     * 
     */
    create<T extends SpaceMemberCreateArgs>(args: SelectSubset<T, SpaceMemberCreateArgs<ExtArgs>>): Prisma__SpaceMemberClient<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpaceMembers.
     * @param {SpaceMemberCreateManyArgs} args - Arguments to create many SpaceMembers.
     * @example
     * // Create many SpaceMembers
     * const spaceMember = await prisma.spaceMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpaceMemberCreateManyArgs>(args?: SelectSubset<T, SpaceMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpaceMembers and returns the data saved in the database.
     * @param {SpaceMemberCreateManyAndReturnArgs} args - Arguments to create many SpaceMembers.
     * @example
     * // Create many SpaceMembers
     * const spaceMember = await prisma.spaceMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpaceMembers and only return the `id`
     * const spaceMemberWithIdOnly = await prisma.spaceMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpaceMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, SpaceMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SpaceMember.
     * @param {SpaceMemberDeleteArgs} args - Arguments to delete one SpaceMember.
     * @example
     * // Delete one SpaceMember
     * const SpaceMember = await prisma.spaceMember.delete({
     *   where: {
     *     // ... filter to delete one SpaceMember
     *   }
     * })
     * 
     */
    delete<T extends SpaceMemberDeleteArgs>(args: SelectSubset<T, SpaceMemberDeleteArgs<ExtArgs>>): Prisma__SpaceMemberClient<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SpaceMember.
     * @param {SpaceMemberUpdateArgs} args - Arguments to update one SpaceMember.
     * @example
     * // Update one SpaceMember
     * const spaceMember = await prisma.spaceMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpaceMemberUpdateArgs>(args: SelectSubset<T, SpaceMemberUpdateArgs<ExtArgs>>): Prisma__SpaceMemberClient<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpaceMembers.
     * @param {SpaceMemberDeleteManyArgs} args - Arguments to filter SpaceMembers to delete.
     * @example
     * // Delete a few SpaceMembers
     * const { count } = await prisma.spaceMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpaceMemberDeleteManyArgs>(args?: SelectSubset<T, SpaceMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpaceMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpaceMembers
     * const spaceMember = await prisma.spaceMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpaceMemberUpdateManyArgs>(args: SelectSubset<T, SpaceMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpaceMember.
     * @param {SpaceMemberUpsertArgs} args - Arguments to update or create a SpaceMember.
     * @example
     * // Update or create a SpaceMember
     * const spaceMember = await prisma.spaceMember.upsert({
     *   create: {
     *     // ... data to create a SpaceMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpaceMember we want to update
     *   }
     * })
     */
    upsert<T extends SpaceMemberUpsertArgs>(args: SelectSubset<T, SpaceMemberUpsertArgs<ExtArgs>>): Prisma__SpaceMemberClient<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SpaceMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceMemberCountArgs} args - Arguments to filter SpaceMembers to count.
     * @example
     * // Count the number of SpaceMembers
     * const count = await prisma.spaceMember.count({
     *   where: {
     *     // ... the filter for the SpaceMembers we want to count
     *   }
     * })
    **/
    count<T extends SpaceMemberCountArgs>(
      args?: Subset<T, SpaceMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpaceMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpaceMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpaceMemberAggregateArgs>(args: Subset<T, SpaceMemberAggregateArgs>): Prisma.PrismaPromise<GetSpaceMemberAggregateType<T>>

    /**
     * Group by SpaceMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpaceMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpaceMemberGroupByArgs['orderBy'] }
        : { orderBy?: SpaceMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpaceMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpaceMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpaceMember model
   */
  readonly fields: SpaceMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpaceMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpaceMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    space<T extends SpaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpaceDefaultArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpaceMember model
   */ 
  interface SpaceMemberFieldRefs {
    readonly id: FieldRef<"SpaceMember", 'String'>
    readonly spaceId: FieldRef<"SpaceMember", 'String'>
    readonly userId: FieldRef<"SpaceMember", 'String'>
    readonly role: FieldRef<"SpaceMember", 'String'>
    readonly joinedAt: FieldRef<"SpaceMember", 'DateTime'>
    readonly status: FieldRef<"SpaceMember", 'String'>
    readonly permissions: FieldRef<"SpaceMember", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * SpaceMember findUnique
   */
  export type SpaceMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which SpaceMember to fetch.
     */
    where: SpaceMemberWhereUniqueInput
  }

  /**
   * SpaceMember findUniqueOrThrow
   */
  export type SpaceMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which SpaceMember to fetch.
     */
    where: SpaceMemberWhereUniqueInput
  }

  /**
   * SpaceMember findFirst
   */
  export type SpaceMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which SpaceMember to fetch.
     */
    where?: SpaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceMembers to fetch.
     */
    orderBy?: SpaceMemberOrderByWithRelationInput | SpaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpaceMembers.
     */
    cursor?: SpaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpaceMembers.
     */
    distinct?: SpaceMemberScalarFieldEnum | SpaceMemberScalarFieldEnum[]
  }

  /**
   * SpaceMember findFirstOrThrow
   */
  export type SpaceMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which SpaceMember to fetch.
     */
    where?: SpaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceMembers to fetch.
     */
    orderBy?: SpaceMemberOrderByWithRelationInput | SpaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpaceMembers.
     */
    cursor?: SpaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpaceMembers.
     */
    distinct?: SpaceMemberScalarFieldEnum | SpaceMemberScalarFieldEnum[]
  }

  /**
   * SpaceMember findMany
   */
  export type SpaceMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which SpaceMembers to fetch.
     */
    where?: SpaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceMembers to fetch.
     */
    orderBy?: SpaceMemberOrderByWithRelationInput | SpaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpaceMembers.
     */
    cursor?: SpaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceMembers.
     */
    skip?: number
    distinct?: SpaceMemberScalarFieldEnum | SpaceMemberScalarFieldEnum[]
  }

  /**
   * SpaceMember create
   */
  export type SpaceMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a SpaceMember.
     */
    data: XOR<SpaceMemberCreateInput, SpaceMemberUncheckedCreateInput>
  }

  /**
   * SpaceMember createMany
   */
  export type SpaceMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpaceMembers.
     */
    data: SpaceMemberCreateManyInput | SpaceMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpaceMember createManyAndReturn
   */
  export type SpaceMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SpaceMembers.
     */
    data: SpaceMemberCreateManyInput | SpaceMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpaceMember update
   */
  export type SpaceMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a SpaceMember.
     */
    data: XOR<SpaceMemberUpdateInput, SpaceMemberUncheckedUpdateInput>
    /**
     * Choose, which SpaceMember to update.
     */
    where: SpaceMemberWhereUniqueInput
  }

  /**
   * SpaceMember updateMany
   */
  export type SpaceMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpaceMembers.
     */
    data: XOR<SpaceMemberUpdateManyMutationInput, SpaceMemberUncheckedUpdateManyInput>
    /**
     * Filter which SpaceMembers to update
     */
    where?: SpaceMemberWhereInput
  }

  /**
   * SpaceMember upsert
   */
  export type SpaceMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the SpaceMember to update in case it exists.
     */
    where: SpaceMemberWhereUniqueInput
    /**
     * In case the SpaceMember found by the `where` argument doesn't exist, create a new SpaceMember with this data.
     */
    create: XOR<SpaceMemberCreateInput, SpaceMemberUncheckedCreateInput>
    /**
     * In case the SpaceMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpaceMemberUpdateInput, SpaceMemberUncheckedUpdateInput>
  }

  /**
   * SpaceMember delete
   */
  export type SpaceMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * Filter which SpaceMember to delete.
     */
    where: SpaceMemberWhereUniqueInput
  }

  /**
   * SpaceMember deleteMany
   */
  export type SpaceMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpaceMembers to delete
     */
    where?: SpaceMemberWhereInput
  }

  /**
   * SpaceMember without action
   */
  export type SpaceMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
  }


  /**
   * Model ChannelMember
   */

  export type AggregateChannelMember = {
    _count: ChannelMemberCountAggregateOutputType | null
    _min: ChannelMemberMinAggregateOutputType | null
    _max: ChannelMemberMaxAggregateOutputType | null
  }

  export type ChannelMemberMinAggregateOutputType = {
    id: string | null
    channelId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    lastRead: Date | null
  }

  export type ChannelMemberMaxAggregateOutputType = {
    id: string | null
    channelId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    lastRead: Date | null
  }

  export type ChannelMemberCountAggregateOutputType = {
    id: number
    channelId: number
    userId: number
    role: number
    joinedAt: number
    lastRead: number
    _all: number
  }


  export type ChannelMemberMinAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
    role?: true
    joinedAt?: true
    lastRead?: true
  }

  export type ChannelMemberMaxAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
    role?: true
    joinedAt?: true
    lastRead?: true
  }

  export type ChannelMemberCountAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
    role?: true
    joinedAt?: true
    lastRead?: true
    _all?: true
  }

  export type ChannelMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelMember to aggregate.
     */
    where?: ChannelMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelMembers to fetch.
     */
    orderBy?: ChannelMemberOrderByWithRelationInput | ChannelMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChannelMembers
    **/
    _count?: true | ChannelMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMemberMaxAggregateInputType
  }

  export type GetChannelMemberAggregateType<T extends ChannelMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateChannelMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannelMember[P]>
      : GetScalarType<T[P], AggregateChannelMember[P]>
  }




  export type ChannelMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelMemberWhereInput
    orderBy?: ChannelMemberOrderByWithAggregationInput | ChannelMemberOrderByWithAggregationInput[]
    by: ChannelMemberScalarFieldEnum[] | ChannelMemberScalarFieldEnum
    having?: ChannelMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelMemberCountAggregateInputType | true
    _min?: ChannelMemberMinAggregateInputType
    _max?: ChannelMemberMaxAggregateInputType
  }

  export type ChannelMemberGroupByOutputType = {
    id: string
    channelId: string
    userId: string
    role: string
    joinedAt: Date
    lastRead: Date | null
    _count: ChannelMemberCountAggregateOutputType | null
    _min: ChannelMemberMinAggregateOutputType | null
    _max: ChannelMemberMaxAggregateOutputType | null
  }

  type GetChannelMemberGroupByPayload<T extends ChannelMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelMemberGroupByOutputType[P]>
        }
      >
    >


  export type ChannelMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    lastRead?: boolean
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelMember"]>

  export type ChannelMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    lastRead?: boolean
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelMember"]>

  export type ChannelMemberSelectScalar = {
    id?: boolean
    channelId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    lastRead?: boolean
  }

  export type ChannelMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }
  export type ChannelMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }

  export type $ChannelMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChannelMember"
    objects: {
      channel: Prisma.$ChannelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      channelId: string
      userId: string
      role: string
      joinedAt: Date
      lastRead: Date | null
    }, ExtArgs["result"]["channelMember"]>
    composites: {}
  }

  type ChannelMemberGetPayload<S extends boolean | null | undefined | ChannelMemberDefaultArgs> = $Result.GetResult<Prisma.$ChannelMemberPayload, S>

  type ChannelMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelMemberCountAggregateInputType | true
    }

  export interface ChannelMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelMember'], meta: { name: 'ChannelMember' } }
    /**
     * Find zero or one ChannelMember that matches the filter.
     * @param {ChannelMemberFindUniqueArgs} args - Arguments to find a ChannelMember
     * @example
     * // Get one ChannelMember
     * const channelMember = await prisma.channelMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelMemberFindUniqueArgs>(args: SelectSubset<T, ChannelMemberFindUniqueArgs<ExtArgs>>): Prisma__ChannelMemberClient<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChannelMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelMemberFindUniqueOrThrowArgs} args - Arguments to find a ChannelMember
     * @example
     * // Get one ChannelMember
     * const channelMember = await prisma.channelMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelMemberClient<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChannelMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMemberFindFirstArgs} args - Arguments to find a ChannelMember
     * @example
     * // Get one ChannelMember
     * const channelMember = await prisma.channelMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelMemberFindFirstArgs>(args?: SelectSubset<T, ChannelMemberFindFirstArgs<ExtArgs>>): Prisma__ChannelMemberClient<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChannelMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMemberFindFirstOrThrowArgs} args - Arguments to find a ChannelMember
     * @example
     * // Get one ChannelMember
     * const channelMember = await prisma.channelMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelMemberClient<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChannelMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelMembers
     * const channelMembers = await prisma.channelMember.findMany()
     * 
     * // Get first 10 ChannelMembers
     * const channelMembers = await prisma.channelMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelMemberWithIdOnly = await prisma.channelMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelMemberFindManyArgs>(args?: SelectSubset<T, ChannelMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChannelMember.
     * @param {ChannelMemberCreateArgs} args - Arguments to create a ChannelMember.
     * @example
     * // Create one ChannelMember
     * const ChannelMember = await prisma.channelMember.create({
     *   data: {
     *     // ... data to create a ChannelMember
     *   }
     * })
     * 
     */
    create<T extends ChannelMemberCreateArgs>(args: SelectSubset<T, ChannelMemberCreateArgs<ExtArgs>>): Prisma__ChannelMemberClient<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChannelMembers.
     * @param {ChannelMemberCreateManyArgs} args - Arguments to create many ChannelMembers.
     * @example
     * // Create many ChannelMembers
     * const channelMember = await prisma.channelMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelMemberCreateManyArgs>(args?: SelectSubset<T, ChannelMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChannelMembers and returns the data saved in the database.
     * @param {ChannelMemberCreateManyAndReturnArgs} args - Arguments to create many ChannelMembers.
     * @example
     * // Create many ChannelMembers
     * const channelMember = await prisma.channelMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChannelMembers and only return the `id`
     * const channelMemberWithIdOnly = await prisma.channelMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChannelMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ChannelMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChannelMember.
     * @param {ChannelMemberDeleteArgs} args - Arguments to delete one ChannelMember.
     * @example
     * // Delete one ChannelMember
     * const ChannelMember = await prisma.channelMember.delete({
     *   where: {
     *     // ... filter to delete one ChannelMember
     *   }
     * })
     * 
     */
    delete<T extends ChannelMemberDeleteArgs>(args: SelectSubset<T, ChannelMemberDeleteArgs<ExtArgs>>): Prisma__ChannelMemberClient<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChannelMember.
     * @param {ChannelMemberUpdateArgs} args - Arguments to update one ChannelMember.
     * @example
     * // Update one ChannelMember
     * const channelMember = await prisma.channelMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelMemberUpdateArgs>(args: SelectSubset<T, ChannelMemberUpdateArgs<ExtArgs>>): Prisma__ChannelMemberClient<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChannelMembers.
     * @param {ChannelMemberDeleteManyArgs} args - Arguments to filter ChannelMembers to delete.
     * @example
     * // Delete a few ChannelMembers
     * const { count } = await prisma.channelMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelMemberDeleteManyArgs>(args?: SelectSubset<T, ChannelMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelMembers
     * const channelMember = await prisma.channelMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelMemberUpdateManyArgs>(args: SelectSubset<T, ChannelMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChannelMember.
     * @param {ChannelMemberUpsertArgs} args - Arguments to update or create a ChannelMember.
     * @example
     * // Update or create a ChannelMember
     * const channelMember = await prisma.channelMember.upsert({
     *   create: {
     *     // ... data to create a ChannelMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelMember we want to update
     *   }
     * })
     */
    upsert<T extends ChannelMemberUpsertArgs>(args: SelectSubset<T, ChannelMemberUpsertArgs<ExtArgs>>): Prisma__ChannelMemberClient<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChannelMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMemberCountArgs} args - Arguments to filter ChannelMembers to count.
     * @example
     * // Count the number of ChannelMembers
     * const count = await prisma.channelMember.count({
     *   where: {
     *     // ... the filter for the ChannelMembers we want to count
     *   }
     * })
    **/
    count<T extends ChannelMemberCountArgs>(
      args?: Subset<T, ChannelMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChannelMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelMemberAggregateArgs>(args: Subset<T, ChannelMemberAggregateArgs>): Prisma.PrismaPromise<GetChannelMemberAggregateType<T>>

    /**
     * Group by ChannelMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelMemberGroupByArgs['orderBy'] }
        : { orderBy?: ChannelMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChannelMember model
   */
  readonly fields: ChannelMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChannelMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel<T extends ChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefaultArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChannelMember model
   */ 
  interface ChannelMemberFieldRefs {
    readonly id: FieldRef<"ChannelMember", 'String'>
    readonly channelId: FieldRef<"ChannelMember", 'String'>
    readonly userId: FieldRef<"ChannelMember", 'String'>
    readonly role: FieldRef<"ChannelMember", 'String'>
    readonly joinedAt: FieldRef<"ChannelMember", 'DateTime'>
    readonly lastRead: FieldRef<"ChannelMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChannelMember findUnique
   */
  export type ChannelMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMember to fetch.
     */
    where: ChannelMemberWhereUniqueInput
  }

  /**
   * ChannelMember findUniqueOrThrow
   */
  export type ChannelMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMember to fetch.
     */
    where: ChannelMemberWhereUniqueInput
  }

  /**
   * ChannelMember findFirst
   */
  export type ChannelMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMember to fetch.
     */
    where?: ChannelMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelMembers to fetch.
     */
    orderBy?: ChannelMemberOrderByWithRelationInput | ChannelMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelMembers.
     */
    cursor?: ChannelMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelMembers.
     */
    distinct?: ChannelMemberScalarFieldEnum | ChannelMemberScalarFieldEnum[]
  }

  /**
   * ChannelMember findFirstOrThrow
   */
  export type ChannelMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMember to fetch.
     */
    where?: ChannelMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelMembers to fetch.
     */
    orderBy?: ChannelMemberOrderByWithRelationInput | ChannelMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelMembers.
     */
    cursor?: ChannelMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelMembers.
     */
    distinct?: ChannelMemberScalarFieldEnum | ChannelMemberScalarFieldEnum[]
  }

  /**
   * ChannelMember findMany
   */
  export type ChannelMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMembers to fetch.
     */
    where?: ChannelMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelMembers to fetch.
     */
    orderBy?: ChannelMemberOrderByWithRelationInput | ChannelMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChannelMembers.
     */
    cursor?: ChannelMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelMembers.
     */
    skip?: number
    distinct?: ChannelMemberScalarFieldEnum | ChannelMemberScalarFieldEnum[]
  }

  /**
   * ChannelMember create
   */
  export type ChannelMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ChannelMember.
     */
    data: XOR<ChannelMemberCreateInput, ChannelMemberUncheckedCreateInput>
  }

  /**
   * ChannelMember createMany
   */
  export type ChannelMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelMembers.
     */
    data: ChannelMemberCreateManyInput | ChannelMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChannelMember createManyAndReturn
   */
  export type ChannelMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChannelMembers.
     */
    data: ChannelMemberCreateManyInput | ChannelMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChannelMember update
   */
  export type ChannelMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ChannelMember.
     */
    data: XOR<ChannelMemberUpdateInput, ChannelMemberUncheckedUpdateInput>
    /**
     * Choose, which ChannelMember to update.
     */
    where: ChannelMemberWhereUniqueInput
  }

  /**
   * ChannelMember updateMany
   */
  export type ChannelMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelMembers.
     */
    data: XOR<ChannelMemberUpdateManyMutationInput, ChannelMemberUncheckedUpdateManyInput>
    /**
     * Filter which ChannelMembers to update
     */
    where?: ChannelMemberWhereInput
  }

  /**
   * ChannelMember upsert
   */
  export type ChannelMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ChannelMember to update in case it exists.
     */
    where: ChannelMemberWhereUniqueInput
    /**
     * In case the ChannelMember found by the `where` argument doesn't exist, create a new ChannelMember with this data.
     */
    create: XOR<ChannelMemberCreateInput, ChannelMemberUncheckedCreateInput>
    /**
     * In case the ChannelMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelMemberUpdateInput, ChannelMemberUncheckedUpdateInput>
  }

  /**
   * ChannelMember delete
   */
  export type ChannelMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * Filter which ChannelMember to delete.
     */
    where: ChannelMemberWhereUniqueInput
  }

  /**
   * ChannelMember deleteMany
   */
  export type ChannelMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelMembers to delete
     */
    where?: ChannelMemberWhereInput
  }

  /**
   * ChannelMember without action
   */
  export type ChannelMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
  }

  export type FileSumAggregateOutputType = {
    size: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.MediaType | null
    url: string | null
    uploadedBy: string | null
    uploadedAt: Date | null
    size: number | null
    status: string | null
    preview: string | null
    thumbnail: string | null
    spaceId: string | null
    channelId: string | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.MediaType | null
    url: string | null
    uploadedBy: string | null
    uploadedAt: Date | null
    size: number | null
    status: string | null
    preview: string | null
    thumbnail: string | null
    spaceId: string | null
    channelId: string | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    name: number
    type: number
    url: number
    metadata: number
    uploadedBy: number
    uploadedAt: number
    size: number
    status: number
    preview: number
    thumbnail: number
    searchMetadata: number
    aiAnalysis: number
    spaceId: number
    channelId: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true
  }

  export type FileSumAggregateInputType = {
    size?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    uploadedBy?: true
    uploadedAt?: true
    size?: true
    status?: true
    preview?: true
    thumbnail?: true
    spaceId?: true
    channelId?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    uploadedBy?: true
    uploadedAt?: true
    size?: true
    status?: true
    preview?: true
    thumbnail?: true
    spaceId?: true
    channelId?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    metadata?: true
    uploadedBy?: true
    uploadedAt?: true
    size?: true
    status?: true
    preview?: true
    thumbnail?: true
    searchMetadata?: true
    aiAnalysis?: true
    spaceId?: true
    channelId?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: JsonValue
    uploadedBy: string
    uploadedAt: Date
    size: number
    status: string
    preview: string | null
    thumbnail: string | null
    searchMetadata: JsonValue | null
    aiAnalysis: JsonValue | null
    spaceId: string | null
    channelId: string | null
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    metadata?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    size?: boolean
    status?: boolean
    preview?: boolean
    thumbnail?: boolean
    searchMetadata?: boolean
    aiAnalysis?: boolean
    spaceId?: boolean
    channelId?: boolean
    posts?: boolean | File$postsArgs<ExtArgs>
    space?: boolean | File$spaceArgs<ExtArgs>
    channel?: boolean | File$channelArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    metadata?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    size?: boolean
    status?: boolean
    preview?: boolean
    thumbnail?: boolean
    searchMetadata?: boolean
    aiAnalysis?: boolean
    spaceId?: boolean
    channelId?: boolean
    space?: boolean | File$spaceArgs<ExtArgs>
    channel?: boolean | File$channelArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    metadata?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    size?: boolean
    status?: boolean
    preview?: boolean
    thumbnail?: boolean
    searchMetadata?: boolean
    aiAnalysis?: boolean
    spaceId?: boolean
    channelId?: boolean
  }

  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | File$postsArgs<ExtArgs>
    space?: boolean | File$spaceArgs<ExtArgs>
    channel?: boolean | File$channelArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    space?: boolean | File$spaceArgs<ExtArgs>
    channel?: boolean | File$channelArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      posts: Prisma.$PostPayload<ExtArgs>[]
      space: Prisma.$SpacePayload<ExtArgs> | null
      channel: Prisma.$ChannelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.MediaType
      url: string
      metadata: Prisma.JsonValue
      uploadedBy: string
      uploadedAt: Date
      size: number
      status: string
      preview: string | null
      thumbnail: string | null
      searchMetadata: Prisma.JsonValue | null
      aiAnalysis: Prisma.JsonValue | null
      spaceId: string | null
      channelId: string | null
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends File$postsArgs<ExtArgs> = {}>(args?: Subset<T, File$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    space<T extends File$spaceArgs<ExtArgs> = {}>(args?: Subset<T, File$spaceArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    channel<T extends File$channelArgs<ExtArgs> = {}>(args?: Subset<T, File$channelArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */ 
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly name: FieldRef<"File", 'String'>
    readonly type: FieldRef<"File", 'MediaType'>
    readonly url: FieldRef<"File", 'String'>
    readonly metadata: FieldRef<"File", 'Json'>
    readonly uploadedBy: FieldRef<"File", 'String'>
    readonly uploadedAt: FieldRef<"File", 'DateTime'>
    readonly size: FieldRef<"File", 'Int'>
    readonly status: FieldRef<"File", 'String'>
    readonly preview: FieldRef<"File", 'String'>
    readonly thumbnail: FieldRef<"File", 'String'>
    readonly searchMetadata: FieldRef<"File", 'Json'>
    readonly aiAnalysis: FieldRef<"File", 'Json'>
    readonly spaceId: FieldRef<"File", 'String'>
    readonly channelId: FieldRef<"File", 'String'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
  }

  /**
   * File.posts
   */
  export type File$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * File.space
   */
  export type File$spaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    where?: SpaceWhereInput
  }

  /**
   * File.channel
   */
  export type File$channelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const VirtualProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    profileType: 'profileType',
    activated: 'activated',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VirtualProfileScalarFieldEnum = (typeof VirtualProfileScalarFieldEnum)[keyof typeof VirtualProfileScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    virtualProfileId: 'virtualProfileId',
    name: 'name',
    profileImageUrl: 'profileImageUrl',
    bio: 'bio',
    private: 'private',
    followersCount: 'followersCount',
    followingCount: 'followingCount',
    newsFeedTimelineId: 'newsFeedTimelineId',
    personalFeedTimelineId: 'personalFeedTimelineId',
    notificationFeedTimelineId: 'notificationFeedTimelineId',
    algoliaId: 'algoliaId',
    metadata: 'metadata',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const CommunityProfileScalarFieldEnum: {
    id: 'id',
    virtualProfileId: 'virtualProfileId',
    name: 'name',
    description: 'description',
    communityRules: 'communityRules',
    profileImageUrl: 'profileImageUrl',
    private: 'private',
    visible: 'visible',
    followers: 'followers',
    newsFeedTimelineId: 'newsFeedTimelineId',
    personalFeedTimelineId: 'personalFeedTimelineId',
    notificationFeedTimelineId: 'notificationFeedTimelineId',
    algoliaId: 'algoliaId',
    metadata: 'metadata',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommunityProfileScalarFieldEnum = (typeof CommunityProfileScalarFieldEnum)[keyof typeof CommunityProfileScalarFieldEnum]


  export const TopicScalarFieldEnum: {
    id: 'id',
    communityProfileId: 'communityProfileId',
    topicName: 'topicName',
    description: 'description',
    imageUrl: 'imageUrl',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TopicScalarFieldEnum = (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum]


  export const PublicationScalarFieldEnum: {
    id: 'id',
    publicationName: 'publicationName',
    description: 'description',
    type: 'type',
    postIds: 'postIds',
    subjects: 'subjects',
    tags: 'tags',
    adminBackendPlatformUserId: 'adminBackendPlatformUserId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PublicationScalarFieldEnum = (typeof PublicationScalarFieldEnum)[keyof typeof PublicationScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    mediaType: 'mediaType',
    status: 'status',
    fileContent: 'fileContent',
    fileName: 'fileName',
    transcription: 'transcription',
    extractedText: 'extractedText',
    createdAt: 'createdAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    communityId: 'communityId',
    parentSpaceId: 'parentSpaceId',
    title: 'title',
    content: 'content',
    description: 'description',
    status: 'status',
    workflowStatus: 'workflowStatus',
    assignedTo: 'assignedTo',
    contentFormat: 'contentFormat',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    publishedAt: 'publishedAt',
    postType: 'postType',
    category: 'category',
    threadParticipantType: 'threadParticipantType',
    backendPlatformUserId: 'backendPlatformUserId',
    profileId: 'profileId',
    authorUsername: 'authorUsername',
    authorProfileImage: 'authorProfileImage',
    authorAccountType: 'authorAccountType',
    tags: 'tags',
    mentions: 'mentions',
    hashtags: 'hashtags',
    topicName: 'topicName',
    mediaId: 'mediaId',
    backgroundImageUrl: 'backgroundImageUrl',
    affinityScore: 'affinityScore',
    qualityScore: 'qualityScore',
    viewCount: 'viewCount',
    userIdToAffinityScoreMap: 'userIdToAffinityScoreMap',
    userIdToReportsMap: 'userIdToReportsMap',
    userIdToReactionMap: 'userIdToReactionMap',
    insights: 'insights',
    readingTime: 'readingTime',
    aiGeneratedQuestionResponse: 'aiGeneratedQuestionResponse',
    aiAnalysis: 'aiAnalysis',
    searchMetadata: 'searchMetadata',
    metadata: 'metadata',
    threadId: 'threadId',
    spaceId: 'spaceId',
    channelId: 'channelId',
    extra: 'extra',
    visibility: 'visibility',
    isPinned: 'isPinned',
    isArchived: 'isArchived',
    workflow: 'workflow',
    version: 'version'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const PollPostScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    action: 'action',
    content: 'content',
    title: 'title',
    pollOptions: 'pollOptions',
    pollDistribution: 'pollDistribution',
    userIdToPollResponsesMap: 'userIdToPollResponsesMap',
    pollEndDate: 'pollEndDate',
    mentions: 'mentions',
    hashtags: 'hashtags',
    tags: 'tags',
    topicName: 'topicName',
    backendPlatformUserId: 'backendPlatformUserId',
    profileId: 'profileId',
    mediaId: 'mediaId',
    threadId: 'threadId',
    extra: 'extra',
    searchMetadata: 'searchMetadata',
    aiAnalysis: 'aiAnalysis'
  };

  export type PollPostScalarFieldEnum = (typeof PollPostScalarFieldEnum)[keyof typeof PollPostScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    content: 'content',
    createdAt: 'createdAt',
    backendPlatformUserId: 'backendPlatformUserId',
    profileId: 'profileId',
    authorUsername: 'authorUsername',
    authorProfileImage: 'authorProfileImage',
    authorAccountType: 'authorAccountType',
    affinityScore: 'affinityScore',
    qualityScore: 'qualityScore',
    userIdToAffinityScoreMap: 'userIdToAffinityScoreMap',
    userIdToReportsMap: 'userIdToReportsMap',
    userIdToReactionMap: 'userIdToReactionMap',
    mentions: 'mentions',
    hashtags: 'hashtags',
    mediaId: 'mediaId',
    postId: 'postId',
    pollPostId: 'pollPostId',
    extra: 'extra',
    aiAnalysis: 'aiAnalysis'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const CommentReplyScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    backendPlatformUserId: 'backendPlatformUserId',
    profileId: 'profileId',
    authorUsername: 'authorUsername',
    authorProfileImage: 'authorProfileImage',
    authorAccountType: 'authorAccountType',
    affinityScore: 'affinityScore',
    qualityScore: 'qualityScore',
    userIdToAffinityScoreMap: 'userIdToAffinityScoreMap',
    userIdToReportsMap: 'userIdToReportsMap',
    userIdToReactionMap: 'userIdToReactionMap',
    mentions: 'mentions',
    hashtags: 'hashtags',
    mediaId: 'mediaId',
    commentId: 'commentId',
    extra: 'extra',
    aiAnalysis: 'aiAnalysis'
  };

  export type CommentReplyScalarFieldEnum = (typeof CommentReplyScalarFieldEnum)[keyof typeof CommentReplyScalarFieldEnum]


  export const ReactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    postId: 'postId',
    commentId: 'commentId',
    type: 'type',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ReactionScalarFieldEnum = (typeof ReactionScalarFieldEnum)[keyof typeof ReactionScalarFieldEnum]


  export const BookmarkScalarFieldEnum: {
    id: 'id',
    postIds: 'postIds',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookmarkScalarFieldEnum = (typeof BookmarkScalarFieldEnum)[keyof typeof BookmarkScalarFieldEnum]


  export const BlockScalarFieldEnum: {
    id: 'id',
    profileBlockingId: 'profileBlockingId',
    profileBlockedId: 'profileBlockedId',
    profileBlockingType: 'profileBlockingType',
    profileBlockedType: 'profileBlockedType',
    reason: 'reason',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type BlockScalarFieldEnum = (typeof BlockScalarFieldEnum)[keyof typeof BlockScalarFieldEnum]


  export const FollowScalarFieldEnum: {
    id: 'id',
    profileFollowingId: 'profileFollowingId',
    profileFollowedId: 'profileFollowedId',
    targetFollowerType: 'targetFollowerType',
    requestApproved: 'requestApproved',
    metadata: 'metadata',
    createdAt: 'createdAt',
    approvedAt: 'approvedAt'
  };

  export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


  export const UserTagScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    tagName: 'tagName',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserTagScalarFieldEnum = (typeof UserTagScalarFieldEnum)[keyof typeof UserTagScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    submitterId: 'submitterId',
    postId: 'postId',
    commentId: 'commentId',
    userId: 'userId',
    reason: 'reason',
    description: 'description',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    resolvedAt: 'resolvedAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    content: 'content',
    isRead: 'isRead',
    metadata: 'metadata',
    createdAt: 'createdAt',
    readAt: 'readAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SpaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    spaceType: 'spaceType',
    status: 'status',
    visibility: 'visibility',
    parentSpaceId: 'parentSpaceId',
    isPrivate: 'isPrivate',
    metadata: 'metadata',
    settings: 'settings',
    accessLevel: 'accessLevel',
    searchMetadata: 'searchMetadata',
    tags: 'tags'
  };

  export type SpaceScalarFieldEnum = (typeof SpaceScalarFieldEnum)[keyof typeof SpaceScalarFieldEnum]


  export const ChannelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    spaceId: 'spaceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    pinnedPosts: 'pinnedPosts',
    isPrivate: 'isPrivate',
    metadata: 'metadata',
    settings: 'settings'
  };

  export type ChannelScalarFieldEnum = (typeof ChannelScalarFieldEnum)[keyof typeof ChannelScalarFieldEnum]


  export const ThreadScalarFieldEnum: {
    id: 'id',
    postIds: 'postIds',
    parentPostId: 'parentPostId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    metadata: 'metadata',
    status: 'status',
    isLocked: 'isLocked'
  };

  export type ThreadScalarFieldEnum = (typeof ThreadScalarFieldEnum)[keyof typeof ThreadScalarFieldEnum]


  export const NoteScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    authorId: 'authorId',
    backendPlatformUserId: 'backendPlatformUserId',
    profileId: 'profileId',
    authorUserName: 'authorUserName',
    authorProfileImage: 'authorProfileImage',
    authorAccountType: 'authorAccountType',
    mentions: 'mentions',
    hashtags: 'hashtags',
    mediaId: 'mediaId',
    postId: 'postId',
    commentId: 'commentId',
    searchMetadata: 'searchMetadata',
    aiAnalysis: 'aiAnalysis'
  };

  export type NoteScalarFieldEnum = (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum]


  export const SpaceMemberScalarFieldEnum: {
    id: 'id',
    spaceId: 'spaceId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt',
    status: 'status',
    permissions: 'permissions'
  };

  export type SpaceMemberScalarFieldEnum = (typeof SpaceMemberScalarFieldEnum)[keyof typeof SpaceMemberScalarFieldEnum]


  export const ChannelMemberScalarFieldEnum: {
    id: 'id',
    channelId: 'channelId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt',
    lastRead: 'lastRead'
  };

  export type ChannelMemberScalarFieldEnum = (typeof ChannelMemberScalarFieldEnum)[keyof typeof ChannelMemberScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    url: 'url',
    metadata: 'metadata',
    uploadedBy: 'uploadedBy',
    uploadedAt: 'uploadedAt',
    size: 'size',
    status: 'status',
    preview: 'preview',
    thumbnail: 'thumbnail',
    searchMetadata: 'searchMetadata',
    aiAnalysis: 'aiAnalysis',
    spaceId: 'spaceId',
    channelId: 'channelId'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'PostStatus'
   */
  export type EnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus'>
    


  /**
   * Reference to a field of type 'PostStatus[]'
   */
  export type ListEnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus[]'>
    


  /**
   * Reference to a field of type 'PostType'
   */
  export type EnumPostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostType'>
    


  /**
   * Reference to a field of type 'PostType[]'
   */
  export type ListEnumPostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostType[]'>
    


  /**
   * Reference to a field of type 'Category'
   */
  export type EnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category'>
    


  /**
   * Reference to a field of type 'Category[]'
   */
  export type ListEnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category[]'>
    


  /**
   * Reference to a field of type 'ThreadParticipantType'
   */
  export type EnumThreadParticipantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ThreadParticipantType'>
    


  /**
   * Reference to a field of type 'ThreadParticipantType[]'
   */
  export type ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ThreadParticipantType[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'Visibility'
   */
  export type EnumVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Visibility'>
    


  /**
   * Reference to a field of type 'Visibility[]'
   */
  export type ListEnumVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Visibility[]'>
    


  /**
   * Reference to a field of type 'ReactionType'
   */
  export type EnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType'>
    


  /**
   * Reference to a field of type 'ReactionType[]'
   */
  export type ListEnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType[]'>
    


  /**
   * Reference to a field of type 'ReportReason'
   */
  export type EnumReportReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportReason'>
    


  /**
   * Reference to a field of type 'ReportReason[]'
   */
  export type ListEnumReportReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportReason[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'SpaceType'
   */
  export type EnumSpaceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SpaceType'>
    


  /**
   * Reference to a field of type 'SpaceType[]'
   */
  export type ListEnumSpaceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SpaceType[]'>
    


  /**
   * Reference to a field of type 'AccessLevel'
   */
  export type EnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel'>
    


  /**
   * Reference to a field of type 'AccessLevel[]'
   */
  export type ListEnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type VirtualProfileWhereInput = {
    AND?: VirtualProfileWhereInput | VirtualProfileWhereInput[]
    OR?: VirtualProfileWhereInput[]
    NOT?: VirtualProfileWhereInput | VirtualProfileWhereInput[]
    id?: StringFilter<"VirtualProfile"> | string
    userId?: StringNullableFilter<"VirtualProfile"> | string | null
    profileType?: StringNullableFilter<"VirtualProfile"> | string | null
    activated?: BoolNullableFilter<"VirtualProfile"> | boolean | null
    metadata?: JsonNullableFilter<"VirtualProfile">
    createdAt?: DateTimeFilter<"VirtualProfile"> | Date | string
    updatedAt?: DateTimeFilter<"VirtualProfile"> | Date | string
    userProfile?: UserProfileListRelationFilter
    communityProfile?: CommunityProfileListRelationFilter
  }

  export type VirtualProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    profileType?: SortOrderInput | SortOrder
    activated?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userProfile?: UserProfileOrderByRelationAggregateInput
    communityProfile?: CommunityProfileOrderByRelationAggregateInput
  }

  export type VirtualProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VirtualProfileWhereInput | VirtualProfileWhereInput[]
    OR?: VirtualProfileWhereInput[]
    NOT?: VirtualProfileWhereInput | VirtualProfileWhereInput[]
    userId?: StringNullableFilter<"VirtualProfile"> | string | null
    profileType?: StringNullableFilter<"VirtualProfile"> | string | null
    activated?: BoolNullableFilter<"VirtualProfile"> | boolean | null
    metadata?: JsonNullableFilter<"VirtualProfile">
    createdAt?: DateTimeFilter<"VirtualProfile"> | Date | string
    updatedAt?: DateTimeFilter<"VirtualProfile"> | Date | string
    userProfile?: UserProfileListRelationFilter
    communityProfile?: CommunityProfileListRelationFilter
  }, "id">

  export type VirtualProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    profileType?: SortOrderInput | SortOrder
    activated?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VirtualProfileCountOrderByAggregateInput
    _max?: VirtualProfileMaxOrderByAggregateInput
    _min?: VirtualProfileMinOrderByAggregateInput
  }

  export type VirtualProfileScalarWhereWithAggregatesInput = {
    AND?: VirtualProfileScalarWhereWithAggregatesInput | VirtualProfileScalarWhereWithAggregatesInput[]
    OR?: VirtualProfileScalarWhereWithAggregatesInput[]
    NOT?: VirtualProfileScalarWhereWithAggregatesInput | VirtualProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VirtualProfile"> | string
    userId?: StringNullableWithAggregatesFilter<"VirtualProfile"> | string | null
    profileType?: StringNullableWithAggregatesFilter<"VirtualProfile"> | string | null
    activated?: BoolNullableWithAggregatesFilter<"VirtualProfile"> | boolean | null
    metadata?: JsonNullableWithAggregatesFilter<"VirtualProfile">
    createdAt?: DateTimeWithAggregatesFilter<"VirtualProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VirtualProfile"> | Date | string
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: StringFilter<"UserProfile"> | string
    virtualProfileId?: StringFilter<"UserProfile"> | string
    name?: StringNullableFilter<"UserProfile"> | string | null
    profileImageUrl?: StringNullableFilter<"UserProfile"> | string | null
    bio?: StringNullableFilter<"UserProfile"> | string | null
    private?: BoolNullableFilter<"UserProfile"> | boolean | null
    followersCount?: IntFilter<"UserProfile"> | number
    followingCount?: IntFilter<"UserProfile"> | number
    newsFeedTimelineId?: StringNullableFilter<"UserProfile"> | string | null
    personalFeedTimelineId?: StringNullableFilter<"UserProfile"> | string | null
    notificationFeedTimelineId?: StringNullableFilter<"UserProfile"> | string | null
    algoliaId?: StringNullableFilter<"UserProfile"> | string | null
    metadata?: JsonNullableFilter<"UserProfile">
    settings?: JsonNullableFilter<"UserProfile">
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    virtualProfile?: XOR<VirtualProfileRelationFilter, VirtualProfileWhereInput>
    bookmarks?: BookmarkListRelationFilter
    tags?: UserTagListRelationFilter
    adminPublications?: PublicationListRelationFilter
    editorPublications?: PublicationListRelationFilter
    blockedBy?: BlockListRelationFilter
    blocking?: BlockListRelationFilter
    followers?: FollowListRelationFilter
    following?: FollowListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    reactions?: ReactionListRelationFilter
    notifications?: NotificationListRelationFilter
    reportsSubmitted?: ReportListRelationFilter
    reportedContent?: ReportListRelationFilter
    moderatedCommunities?: CommunityProfileListRelationFilter
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    virtualProfileId?: SortOrder
    name?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    private?: SortOrderInput | SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    newsFeedTimelineId?: SortOrderInput | SortOrder
    personalFeedTimelineId?: SortOrderInput | SortOrder
    notificationFeedTimelineId?: SortOrderInput | SortOrder
    algoliaId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    virtualProfile?: VirtualProfileOrderByWithRelationInput
    bookmarks?: BookmarkOrderByRelationAggregateInput
    tags?: UserTagOrderByRelationAggregateInput
    adminPublications?: PublicationOrderByRelationAggregateInput
    editorPublications?: PublicationOrderByRelationAggregateInput
    blockedBy?: BlockOrderByRelationAggregateInput
    blocking?: BlockOrderByRelationAggregateInput
    followers?: FollowOrderByRelationAggregateInput
    following?: FollowOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    reactions?: ReactionOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    reportsSubmitted?: ReportOrderByRelationAggregateInput
    reportedContent?: ReportOrderByRelationAggregateInput
    moderatedCommunities?: CommunityProfileOrderByRelationAggregateInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    newsFeedTimelineId?: string
    personalFeedTimelineId?: string
    notificationFeedTimelineId?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    virtualProfileId?: StringFilter<"UserProfile"> | string
    name?: StringNullableFilter<"UserProfile"> | string | null
    profileImageUrl?: StringNullableFilter<"UserProfile"> | string | null
    bio?: StringNullableFilter<"UserProfile"> | string | null
    private?: BoolNullableFilter<"UserProfile"> | boolean | null
    followersCount?: IntFilter<"UserProfile"> | number
    followingCount?: IntFilter<"UserProfile"> | number
    algoliaId?: StringNullableFilter<"UserProfile"> | string | null
    metadata?: JsonNullableFilter<"UserProfile">
    settings?: JsonNullableFilter<"UserProfile">
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    virtualProfile?: XOR<VirtualProfileRelationFilter, VirtualProfileWhereInput>
    bookmarks?: BookmarkListRelationFilter
    tags?: UserTagListRelationFilter
    adminPublications?: PublicationListRelationFilter
    editorPublications?: PublicationListRelationFilter
    blockedBy?: BlockListRelationFilter
    blocking?: BlockListRelationFilter
    followers?: FollowListRelationFilter
    following?: FollowListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    reactions?: ReactionListRelationFilter
    notifications?: NotificationListRelationFilter
    reportsSubmitted?: ReportListRelationFilter
    reportedContent?: ReportListRelationFilter
    moderatedCommunities?: CommunityProfileListRelationFilter
  }, "id" | "newsFeedTimelineId" | "personalFeedTimelineId" | "notificationFeedTimelineId">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    virtualProfileId?: SortOrder
    name?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    private?: SortOrderInput | SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    newsFeedTimelineId?: SortOrderInput | SortOrder
    personalFeedTimelineId?: SortOrderInput | SortOrder
    notificationFeedTimelineId?: SortOrderInput | SortOrder
    algoliaId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _avg?: UserProfileAvgOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
    _sum?: UserProfileSumOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProfile"> | string
    virtualProfileId?: StringWithAggregatesFilter<"UserProfile"> | string
    name?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    profileImageUrl?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    private?: BoolNullableWithAggregatesFilter<"UserProfile"> | boolean | null
    followersCount?: IntWithAggregatesFilter<"UserProfile"> | number
    followingCount?: IntWithAggregatesFilter<"UserProfile"> | number
    newsFeedTimelineId?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    personalFeedTimelineId?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    notificationFeedTimelineId?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    algoliaId?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"UserProfile">
    settings?: JsonNullableWithAggregatesFilter<"UserProfile">
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
  }

  export type CommunityProfileWhereInput = {
    AND?: CommunityProfileWhereInput | CommunityProfileWhereInput[]
    OR?: CommunityProfileWhereInput[]
    NOT?: CommunityProfileWhereInput | CommunityProfileWhereInput[]
    id?: StringFilter<"CommunityProfile"> | string
    virtualProfileId?: StringFilter<"CommunityProfile"> | string
    name?: StringNullableFilter<"CommunityProfile"> | string | null
    description?: StringNullableFilter<"CommunityProfile"> | string | null
    communityRules?: StringNullableFilter<"CommunityProfile"> | string | null
    profileImageUrl?: StringNullableFilter<"CommunityProfile"> | string | null
    private?: BoolNullableFilter<"CommunityProfile"> | boolean | null
    visible?: BoolNullableFilter<"CommunityProfile"> | boolean | null
    followers?: IntFilter<"CommunityProfile"> | number
    newsFeedTimelineId?: StringNullableFilter<"CommunityProfile"> | string | null
    personalFeedTimelineId?: StringNullableFilter<"CommunityProfile"> | string | null
    notificationFeedTimelineId?: StringNullableFilter<"CommunityProfile"> | string | null
    algoliaId?: StringNullableFilter<"CommunityProfile"> | string | null
    metadata?: JsonNullableFilter<"CommunityProfile">
    settings?: JsonNullableFilter<"CommunityProfile">
    createdAt?: DateTimeFilter<"CommunityProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityProfile"> | Date | string
    virtualProfile?: XOR<VirtualProfileRelationFilter, VirtualProfileWhereInput>
    topics?: TopicListRelationFilter
    posts?: PostListRelationFilter
    moderators?: UserProfileListRelationFilter
  }

  export type CommunityProfileOrderByWithRelationInput = {
    id?: SortOrder
    virtualProfileId?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    communityRules?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    private?: SortOrderInput | SortOrder
    visible?: SortOrderInput | SortOrder
    followers?: SortOrder
    newsFeedTimelineId?: SortOrderInput | SortOrder
    personalFeedTimelineId?: SortOrderInput | SortOrder
    notificationFeedTimelineId?: SortOrderInput | SortOrder
    algoliaId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    virtualProfile?: VirtualProfileOrderByWithRelationInput
    topics?: TopicOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    moderators?: UserProfileOrderByRelationAggregateInput
  }

  export type CommunityProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    newsFeedTimelineId?: string
    personalFeedTimelineId?: string
    notificationFeedTimelineId?: string
    AND?: CommunityProfileWhereInput | CommunityProfileWhereInput[]
    OR?: CommunityProfileWhereInput[]
    NOT?: CommunityProfileWhereInput | CommunityProfileWhereInput[]
    virtualProfileId?: StringFilter<"CommunityProfile"> | string
    name?: StringNullableFilter<"CommunityProfile"> | string | null
    description?: StringNullableFilter<"CommunityProfile"> | string | null
    communityRules?: StringNullableFilter<"CommunityProfile"> | string | null
    profileImageUrl?: StringNullableFilter<"CommunityProfile"> | string | null
    private?: BoolNullableFilter<"CommunityProfile"> | boolean | null
    visible?: BoolNullableFilter<"CommunityProfile"> | boolean | null
    followers?: IntFilter<"CommunityProfile"> | number
    algoliaId?: StringNullableFilter<"CommunityProfile"> | string | null
    metadata?: JsonNullableFilter<"CommunityProfile">
    settings?: JsonNullableFilter<"CommunityProfile">
    createdAt?: DateTimeFilter<"CommunityProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityProfile"> | Date | string
    virtualProfile?: XOR<VirtualProfileRelationFilter, VirtualProfileWhereInput>
    topics?: TopicListRelationFilter
    posts?: PostListRelationFilter
    moderators?: UserProfileListRelationFilter
  }, "id" | "newsFeedTimelineId" | "personalFeedTimelineId" | "notificationFeedTimelineId">

  export type CommunityProfileOrderByWithAggregationInput = {
    id?: SortOrder
    virtualProfileId?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    communityRules?: SortOrderInput | SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    private?: SortOrderInput | SortOrder
    visible?: SortOrderInput | SortOrder
    followers?: SortOrder
    newsFeedTimelineId?: SortOrderInput | SortOrder
    personalFeedTimelineId?: SortOrderInput | SortOrder
    notificationFeedTimelineId?: SortOrderInput | SortOrder
    algoliaId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommunityProfileCountOrderByAggregateInput
    _avg?: CommunityProfileAvgOrderByAggregateInput
    _max?: CommunityProfileMaxOrderByAggregateInput
    _min?: CommunityProfileMinOrderByAggregateInput
    _sum?: CommunityProfileSumOrderByAggregateInput
  }

  export type CommunityProfileScalarWhereWithAggregatesInput = {
    AND?: CommunityProfileScalarWhereWithAggregatesInput | CommunityProfileScalarWhereWithAggregatesInput[]
    OR?: CommunityProfileScalarWhereWithAggregatesInput[]
    NOT?: CommunityProfileScalarWhereWithAggregatesInput | CommunityProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommunityProfile"> | string
    virtualProfileId?: StringWithAggregatesFilter<"CommunityProfile"> | string
    name?: StringNullableWithAggregatesFilter<"CommunityProfile"> | string | null
    description?: StringNullableWithAggregatesFilter<"CommunityProfile"> | string | null
    communityRules?: StringNullableWithAggregatesFilter<"CommunityProfile"> | string | null
    profileImageUrl?: StringNullableWithAggregatesFilter<"CommunityProfile"> | string | null
    private?: BoolNullableWithAggregatesFilter<"CommunityProfile"> | boolean | null
    visible?: BoolNullableWithAggregatesFilter<"CommunityProfile"> | boolean | null
    followers?: IntWithAggregatesFilter<"CommunityProfile"> | number
    newsFeedTimelineId?: StringNullableWithAggregatesFilter<"CommunityProfile"> | string | null
    personalFeedTimelineId?: StringNullableWithAggregatesFilter<"CommunityProfile"> | string | null
    notificationFeedTimelineId?: StringNullableWithAggregatesFilter<"CommunityProfile"> | string | null
    algoliaId?: StringNullableWithAggregatesFilter<"CommunityProfile"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"CommunityProfile">
    settings?: JsonNullableWithAggregatesFilter<"CommunityProfile">
    createdAt?: DateTimeWithAggregatesFilter<"CommunityProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommunityProfile"> | Date | string
  }

  export type TopicWhereInput = {
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    id?: StringFilter<"Topic"> | string
    communityProfileId?: StringFilter<"Topic"> | string
    topicName?: StringNullableFilter<"Topic"> | string | null
    description?: StringNullableFilter<"Topic"> | string | null
    imageUrl?: StringNullableFilter<"Topic"> | string | null
    metadata?: JsonNullableFilter<"Topic">
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
    communityProfile?: XOR<CommunityProfileRelationFilter, CommunityProfileWhereInput>
  }

  export type TopicOrderByWithRelationInput = {
    id?: SortOrder
    communityProfileId?: SortOrder
    topicName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    communityProfile?: CommunityProfileOrderByWithRelationInput
  }

  export type TopicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    communityProfileId?: StringFilter<"Topic"> | string
    topicName?: StringNullableFilter<"Topic"> | string | null
    description?: StringNullableFilter<"Topic"> | string | null
    imageUrl?: StringNullableFilter<"Topic"> | string | null
    metadata?: JsonNullableFilter<"Topic">
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
    communityProfile?: XOR<CommunityProfileRelationFilter, CommunityProfileWhereInput>
  }, "id">

  export type TopicOrderByWithAggregationInput = {
    id?: SortOrder
    communityProfileId?: SortOrder
    topicName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TopicCountOrderByAggregateInput
    _max?: TopicMaxOrderByAggregateInput
    _min?: TopicMinOrderByAggregateInput
  }

  export type TopicScalarWhereWithAggregatesInput = {
    AND?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    OR?: TopicScalarWhereWithAggregatesInput[]
    NOT?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Topic"> | string
    communityProfileId?: StringWithAggregatesFilter<"Topic"> | string
    topicName?: StringNullableWithAggregatesFilter<"Topic"> | string | null
    description?: StringNullableWithAggregatesFilter<"Topic"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Topic"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Topic">
    createdAt?: DateTimeWithAggregatesFilter<"Topic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Topic"> | Date | string
  }

  export type PublicationWhereInput = {
    AND?: PublicationWhereInput | PublicationWhereInput[]
    OR?: PublicationWhereInput[]
    NOT?: PublicationWhereInput | PublicationWhereInput[]
    id?: StringFilter<"Publication"> | string
    publicationName?: StringNullableFilter<"Publication"> | string | null
    description?: StringNullableFilter<"Publication"> | string | null
    type?: StringNullableFilter<"Publication"> | string | null
    postIds?: StringNullableListFilter<"Publication">
    subjects?: StringNullableListFilter<"Publication">
    tags?: StringNullableListFilter<"Publication">
    adminBackendPlatformUserId?: StringNullableFilter<"Publication"> | string | null
    metadata?: JsonNullableFilter<"Publication">
    createdAt?: DateTimeFilter<"Publication"> | Date | string
    updatedAt?: DateTimeFilter<"Publication"> | Date | string
    bookmarks?: BookmarkListRelationFilter
    admins?: UserProfileListRelationFilter
    editors?: UserProfileListRelationFilter
    posts?: PostListRelationFilter
  }

  export type PublicationOrderByWithRelationInput = {
    id?: SortOrder
    publicationName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    postIds?: SortOrder
    subjects?: SortOrder
    tags?: SortOrder
    adminBackendPlatformUserId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookmarks?: BookmarkOrderByRelationAggregateInput
    admins?: UserProfileOrderByRelationAggregateInput
    editors?: UserProfileOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
  }

  export type PublicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PublicationWhereInput | PublicationWhereInput[]
    OR?: PublicationWhereInput[]
    NOT?: PublicationWhereInput | PublicationWhereInput[]
    publicationName?: StringNullableFilter<"Publication"> | string | null
    description?: StringNullableFilter<"Publication"> | string | null
    type?: StringNullableFilter<"Publication"> | string | null
    postIds?: StringNullableListFilter<"Publication">
    subjects?: StringNullableListFilter<"Publication">
    tags?: StringNullableListFilter<"Publication">
    adminBackendPlatformUserId?: StringNullableFilter<"Publication"> | string | null
    metadata?: JsonNullableFilter<"Publication">
    createdAt?: DateTimeFilter<"Publication"> | Date | string
    updatedAt?: DateTimeFilter<"Publication"> | Date | string
    bookmarks?: BookmarkListRelationFilter
    admins?: UserProfileListRelationFilter
    editors?: UserProfileListRelationFilter
    posts?: PostListRelationFilter
  }, "id">

  export type PublicationOrderByWithAggregationInput = {
    id?: SortOrder
    publicationName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    postIds?: SortOrder
    subjects?: SortOrder
    tags?: SortOrder
    adminBackendPlatformUserId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PublicationCountOrderByAggregateInput
    _max?: PublicationMaxOrderByAggregateInput
    _min?: PublicationMinOrderByAggregateInput
  }

  export type PublicationScalarWhereWithAggregatesInput = {
    AND?: PublicationScalarWhereWithAggregatesInput | PublicationScalarWhereWithAggregatesInput[]
    OR?: PublicationScalarWhereWithAggregatesInput[]
    NOT?: PublicationScalarWhereWithAggregatesInput | PublicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Publication"> | string
    publicationName?: StringNullableWithAggregatesFilter<"Publication"> | string | null
    description?: StringNullableWithAggregatesFilter<"Publication"> | string | null
    type?: StringNullableWithAggregatesFilter<"Publication"> | string | null
    postIds?: StringNullableListFilter<"Publication">
    subjects?: StringNullableListFilter<"Publication">
    tags?: StringNullableListFilter<"Publication">
    adminBackendPlatformUserId?: StringNullableWithAggregatesFilter<"Publication"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Publication">
    createdAt?: DateTimeWithAggregatesFilter<"Publication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Publication"> | Date | string
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    mediaType?: EnumMediaTypeFilter<"Media"> | $Enums.MediaType
    status?: StringFilter<"Media"> | string
    fileContent?: StringNullableFilter<"Media"> | string | null
    fileName?: StringFilter<"Media"> | string
    transcription?: StringNullableFilter<"Media"> | string | null
    extractedText?: StringNullableFilter<"Media"> | string | null
    createdAt?: DateTimeFilter<"Media"> | Date | string
    commentReplies?: CommentReplyListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    pollPosts?: PollPostListRelationFilter
    notes?: NoteListRelationFilter
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    mediaType?: SortOrder
    status?: SortOrder
    fileContent?: SortOrderInput | SortOrder
    fileName?: SortOrder
    transcription?: SortOrderInput | SortOrder
    extractedText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    commentReplies?: CommentReplyOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    pollPosts?: PollPostOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    mediaType?: EnumMediaTypeFilter<"Media"> | $Enums.MediaType
    status?: StringFilter<"Media"> | string
    fileContent?: StringNullableFilter<"Media"> | string | null
    fileName?: StringFilter<"Media"> | string
    transcription?: StringNullableFilter<"Media"> | string | null
    extractedText?: StringNullableFilter<"Media"> | string | null
    createdAt?: DateTimeFilter<"Media"> | Date | string
    commentReplies?: CommentReplyListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    pollPosts?: PollPostListRelationFilter
    notes?: NoteListRelationFilter
  }, "id">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    mediaType?: SortOrder
    status?: SortOrder
    fileContent?: SortOrderInput | SortOrder
    fileName?: SortOrder
    transcription?: SortOrderInput | SortOrder
    extractedText?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    mediaType?: EnumMediaTypeWithAggregatesFilter<"Media"> | $Enums.MediaType
    status?: StringWithAggregatesFilter<"Media"> | string
    fileContent?: StringNullableWithAggregatesFilter<"Media"> | string | null
    fileName?: StringWithAggregatesFilter<"Media"> | string
    transcription?: StringNullableWithAggregatesFilter<"Media"> | string | null
    extractedText?: StringNullableWithAggregatesFilter<"Media"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    authorId?: StringFilter<"Post"> | string
    communityId?: StringNullableFilter<"Post"> | string | null
    parentSpaceId?: StringNullableFilter<"Post"> | string | null
    title?: StringNullableFilter<"Post"> | string | null
    content?: StringFilter<"Post"> | string
    description?: StringNullableFilter<"Post"> | string | null
    status?: EnumPostStatusFilter<"Post"> | $Enums.PostStatus
    workflowStatus?: StringNullableFilter<"Post"> | string | null
    assignedTo?: StringNullableFilter<"Post"> | string | null
    contentFormat?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    postType?: EnumPostTypeFilter<"Post"> | $Enums.PostType
    category?: EnumCategoryNullableFilter<"Post"> | $Enums.Category | null
    threadParticipantType?: EnumThreadParticipantTypeNullableFilter<"Post"> | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFilter<"Post"> | string
    profileId?: IntFilter<"Post"> | number
    authorUsername?: StringFilter<"Post"> | string
    authorProfileImage?: StringNullableFilter<"Post"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Post"> | $Enums.AccountType
    tags?: StringNullableListFilter<"Post">
    mentions?: StringNullableListFilter<"Post">
    hashtags?: StringNullableListFilter<"Post">
    topicName?: StringNullableFilter<"Post"> | string | null
    mediaId?: StringNullableFilter<"Post"> | string | null
    backgroundImageUrl?: StringNullableFilter<"Post"> | string | null
    affinityScore?: IntFilter<"Post"> | number
    qualityScore?: IntFilter<"Post"> | number
    viewCount?: IntFilter<"Post"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"Post">
    userIdToReportsMap?: JsonNullableFilter<"Post">
    userIdToReactionMap?: JsonNullableFilter<"Post">
    insights?: JsonNullableFilter<"Post">
    readingTime?: StringNullableFilter<"Post"> | string | null
    aiGeneratedQuestionResponse?: StringNullableFilter<"Post"> | string | null
    aiAnalysis?: JsonNullableFilter<"Post">
    searchMetadata?: JsonNullableFilter<"Post">
    metadata?: JsonNullableFilter<"Post">
    threadId?: StringNullableFilter<"Post"> | string | null
    spaceId?: StringNullableFilter<"Post"> | string | null
    channelId?: StringNullableFilter<"Post"> | string | null
    extra?: JsonNullableFilter<"Post">
    visibility?: EnumVisibilityFilter<"Post"> | $Enums.Visibility
    isPinned?: BoolFilter<"Post"> | boolean
    isArchived?: BoolFilter<"Post"> | boolean
    workflow?: JsonNullableFilter<"Post">
    version?: IntFilter<"Post"> | number
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    files?: FileListRelationFilter
    author?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    community?: XOR<CommunityProfileNullableRelationFilter, CommunityProfileWhereInput> | null
    comments?: CommentListRelationFilter
    reactions?: ReactionListRelationFilter
    bookmarks?: BookmarkListRelationFilter
    publications?: PublicationListRelationFilter
    reports?: ReportListRelationFilter
    notes?: NoteListRelationFilter
    thread?: XOR<ThreadNullableRelationFilter, ThreadWhereInput> | null
    space?: XOR<SpaceNullableRelationFilter, SpaceWhereInput> | null
    channel?: XOR<ChannelNullableRelationFilter, ChannelWhereInput> | null
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    communityId?: SortOrderInput | SortOrder
    parentSpaceId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    workflowStatus?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    contentFormat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    postType?: SortOrder
    category?: SortOrderInput | SortOrder
    threadParticipantType?: SortOrderInput | SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrderInput | SortOrder
    authorAccountType?: SortOrder
    tags?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    topicName?: SortOrderInput | SortOrder
    mediaId?: SortOrderInput | SortOrder
    backgroundImageUrl?: SortOrderInput | SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    userIdToAffinityScoreMap?: SortOrderInput | SortOrder
    userIdToReportsMap?: SortOrderInput | SortOrder
    userIdToReactionMap?: SortOrderInput | SortOrder
    insights?: SortOrderInput | SortOrder
    readingTime?: SortOrderInput | SortOrder
    aiGeneratedQuestionResponse?: SortOrderInput | SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    searchMetadata?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    threadId?: SortOrderInput | SortOrder
    spaceId?: SortOrderInput | SortOrder
    channelId?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    visibility?: SortOrder
    isPinned?: SortOrder
    isArchived?: SortOrder
    workflow?: SortOrderInput | SortOrder
    version?: SortOrder
    media?: MediaOrderByWithRelationInput
    files?: FileOrderByRelationAggregateInput
    author?: UserProfileOrderByWithRelationInput
    community?: CommunityProfileOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    reactions?: ReactionOrderByRelationAggregateInput
    bookmarks?: BookmarkOrderByRelationAggregateInput
    publications?: PublicationOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    thread?: ThreadOrderByWithRelationInput
    space?: SpaceOrderByWithRelationInput
    channel?: ChannelOrderByWithRelationInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    authorId?: StringFilter<"Post"> | string
    communityId?: StringNullableFilter<"Post"> | string | null
    parentSpaceId?: StringNullableFilter<"Post"> | string | null
    title?: StringNullableFilter<"Post"> | string | null
    content?: StringFilter<"Post"> | string
    description?: StringNullableFilter<"Post"> | string | null
    status?: EnumPostStatusFilter<"Post"> | $Enums.PostStatus
    workflowStatus?: StringNullableFilter<"Post"> | string | null
    assignedTo?: StringNullableFilter<"Post"> | string | null
    contentFormat?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    postType?: EnumPostTypeFilter<"Post"> | $Enums.PostType
    category?: EnumCategoryNullableFilter<"Post"> | $Enums.Category | null
    threadParticipantType?: EnumThreadParticipantTypeNullableFilter<"Post"> | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFilter<"Post"> | string
    profileId?: IntFilter<"Post"> | number
    authorUsername?: StringFilter<"Post"> | string
    authorProfileImage?: StringNullableFilter<"Post"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Post"> | $Enums.AccountType
    tags?: StringNullableListFilter<"Post">
    mentions?: StringNullableListFilter<"Post">
    hashtags?: StringNullableListFilter<"Post">
    topicName?: StringNullableFilter<"Post"> | string | null
    mediaId?: StringNullableFilter<"Post"> | string | null
    backgroundImageUrl?: StringNullableFilter<"Post"> | string | null
    affinityScore?: IntFilter<"Post"> | number
    qualityScore?: IntFilter<"Post"> | number
    viewCount?: IntFilter<"Post"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"Post">
    userIdToReportsMap?: JsonNullableFilter<"Post">
    userIdToReactionMap?: JsonNullableFilter<"Post">
    insights?: JsonNullableFilter<"Post">
    readingTime?: StringNullableFilter<"Post"> | string | null
    aiGeneratedQuestionResponse?: StringNullableFilter<"Post"> | string | null
    aiAnalysis?: JsonNullableFilter<"Post">
    searchMetadata?: JsonNullableFilter<"Post">
    metadata?: JsonNullableFilter<"Post">
    threadId?: StringNullableFilter<"Post"> | string | null
    spaceId?: StringNullableFilter<"Post"> | string | null
    channelId?: StringNullableFilter<"Post"> | string | null
    extra?: JsonNullableFilter<"Post">
    visibility?: EnumVisibilityFilter<"Post"> | $Enums.Visibility
    isPinned?: BoolFilter<"Post"> | boolean
    isArchived?: BoolFilter<"Post"> | boolean
    workflow?: JsonNullableFilter<"Post">
    version?: IntFilter<"Post"> | number
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    files?: FileListRelationFilter
    author?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    community?: XOR<CommunityProfileNullableRelationFilter, CommunityProfileWhereInput> | null
    comments?: CommentListRelationFilter
    reactions?: ReactionListRelationFilter
    bookmarks?: BookmarkListRelationFilter
    publications?: PublicationListRelationFilter
    reports?: ReportListRelationFilter
    notes?: NoteListRelationFilter
    thread?: XOR<ThreadNullableRelationFilter, ThreadWhereInput> | null
    space?: XOR<SpaceNullableRelationFilter, SpaceWhereInput> | null
    channel?: XOR<ChannelNullableRelationFilter, ChannelWhereInput> | null
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    communityId?: SortOrderInput | SortOrder
    parentSpaceId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    workflowStatus?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    contentFormat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    postType?: SortOrder
    category?: SortOrderInput | SortOrder
    threadParticipantType?: SortOrderInput | SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrderInput | SortOrder
    authorAccountType?: SortOrder
    tags?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    topicName?: SortOrderInput | SortOrder
    mediaId?: SortOrderInput | SortOrder
    backgroundImageUrl?: SortOrderInput | SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    userIdToAffinityScoreMap?: SortOrderInput | SortOrder
    userIdToReportsMap?: SortOrderInput | SortOrder
    userIdToReactionMap?: SortOrderInput | SortOrder
    insights?: SortOrderInput | SortOrder
    readingTime?: SortOrderInput | SortOrder
    aiGeneratedQuestionResponse?: SortOrderInput | SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    searchMetadata?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    threadId?: SortOrderInput | SortOrder
    spaceId?: SortOrderInput | SortOrder
    channelId?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    visibility?: SortOrder
    isPinned?: SortOrder
    isArchived?: SortOrder
    workflow?: SortOrderInput | SortOrder
    version?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    authorId?: StringWithAggregatesFilter<"Post"> | string
    communityId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    parentSpaceId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    title?: StringNullableWithAggregatesFilter<"Post"> | string | null
    content?: StringWithAggregatesFilter<"Post"> | string
    description?: StringNullableWithAggregatesFilter<"Post"> | string | null
    status?: EnumPostStatusWithAggregatesFilter<"Post"> | $Enums.PostStatus
    workflowStatus?: StringNullableWithAggregatesFilter<"Post"> | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"Post"> | string | null
    contentFormat?: StringWithAggregatesFilter<"Post"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Post"> | Date | string | null
    postType?: EnumPostTypeWithAggregatesFilter<"Post"> | $Enums.PostType
    category?: EnumCategoryNullableWithAggregatesFilter<"Post"> | $Enums.Category | null
    threadParticipantType?: EnumThreadParticipantTypeNullableWithAggregatesFilter<"Post"> | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringWithAggregatesFilter<"Post"> | string
    profileId?: IntWithAggregatesFilter<"Post"> | number
    authorUsername?: StringWithAggregatesFilter<"Post"> | string
    authorProfileImage?: StringNullableWithAggregatesFilter<"Post"> | string | null
    authorAccountType?: EnumAccountTypeWithAggregatesFilter<"Post"> | $Enums.AccountType
    tags?: StringNullableListFilter<"Post">
    mentions?: StringNullableListFilter<"Post">
    hashtags?: StringNullableListFilter<"Post">
    topicName?: StringNullableWithAggregatesFilter<"Post"> | string | null
    mediaId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    backgroundImageUrl?: StringNullableWithAggregatesFilter<"Post"> | string | null
    affinityScore?: IntWithAggregatesFilter<"Post"> | number
    qualityScore?: IntWithAggregatesFilter<"Post"> | number
    viewCount?: IntWithAggregatesFilter<"Post"> | number
    userIdToAffinityScoreMap?: JsonNullableWithAggregatesFilter<"Post">
    userIdToReportsMap?: JsonNullableWithAggregatesFilter<"Post">
    userIdToReactionMap?: JsonNullableWithAggregatesFilter<"Post">
    insights?: JsonNullableWithAggregatesFilter<"Post">
    readingTime?: StringNullableWithAggregatesFilter<"Post"> | string | null
    aiGeneratedQuestionResponse?: StringNullableWithAggregatesFilter<"Post"> | string | null
    aiAnalysis?: JsonNullableWithAggregatesFilter<"Post">
    searchMetadata?: JsonNullableWithAggregatesFilter<"Post">
    metadata?: JsonNullableWithAggregatesFilter<"Post">
    threadId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    spaceId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    channelId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    extra?: JsonNullableWithAggregatesFilter<"Post">
    visibility?: EnumVisibilityWithAggregatesFilter<"Post"> | $Enums.Visibility
    isPinned?: BoolWithAggregatesFilter<"Post"> | boolean
    isArchived?: BoolWithAggregatesFilter<"Post"> | boolean
    workflow?: JsonNullableWithAggregatesFilter<"Post">
    version?: IntWithAggregatesFilter<"Post"> | number
  }

  export type PollPostWhereInput = {
    AND?: PollPostWhereInput | PollPostWhereInput[]
    OR?: PollPostWhereInput[]
    NOT?: PollPostWhereInput | PollPostWhereInput[]
    id?: StringFilter<"PollPost"> | string
    createdAt?: DateTimeFilter<"PollPost"> | Date | string
    action?: EnumPostTypeFilter<"PollPost"> | $Enums.PostType
    content?: StringFilter<"PollPost"> | string
    title?: StringNullableFilter<"PollPost"> | string | null
    pollOptions?: StringNullableListFilter<"PollPost">
    pollDistribution?: JsonNullableFilter<"PollPost">
    userIdToPollResponsesMap?: JsonNullableFilter<"PollPost">
    pollEndDate?: DateTimeFilter<"PollPost"> | Date | string
    mentions?: StringNullableListFilter<"PollPost">
    hashtags?: StringNullableListFilter<"PollPost">
    tags?: StringNullableListFilter<"PollPost">
    topicName?: StringNullableFilter<"PollPost"> | string | null
    backendPlatformUserId?: StringFilter<"PollPost"> | string
    profileId?: IntFilter<"PollPost"> | number
    mediaId?: StringNullableFilter<"PollPost"> | string | null
    threadId?: StringNullableFilter<"PollPost"> | string | null
    extra?: JsonNullableFilter<"PollPost">
    searchMetadata?: JsonNullableFilter<"PollPost">
    aiAnalysis?: JsonNullableFilter<"PollPost">
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    comments?: CommentListRelationFilter
    thread?: XOR<ThreadNullableRelationFilter, ThreadWhereInput> | null
  }

  export type PollPostOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    content?: SortOrder
    title?: SortOrderInput | SortOrder
    pollOptions?: SortOrder
    pollDistribution?: SortOrderInput | SortOrder
    userIdToPollResponsesMap?: SortOrderInput | SortOrder
    pollEndDate?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    tags?: SortOrder
    topicName?: SortOrderInput | SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    mediaId?: SortOrderInput | SortOrder
    threadId?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    searchMetadata?: SortOrderInput | SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    media?: MediaOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    thread?: ThreadOrderByWithRelationInput
  }

  export type PollPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PollPostWhereInput | PollPostWhereInput[]
    OR?: PollPostWhereInput[]
    NOT?: PollPostWhereInput | PollPostWhereInput[]
    createdAt?: DateTimeFilter<"PollPost"> | Date | string
    action?: EnumPostTypeFilter<"PollPost"> | $Enums.PostType
    content?: StringFilter<"PollPost"> | string
    title?: StringNullableFilter<"PollPost"> | string | null
    pollOptions?: StringNullableListFilter<"PollPost">
    pollDistribution?: JsonNullableFilter<"PollPost">
    userIdToPollResponsesMap?: JsonNullableFilter<"PollPost">
    pollEndDate?: DateTimeFilter<"PollPost"> | Date | string
    mentions?: StringNullableListFilter<"PollPost">
    hashtags?: StringNullableListFilter<"PollPost">
    tags?: StringNullableListFilter<"PollPost">
    topicName?: StringNullableFilter<"PollPost"> | string | null
    backendPlatformUserId?: StringFilter<"PollPost"> | string
    profileId?: IntFilter<"PollPost"> | number
    mediaId?: StringNullableFilter<"PollPost"> | string | null
    threadId?: StringNullableFilter<"PollPost"> | string | null
    extra?: JsonNullableFilter<"PollPost">
    searchMetadata?: JsonNullableFilter<"PollPost">
    aiAnalysis?: JsonNullableFilter<"PollPost">
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    comments?: CommentListRelationFilter
    thread?: XOR<ThreadNullableRelationFilter, ThreadWhereInput> | null
  }, "id">

  export type PollPostOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    content?: SortOrder
    title?: SortOrderInput | SortOrder
    pollOptions?: SortOrder
    pollDistribution?: SortOrderInput | SortOrder
    userIdToPollResponsesMap?: SortOrderInput | SortOrder
    pollEndDate?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    tags?: SortOrder
    topicName?: SortOrderInput | SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    mediaId?: SortOrderInput | SortOrder
    threadId?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    searchMetadata?: SortOrderInput | SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    _count?: PollPostCountOrderByAggregateInput
    _avg?: PollPostAvgOrderByAggregateInput
    _max?: PollPostMaxOrderByAggregateInput
    _min?: PollPostMinOrderByAggregateInput
    _sum?: PollPostSumOrderByAggregateInput
  }

  export type PollPostScalarWhereWithAggregatesInput = {
    AND?: PollPostScalarWhereWithAggregatesInput | PollPostScalarWhereWithAggregatesInput[]
    OR?: PollPostScalarWhereWithAggregatesInput[]
    NOT?: PollPostScalarWhereWithAggregatesInput | PollPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PollPost"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PollPost"> | Date | string
    action?: EnumPostTypeWithAggregatesFilter<"PollPost"> | $Enums.PostType
    content?: StringWithAggregatesFilter<"PollPost"> | string
    title?: StringNullableWithAggregatesFilter<"PollPost"> | string | null
    pollOptions?: StringNullableListFilter<"PollPost">
    pollDistribution?: JsonNullableWithAggregatesFilter<"PollPost">
    userIdToPollResponsesMap?: JsonNullableWithAggregatesFilter<"PollPost">
    pollEndDate?: DateTimeWithAggregatesFilter<"PollPost"> | Date | string
    mentions?: StringNullableListFilter<"PollPost">
    hashtags?: StringNullableListFilter<"PollPost">
    tags?: StringNullableListFilter<"PollPost">
    topicName?: StringNullableWithAggregatesFilter<"PollPost"> | string | null
    backendPlatformUserId?: StringWithAggregatesFilter<"PollPost"> | string
    profileId?: IntWithAggregatesFilter<"PollPost"> | number
    mediaId?: StringNullableWithAggregatesFilter<"PollPost"> | string | null
    threadId?: StringNullableWithAggregatesFilter<"PollPost"> | string | null
    extra?: JsonNullableWithAggregatesFilter<"PollPost">
    searchMetadata?: JsonNullableWithAggregatesFilter<"PollPost">
    aiAnalysis?: JsonNullableWithAggregatesFilter<"PollPost">
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    backendPlatformUserId?: StringFilter<"Comment"> | string
    profileId?: IntFilter<"Comment"> | number
    authorUsername?: StringFilter<"Comment"> | string
    authorProfileImage?: StringNullableFilter<"Comment"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Comment"> | $Enums.AccountType
    affinityScore?: IntFilter<"Comment"> | number
    qualityScore?: IntFilter<"Comment"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"Comment">
    userIdToReportsMap?: JsonNullableFilter<"Comment">
    userIdToReactionMap?: JsonNullableFilter<"Comment">
    mentions?: StringNullableListFilter<"Comment">
    hashtags?: StringNullableListFilter<"Comment">
    mediaId?: StringNullableFilter<"Comment"> | string | null
    postId?: StringFilter<"Comment"> | string
    pollPostId?: StringNullableFilter<"Comment"> | string | null
    extra?: JsonNullableFilter<"Comment">
    aiAnalysis?: JsonNullableFilter<"Comment">
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    replies?: CommentReplyListRelationFilter
    notes?: NoteListRelationFilter
    post?: XOR<PostRelationFilter, PostWhereInput>
    pollPost?: XOR<PollPostNullableRelationFilter, PollPostWhereInput> | null
    Report?: ReportListRelationFilter
    Reaction?: ReactionListRelationFilter
    UserProfile?: UserProfileListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrderInput | SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    userIdToAffinityScoreMap?: SortOrderInput | SortOrder
    userIdToReportsMap?: SortOrderInput | SortOrder
    userIdToReactionMap?: SortOrderInput | SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    mediaId?: SortOrderInput | SortOrder
    postId?: SortOrder
    pollPostId?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    media?: MediaOrderByWithRelationInput
    replies?: CommentReplyOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    post?: PostOrderByWithRelationInput
    pollPost?: PollPostOrderByWithRelationInput
    Report?: ReportOrderByRelationAggregateInput
    Reaction?: ReactionOrderByRelationAggregateInput
    UserProfile?: UserProfileOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    backendPlatformUserId?: StringFilter<"Comment"> | string
    profileId?: IntFilter<"Comment"> | number
    authorUsername?: StringFilter<"Comment"> | string
    authorProfileImage?: StringNullableFilter<"Comment"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Comment"> | $Enums.AccountType
    affinityScore?: IntFilter<"Comment"> | number
    qualityScore?: IntFilter<"Comment"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"Comment">
    userIdToReportsMap?: JsonNullableFilter<"Comment">
    userIdToReactionMap?: JsonNullableFilter<"Comment">
    mentions?: StringNullableListFilter<"Comment">
    hashtags?: StringNullableListFilter<"Comment">
    mediaId?: StringNullableFilter<"Comment"> | string | null
    postId?: StringFilter<"Comment"> | string
    pollPostId?: StringNullableFilter<"Comment"> | string | null
    extra?: JsonNullableFilter<"Comment">
    aiAnalysis?: JsonNullableFilter<"Comment">
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    replies?: CommentReplyListRelationFilter
    notes?: NoteListRelationFilter
    post?: XOR<PostRelationFilter, PostWhereInput>
    pollPost?: XOR<PollPostNullableRelationFilter, PollPostWhereInput> | null
    Report?: ReportListRelationFilter
    Reaction?: ReactionListRelationFilter
    UserProfile?: UserProfileListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrderInput | SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    userIdToAffinityScoreMap?: SortOrderInput | SortOrder
    userIdToReportsMap?: SortOrderInput | SortOrder
    userIdToReactionMap?: SortOrderInput | SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    mediaId?: SortOrderInput | SortOrder
    postId?: SortOrder
    pollPostId?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    backendPlatformUserId?: StringWithAggregatesFilter<"Comment"> | string
    profileId?: IntWithAggregatesFilter<"Comment"> | number
    authorUsername?: StringWithAggregatesFilter<"Comment"> | string
    authorProfileImage?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    authorAccountType?: EnumAccountTypeWithAggregatesFilter<"Comment"> | $Enums.AccountType
    affinityScore?: IntWithAggregatesFilter<"Comment"> | number
    qualityScore?: IntWithAggregatesFilter<"Comment"> | number
    userIdToAffinityScoreMap?: JsonNullableWithAggregatesFilter<"Comment">
    userIdToReportsMap?: JsonNullableWithAggregatesFilter<"Comment">
    userIdToReactionMap?: JsonNullableWithAggregatesFilter<"Comment">
    mentions?: StringNullableListFilter<"Comment">
    hashtags?: StringNullableListFilter<"Comment">
    mediaId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    postId?: StringWithAggregatesFilter<"Comment"> | string
    pollPostId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    extra?: JsonNullableWithAggregatesFilter<"Comment">
    aiAnalysis?: JsonNullableWithAggregatesFilter<"Comment">
  }

  export type CommentReplyWhereInput = {
    AND?: CommentReplyWhereInput | CommentReplyWhereInput[]
    OR?: CommentReplyWhereInput[]
    NOT?: CommentReplyWhereInput | CommentReplyWhereInput[]
    id?: StringFilter<"CommentReply"> | string
    content?: StringFilter<"CommentReply"> | string
    createdAt?: DateTimeFilter<"CommentReply"> | Date | string
    backendPlatformUserId?: StringFilter<"CommentReply"> | string
    profileId?: IntFilter<"CommentReply"> | number
    authorUsername?: StringFilter<"CommentReply"> | string
    authorProfileImage?: StringNullableFilter<"CommentReply"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"CommentReply"> | $Enums.AccountType
    affinityScore?: IntFilter<"CommentReply"> | number
    qualityScore?: IntFilter<"CommentReply"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"CommentReply">
    userIdToReportsMap?: JsonNullableFilter<"CommentReply">
    userIdToReactionMap?: JsonNullableFilter<"CommentReply">
    mentions?: StringNullableListFilter<"CommentReply">
    hashtags?: StringNullableListFilter<"CommentReply">
    mediaId?: StringNullableFilter<"CommentReply"> | string | null
    commentId?: StringFilter<"CommentReply"> | string
    extra?: JsonNullableFilter<"CommentReply">
    aiAnalysis?: JsonNullableFilter<"CommentReply">
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    comment?: XOR<CommentRelationFilter, CommentWhereInput>
  }

  export type CommentReplyOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrderInput | SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    userIdToAffinityScoreMap?: SortOrderInput | SortOrder
    userIdToReportsMap?: SortOrderInput | SortOrder
    userIdToReactionMap?: SortOrderInput | SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    mediaId?: SortOrderInput | SortOrder
    commentId?: SortOrder
    extra?: SortOrderInput | SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    media?: MediaOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
  }

  export type CommentReplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentReplyWhereInput | CommentReplyWhereInput[]
    OR?: CommentReplyWhereInput[]
    NOT?: CommentReplyWhereInput | CommentReplyWhereInput[]
    content?: StringFilter<"CommentReply"> | string
    createdAt?: DateTimeFilter<"CommentReply"> | Date | string
    backendPlatformUserId?: StringFilter<"CommentReply"> | string
    profileId?: IntFilter<"CommentReply"> | number
    authorUsername?: StringFilter<"CommentReply"> | string
    authorProfileImage?: StringNullableFilter<"CommentReply"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"CommentReply"> | $Enums.AccountType
    affinityScore?: IntFilter<"CommentReply"> | number
    qualityScore?: IntFilter<"CommentReply"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"CommentReply">
    userIdToReportsMap?: JsonNullableFilter<"CommentReply">
    userIdToReactionMap?: JsonNullableFilter<"CommentReply">
    mentions?: StringNullableListFilter<"CommentReply">
    hashtags?: StringNullableListFilter<"CommentReply">
    mediaId?: StringNullableFilter<"CommentReply"> | string | null
    commentId?: StringFilter<"CommentReply"> | string
    extra?: JsonNullableFilter<"CommentReply">
    aiAnalysis?: JsonNullableFilter<"CommentReply">
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    comment?: XOR<CommentRelationFilter, CommentWhereInput>
  }, "id">

  export type CommentReplyOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrderInput | SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    userIdToAffinityScoreMap?: SortOrderInput | SortOrder
    userIdToReportsMap?: SortOrderInput | SortOrder
    userIdToReactionMap?: SortOrderInput | SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    mediaId?: SortOrderInput | SortOrder
    commentId?: SortOrder
    extra?: SortOrderInput | SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    _count?: CommentReplyCountOrderByAggregateInput
    _avg?: CommentReplyAvgOrderByAggregateInput
    _max?: CommentReplyMaxOrderByAggregateInput
    _min?: CommentReplyMinOrderByAggregateInput
    _sum?: CommentReplySumOrderByAggregateInput
  }

  export type CommentReplyScalarWhereWithAggregatesInput = {
    AND?: CommentReplyScalarWhereWithAggregatesInput | CommentReplyScalarWhereWithAggregatesInput[]
    OR?: CommentReplyScalarWhereWithAggregatesInput[]
    NOT?: CommentReplyScalarWhereWithAggregatesInput | CommentReplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommentReply"> | string
    content?: StringWithAggregatesFilter<"CommentReply"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CommentReply"> | Date | string
    backendPlatformUserId?: StringWithAggregatesFilter<"CommentReply"> | string
    profileId?: IntWithAggregatesFilter<"CommentReply"> | number
    authorUsername?: StringWithAggregatesFilter<"CommentReply"> | string
    authorProfileImage?: StringNullableWithAggregatesFilter<"CommentReply"> | string | null
    authorAccountType?: EnumAccountTypeWithAggregatesFilter<"CommentReply"> | $Enums.AccountType
    affinityScore?: IntWithAggregatesFilter<"CommentReply"> | number
    qualityScore?: IntWithAggregatesFilter<"CommentReply"> | number
    userIdToAffinityScoreMap?: JsonNullableWithAggregatesFilter<"CommentReply">
    userIdToReportsMap?: JsonNullableWithAggregatesFilter<"CommentReply">
    userIdToReactionMap?: JsonNullableWithAggregatesFilter<"CommentReply">
    mentions?: StringNullableListFilter<"CommentReply">
    hashtags?: StringNullableListFilter<"CommentReply">
    mediaId?: StringNullableWithAggregatesFilter<"CommentReply"> | string | null
    commentId?: StringWithAggregatesFilter<"CommentReply"> | string
    extra?: JsonNullableWithAggregatesFilter<"CommentReply">
    aiAnalysis?: JsonNullableWithAggregatesFilter<"CommentReply">
  }

  export type ReactionWhereInput = {
    AND?: ReactionWhereInput | ReactionWhereInput[]
    OR?: ReactionWhereInput[]
    NOT?: ReactionWhereInput | ReactionWhereInput[]
    id?: StringFilter<"Reaction"> | string
    userId?: StringFilter<"Reaction"> | string
    postId?: StringNullableFilter<"Reaction"> | string | null
    commentId?: StringNullableFilter<"Reaction"> | string | null
    type?: EnumReactionTypeFilter<"Reaction"> | $Enums.ReactionType
    metadata?: JsonNullableFilter<"Reaction">
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
    user?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    post?: XOR<PostNullableRelationFilter, PostWhereInput> | null
    comment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
  }

  export type ReactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    type?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserProfileOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
  }

  export type ReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_postId_commentId_type?: ReactionUserIdPostIdCommentIdTypeCompoundUniqueInput
    AND?: ReactionWhereInput | ReactionWhereInput[]
    OR?: ReactionWhereInput[]
    NOT?: ReactionWhereInput | ReactionWhereInput[]
    userId?: StringFilter<"Reaction"> | string
    postId?: StringNullableFilter<"Reaction"> | string | null
    commentId?: StringNullableFilter<"Reaction"> | string | null
    type?: EnumReactionTypeFilter<"Reaction"> | $Enums.ReactionType
    metadata?: JsonNullableFilter<"Reaction">
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
    user?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    post?: XOR<PostNullableRelationFilter, PostWhereInput> | null
    comment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
  }, "id" | "userId_postId_commentId_type">

  export type ReactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    type?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReactionCountOrderByAggregateInput
    _max?: ReactionMaxOrderByAggregateInput
    _min?: ReactionMinOrderByAggregateInput
  }

  export type ReactionScalarWhereWithAggregatesInput = {
    AND?: ReactionScalarWhereWithAggregatesInput | ReactionScalarWhereWithAggregatesInput[]
    OR?: ReactionScalarWhereWithAggregatesInput[]
    NOT?: ReactionScalarWhereWithAggregatesInput | ReactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reaction"> | string
    userId?: StringWithAggregatesFilter<"Reaction"> | string
    postId?: StringNullableWithAggregatesFilter<"Reaction"> | string | null
    commentId?: StringNullableWithAggregatesFilter<"Reaction"> | string | null
    type?: EnumReactionTypeWithAggregatesFilter<"Reaction"> | $Enums.ReactionType
    metadata?: JsonNullableWithAggregatesFilter<"Reaction">
    createdAt?: DateTimeWithAggregatesFilter<"Reaction"> | Date | string
  }

  export type BookmarkWhereInput = {
    AND?: BookmarkWhereInput | BookmarkWhereInput[]
    OR?: BookmarkWhereInput[]
    NOT?: BookmarkWhereInput | BookmarkWhereInput[]
    id?: StringFilter<"Bookmark"> | string
    postIds?: StringNullableListFilter<"Bookmark">
    metadata?: JsonNullableFilter<"Bookmark">
    createdAt?: DateTimeFilter<"Bookmark"> | Date | string
    updatedAt?: DateTimeFilter<"Bookmark"> | Date | string
    publications?: PublicationListRelationFilter
    users?: UserProfileListRelationFilter
    posts?: PostListRelationFilter
  }

  export type BookmarkOrderByWithRelationInput = {
    id?: SortOrder
    postIds?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publications?: PublicationOrderByRelationAggregateInput
    users?: UserProfileOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
  }

  export type BookmarkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookmarkWhereInput | BookmarkWhereInput[]
    OR?: BookmarkWhereInput[]
    NOT?: BookmarkWhereInput | BookmarkWhereInput[]
    postIds?: StringNullableListFilter<"Bookmark">
    metadata?: JsonNullableFilter<"Bookmark">
    createdAt?: DateTimeFilter<"Bookmark"> | Date | string
    updatedAt?: DateTimeFilter<"Bookmark"> | Date | string
    publications?: PublicationListRelationFilter
    users?: UserProfileListRelationFilter
    posts?: PostListRelationFilter
  }, "id">

  export type BookmarkOrderByWithAggregationInput = {
    id?: SortOrder
    postIds?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookmarkCountOrderByAggregateInput
    _max?: BookmarkMaxOrderByAggregateInput
    _min?: BookmarkMinOrderByAggregateInput
  }

  export type BookmarkScalarWhereWithAggregatesInput = {
    AND?: BookmarkScalarWhereWithAggregatesInput | BookmarkScalarWhereWithAggregatesInput[]
    OR?: BookmarkScalarWhereWithAggregatesInput[]
    NOT?: BookmarkScalarWhereWithAggregatesInput | BookmarkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bookmark"> | string
    postIds?: StringNullableListFilter<"Bookmark">
    metadata?: JsonNullableWithAggregatesFilter<"Bookmark">
    createdAt?: DateTimeWithAggregatesFilter<"Bookmark"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bookmark"> | Date | string
  }

  export type BlockWhereInput = {
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    id?: StringFilter<"Block"> | string
    profileBlockingId?: StringFilter<"Block"> | string
    profileBlockedId?: StringFilter<"Block"> | string
    profileBlockingType?: StringFilter<"Block"> | string
    profileBlockedType?: StringFilter<"Block"> | string
    reason?: StringNullableFilter<"Block"> | string | null
    metadata?: JsonNullableFilter<"Block">
    createdAt?: DateTimeFilter<"Block"> | Date | string
    blockingProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    blockedProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }

  export type BlockOrderByWithRelationInput = {
    id?: SortOrder
    profileBlockingId?: SortOrder
    profileBlockedId?: SortOrder
    profileBlockingType?: SortOrder
    profileBlockedType?: SortOrder
    reason?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    blockingProfile?: UserProfileOrderByWithRelationInput
    blockedProfile?: UserProfileOrderByWithRelationInput
  }

  export type BlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileBlockingId_profileBlockedId?: BlockProfileBlockingIdProfileBlockedIdCompoundUniqueInput
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    profileBlockingId?: StringFilter<"Block"> | string
    profileBlockedId?: StringFilter<"Block"> | string
    profileBlockingType?: StringFilter<"Block"> | string
    profileBlockedType?: StringFilter<"Block"> | string
    reason?: StringNullableFilter<"Block"> | string | null
    metadata?: JsonNullableFilter<"Block">
    createdAt?: DateTimeFilter<"Block"> | Date | string
    blockingProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    blockedProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }, "id" | "profileBlockingId_profileBlockedId">

  export type BlockOrderByWithAggregationInput = {
    id?: SortOrder
    profileBlockingId?: SortOrder
    profileBlockedId?: SortOrder
    profileBlockingType?: SortOrder
    profileBlockedType?: SortOrder
    reason?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BlockCountOrderByAggregateInput
    _max?: BlockMaxOrderByAggregateInput
    _min?: BlockMinOrderByAggregateInput
  }

  export type BlockScalarWhereWithAggregatesInput = {
    AND?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    OR?: BlockScalarWhereWithAggregatesInput[]
    NOT?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Block"> | string
    profileBlockingId?: StringWithAggregatesFilter<"Block"> | string
    profileBlockedId?: StringWithAggregatesFilter<"Block"> | string
    profileBlockingType?: StringWithAggregatesFilter<"Block"> | string
    profileBlockedType?: StringWithAggregatesFilter<"Block"> | string
    reason?: StringNullableWithAggregatesFilter<"Block"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Block">
    createdAt?: DateTimeWithAggregatesFilter<"Block"> | Date | string
  }

  export type FollowWhereInput = {
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    id?: StringFilter<"Follow"> | string
    profileFollowingId?: StringFilter<"Follow"> | string
    profileFollowedId?: StringFilter<"Follow"> | string
    targetFollowerType?: StringFilter<"Follow"> | string
    requestApproved?: BoolFilter<"Follow"> | boolean
    metadata?: JsonNullableFilter<"Follow">
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Follow"> | Date | string | null
    followingProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    followedProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }

  export type FollowOrderByWithRelationInput = {
    id?: SortOrder
    profileFollowingId?: SortOrder
    profileFollowedId?: SortOrder
    targetFollowerType?: SortOrder
    requestApproved?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    followingProfile?: UserProfileOrderByWithRelationInput
    followedProfile?: UserProfileOrderByWithRelationInput
  }

  export type FollowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileFollowingId_profileFollowedId?: FollowProfileFollowingIdProfileFollowedIdCompoundUniqueInput
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    profileFollowingId?: StringFilter<"Follow"> | string
    profileFollowedId?: StringFilter<"Follow"> | string
    targetFollowerType?: StringFilter<"Follow"> | string
    requestApproved?: BoolFilter<"Follow"> | boolean
    metadata?: JsonNullableFilter<"Follow">
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Follow"> | Date | string | null
    followingProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    followedProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }, "id" | "profileFollowingId_profileFollowedId">

  export type FollowOrderByWithAggregationInput = {
    id?: SortOrder
    profileFollowingId?: SortOrder
    profileFollowedId?: SortOrder
    targetFollowerType?: SortOrder
    requestApproved?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    _count?: FollowCountOrderByAggregateInput
    _max?: FollowMaxOrderByAggregateInput
    _min?: FollowMinOrderByAggregateInput
  }

  export type FollowScalarWhereWithAggregatesInput = {
    AND?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    OR?: FollowScalarWhereWithAggregatesInput[]
    NOT?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Follow"> | string
    profileFollowingId?: StringWithAggregatesFilter<"Follow"> | string
    profileFollowedId?: StringWithAggregatesFilter<"Follow"> | string
    targetFollowerType?: StringWithAggregatesFilter<"Follow"> | string
    requestApproved?: BoolWithAggregatesFilter<"Follow"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Follow">
    createdAt?: DateTimeWithAggregatesFilter<"Follow"> | Date | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Follow"> | Date | string | null
  }

  export type UserTagWhereInput = {
    AND?: UserTagWhereInput | UserTagWhereInput[]
    OR?: UserTagWhereInput[]
    NOT?: UserTagWhereInput | UserTagWhereInput[]
    id?: StringFilter<"UserTag"> | string
    userProfileId?: StringFilter<"UserTag"> | string
    tagName?: StringNullableFilter<"UserTag"> | string | null
    description?: StringNullableFilter<"UserTag"> | string | null
    metadata?: JsonNullableFilter<"UserTag">
    createdAt?: DateTimeFilter<"UserTag"> | Date | string
    updatedAt?: DateTimeFilter<"UserTag"> | Date | string
    userProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }

  export type UserTagOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    tagName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
  }

  export type UserTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserTagWhereInput | UserTagWhereInput[]
    OR?: UserTagWhereInput[]
    NOT?: UserTagWhereInput | UserTagWhereInput[]
    userProfileId?: StringFilter<"UserTag"> | string
    tagName?: StringNullableFilter<"UserTag"> | string | null
    description?: StringNullableFilter<"UserTag"> | string | null
    metadata?: JsonNullableFilter<"UserTag">
    createdAt?: DateTimeFilter<"UserTag"> | Date | string
    updatedAt?: DateTimeFilter<"UserTag"> | Date | string
    userProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }, "id">

  export type UserTagOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    tagName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserTagCountOrderByAggregateInput
    _max?: UserTagMaxOrderByAggregateInput
    _min?: UserTagMinOrderByAggregateInput
  }

  export type UserTagScalarWhereWithAggregatesInput = {
    AND?: UserTagScalarWhereWithAggregatesInput | UserTagScalarWhereWithAggregatesInput[]
    OR?: UserTagScalarWhereWithAggregatesInput[]
    NOT?: UserTagScalarWhereWithAggregatesInput | UserTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserTag"> | string
    userProfileId?: StringWithAggregatesFilter<"UserTag"> | string
    tagName?: StringNullableWithAggregatesFilter<"UserTag"> | string | null
    description?: StringNullableWithAggregatesFilter<"UserTag"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"UserTag">
    createdAt?: DateTimeWithAggregatesFilter<"UserTag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserTag"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    submitterId?: StringFilter<"Report"> | string
    postId?: StringNullableFilter<"Report"> | string | null
    commentId?: StringNullableFilter<"Report"> | string | null
    userId?: StringNullableFilter<"Report"> | string | null
    reason?: EnumReportReasonFilter<"Report"> | $Enums.ReportReason
    description?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    metadata?: JsonNullableFilter<"Report">
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    submitter?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    reportedUser?: XOR<UserProfileNullableRelationFilter, UserProfileWhereInput> | null
    reportedPost?: XOR<PostNullableRelationFilter, PostWhereInput> | null
    reportedComment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    submitterId?: SortOrder
    postId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    reason?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    submitter?: UserProfileOrderByWithRelationInput
    reportedUser?: UserProfileOrderByWithRelationInput
    reportedPost?: PostOrderByWithRelationInput
    reportedComment?: CommentOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    submitterId?: StringFilter<"Report"> | string
    postId?: StringNullableFilter<"Report"> | string | null
    commentId?: StringNullableFilter<"Report"> | string | null
    userId?: StringNullableFilter<"Report"> | string | null
    reason?: EnumReportReasonFilter<"Report"> | $Enums.ReportReason
    description?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    metadata?: JsonNullableFilter<"Report">
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    submitter?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    reportedUser?: XOR<UserProfileNullableRelationFilter, UserProfileWhereInput> | null
    reportedPost?: XOR<PostNullableRelationFilter, PostWhereInput> | null
    reportedComment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    submitterId?: SortOrder
    postId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    reason?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    submitterId?: StringWithAggregatesFilter<"Report"> | string
    postId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    commentId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    reason?: EnumReportReasonWithAggregatesFilter<"Report"> | $Enums.ReportReason
    description?: StringNullableWithAggregatesFilter<"Report"> | string | null
    status?: EnumReportStatusWithAggregatesFilter<"Report"> | $Enums.ReportStatus
    metadata?: JsonNullableWithAggregatesFilter<"Report">
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    user?: UserProfileOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type SpaceWhereInput = {
    AND?: SpaceWhereInput | SpaceWhereInput[]
    OR?: SpaceWhereInput[]
    NOT?: SpaceWhereInput | SpaceWhereInput[]
    id?: StringFilter<"Space"> | string
    name?: StringFilter<"Space"> | string
    description?: StringNullableFilter<"Space"> | string | null
    type?: EnumSpaceTypeFilter<"Space"> | $Enums.SpaceType
    createdAt?: DateTimeFilter<"Space"> | Date | string
    updatedAt?: DateTimeFilter<"Space"> | Date | string
    spaceType?: StringFilter<"Space"> | string
    status?: StringFilter<"Space"> | string
    visibility?: EnumVisibilityFilter<"Space"> | $Enums.Visibility
    parentSpaceId?: StringNullableFilter<"Space"> | string | null
    isPrivate?: BoolFilter<"Space"> | boolean
    metadata?: JsonNullableFilter<"Space">
    settings?: JsonNullableFilter<"Space">
    accessLevel?: EnumAccessLevelFilter<"Space"> | $Enums.AccessLevel
    searchMetadata?: JsonNullableFilter<"Space">
    tags?: StringNullableListFilter<"Space">
    members?: SpaceMemberListRelationFilter
    channels?: ChannelListRelationFilter
    posts?: PostListRelationFilter
    files?: FileListRelationFilter
    parentSpace?: XOR<SpaceNullableRelationFilter, SpaceWhereInput> | null
    childSpaces?: SpaceListRelationFilter
  }

  export type SpaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    spaceType?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    parentSpaceId?: SortOrderInput | SortOrder
    isPrivate?: SortOrder
    metadata?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    accessLevel?: SortOrder
    searchMetadata?: SortOrderInput | SortOrder
    tags?: SortOrder
    members?: SpaceMemberOrderByRelationAggregateInput
    channels?: ChannelOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    parentSpace?: SpaceOrderByWithRelationInput
    childSpaces?: SpaceOrderByRelationAggregateInput
  }

  export type SpaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpaceWhereInput | SpaceWhereInput[]
    OR?: SpaceWhereInput[]
    NOT?: SpaceWhereInput | SpaceWhereInput[]
    name?: StringFilter<"Space"> | string
    description?: StringNullableFilter<"Space"> | string | null
    type?: EnumSpaceTypeFilter<"Space"> | $Enums.SpaceType
    createdAt?: DateTimeFilter<"Space"> | Date | string
    updatedAt?: DateTimeFilter<"Space"> | Date | string
    spaceType?: StringFilter<"Space"> | string
    status?: StringFilter<"Space"> | string
    visibility?: EnumVisibilityFilter<"Space"> | $Enums.Visibility
    parentSpaceId?: StringNullableFilter<"Space"> | string | null
    isPrivate?: BoolFilter<"Space"> | boolean
    metadata?: JsonNullableFilter<"Space">
    settings?: JsonNullableFilter<"Space">
    accessLevel?: EnumAccessLevelFilter<"Space"> | $Enums.AccessLevel
    searchMetadata?: JsonNullableFilter<"Space">
    tags?: StringNullableListFilter<"Space">
    members?: SpaceMemberListRelationFilter
    channels?: ChannelListRelationFilter
    posts?: PostListRelationFilter
    files?: FileListRelationFilter
    parentSpace?: XOR<SpaceNullableRelationFilter, SpaceWhereInput> | null
    childSpaces?: SpaceListRelationFilter
  }, "id">

  export type SpaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    spaceType?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    parentSpaceId?: SortOrderInput | SortOrder
    isPrivate?: SortOrder
    metadata?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    accessLevel?: SortOrder
    searchMetadata?: SortOrderInput | SortOrder
    tags?: SortOrder
    _count?: SpaceCountOrderByAggregateInput
    _max?: SpaceMaxOrderByAggregateInput
    _min?: SpaceMinOrderByAggregateInput
  }

  export type SpaceScalarWhereWithAggregatesInput = {
    AND?: SpaceScalarWhereWithAggregatesInput | SpaceScalarWhereWithAggregatesInput[]
    OR?: SpaceScalarWhereWithAggregatesInput[]
    NOT?: SpaceScalarWhereWithAggregatesInput | SpaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Space"> | string
    name?: StringWithAggregatesFilter<"Space"> | string
    description?: StringNullableWithAggregatesFilter<"Space"> | string | null
    type?: EnumSpaceTypeWithAggregatesFilter<"Space"> | $Enums.SpaceType
    createdAt?: DateTimeWithAggregatesFilter<"Space"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Space"> | Date | string
    spaceType?: StringWithAggregatesFilter<"Space"> | string
    status?: StringWithAggregatesFilter<"Space"> | string
    visibility?: EnumVisibilityWithAggregatesFilter<"Space"> | $Enums.Visibility
    parentSpaceId?: StringNullableWithAggregatesFilter<"Space"> | string | null
    isPrivate?: BoolWithAggregatesFilter<"Space"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Space">
    settings?: JsonNullableWithAggregatesFilter<"Space">
    accessLevel?: EnumAccessLevelWithAggregatesFilter<"Space"> | $Enums.AccessLevel
    searchMetadata?: JsonNullableWithAggregatesFilter<"Space">
    tags?: StringNullableListFilter<"Space">
  }

  export type ChannelWhereInput = {
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    id?: StringFilter<"Channel"> | string
    name?: StringFilter<"Channel"> | string
    description?: StringNullableFilter<"Channel"> | string | null
    spaceId?: StringFilter<"Channel"> | string
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
    status?: StringFilter<"Channel"> | string
    pinnedPosts?: StringNullableListFilter<"Channel">
    isPrivate?: BoolFilter<"Channel"> | boolean
    metadata?: JsonNullableFilter<"Channel">
    settings?: JsonNullableFilter<"Channel">
    space?: XOR<SpaceRelationFilter, SpaceWhereInput>
    posts?: PostListRelationFilter
    files?: FileListRelationFilter
    members?: ChannelMemberListRelationFilter
  }

  export type ChannelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    spaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    pinnedPosts?: SortOrder
    isPrivate?: SortOrder
    metadata?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    space?: SpaceOrderByWithRelationInput
    posts?: PostOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    members?: ChannelMemberOrderByRelationAggregateInput
  }

  export type ChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    name?: StringFilter<"Channel"> | string
    description?: StringNullableFilter<"Channel"> | string | null
    spaceId?: StringFilter<"Channel"> | string
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
    status?: StringFilter<"Channel"> | string
    pinnedPosts?: StringNullableListFilter<"Channel">
    isPrivate?: BoolFilter<"Channel"> | boolean
    metadata?: JsonNullableFilter<"Channel">
    settings?: JsonNullableFilter<"Channel">
    space?: XOR<SpaceRelationFilter, SpaceWhereInput>
    posts?: PostListRelationFilter
    files?: FileListRelationFilter
    members?: ChannelMemberListRelationFilter
  }, "id">

  export type ChannelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    spaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    pinnedPosts?: SortOrder
    isPrivate?: SortOrder
    metadata?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    _count?: ChannelCountOrderByAggregateInput
    _max?: ChannelMaxOrderByAggregateInput
    _min?: ChannelMinOrderByAggregateInput
  }

  export type ChannelScalarWhereWithAggregatesInput = {
    AND?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    OR?: ChannelScalarWhereWithAggregatesInput[]
    NOT?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Channel"> | string
    name?: StringWithAggregatesFilter<"Channel"> | string
    description?: StringNullableWithAggregatesFilter<"Channel"> | string | null
    spaceId?: StringWithAggregatesFilter<"Channel"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Channel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Channel"> | Date | string
    status?: StringWithAggregatesFilter<"Channel"> | string
    pinnedPosts?: StringNullableListFilter<"Channel">
    isPrivate?: BoolWithAggregatesFilter<"Channel"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Channel">
    settings?: JsonNullableWithAggregatesFilter<"Channel">
  }

  export type ThreadWhereInput = {
    AND?: ThreadWhereInput | ThreadWhereInput[]
    OR?: ThreadWhereInput[]
    NOT?: ThreadWhereInput | ThreadWhereInput[]
    id?: StringFilter<"Thread"> | string
    postIds?: StringNullableListFilter<"Thread">
    parentPostId?: StringFilter<"Thread"> | string
    createdAt?: DateTimeFilter<"Thread"> | Date | string
    updatedAt?: DateTimeFilter<"Thread"> | Date | string
    metadata?: JsonNullableFilter<"Thread">
    status?: StringFilter<"Thread"> | string
    isLocked?: BoolFilter<"Thread"> | boolean
    posts?: PostListRelationFilter
    pollPosts?: PollPostListRelationFilter
  }

  export type ThreadOrderByWithRelationInput = {
    id?: SortOrder
    postIds?: SortOrder
    parentPostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    status?: SortOrder
    isLocked?: SortOrder
    posts?: PostOrderByRelationAggregateInput
    pollPosts?: PollPostOrderByRelationAggregateInput
  }

  export type ThreadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ThreadWhereInput | ThreadWhereInput[]
    OR?: ThreadWhereInput[]
    NOT?: ThreadWhereInput | ThreadWhereInput[]
    postIds?: StringNullableListFilter<"Thread">
    parentPostId?: StringFilter<"Thread"> | string
    createdAt?: DateTimeFilter<"Thread"> | Date | string
    updatedAt?: DateTimeFilter<"Thread"> | Date | string
    metadata?: JsonNullableFilter<"Thread">
    status?: StringFilter<"Thread"> | string
    isLocked?: BoolFilter<"Thread"> | boolean
    posts?: PostListRelationFilter
    pollPosts?: PollPostListRelationFilter
  }, "id">

  export type ThreadOrderByWithAggregationInput = {
    id?: SortOrder
    postIds?: SortOrder
    parentPostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    status?: SortOrder
    isLocked?: SortOrder
    _count?: ThreadCountOrderByAggregateInput
    _max?: ThreadMaxOrderByAggregateInput
    _min?: ThreadMinOrderByAggregateInput
  }

  export type ThreadScalarWhereWithAggregatesInput = {
    AND?: ThreadScalarWhereWithAggregatesInput | ThreadScalarWhereWithAggregatesInput[]
    OR?: ThreadScalarWhereWithAggregatesInput[]
    NOT?: ThreadScalarWhereWithAggregatesInput | ThreadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Thread"> | string
    postIds?: StringNullableListFilter<"Thread">
    parentPostId?: StringWithAggregatesFilter<"Thread"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Thread"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Thread"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"Thread">
    status?: StringWithAggregatesFilter<"Thread"> | string
    isLocked?: BoolWithAggregatesFilter<"Thread"> | boolean
  }

  export type NoteWhereInput = {
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    id?: StringFilter<"Note"> | string
    content?: StringFilter<"Note"> | string
    createdAt?: DateTimeFilter<"Note"> | Date | string
    authorId?: StringFilter<"Note"> | string
    backendPlatformUserId?: StringFilter<"Note"> | string
    profileId?: IntFilter<"Note"> | number
    authorUserName?: StringFilter<"Note"> | string
    authorProfileImage?: StringNullableFilter<"Note"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Note"> | $Enums.AccountType
    mentions?: StringNullableListFilter<"Note">
    hashtags?: StringNullableListFilter<"Note">
    mediaId?: StringNullableFilter<"Note"> | string | null
    postId?: StringFilter<"Note"> | string
    commentId?: StringNullableFilter<"Note"> | string | null
    searchMetadata?: JsonNullableFilter<"Note">
    aiAnalysis?: JsonNullableFilter<"Note">
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    post?: XOR<PostRelationFilter, PostWhereInput>
    comment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
  }

  export type NoteOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    authorId?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUserName?: SortOrder
    authorProfileImage?: SortOrderInput | SortOrder
    authorAccountType?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    mediaId?: SortOrderInput | SortOrder
    postId?: SortOrder
    commentId?: SortOrderInput | SortOrder
    searchMetadata?: SortOrderInput | SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    media?: MediaOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
  }

  export type NoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    content?: StringFilter<"Note"> | string
    createdAt?: DateTimeFilter<"Note"> | Date | string
    authorId?: StringFilter<"Note"> | string
    backendPlatformUserId?: StringFilter<"Note"> | string
    profileId?: IntFilter<"Note"> | number
    authorUserName?: StringFilter<"Note"> | string
    authorProfileImage?: StringNullableFilter<"Note"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Note"> | $Enums.AccountType
    mentions?: StringNullableListFilter<"Note">
    hashtags?: StringNullableListFilter<"Note">
    mediaId?: StringNullableFilter<"Note"> | string | null
    postId?: StringFilter<"Note"> | string
    commentId?: StringNullableFilter<"Note"> | string | null
    searchMetadata?: JsonNullableFilter<"Note">
    aiAnalysis?: JsonNullableFilter<"Note">
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    post?: XOR<PostRelationFilter, PostWhereInput>
    comment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
  }, "id">

  export type NoteOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    authorId?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUserName?: SortOrder
    authorProfileImage?: SortOrderInput | SortOrder
    authorAccountType?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    mediaId?: SortOrderInput | SortOrder
    postId?: SortOrder
    commentId?: SortOrderInput | SortOrder
    searchMetadata?: SortOrderInput | SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    _count?: NoteCountOrderByAggregateInput
    _avg?: NoteAvgOrderByAggregateInput
    _max?: NoteMaxOrderByAggregateInput
    _min?: NoteMinOrderByAggregateInput
    _sum?: NoteSumOrderByAggregateInput
  }

  export type NoteScalarWhereWithAggregatesInput = {
    AND?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    OR?: NoteScalarWhereWithAggregatesInput[]
    NOT?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Note"> | string
    content?: StringWithAggregatesFilter<"Note"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
    authorId?: StringWithAggregatesFilter<"Note"> | string
    backendPlatformUserId?: StringWithAggregatesFilter<"Note"> | string
    profileId?: IntWithAggregatesFilter<"Note"> | number
    authorUserName?: StringWithAggregatesFilter<"Note"> | string
    authorProfileImage?: StringNullableWithAggregatesFilter<"Note"> | string | null
    authorAccountType?: EnumAccountTypeWithAggregatesFilter<"Note"> | $Enums.AccountType
    mentions?: StringNullableListFilter<"Note">
    hashtags?: StringNullableListFilter<"Note">
    mediaId?: StringNullableWithAggregatesFilter<"Note"> | string | null
    postId?: StringWithAggregatesFilter<"Note"> | string
    commentId?: StringNullableWithAggregatesFilter<"Note"> | string | null
    searchMetadata?: JsonNullableWithAggregatesFilter<"Note">
    aiAnalysis?: JsonNullableWithAggregatesFilter<"Note">
  }

  export type SpaceMemberWhereInput = {
    AND?: SpaceMemberWhereInput | SpaceMemberWhereInput[]
    OR?: SpaceMemberWhereInput[]
    NOT?: SpaceMemberWhereInput | SpaceMemberWhereInput[]
    id?: StringFilter<"SpaceMember"> | string
    spaceId?: StringFilter<"SpaceMember"> | string
    userId?: StringFilter<"SpaceMember"> | string
    role?: StringFilter<"SpaceMember"> | string
    joinedAt?: DateTimeFilter<"SpaceMember"> | Date | string
    status?: StringFilter<"SpaceMember"> | string
    permissions?: StringNullableListFilter<"SpaceMember">
    space?: XOR<SpaceRelationFilter, SpaceWhereInput>
  }

  export type SpaceMemberOrderByWithRelationInput = {
    id?: SortOrder
    spaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    permissions?: SortOrder
    space?: SpaceOrderByWithRelationInput
  }

  export type SpaceMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    spaceId_userId?: SpaceMemberSpaceIdUserIdCompoundUniqueInput
    AND?: SpaceMemberWhereInput | SpaceMemberWhereInput[]
    OR?: SpaceMemberWhereInput[]
    NOT?: SpaceMemberWhereInput | SpaceMemberWhereInput[]
    spaceId?: StringFilter<"SpaceMember"> | string
    userId?: StringFilter<"SpaceMember"> | string
    role?: StringFilter<"SpaceMember"> | string
    joinedAt?: DateTimeFilter<"SpaceMember"> | Date | string
    status?: StringFilter<"SpaceMember"> | string
    permissions?: StringNullableListFilter<"SpaceMember">
    space?: XOR<SpaceRelationFilter, SpaceWhereInput>
  }, "id" | "spaceId_userId">

  export type SpaceMemberOrderByWithAggregationInput = {
    id?: SortOrder
    spaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    permissions?: SortOrder
    _count?: SpaceMemberCountOrderByAggregateInput
    _max?: SpaceMemberMaxOrderByAggregateInput
    _min?: SpaceMemberMinOrderByAggregateInput
  }

  export type SpaceMemberScalarWhereWithAggregatesInput = {
    AND?: SpaceMemberScalarWhereWithAggregatesInput | SpaceMemberScalarWhereWithAggregatesInput[]
    OR?: SpaceMemberScalarWhereWithAggregatesInput[]
    NOT?: SpaceMemberScalarWhereWithAggregatesInput | SpaceMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpaceMember"> | string
    spaceId?: StringWithAggregatesFilter<"SpaceMember"> | string
    userId?: StringWithAggregatesFilter<"SpaceMember"> | string
    role?: StringWithAggregatesFilter<"SpaceMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"SpaceMember"> | Date | string
    status?: StringWithAggregatesFilter<"SpaceMember"> | string
    permissions?: StringNullableListFilter<"SpaceMember">
  }

  export type ChannelMemberWhereInput = {
    AND?: ChannelMemberWhereInput | ChannelMemberWhereInput[]
    OR?: ChannelMemberWhereInput[]
    NOT?: ChannelMemberWhereInput | ChannelMemberWhereInput[]
    id?: StringFilter<"ChannelMember"> | string
    channelId?: StringFilter<"ChannelMember"> | string
    userId?: StringFilter<"ChannelMember"> | string
    role?: StringFilter<"ChannelMember"> | string
    joinedAt?: DateTimeFilter<"ChannelMember"> | Date | string
    lastRead?: DateTimeNullableFilter<"ChannelMember"> | Date | string | null
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
  }

  export type ChannelMemberOrderByWithRelationInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    lastRead?: SortOrderInput | SortOrder
    channel?: ChannelOrderByWithRelationInput
  }

  export type ChannelMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    channelId_userId?: ChannelMemberChannelIdUserIdCompoundUniqueInput
    AND?: ChannelMemberWhereInput | ChannelMemberWhereInput[]
    OR?: ChannelMemberWhereInput[]
    NOT?: ChannelMemberWhereInput | ChannelMemberWhereInput[]
    channelId?: StringFilter<"ChannelMember"> | string
    userId?: StringFilter<"ChannelMember"> | string
    role?: StringFilter<"ChannelMember"> | string
    joinedAt?: DateTimeFilter<"ChannelMember"> | Date | string
    lastRead?: DateTimeNullableFilter<"ChannelMember"> | Date | string | null
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
  }, "id" | "channelId_userId">

  export type ChannelMemberOrderByWithAggregationInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    lastRead?: SortOrderInput | SortOrder
    _count?: ChannelMemberCountOrderByAggregateInput
    _max?: ChannelMemberMaxOrderByAggregateInput
    _min?: ChannelMemberMinOrderByAggregateInput
  }

  export type ChannelMemberScalarWhereWithAggregatesInput = {
    AND?: ChannelMemberScalarWhereWithAggregatesInput | ChannelMemberScalarWhereWithAggregatesInput[]
    OR?: ChannelMemberScalarWhereWithAggregatesInput[]
    NOT?: ChannelMemberScalarWhereWithAggregatesInput | ChannelMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChannelMember"> | string
    channelId?: StringWithAggregatesFilter<"ChannelMember"> | string
    userId?: StringWithAggregatesFilter<"ChannelMember"> | string
    role?: StringWithAggregatesFilter<"ChannelMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"ChannelMember"> | Date | string
    lastRead?: DateTimeNullableWithAggregatesFilter<"ChannelMember"> | Date | string | null
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: StringFilter<"File"> | string
    name?: StringFilter<"File"> | string
    type?: EnumMediaTypeFilter<"File"> | $Enums.MediaType
    url?: StringFilter<"File"> | string
    metadata?: JsonFilter<"File">
    uploadedBy?: StringFilter<"File"> | string
    uploadedAt?: DateTimeFilter<"File"> | Date | string
    size?: IntFilter<"File"> | number
    status?: StringFilter<"File"> | string
    preview?: StringNullableFilter<"File"> | string | null
    thumbnail?: StringNullableFilter<"File"> | string | null
    searchMetadata?: JsonNullableFilter<"File">
    aiAnalysis?: JsonNullableFilter<"File">
    spaceId?: StringNullableFilter<"File"> | string | null
    channelId?: StringNullableFilter<"File"> | string | null
    posts?: PostListRelationFilter
    space?: XOR<SpaceNullableRelationFilter, SpaceWhereInput> | null
    channel?: XOR<ChannelNullableRelationFilter, ChannelWhereInput> | null
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    metadata?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    size?: SortOrder
    status?: SortOrder
    preview?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    searchMetadata?: SortOrderInput | SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    spaceId?: SortOrderInput | SortOrder
    channelId?: SortOrderInput | SortOrder
    posts?: PostOrderByRelationAggregateInput
    space?: SpaceOrderByWithRelationInput
    channel?: ChannelOrderByWithRelationInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    name?: StringFilter<"File"> | string
    type?: EnumMediaTypeFilter<"File"> | $Enums.MediaType
    url?: StringFilter<"File"> | string
    metadata?: JsonFilter<"File">
    uploadedBy?: StringFilter<"File"> | string
    uploadedAt?: DateTimeFilter<"File"> | Date | string
    size?: IntFilter<"File"> | number
    status?: StringFilter<"File"> | string
    preview?: StringNullableFilter<"File"> | string | null
    thumbnail?: StringNullableFilter<"File"> | string | null
    searchMetadata?: JsonNullableFilter<"File">
    aiAnalysis?: JsonNullableFilter<"File">
    spaceId?: StringNullableFilter<"File"> | string | null
    channelId?: StringNullableFilter<"File"> | string | null
    posts?: PostListRelationFilter
    space?: XOR<SpaceNullableRelationFilter, SpaceWhereInput> | null
    channel?: XOR<ChannelNullableRelationFilter, ChannelWhereInput> | null
  }, "id">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    metadata?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    size?: SortOrder
    status?: SortOrder
    preview?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    searchMetadata?: SortOrderInput | SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    spaceId?: SortOrderInput | SortOrder
    channelId?: SortOrderInput | SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"File"> | string
    name?: StringWithAggregatesFilter<"File"> | string
    type?: EnumMediaTypeWithAggregatesFilter<"File"> | $Enums.MediaType
    url?: StringWithAggregatesFilter<"File"> | string
    metadata?: JsonWithAggregatesFilter<"File">
    uploadedBy?: StringWithAggregatesFilter<"File"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    size?: IntWithAggregatesFilter<"File"> | number
    status?: StringWithAggregatesFilter<"File"> | string
    preview?: StringNullableWithAggregatesFilter<"File"> | string | null
    thumbnail?: StringNullableWithAggregatesFilter<"File"> | string | null
    searchMetadata?: JsonNullableWithAggregatesFilter<"File">
    aiAnalysis?: JsonNullableWithAggregatesFilter<"File">
    spaceId?: StringNullableWithAggregatesFilter<"File"> | string | null
    channelId?: StringNullableWithAggregatesFilter<"File"> | string | null
  }

  export type VirtualProfileCreateInput = {
    id?: string
    userId?: string | null
    profileType?: string | null
    activated?: boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userProfile?: UserProfileCreateNestedManyWithoutVirtualProfileInput
    communityProfile?: CommunityProfileCreateNestedManyWithoutVirtualProfileInput
  }

  export type VirtualProfileUncheckedCreateInput = {
    id?: string
    userId?: string | null
    profileType?: string | null
    activated?: boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userProfile?: UserProfileUncheckedCreateNestedManyWithoutVirtualProfileInput
    communityProfile?: CommunityProfileUncheckedCreateNestedManyWithoutVirtualProfileInput
  }

  export type VirtualProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    profileType?: NullableStringFieldUpdateOperationsInput | string | null
    activated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUpdateManyWithoutVirtualProfileNestedInput
    communityProfile?: CommunityProfileUpdateManyWithoutVirtualProfileNestedInput
  }

  export type VirtualProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    profileType?: NullableStringFieldUpdateOperationsInput | string | null
    activated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUncheckedUpdateManyWithoutVirtualProfileNestedInput
    communityProfile?: CommunityProfileUncheckedUpdateManyWithoutVirtualProfileNestedInput
  }

  export type VirtualProfileCreateManyInput = {
    id?: string
    userId?: string | null
    profileType?: string | null
    activated?: boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VirtualProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    profileType?: NullableStringFieldUpdateOperationsInput | string | null
    activated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VirtualProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    profileType?: NullableStringFieldUpdateOperationsInput | string | null
    activated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutUserProfileInput
    bookmarks?: BookmarkCreateNestedManyWithoutUsersInput
    tags?: UserTagCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowCreateNestedManyWithoutFollowedProfileInput
    following?: FollowCreateNestedManyWithoutFollowingProfileInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUsersInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationUncheckedCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationUncheckedCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowedProfileInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportUncheckedCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUsersNestedInput
    tags?: UserTagUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUsersNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUncheckedUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUncheckedUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUncheckedUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileCreateManyInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityProfileCreateInput = {
    id?: string
    name?: string | null
    description?: string | null
    communityRules?: string | null
    profileImageUrl?: string | null
    private?: boolean | null
    visible?: boolean | null
    followers?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutCommunityProfileInput
    topics?: TopicCreateNestedManyWithoutCommunityProfileInput
    posts?: PostCreateNestedManyWithoutCommunityInput
    moderators?: UserProfileCreateNestedManyWithoutModeratedCommunitiesInput
  }

  export type CommunityProfileUncheckedCreateInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    description?: string | null
    communityRules?: string | null
    profileImageUrl?: string | null
    private?: boolean | null
    visible?: boolean | null
    followers?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutCommunityProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutCommunityInput
    moderators?: UserProfileUncheckedCreateNestedManyWithoutModeratedCommunitiesInput
  }

  export type CommunityProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    communityRules?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    visible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followers?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutCommunityProfileNestedInput
    topics?: TopicUpdateManyWithoutCommunityProfileNestedInput
    posts?: PostUpdateManyWithoutCommunityNestedInput
    moderators?: UserProfileUpdateManyWithoutModeratedCommunitiesNestedInput
  }

  export type CommunityProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    communityRules?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    visible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followers?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutCommunityProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutCommunityNestedInput
    moderators?: UserProfileUncheckedUpdateManyWithoutModeratedCommunitiesNestedInput
  }

  export type CommunityProfileCreateManyInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    description?: string | null
    communityRules?: string | null
    profileImageUrl?: string | null
    private?: boolean | null
    visible?: boolean | null
    followers?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    communityRules?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    visible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followers?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    communityRules?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    visible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followers?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicCreateInput = {
    id?: string
    topicName?: string | null
    description?: string | null
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    communityProfile: CommunityProfileCreateNestedOneWithoutTopicsInput
  }

  export type TopicUncheckedCreateInput = {
    id?: string
    communityProfileId: string
    topicName?: string | null
    description?: string | null
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityProfile?: CommunityProfileUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityProfileId?: StringFieldUpdateOperationsInput | string
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicCreateManyInput = {
    id?: string
    communityProfileId: string
    topicName?: string | null
    description?: string | null
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityProfileId?: StringFieldUpdateOperationsInput | string
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationCreateInput = {
    id?: string
    publicationName?: string | null
    description?: string | null
    type?: string | null
    postIds?: PublicationCreatepostIdsInput | string[]
    subjects?: PublicationCreatesubjectsInput | string[]
    tags?: PublicationCreatetagsInput | string[]
    adminBackendPlatformUserId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkCreateNestedManyWithoutPublicationsInput
    admins?: UserProfileCreateNestedManyWithoutAdminPublicationsInput
    editors?: UserProfileCreateNestedManyWithoutEditorPublicationsInput
    posts?: PostCreateNestedManyWithoutPublicationsInput
  }

  export type PublicationUncheckedCreateInput = {
    id?: string
    publicationName?: string | null
    description?: string | null
    type?: string | null
    postIds?: PublicationCreatepostIdsInput | string[]
    subjects?: PublicationCreatesubjectsInput | string[]
    tags?: PublicationCreatetagsInput | string[]
    adminBackendPlatformUserId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPublicationsInput
    admins?: UserProfileUncheckedCreateNestedManyWithoutAdminPublicationsInput
    editors?: UserProfileUncheckedCreateNestedManyWithoutEditorPublicationsInput
    posts?: PostUncheckedCreateNestedManyWithoutPublicationsInput
  }

  export type PublicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    postIds?: PublicationUpdatepostIdsInput | string[]
    subjects?: PublicationUpdatesubjectsInput | string[]
    tags?: PublicationUpdatetagsInput | string[]
    adminBackendPlatformUserId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUpdateManyWithoutPublicationsNestedInput
    admins?: UserProfileUpdateManyWithoutAdminPublicationsNestedInput
    editors?: UserProfileUpdateManyWithoutEditorPublicationsNestedInput
    posts?: PostUpdateManyWithoutPublicationsNestedInput
  }

  export type PublicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    postIds?: PublicationUpdatepostIdsInput | string[]
    subjects?: PublicationUpdatesubjectsInput | string[]
    tags?: PublicationUpdatetagsInput | string[]
    adminBackendPlatformUserId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPublicationsNestedInput
    admins?: UserProfileUncheckedUpdateManyWithoutAdminPublicationsNestedInput
    editors?: UserProfileUncheckedUpdateManyWithoutEditorPublicationsNestedInput
    posts?: PostUncheckedUpdateManyWithoutPublicationsNestedInput
  }

  export type PublicationCreateManyInput = {
    id?: string
    publicationName?: string | null
    description?: string | null
    type?: string | null
    postIds?: PublicationCreatepostIdsInput | string[]
    subjects?: PublicationCreatesubjectsInput | string[]
    tags?: PublicationCreatetagsInput | string[]
    adminBackendPlatformUserId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    postIds?: PublicationUpdatepostIdsInput | string[]
    subjects?: PublicationUpdatesubjectsInput | string[]
    tags?: PublicationUpdatetagsInput | string[]
    adminBackendPlatformUserId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    postIds?: PublicationUpdatepostIdsInput | string[]
    subjects?: PublicationUpdatesubjectsInput | string[]
    tags?: PublicationUpdatetagsInput | string[]
    adminBackendPlatformUserId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateInput = {
    id?: string
    mediaType: $Enums.MediaType
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    commentReplies?: CommentReplyCreateNestedManyWithoutMediaInput
    posts?: PostCreateNestedManyWithoutMediaInput
    comments?: CommentCreateNestedManyWithoutMediaInput
    pollPosts?: PollPostCreateNestedManyWithoutMediaInput
    notes?: NoteCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    mediaType: $Enums.MediaType
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutMediaInput
    posts?: PostUncheckedCreateNestedManyWithoutMediaInput
    comments?: CommentUncheckedCreateNestedManyWithoutMediaInput
    pollPosts?: PollPostUncheckedCreateNestedManyWithoutMediaInput
    notes?: NoteUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentReplies?: CommentReplyUpdateManyWithoutMediaNestedInput
    posts?: PostUpdateManyWithoutMediaNestedInput
    comments?: CommentUpdateManyWithoutMediaNestedInput
    pollPosts?: PollPostUpdateManyWithoutMediaNestedInput
    notes?: NoteUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutMediaNestedInput
    posts?: PostUncheckedUpdateManyWithoutMediaNestedInput
    comments?: CommentUncheckedUpdateManyWithoutMediaNestedInput
    pollPosts?: PollPostUncheckedUpdateManyWithoutMediaNestedInput
    notes?: NoteUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaCreateManyInput = {
    id?: string
    mediaType: $Enums.MediaType
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    id?: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    media?: MediaCreateNestedOneWithoutPostsInput
    files?: FileCreateNestedManyWithoutPostsInput
    author: UserProfileCreateNestedOneWithoutPostsInput
    community?: CommunityProfileCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkCreateNestedManyWithoutPostsInput
    publications?: PublicationCreateNestedManyWithoutPostsInput
    reports?: ReportCreateNestedManyWithoutReportedPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    files?: FileUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPostsInput
    publications?: PublicationUncheckedCreateNestedManyWithoutPostsInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostsNestedInput
    files?: FileUpdateManyWithoutPostsNestedInput
    author?: UserProfileUpdateOneRequiredWithoutPostsNestedInput
    community?: CommunityProfileUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUpdateManyWithoutPostsNestedInput
    publications?: PublicationUpdateManyWithoutPostsNestedInput
    reports?: ReportUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    files?: FileUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPostsNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutPostsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type PollPostCreateInput = {
    id?: string
    createdAt?: Date | string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaCreateNestedOneWithoutPollPostsInput
    comments?: CommentCreateNestedManyWithoutPollPostInput
    thread?: ThreadCreateNestedOneWithoutPollPostsInput
  }

  export type PollPostUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    mediaId?: string | null
    threadId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentUncheckedCreateNestedManyWithoutPollPostInput
  }

  export type PollPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaUpdateOneWithoutPollPostsNestedInput
    comments?: CommentUpdateManyWithoutPollPostNestedInput
    thread?: ThreadUpdateOneWithoutPollPostsNestedInput
  }

  export type PollPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentUncheckedUpdateManyWithoutPollPostNestedInput
  }

  export type PollPostCreateManyInput = {
    id?: string
    createdAt?: Date | string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    mediaId?: string | null
    threadId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PollPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PollPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentCreateInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaCreateNestedOneWithoutCommentsInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    notes?: NoteCreateNestedManyWithoutCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    pollPost?: PollPostCreateNestedOneWithoutCommentsInput
    Report?: ReportCreateNestedManyWithoutReportedCommentInput
    Reaction?: ReactionCreateNestedManyWithoutCommentInput
    UserProfile?: UserProfileCreateNestedManyWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    pollPostId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
    notes?: NoteUncheckedCreateNestedManyWithoutCommentInput
    Report?: ReportUncheckedCreateNestedManyWithoutReportedCommentInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutCommentInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutCommentsInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaUpdateOneWithoutCommentsNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    notes?: NoteUpdateManyWithoutCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    pollPost?: PollPostUpdateOneWithoutCommentsNestedInput
    Report?: ReportUpdateManyWithoutReportedCommentNestedInput
    Reaction?: ReactionUpdateManyWithoutCommentNestedInput
    UserProfile?: UserProfileUpdateManyWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutCommentNestedInput
    Report?: ReportUncheckedUpdateManyWithoutReportedCommentNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutCommentNestedInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutCommentsNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    pollPostId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentReplyCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaCreateNestedOneWithoutCommentRepliesInput
    comment: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentReplyUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    mediaId?: string | null
    commentId: string
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentReplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaUpdateOneWithoutCommentRepliesNestedInput
    comment?: CommentUpdateOneRequiredWithoutRepliesNestedInput
  }

  export type CommentReplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: StringFieldUpdateOperationsInput | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentReplyCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    mediaId?: string | null
    commentId: string
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentReplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentReplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: StringFieldUpdateOperationsInput | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReactionCreateInput = {
    id?: string
    type: $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserProfileCreateNestedOneWithoutReactionsInput
    post?: PostCreateNestedOneWithoutReactionsInput
    comment?: CommentCreateNestedOneWithoutReactionInput
  }

  export type ReactionUncheckedCreateInput = {
    id?: string
    userId: string
    postId?: string | null
    commentId?: string | null
    type: $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutReactionsNestedInput
    post?: PostUpdateOneWithoutReactionsNestedInput
    comment?: CommentUpdateOneWithoutReactionNestedInput
  }

  export type ReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionCreateManyInput = {
    id?: string
    userId: string
    postId?: string | null
    commentId?: string | null
    type: $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkCreateInput = {
    id?: string
    postIds?: BookmarkCreatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    publications?: PublicationCreateNestedManyWithoutBookmarksInput
    users?: UserProfileCreateNestedManyWithoutBookmarksInput
    posts?: PostCreateNestedManyWithoutBookmarksInput
  }

  export type BookmarkUncheckedCreateInput = {
    id?: string
    postIds?: BookmarkCreatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    publications?: PublicationUncheckedCreateNestedManyWithoutBookmarksInput
    users?: UserProfileUncheckedCreateNestedManyWithoutBookmarksInput
    posts?: PostUncheckedCreateNestedManyWithoutBookmarksInput
  }

  export type BookmarkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: BookmarkUpdatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publications?: PublicationUpdateManyWithoutBookmarksNestedInput
    users?: UserProfileUpdateManyWithoutBookmarksNestedInput
    posts?: PostUpdateManyWithoutBookmarksNestedInput
  }

  export type BookmarkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: BookmarkUpdatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publications?: PublicationUncheckedUpdateManyWithoutBookmarksNestedInput
    users?: UserProfileUncheckedUpdateManyWithoutBookmarksNestedInput
    posts?: PostUncheckedUpdateManyWithoutBookmarksNestedInput
  }

  export type BookmarkCreateManyInput = {
    id?: string
    postIds?: BookmarkCreatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookmarkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: BookmarkUpdatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: BookmarkUpdatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateInput = {
    id?: string
    profileBlockingType: string
    profileBlockedType: string
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    blockingProfile: UserProfileCreateNestedOneWithoutBlockingInput
    blockedProfile: UserProfileCreateNestedOneWithoutBlockedByInput
  }

  export type BlockUncheckedCreateInput = {
    id?: string
    profileBlockingId: string
    profileBlockedId: string
    profileBlockingType: string
    profileBlockedType: string
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileBlockingType?: StringFieldUpdateOperationsInput | string
    profileBlockedType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockingProfile?: UserProfileUpdateOneRequiredWithoutBlockingNestedInput
    blockedProfile?: UserProfileUpdateOneRequiredWithoutBlockedByNestedInput
  }

  export type BlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileBlockingId?: StringFieldUpdateOperationsInput | string
    profileBlockedId?: StringFieldUpdateOperationsInput | string
    profileBlockingType?: StringFieldUpdateOperationsInput | string
    profileBlockedType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateManyInput = {
    id?: string
    profileBlockingId: string
    profileBlockedId: string
    profileBlockingType: string
    profileBlockedType: string
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileBlockingType?: StringFieldUpdateOperationsInput | string
    profileBlockedType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileBlockingId?: StringFieldUpdateOperationsInput | string
    profileBlockedId?: StringFieldUpdateOperationsInput | string
    profileBlockingType?: StringFieldUpdateOperationsInput | string
    profileBlockedType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateInput = {
    id?: string
    targetFollowerType: string
    requestApproved?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    approvedAt?: Date | string | null
    followingProfile: UserProfileCreateNestedOneWithoutFollowingInput
    followedProfile: UserProfileCreateNestedOneWithoutFollowersInput
  }

  export type FollowUncheckedCreateInput = {
    id?: string
    profileFollowingId: string
    profileFollowedId: string
    targetFollowerType: string
    requestApproved?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type FollowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetFollowerType?: StringFieldUpdateOperationsInput | string
    requestApproved?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingProfile?: UserProfileUpdateOneRequiredWithoutFollowingNestedInput
    followedProfile?: UserProfileUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileFollowingId?: StringFieldUpdateOperationsInput | string
    profileFollowedId?: StringFieldUpdateOperationsInput | string
    targetFollowerType?: StringFieldUpdateOperationsInput | string
    requestApproved?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FollowCreateManyInput = {
    id?: string
    profileFollowingId: string
    profileFollowedId: string
    targetFollowerType: string
    requestApproved?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type FollowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetFollowerType?: StringFieldUpdateOperationsInput | string
    requestApproved?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FollowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileFollowingId?: StringFieldUpdateOperationsInput | string
    profileFollowedId?: StringFieldUpdateOperationsInput | string
    targetFollowerType?: StringFieldUpdateOperationsInput | string
    requestApproved?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserTagCreateInput = {
    id?: string
    tagName?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userProfile: UserProfileCreateNestedOneWithoutTagsInput
  }

  export type UserTagUncheckedCreateInput = {
    id?: string
    userProfileId: string
    tagName?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUpdateOneRequiredWithoutTagsNestedInput
  }

  export type UserTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    tagName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagCreateManyInput = {
    id?: string
    userProfileId: string
    tagName?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    tagName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    reason: $Enums.ReportReason
    description?: string | null
    status?: $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    submitter: UserProfileCreateNestedOneWithoutReportsSubmittedInput
    reportedUser?: UserProfileCreateNestedOneWithoutReportedContentInput
    reportedPost?: PostCreateNestedOneWithoutReportsInput
    reportedComment?: CommentCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    submitterId: string
    postId?: string | null
    commentId?: string | null
    userId?: string | null
    reason: $Enums.ReportReason
    description?: string | null
    status?: $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submitter?: UserProfileUpdateOneRequiredWithoutReportsSubmittedNestedInput
    reportedUser?: UserProfileUpdateOneWithoutReportedContentNestedInput
    reportedPost?: PostUpdateOneWithoutReportsNestedInput
    reportedComment?: CommentUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    submitterId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportCreateManyInput = {
    id?: string
    submitterId: string
    postId?: string | null
    commentId?: string | null
    userId?: string | null
    reason: $Enums.ReportReason
    description?: string | null
    status?: $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    submitterId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    user: UserProfileCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserProfileUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpaceCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberCreateNestedManyWithoutSpaceInput
    channels?: ChannelCreateNestedManyWithoutSpaceInput
    posts?: PostCreateNestedManyWithoutSpaceInput
    files?: FileCreateNestedManyWithoutSpaceInput
    parentSpace?: SpaceCreateNestedOneWithoutChildSpacesInput
    childSpaces?: SpaceCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    parentSpaceId?: string | null
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberUncheckedCreateNestedManyWithoutSpaceInput
    channels?: ChannelUncheckedCreateNestedManyWithoutSpaceInput
    posts?: PostUncheckedCreateNestedManyWithoutSpaceInput
    files?: FileUncheckedCreateNestedManyWithoutSpaceInput
    childSpaces?: SpaceUncheckedCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUpdateManyWithoutSpaceNestedInput
    posts?: PostUpdateManyWithoutSpaceNestedInput
    files?: FileUpdateManyWithoutSpaceNestedInput
    parentSpace?: SpaceUpdateOneWithoutChildSpacesNestedInput
    childSpaces?: SpaceUpdateManyWithoutParentSpaceNestedInput
  }

  export type SpaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUncheckedUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutSpaceNestedInput
    posts?: PostUncheckedUpdateManyWithoutSpaceNestedInput
    files?: FileUncheckedUpdateManyWithoutSpaceNestedInput
    childSpaces?: SpaceUncheckedUpdateManyWithoutParentSpaceNestedInput
  }

  export type SpaceCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    parentSpaceId?: string | null
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceCreatetagsInput | string[]
  }

  export type SpaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
  }

  export type SpaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
  }

  export type ChannelCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    space: SpaceCreateNestedOneWithoutChannelsInput
    posts?: PostCreateNestedManyWithoutChannelInput
    files?: FileCreateNestedManyWithoutChannelInput
    members?: ChannelMemberCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    spaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    posts?: PostUncheckedCreateNestedManyWithoutChannelInput
    files?: FileUncheckedCreateNestedManyWithoutChannelInput
    members?: ChannelMemberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    space?: SpaceUpdateOneRequiredWithoutChannelsNestedInput
    posts?: PostUpdateManyWithoutChannelNestedInput
    files?: FileUpdateManyWithoutChannelNestedInput
    members?: ChannelMemberUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    posts?: PostUncheckedUpdateManyWithoutChannelNestedInput
    files?: FileUncheckedUpdateManyWithoutChannelNestedInput
    members?: ChannelMemberUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    spaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ThreadCreateInput = {
    id?: string
    postIds?: ThreadCreatepostIdsInput | string[]
    parentPostId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isLocked?: boolean
    posts?: PostCreateNestedManyWithoutThreadInput
    pollPosts?: PollPostCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateInput = {
    id?: string
    postIds?: ThreadCreatepostIdsInput | string[]
    parentPostId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isLocked?: boolean
    posts?: PostUncheckedCreateNestedManyWithoutThreadInput
    pollPosts?: PollPostUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: ThreadUpdatepostIdsInput | string[]
    parentPostId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUpdateManyWithoutThreadNestedInput
    pollPosts?: PollPostUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: ThreadUpdatepostIdsInput | string[]
    parentPostId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUncheckedUpdateManyWithoutThreadNestedInput
    pollPosts?: PollPostUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type ThreadCreateManyInput = {
    id?: string
    postIds?: ThreadCreatepostIdsInput | string[]
    parentPostId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isLocked?: boolean
  }

  export type ThreadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: ThreadUpdatepostIdsInput | string[]
    parentPostId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ThreadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: ThreadUpdatepostIdsInput | string[]
    parentPostId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NoteCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaCreateNestedOneWithoutNotesInput
    post: PostCreateNestedOneWithoutNotesInput
    comment?: CommentCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    commentId?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaUpdateOneWithoutNotesNestedInput
    post?: PostUpdateOneRequiredWithoutNotesNestedInput
    comment?: CommentUpdateOneWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NoteCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    commentId?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SpaceMemberCreateInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    status?: string
    permissions?: SpaceMemberCreatepermissionsInput | string[]
    space: SpaceCreateNestedOneWithoutMembersInput
  }

  export type SpaceMemberUncheckedCreateInput = {
    id?: string
    spaceId: string
    userId: string
    role: string
    joinedAt?: Date | string
    status?: string
    permissions?: SpaceMemberCreatepermissionsInput | string[]
  }

  export type SpaceMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    permissions?: SpaceMemberUpdatepermissionsInput | string[]
    space?: SpaceUpdateOneRequiredWithoutMembersNestedInput
  }

  export type SpaceMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    spaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    permissions?: SpaceMemberUpdatepermissionsInput | string[]
  }

  export type SpaceMemberCreateManyInput = {
    id?: string
    spaceId: string
    userId: string
    role: string
    joinedAt?: Date | string
    status?: string
    permissions?: SpaceMemberCreatepermissionsInput | string[]
  }

  export type SpaceMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    permissions?: SpaceMemberUpdatepermissionsInput | string[]
  }

  export type SpaceMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    spaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    permissions?: SpaceMemberUpdatepermissionsInput | string[]
  }

  export type ChannelMemberCreateInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    lastRead?: Date | string | null
    channel: ChannelCreateNestedOneWithoutMembersInput
  }

  export type ChannelMemberUncheckedCreateInput = {
    id?: string
    channelId: string
    userId: string
    role: string
    joinedAt?: Date | string
    lastRead?: Date | string | null
  }

  export type ChannelMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: ChannelUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ChannelMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelMemberCreateManyInput = {
    id?: string
    channelId: string
    userId: string
    role: string
    joinedAt?: Date | string
    lastRead?: Date | string | null
  }

  export type ChannelMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileCreateInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    posts?: PostCreateNestedManyWithoutFilesInput
    space?: SpaceCreateNestedOneWithoutFilesInput
    channel?: ChannelCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    spaceId?: string | null
    channelId?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutFilesInput
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    posts?: PostUpdateManyWithoutFilesNestedInput
    space?: SpaceUpdateOneWithoutFilesNestedInput
    channel?: ChannelUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutFilesNestedInput
  }

  export type FileCreateManyInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    spaceId?: string | null
    channelId?: string | null
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserProfileListRelationFilter = {
    every?: UserProfileWhereInput
    some?: UserProfileWhereInput
    none?: UserProfileWhereInput
  }

  export type CommunityProfileListRelationFilter = {
    every?: CommunityProfileWhereInput
    some?: CommunityProfileWhereInput
    none?: CommunityProfileWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VirtualProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileType?: SortOrder
    activated?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VirtualProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileType?: SortOrder
    activated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VirtualProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileType?: SortOrder
    activated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type VirtualProfileRelationFilter = {
    is?: VirtualProfileWhereInput
    isNot?: VirtualProfileWhereInput
  }

  export type BookmarkListRelationFilter = {
    every?: BookmarkWhereInput
    some?: BookmarkWhereInput
    none?: BookmarkWhereInput
  }

  export type UserTagListRelationFilter = {
    every?: UserTagWhereInput
    some?: UserTagWhereInput
    none?: UserTagWhereInput
  }

  export type PublicationListRelationFilter = {
    every?: PublicationWhereInput
    some?: PublicationWhereInput
    none?: PublicationWhereInput
  }

  export type BlockListRelationFilter = {
    every?: BlockWhereInput
    some?: BlockWhereInput
    none?: BlockWhereInput
  }

  export type FollowListRelationFilter = {
    every?: FollowWhereInput
    some?: FollowWhereInput
    none?: FollowWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type ReactionListRelationFilter = {
    every?: ReactionWhereInput
    some?: ReactionWhereInput
    none?: ReactionWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type BookmarkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PublicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    virtualProfileId?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    bio?: SortOrder
    private?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    newsFeedTimelineId?: SortOrder
    personalFeedTimelineId?: SortOrder
    notificationFeedTimelineId?: SortOrder
    algoliaId?: SortOrder
    metadata?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileAvgOrderByAggregateInput = {
    followersCount?: SortOrder
    followingCount?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    virtualProfileId?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    bio?: SortOrder
    private?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    newsFeedTimelineId?: SortOrder
    personalFeedTimelineId?: SortOrder
    notificationFeedTimelineId?: SortOrder
    algoliaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    virtualProfileId?: SortOrder
    name?: SortOrder
    profileImageUrl?: SortOrder
    bio?: SortOrder
    private?: SortOrder
    followersCount?: SortOrder
    followingCount?: SortOrder
    newsFeedTimelineId?: SortOrder
    personalFeedTimelineId?: SortOrder
    notificationFeedTimelineId?: SortOrder
    algoliaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileSumOrderByAggregateInput = {
    followersCount?: SortOrder
    followingCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type TopicListRelationFilter = {
    every?: TopicWhereInput
    some?: TopicWhereInput
    none?: TopicWhereInput
  }

  export type TopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityProfileCountOrderByAggregateInput = {
    id?: SortOrder
    virtualProfileId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    communityRules?: SortOrder
    profileImageUrl?: SortOrder
    private?: SortOrder
    visible?: SortOrder
    followers?: SortOrder
    newsFeedTimelineId?: SortOrder
    personalFeedTimelineId?: SortOrder
    notificationFeedTimelineId?: SortOrder
    algoliaId?: SortOrder
    metadata?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityProfileAvgOrderByAggregateInput = {
    followers?: SortOrder
  }

  export type CommunityProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    virtualProfileId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    communityRules?: SortOrder
    profileImageUrl?: SortOrder
    private?: SortOrder
    visible?: SortOrder
    followers?: SortOrder
    newsFeedTimelineId?: SortOrder
    personalFeedTimelineId?: SortOrder
    notificationFeedTimelineId?: SortOrder
    algoliaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityProfileMinOrderByAggregateInput = {
    id?: SortOrder
    virtualProfileId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    communityRules?: SortOrder
    profileImageUrl?: SortOrder
    private?: SortOrder
    visible?: SortOrder
    followers?: SortOrder
    newsFeedTimelineId?: SortOrder
    personalFeedTimelineId?: SortOrder
    notificationFeedTimelineId?: SortOrder
    algoliaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityProfileSumOrderByAggregateInput = {
    followers?: SortOrder
  }

  export type CommunityProfileRelationFilter = {
    is?: CommunityProfileWhereInput
    isNot?: CommunityProfileWhereInput
  }

  export type TopicCountOrderByAggregateInput = {
    id?: SortOrder
    communityProfileId?: SortOrder
    topicName?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicMaxOrderByAggregateInput = {
    id?: SortOrder
    communityProfileId?: SortOrder
    topicName?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicMinOrderByAggregateInput = {
    id?: SortOrder
    communityProfileId?: SortOrder
    topicName?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type PublicationCountOrderByAggregateInput = {
    id?: SortOrder
    publicationName?: SortOrder
    description?: SortOrder
    type?: SortOrder
    postIds?: SortOrder
    subjects?: SortOrder
    tags?: SortOrder
    adminBackendPlatformUserId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PublicationMaxOrderByAggregateInput = {
    id?: SortOrder
    publicationName?: SortOrder
    description?: SortOrder
    type?: SortOrder
    adminBackendPlatformUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PublicationMinOrderByAggregateInput = {
    id?: SortOrder
    publicationName?: SortOrder
    description?: SortOrder
    type?: SortOrder
    adminBackendPlatformUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type CommentReplyListRelationFilter = {
    every?: CommentReplyWhereInput
    some?: CommentReplyWhereInput
    none?: CommentReplyWhereInput
  }

  export type PollPostListRelationFilter = {
    every?: PollPostWhereInput
    some?: PollPostWhereInput
    none?: PollPostWhereInput
  }

  export type NoteListRelationFilter = {
    every?: NoteWhereInput
    some?: NoteWhereInput
    none?: NoteWhereInput
  }

  export type CommentReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PollPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    mediaType?: SortOrder
    status?: SortOrder
    fileContent?: SortOrder
    fileName?: SortOrder
    transcription?: SortOrder
    extractedText?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    mediaType?: SortOrder
    status?: SortOrder
    fileContent?: SortOrder
    fileName?: SortOrder
    transcription?: SortOrder
    extractedText?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    mediaType?: SortOrder
    status?: SortOrder
    fileContent?: SortOrder
    fileName?: SortOrder
    transcription?: SortOrder
    extractedText?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type EnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumPostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeFilter<$PrismaModel> | $Enums.PostType
  }

  export type EnumCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableFilter<$PrismaModel> | $Enums.Category | null
  }

  export type EnumThreadParticipantTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreadParticipantType | EnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ThreadParticipantType[] | ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ThreadParticipantType[] | ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumThreadParticipantTypeNullableFilter<$PrismaModel> | $Enums.ThreadParticipantType | null
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type EnumVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityFilter<$PrismaModel> | $Enums.Visibility
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type MediaNullableRelationFilter = {
    is?: MediaWhereInput | null
    isNot?: MediaWhereInput | null
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type UserProfileRelationFilter = {
    is?: UserProfileWhereInput
    isNot?: UserProfileWhereInput
  }

  export type CommunityProfileNullableRelationFilter = {
    is?: CommunityProfileWhereInput | null
    isNot?: CommunityProfileWhereInput | null
  }

  export type ThreadNullableRelationFilter = {
    is?: ThreadWhereInput | null
    isNot?: ThreadWhereInput | null
  }

  export type SpaceNullableRelationFilter = {
    is?: SpaceWhereInput | null
    isNot?: SpaceWhereInput | null
  }

  export type ChannelNullableRelationFilter = {
    is?: ChannelWhereInput | null
    isNot?: ChannelWhereInput | null
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    communityId?: SortOrder
    parentSpaceId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    description?: SortOrder
    status?: SortOrder
    workflowStatus?: SortOrder
    assignedTo?: SortOrder
    contentFormat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    postType?: SortOrder
    category?: SortOrder
    threadParticipantType?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    tags?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    topicName?: SortOrder
    mediaId?: SortOrder
    backgroundImageUrl?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    userIdToAffinityScoreMap?: SortOrder
    userIdToReportsMap?: SortOrder
    userIdToReactionMap?: SortOrder
    insights?: SortOrder
    readingTime?: SortOrder
    aiGeneratedQuestionResponse?: SortOrder
    aiAnalysis?: SortOrder
    searchMetadata?: SortOrder
    metadata?: SortOrder
    threadId?: SortOrder
    spaceId?: SortOrder
    channelId?: SortOrder
    extra?: SortOrder
    visibility?: SortOrder
    isPinned?: SortOrder
    isArchived?: SortOrder
    workflow?: SortOrder
    version?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    profileId?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    version?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    communityId?: SortOrder
    parentSpaceId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    description?: SortOrder
    status?: SortOrder
    workflowStatus?: SortOrder
    assignedTo?: SortOrder
    contentFormat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    postType?: SortOrder
    category?: SortOrder
    threadParticipantType?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    topicName?: SortOrder
    mediaId?: SortOrder
    backgroundImageUrl?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    readingTime?: SortOrder
    aiGeneratedQuestionResponse?: SortOrder
    threadId?: SortOrder
    spaceId?: SortOrder
    channelId?: SortOrder
    visibility?: SortOrder
    isPinned?: SortOrder
    isArchived?: SortOrder
    version?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    communityId?: SortOrder
    parentSpaceId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    description?: SortOrder
    status?: SortOrder
    workflowStatus?: SortOrder
    assignedTo?: SortOrder
    contentFormat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    postType?: SortOrder
    category?: SortOrder
    threadParticipantType?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    topicName?: SortOrder
    mediaId?: SortOrder
    backgroundImageUrl?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    readingTime?: SortOrder
    aiGeneratedQuestionResponse?: SortOrder
    threadId?: SortOrder
    spaceId?: SortOrder
    channelId?: SortOrder
    visibility?: SortOrder
    isPinned?: SortOrder
    isArchived?: SortOrder
    version?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    profileId?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    version?: SortOrder
  }

  export type EnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumPostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeWithAggregatesFilter<$PrismaModel> | $Enums.PostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostTypeFilter<$PrismaModel>
    _max?: NestedEnumPostTypeFilter<$PrismaModel>
  }

  export type EnumCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.Category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumCategoryNullableFilter<$PrismaModel>
  }

  export type EnumThreadParticipantTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreadParticipantType | EnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ThreadParticipantType[] | ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ThreadParticipantType[] | ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumThreadParticipantTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ThreadParticipantType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumThreadParticipantTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumThreadParticipantTypeNullableFilter<$PrismaModel>
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type EnumVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.Visibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisibilityFilter<$PrismaModel>
    _max?: NestedEnumVisibilityFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PollPostCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    content?: SortOrder
    title?: SortOrder
    pollOptions?: SortOrder
    pollDistribution?: SortOrder
    userIdToPollResponsesMap?: SortOrder
    pollEndDate?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    tags?: SortOrder
    topicName?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    mediaId?: SortOrder
    threadId?: SortOrder
    extra?: SortOrder
    searchMetadata?: SortOrder
    aiAnalysis?: SortOrder
  }

  export type PollPostAvgOrderByAggregateInput = {
    profileId?: SortOrder
  }

  export type PollPostMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    content?: SortOrder
    title?: SortOrder
    pollEndDate?: SortOrder
    topicName?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    mediaId?: SortOrder
    threadId?: SortOrder
  }

  export type PollPostMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    content?: SortOrder
    title?: SortOrder
    pollEndDate?: SortOrder
    topicName?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    mediaId?: SortOrder
    threadId?: SortOrder
  }

  export type PollPostSumOrderByAggregateInput = {
    profileId?: SortOrder
  }

  export type PostRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type PollPostNullableRelationFilter = {
    is?: PollPostWhereInput | null
    isNot?: PollPostWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    userIdToAffinityScoreMap?: SortOrder
    userIdToReportsMap?: SortOrder
    userIdToReactionMap?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    mediaId?: SortOrder
    postId?: SortOrder
    pollPostId?: SortOrder
    extra?: SortOrder
    aiAnalysis?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    profileId?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    mediaId?: SortOrder
    postId?: SortOrder
    pollPostId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    mediaId?: SortOrder
    postId?: SortOrder
    pollPostId?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    profileId?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
  }

  export type CommentRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type CommentReplyCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    userIdToAffinityScoreMap?: SortOrder
    userIdToReportsMap?: SortOrder
    userIdToReactionMap?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    mediaId?: SortOrder
    commentId?: SortOrder
    extra?: SortOrder
    aiAnalysis?: SortOrder
  }

  export type CommentReplyAvgOrderByAggregateInput = {
    profileId?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
  }

  export type CommentReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    mediaId?: SortOrder
    commentId?: SortOrder
  }

  export type CommentReplyMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    mediaId?: SortOrder
    commentId?: SortOrder
  }

  export type CommentReplySumOrderByAggregateInput = {
    profileId?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
  }

  export type EnumReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeFilter<$PrismaModel> | $Enums.ReactionType
  }

  export type PostNullableRelationFilter = {
    is?: PostWhereInput | null
    isNot?: PostWhereInput | null
  }

  export type CommentNullableRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type ReactionUserIdPostIdCommentIdTypeCompoundUniqueInput = {
    userId: string
    postId: string
    commentId: string
    type: $Enums.ReactionType
  }

  export type ReactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ReactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeFilter<$PrismaModel>
  }

  export type BookmarkCountOrderByAggregateInput = {
    id?: SortOrder
    postIds?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookmarkMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookmarkMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockProfileBlockingIdProfileBlockedIdCompoundUniqueInput = {
    profileBlockingId: string
    profileBlockedId: string
  }

  export type BlockCountOrderByAggregateInput = {
    id?: SortOrder
    profileBlockingId?: SortOrder
    profileBlockedId?: SortOrder
    profileBlockingType?: SortOrder
    profileBlockedType?: SortOrder
    reason?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockMaxOrderByAggregateInput = {
    id?: SortOrder
    profileBlockingId?: SortOrder
    profileBlockedId?: SortOrder
    profileBlockingType?: SortOrder
    profileBlockedType?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockMinOrderByAggregateInput = {
    id?: SortOrder
    profileBlockingId?: SortOrder
    profileBlockedId?: SortOrder
    profileBlockingType?: SortOrder
    profileBlockedType?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowProfileFollowingIdProfileFollowedIdCompoundUniqueInput = {
    profileFollowingId: string
    profileFollowedId: string
  }

  export type FollowCountOrderByAggregateInput = {
    id?: SortOrder
    profileFollowingId?: SortOrder
    profileFollowedId?: SortOrder
    targetFollowerType?: SortOrder
    requestApproved?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
  }

  export type FollowMaxOrderByAggregateInput = {
    id?: SortOrder
    profileFollowingId?: SortOrder
    profileFollowedId?: SortOrder
    targetFollowerType?: SortOrder
    requestApproved?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
  }

  export type FollowMinOrderByAggregateInput = {
    id?: SortOrder
    profileFollowingId?: SortOrder
    profileFollowedId?: SortOrder
    targetFollowerType?: SortOrder
    requestApproved?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
  }

  export type UserTagCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    tagName?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTagMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    tagName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTagMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    tagName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReportReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportReason | EnumReportReasonFieldRefInput<$PrismaModel>
    in?: $Enums.ReportReason[] | ListEnumReportReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportReason[] | ListEnumReportReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumReportReasonFilter<$PrismaModel> | $Enums.ReportReason
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type UserProfileNullableRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    submitterId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    submitterId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    submitterId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type EnumReportReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportReason | EnumReportReasonFieldRefInput<$PrismaModel>
    in?: $Enums.ReportReason[] | ListEnumReportReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportReason[] | ListEnumReportReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumReportReasonWithAggregatesFilter<$PrismaModel> | $Enums.ReportReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportReasonFilter<$PrismaModel>
    _max?: NestedEnumReportReasonFilter<$PrismaModel>
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumSpaceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SpaceType | EnumSpaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SpaceType[] | ListEnumSpaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpaceType[] | ListEnumSpaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpaceTypeFilter<$PrismaModel> | $Enums.SpaceType
  }

  export type EnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }

  export type SpaceMemberListRelationFilter = {
    every?: SpaceMemberWhereInput
    some?: SpaceMemberWhereInput
    none?: SpaceMemberWhereInput
  }

  export type ChannelListRelationFilter = {
    every?: ChannelWhereInput
    some?: ChannelWhereInput
    none?: ChannelWhereInput
  }

  export type SpaceListRelationFilter = {
    every?: SpaceWhereInput
    some?: SpaceWhereInput
    none?: SpaceWhereInput
  }

  export type SpaceMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    spaceType?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    parentSpaceId?: SortOrder
    isPrivate?: SortOrder
    metadata?: SortOrder
    settings?: SortOrder
    accessLevel?: SortOrder
    searchMetadata?: SortOrder
    tags?: SortOrder
  }

  export type SpaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    spaceType?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    parentSpaceId?: SortOrder
    isPrivate?: SortOrder
    accessLevel?: SortOrder
  }

  export type SpaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    spaceType?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    parentSpaceId?: SortOrder
    isPrivate?: SortOrder
    accessLevel?: SortOrder
  }

  export type EnumSpaceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SpaceType | EnumSpaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SpaceType[] | ListEnumSpaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpaceType[] | ListEnumSpaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpaceTypeWithAggregatesFilter<$PrismaModel> | $Enums.SpaceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpaceTypeFilter<$PrismaModel>
    _max?: NestedEnumSpaceTypeFilter<$PrismaModel>
  }

  export type EnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }

  export type SpaceRelationFilter = {
    is?: SpaceWhereInput
    isNot?: SpaceWhereInput
  }

  export type ChannelMemberListRelationFilter = {
    every?: ChannelMemberWhereInput
    some?: ChannelMemberWhereInput
    none?: ChannelMemberWhereInput
  }

  export type ChannelMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    spaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    pinnedPosts?: SortOrder
    isPrivate?: SortOrder
    metadata?: SortOrder
    settings?: SortOrder
  }

  export type ChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    spaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    isPrivate?: SortOrder
  }

  export type ChannelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    spaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    isPrivate?: SortOrder
  }

  export type ThreadCountOrderByAggregateInput = {
    id?: SortOrder
    postIds?: SortOrder
    parentPostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
    status?: SortOrder
    isLocked?: SortOrder
  }

  export type ThreadMaxOrderByAggregateInput = {
    id?: SortOrder
    parentPostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    isLocked?: SortOrder
  }

  export type ThreadMinOrderByAggregateInput = {
    id?: SortOrder
    parentPostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    isLocked?: SortOrder
  }

  export type NoteCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    authorId?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUserName?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    mediaId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    searchMetadata?: SortOrder
    aiAnalysis?: SortOrder
  }

  export type NoteAvgOrderByAggregateInput = {
    profileId?: SortOrder
  }

  export type NoteMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    authorId?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUserName?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    mediaId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
  }

  export type NoteMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    authorId?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUserName?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    mediaId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
  }

  export type NoteSumOrderByAggregateInput = {
    profileId?: SortOrder
  }

  export type SpaceMemberSpaceIdUserIdCompoundUniqueInput = {
    spaceId: string
    userId: string
  }

  export type SpaceMemberCountOrderByAggregateInput = {
    id?: SortOrder
    spaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    permissions?: SortOrder
  }

  export type SpaceMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    spaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
  }

  export type SpaceMemberMinOrderByAggregateInput = {
    id?: SortOrder
    spaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
  }

  export type ChannelRelationFilter = {
    is?: ChannelWhereInput
    isNot?: ChannelWhereInput
  }

  export type ChannelMemberChannelIdUserIdCompoundUniqueInput = {
    channelId: string
    userId: string
  }

  export type ChannelMemberCountOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    lastRead?: SortOrder
  }

  export type ChannelMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    lastRead?: SortOrder
  }

  export type ChannelMemberMinOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    lastRead?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    metadata?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    size?: SortOrder
    status?: SortOrder
    preview?: SortOrder
    thumbnail?: SortOrder
    searchMetadata?: SortOrder
    aiAnalysis?: SortOrder
    spaceId?: SortOrder
    channelId?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    size?: SortOrder
    status?: SortOrder
    preview?: SortOrder
    thumbnail?: SortOrder
    spaceId?: SortOrder
    channelId?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    size?: SortOrder
    status?: SortOrder
    preview?: SortOrder
    thumbnail?: SortOrder
    spaceId?: SortOrder
    channelId?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type UserProfileCreateNestedManyWithoutVirtualProfileInput = {
    create?: XOR<UserProfileCreateWithoutVirtualProfileInput, UserProfileUncheckedCreateWithoutVirtualProfileInput> | UserProfileCreateWithoutVirtualProfileInput[] | UserProfileUncheckedCreateWithoutVirtualProfileInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutVirtualProfileInput | UserProfileCreateOrConnectWithoutVirtualProfileInput[]
    createMany?: UserProfileCreateManyVirtualProfileInputEnvelope
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
  }

  export type CommunityProfileCreateNestedManyWithoutVirtualProfileInput = {
    create?: XOR<CommunityProfileCreateWithoutVirtualProfileInput, CommunityProfileUncheckedCreateWithoutVirtualProfileInput> | CommunityProfileCreateWithoutVirtualProfileInput[] | CommunityProfileUncheckedCreateWithoutVirtualProfileInput[]
    connectOrCreate?: CommunityProfileCreateOrConnectWithoutVirtualProfileInput | CommunityProfileCreateOrConnectWithoutVirtualProfileInput[]
    createMany?: CommunityProfileCreateManyVirtualProfileInputEnvelope
    connect?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedManyWithoutVirtualProfileInput = {
    create?: XOR<UserProfileCreateWithoutVirtualProfileInput, UserProfileUncheckedCreateWithoutVirtualProfileInput> | UserProfileCreateWithoutVirtualProfileInput[] | UserProfileUncheckedCreateWithoutVirtualProfileInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutVirtualProfileInput | UserProfileCreateOrConnectWithoutVirtualProfileInput[]
    createMany?: UserProfileCreateManyVirtualProfileInputEnvelope
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
  }

  export type CommunityProfileUncheckedCreateNestedManyWithoutVirtualProfileInput = {
    create?: XOR<CommunityProfileCreateWithoutVirtualProfileInput, CommunityProfileUncheckedCreateWithoutVirtualProfileInput> | CommunityProfileCreateWithoutVirtualProfileInput[] | CommunityProfileUncheckedCreateWithoutVirtualProfileInput[]
    connectOrCreate?: CommunityProfileCreateOrConnectWithoutVirtualProfileInput | CommunityProfileCreateOrConnectWithoutVirtualProfileInput[]
    createMany?: CommunityProfileCreateManyVirtualProfileInputEnvelope
    connect?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserProfileUpdateManyWithoutVirtualProfileNestedInput = {
    create?: XOR<UserProfileCreateWithoutVirtualProfileInput, UserProfileUncheckedCreateWithoutVirtualProfileInput> | UserProfileCreateWithoutVirtualProfileInput[] | UserProfileUncheckedCreateWithoutVirtualProfileInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutVirtualProfileInput | UserProfileCreateOrConnectWithoutVirtualProfileInput[]
    upsert?: UserProfileUpsertWithWhereUniqueWithoutVirtualProfileInput | UserProfileUpsertWithWhereUniqueWithoutVirtualProfileInput[]
    createMany?: UserProfileCreateManyVirtualProfileInputEnvelope
    set?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    disconnect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    delete?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    update?: UserProfileUpdateWithWhereUniqueWithoutVirtualProfileInput | UserProfileUpdateWithWhereUniqueWithoutVirtualProfileInput[]
    updateMany?: UserProfileUpdateManyWithWhereWithoutVirtualProfileInput | UserProfileUpdateManyWithWhereWithoutVirtualProfileInput[]
    deleteMany?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
  }

  export type CommunityProfileUpdateManyWithoutVirtualProfileNestedInput = {
    create?: XOR<CommunityProfileCreateWithoutVirtualProfileInput, CommunityProfileUncheckedCreateWithoutVirtualProfileInput> | CommunityProfileCreateWithoutVirtualProfileInput[] | CommunityProfileUncheckedCreateWithoutVirtualProfileInput[]
    connectOrCreate?: CommunityProfileCreateOrConnectWithoutVirtualProfileInput | CommunityProfileCreateOrConnectWithoutVirtualProfileInput[]
    upsert?: CommunityProfileUpsertWithWhereUniqueWithoutVirtualProfileInput | CommunityProfileUpsertWithWhereUniqueWithoutVirtualProfileInput[]
    createMany?: CommunityProfileCreateManyVirtualProfileInputEnvelope
    set?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
    disconnect?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
    delete?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
    connect?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
    update?: CommunityProfileUpdateWithWhereUniqueWithoutVirtualProfileInput | CommunityProfileUpdateWithWhereUniqueWithoutVirtualProfileInput[]
    updateMany?: CommunityProfileUpdateManyWithWhereWithoutVirtualProfileInput | CommunityProfileUpdateManyWithWhereWithoutVirtualProfileInput[]
    deleteMany?: CommunityProfileScalarWhereInput | CommunityProfileScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateManyWithoutVirtualProfileNestedInput = {
    create?: XOR<UserProfileCreateWithoutVirtualProfileInput, UserProfileUncheckedCreateWithoutVirtualProfileInput> | UserProfileCreateWithoutVirtualProfileInput[] | UserProfileUncheckedCreateWithoutVirtualProfileInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutVirtualProfileInput | UserProfileCreateOrConnectWithoutVirtualProfileInput[]
    upsert?: UserProfileUpsertWithWhereUniqueWithoutVirtualProfileInput | UserProfileUpsertWithWhereUniqueWithoutVirtualProfileInput[]
    createMany?: UserProfileCreateManyVirtualProfileInputEnvelope
    set?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    disconnect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    delete?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    update?: UserProfileUpdateWithWhereUniqueWithoutVirtualProfileInput | UserProfileUpdateWithWhereUniqueWithoutVirtualProfileInput[]
    updateMany?: UserProfileUpdateManyWithWhereWithoutVirtualProfileInput | UserProfileUpdateManyWithWhereWithoutVirtualProfileInput[]
    deleteMany?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
  }

  export type CommunityProfileUncheckedUpdateManyWithoutVirtualProfileNestedInput = {
    create?: XOR<CommunityProfileCreateWithoutVirtualProfileInput, CommunityProfileUncheckedCreateWithoutVirtualProfileInput> | CommunityProfileCreateWithoutVirtualProfileInput[] | CommunityProfileUncheckedCreateWithoutVirtualProfileInput[]
    connectOrCreate?: CommunityProfileCreateOrConnectWithoutVirtualProfileInput | CommunityProfileCreateOrConnectWithoutVirtualProfileInput[]
    upsert?: CommunityProfileUpsertWithWhereUniqueWithoutVirtualProfileInput | CommunityProfileUpsertWithWhereUniqueWithoutVirtualProfileInput[]
    createMany?: CommunityProfileCreateManyVirtualProfileInputEnvelope
    set?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
    disconnect?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
    delete?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
    connect?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
    update?: CommunityProfileUpdateWithWhereUniqueWithoutVirtualProfileInput | CommunityProfileUpdateWithWhereUniqueWithoutVirtualProfileInput[]
    updateMany?: CommunityProfileUpdateManyWithWhereWithoutVirtualProfileInput | CommunityProfileUpdateManyWithWhereWithoutVirtualProfileInput[]
    deleteMany?: CommunityProfileScalarWhereInput | CommunityProfileScalarWhereInput[]
  }

  export type VirtualProfileCreateNestedOneWithoutUserProfileInput = {
    create?: XOR<VirtualProfileCreateWithoutUserProfileInput, VirtualProfileUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: VirtualProfileCreateOrConnectWithoutUserProfileInput
    connect?: VirtualProfileWhereUniqueInput
  }

  export type BookmarkCreateNestedManyWithoutUsersInput = {
    create?: XOR<BookmarkCreateWithoutUsersInput, BookmarkUncheckedCreateWithoutUsersInput> | BookmarkCreateWithoutUsersInput[] | BookmarkUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUsersInput | BookmarkCreateOrConnectWithoutUsersInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type UserTagCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<UserTagCreateWithoutUserProfileInput, UserTagUncheckedCreateWithoutUserProfileInput> | UserTagCreateWithoutUserProfileInput[] | UserTagUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: UserTagCreateOrConnectWithoutUserProfileInput | UserTagCreateOrConnectWithoutUserProfileInput[]
    createMany?: UserTagCreateManyUserProfileInputEnvelope
    connect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
  }

  export type PublicationCreateNestedManyWithoutAdminsInput = {
    create?: XOR<PublicationCreateWithoutAdminsInput, PublicationUncheckedCreateWithoutAdminsInput> | PublicationCreateWithoutAdminsInput[] | PublicationUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutAdminsInput | PublicationCreateOrConnectWithoutAdminsInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
  }

  export type PublicationCreateNestedManyWithoutEditorsInput = {
    create?: XOR<PublicationCreateWithoutEditorsInput, PublicationUncheckedCreateWithoutEditorsInput> | PublicationCreateWithoutEditorsInput[] | PublicationUncheckedCreateWithoutEditorsInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutEditorsInput | PublicationCreateOrConnectWithoutEditorsInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
  }

  export type BlockCreateNestedManyWithoutBlockedProfileInput = {
    create?: XOR<BlockCreateWithoutBlockedProfileInput, BlockUncheckedCreateWithoutBlockedProfileInput> | BlockCreateWithoutBlockedProfileInput[] | BlockUncheckedCreateWithoutBlockedProfileInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedProfileInput | BlockCreateOrConnectWithoutBlockedProfileInput[]
    createMany?: BlockCreateManyBlockedProfileInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockCreateNestedManyWithoutBlockingProfileInput = {
    create?: XOR<BlockCreateWithoutBlockingProfileInput, BlockUncheckedCreateWithoutBlockingProfileInput> | BlockCreateWithoutBlockingProfileInput[] | BlockUncheckedCreateWithoutBlockingProfileInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockingProfileInput | BlockCreateOrConnectWithoutBlockingProfileInput[]
    createMany?: BlockCreateManyBlockingProfileInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowedProfileInput = {
    create?: XOR<FollowCreateWithoutFollowedProfileInput, FollowUncheckedCreateWithoutFollowedProfileInput> | FollowCreateWithoutFollowedProfileInput[] | FollowUncheckedCreateWithoutFollowedProfileInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowedProfileInput | FollowCreateOrConnectWithoutFollowedProfileInput[]
    createMany?: FollowCreateManyFollowedProfileInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowingProfileInput = {
    create?: XOR<FollowCreateWithoutFollowingProfileInput, FollowUncheckedCreateWithoutFollowingProfileInput> | FollowCreateWithoutFollowingProfileInput[] | FollowUncheckedCreateWithoutFollowingProfileInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingProfileInput | FollowCreateOrConnectWithoutFollowingProfileInput[]
    createMany?: FollowCreateManyFollowingProfileInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<CommentCreateWithoutUserProfileInput, CommentUncheckedCreateWithoutUserProfileInput> | CommentCreateWithoutUserProfileInput[] | CommentUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserProfileInput | CommentCreateOrConnectWithoutUserProfileInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReactionCreateNestedManyWithoutUserInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutSubmitterInput = {
    create?: XOR<ReportCreateWithoutSubmitterInput, ReportUncheckedCreateWithoutSubmitterInput> | ReportCreateWithoutSubmitterInput[] | ReportUncheckedCreateWithoutSubmitterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutSubmitterInput | ReportCreateOrConnectWithoutSubmitterInput[]
    createMany?: ReportCreateManySubmitterInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutReportedUserInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type CommunityProfileCreateNestedManyWithoutModeratorsInput = {
    create?: XOR<CommunityProfileCreateWithoutModeratorsInput, CommunityProfileUncheckedCreateWithoutModeratorsInput> | CommunityProfileCreateWithoutModeratorsInput[] | CommunityProfileUncheckedCreateWithoutModeratorsInput[]
    connectOrCreate?: CommunityProfileCreateOrConnectWithoutModeratorsInput | CommunityProfileCreateOrConnectWithoutModeratorsInput[]
    connect?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
  }

  export type BookmarkUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<BookmarkCreateWithoutUsersInput, BookmarkUncheckedCreateWithoutUsersInput> | BookmarkCreateWithoutUsersInput[] | BookmarkUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUsersInput | BookmarkCreateOrConnectWithoutUsersInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type UserTagUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<UserTagCreateWithoutUserProfileInput, UserTagUncheckedCreateWithoutUserProfileInput> | UserTagCreateWithoutUserProfileInput[] | UserTagUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: UserTagCreateOrConnectWithoutUserProfileInput | UserTagCreateOrConnectWithoutUserProfileInput[]
    createMany?: UserTagCreateManyUserProfileInputEnvelope
    connect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
  }

  export type PublicationUncheckedCreateNestedManyWithoutAdminsInput = {
    create?: XOR<PublicationCreateWithoutAdminsInput, PublicationUncheckedCreateWithoutAdminsInput> | PublicationCreateWithoutAdminsInput[] | PublicationUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutAdminsInput | PublicationCreateOrConnectWithoutAdminsInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
  }

  export type PublicationUncheckedCreateNestedManyWithoutEditorsInput = {
    create?: XOR<PublicationCreateWithoutEditorsInput, PublicationUncheckedCreateWithoutEditorsInput> | PublicationCreateWithoutEditorsInput[] | PublicationUncheckedCreateWithoutEditorsInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutEditorsInput | PublicationCreateOrConnectWithoutEditorsInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutBlockedProfileInput = {
    create?: XOR<BlockCreateWithoutBlockedProfileInput, BlockUncheckedCreateWithoutBlockedProfileInput> | BlockCreateWithoutBlockedProfileInput[] | BlockUncheckedCreateWithoutBlockedProfileInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedProfileInput | BlockCreateOrConnectWithoutBlockedProfileInput[]
    createMany?: BlockCreateManyBlockedProfileInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutBlockingProfileInput = {
    create?: XOR<BlockCreateWithoutBlockingProfileInput, BlockUncheckedCreateWithoutBlockingProfileInput> | BlockCreateWithoutBlockingProfileInput[] | BlockUncheckedCreateWithoutBlockingProfileInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockingProfileInput | BlockCreateOrConnectWithoutBlockingProfileInput[]
    createMany?: BlockCreateManyBlockingProfileInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowedProfileInput = {
    create?: XOR<FollowCreateWithoutFollowedProfileInput, FollowUncheckedCreateWithoutFollowedProfileInput> | FollowCreateWithoutFollowedProfileInput[] | FollowUncheckedCreateWithoutFollowedProfileInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowedProfileInput | FollowCreateOrConnectWithoutFollowedProfileInput[]
    createMany?: FollowCreateManyFollowedProfileInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowingProfileInput = {
    create?: XOR<FollowCreateWithoutFollowingProfileInput, FollowUncheckedCreateWithoutFollowingProfileInput> | FollowCreateWithoutFollowingProfileInput[] | FollowUncheckedCreateWithoutFollowingProfileInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingProfileInput | FollowCreateOrConnectWithoutFollowingProfileInput[]
    createMany?: FollowCreateManyFollowingProfileInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<CommentCreateWithoutUserProfileInput, CommentUncheckedCreateWithoutUserProfileInput> | CommentCreateWithoutUserProfileInput[] | CommentUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserProfileInput | CommentCreateOrConnectWithoutUserProfileInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutSubmitterInput = {
    create?: XOR<ReportCreateWithoutSubmitterInput, ReportUncheckedCreateWithoutSubmitterInput> | ReportCreateWithoutSubmitterInput[] | ReportUncheckedCreateWithoutSubmitterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutSubmitterInput | ReportCreateOrConnectWithoutSubmitterInput[]
    createMany?: ReportCreateManySubmitterInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReportedUserInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput = {
    create?: XOR<CommunityProfileCreateWithoutModeratorsInput, CommunityProfileUncheckedCreateWithoutModeratorsInput> | CommunityProfileCreateWithoutModeratorsInput[] | CommunityProfileUncheckedCreateWithoutModeratorsInput[]
    connectOrCreate?: CommunityProfileCreateOrConnectWithoutModeratorsInput | CommunityProfileCreateOrConnectWithoutModeratorsInput[]
    connect?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput = {
    create?: XOR<VirtualProfileCreateWithoutUserProfileInput, VirtualProfileUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: VirtualProfileCreateOrConnectWithoutUserProfileInput
    upsert?: VirtualProfileUpsertWithoutUserProfileInput
    connect?: VirtualProfileWhereUniqueInput
    update?: XOR<XOR<VirtualProfileUpdateToOneWithWhereWithoutUserProfileInput, VirtualProfileUpdateWithoutUserProfileInput>, VirtualProfileUncheckedUpdateWithoutUserProfileInput>
  }

  export type BookmarkUpdateManyWithoutUsersNestedInput = {
    create?: XOR<BookmarkCreateWithoutUsersInput, BookmarkUncheckedCreateWithoutUsersInput> | BookmarkCreateWithoutUsersInput[] | BookmarkUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUsersInput | BookmarkCreateOrConnectWithoutUsersInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutUsersInput | BookmarkUpsertWithWhereUniqueWithoutUsersInput[]
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutUsersInput | BookmarkUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutUsersInput | BookmarkUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type UserTagUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<UserTagCreateWithoutUserProfileInput, UserTagUncheckedCreateWithoutUserProfileInput> | UserTagCreateWithoutUserProfileInput[] | UserTagUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: UserTagCreateOrConnectWithoutUserProfileInput | UserTagCreateOrConnectWithoutUserProfileInput[]
    upsert?: UserTagUpsertWithWhereUniqueWithoutUserProfileInput | UserTagUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: UserTagCreateManyUserProfileInputEnvelope
    set?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    disconnect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    delete?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    connect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    update?: UserTagUpdateWithWhereUniqueWithoutUserProfileInput | UserTagUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: UserTagUpdateManyWithWhereWithoutUserProfileInput | UserTagUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: UserTagScalarWhereInput | UserTagScalarWhereInput[]
  }

  export type PublicationUpdateManyWithoutAdminsNestedInput = {
    create?: XOR<PublicationCreateWithoutAdminsInput, PublicationUncheckedCreateWithoutAdminsInput> | PublicationCreateWithoutAdminsInput[] | PublicationUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutAdminsInput | PublicationCreateOrConnectWithoutAdminsInput[]
    upsert?: PublicationUpsertWithWhereUniqueWithoutAdminsInput | PublicationUpsertWithWhereUniqueWithoutAdminsInput[]
    set?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    disconnect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    delete?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    update?: PublicationUpdateWithWhereUniqueWithoutAdminsInput | PublicationUpdateWithWhereUniqueWithoutAdminsInput[]
    updateMany?: PublicationUpdateManyWithWhereWithoutAdminsInput | PublicationUpdateManyWithWhereWithoutAdminsInput[]
    deleteMany?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
  }

  export type PublicationUpdateManyWithoutEditorsNestedInput = {
    create?: XOR<PublicationCreateWithoutEditorsInput, PublicationUncheckedCreateWithoutEditorsInput> | PublicationCreateWithoutEditorsInput[] | PublicationUncheckedCreateWithoutEditorsInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutEditorsInput | PublicationCreateOrConnectWithoutEditorsInput[]
    upsert?: PublicationUpsertWithWhereUniqueWithoutEditorsInput | PublicationUpsertWithWhereUniqueWithoutEditorsInput[]
    set?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    disconnect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    delete?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    update?: PublicationUpdateWithWhereUniqueWithoutEditorsInput | PublicationUpdateWithWhereUniqueWithoutEditorsInput[]
    updateMany?: PublicationUpdateManyWithWhereWithoutEditorsInput | PublicationUpdateManyWithWhereWithoutEditorsInput[]
    deleteMany?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
  }

  export type BlockUpdateManyWithoutBlockedProfileNestedInput = {
    create?: XOR<BlockCreateWithoutBlockedProfileInput, BlockUncheckedCreateWithoutBlockedProfileInput> | BlockCreateWithoutBlockedProfileInput[] | BlockUncheckedCreateWithoutBlockedProfileInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedProfileInput | BlockCreateOrConnectWithoutBlockedProfileInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockedProfileInput | BlockUpsertWithWhereUniqueWithoutBlockedProfileInput[]
    createMany?: BlockCreateManyBlockedProfileInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockedProfileInput | BlockUpdateWithWhereUniqueWithoutBlockedProfileInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockedProfileInput | BlockUpdateManyWithWhereWithoutBlockedProfileInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUpdateManyWithoutBlockingProfileNestedInput = {
    create?: XOR<BlockCreateWithoutBlockingProfileInput, BlockUncheckedCreateWithoutBlockingProfileInput> | BlockCreateWithoutBlockingProfileInput[] | BlockUncheckedCreateWithoutBlockingProfileInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockingProfileInput | BlockCreateOrConnectWithoutBlockingProfileInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockingProfileInput | BlockUpsertWithWhereUniqueWithoutBlockingProfileInput[]
    createMany?: BlockCreateManyBlockingProfileInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockingProfileInput | BlockUpdateWithWhereUniqueWithoutBlockingProfileInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockingProfileInput | BlockUpdateManyWithWhereWithoutBlockingProfileInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowedProfileNestedInput = {
    create?: XOR<FollowCreateWithoutFollowedProfileInput, FollowUncheckedCreateWithoutFollowedProfileInput> | FollowCreateWithoutFollowedProfileInput[] | FollowUncheckedCreateWithoutFollowedProfileInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowedProfileInput | FollowCreateOrConnectWithoutFollowedProfileInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowedProfileInput | FollowUpsertWithWhereUniqueWithoutFollowedProfileInput[]
    createMany?: FollowCreateManyFollowedProfileInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowedProfileInput | FollowUpdateWithWhereUniqueWithoutFollowedProfileInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowedProfileInput | FollowUpdateManyWithWhereWithoutFollowedProfileInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowingProfileNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingProfileInput, FollowUncheckedCreateWithoutFollowingProfileInput> | FollowCreateWithoutFollowingProfileInput[] | FollowUncheckedCreateWithoutFollowingProfileInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingProfileInput | FollowCreateOrConnectWithoutFollowingProfileInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingProfileInput | FollowUpsertWithWhereUniqueWithoutFollowingProfileInput[]
    createMany?: FollowCreateManyFollowingProfileInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingProfileInput | FollowUpdateWithWhereUniqueWithoutFollowingProfileInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingProfileInput | FollowUpdateManyWithWhereWithoutFollowingProfileInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<CommentCreateWithoutUserProfileInput, CommentUncheckedCreateWithoutUserProfileInput> | CommentCreateWithoutUserProfileInput[] | CommentUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserProfileInput | CommentCreateOrConnectWithoutUserProfileInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserProfileInput | CommentUpsertWithWhereUniqueWithoutUserProfileInput[]
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserProfileInput | CommentUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserProfileInput | CommentUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutUserInput | ReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutUserInput | ReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutUserInput | ReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutSubmitterNestedInput = {
    create?: XOR<ReportCreateWithoutSubmitterInput, ReportUncheckedCreateWithoutSubmitterInput> | ReportCreateWithoutSubmitterInput[] | ReportUncheckedCreateWithoutSubmitterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutSubmitterInput | ReportCreateOrConnectWithoutSubmitterInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutSubmitterInput | ReportUpsertWithWhereUniqueWithoutSubmitterInput[]
    createMany?: ReportCreateManySubmitterInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutSubmitterInput | ReportUpdateWithWhereUniqueWithoutSubmitterInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutSubmitterInput | ReportUpdateManyWithWhereWithoutSubmitterInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutReportedUserNestedInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedUserInput | ReportUpsertWithWhereUniqueWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedUserInput | ReportUpdateWithWhereUniqueWithoutReportedUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedUserInput | ReportUpdateManyWithWhereWithoutReportedUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type CommunityProfileUpdateManyWithoutModeratorsNestedInput = {
    create?: XOR<CommunityProfileCreateWithoutModeratorsInput, CommunityProfileUncheckedCreateWithoutModeratorsInput> | CommunityProfileCreateWithoutModeratorsInput[] | CommunityProfileUncheckedCreateWithoutModeratorsInput[]
    connectOrCreate?: CommunityProfileCreateOrConnectWithoutModeratorsInput | CommunityProfileCreateOrConnectWithoutModeratorsInput[]
    upsert?: CommunityProfileUpsertWithWhereUniqueWithoutModeratorsInput | CommunityProfileUpsertWithWhereUniqueWithoutModeratorsInput[]
    set?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
    disconnect?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
    delete?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
    connect?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
    update?: CommunityProfileUpdateWithWhereUniqueWithoutModeratorsInput | CommunityProfileUpdateWithWhereUniqueWithoutModeratorsInput[]
    updateMany?: CommunityProfileUpdateManyWithWhereWithoutModeratorsInput | CommunityProfileUpdateManyWithWhereWithoutModeratorsInput[]
    deleteMany?: CommunityProfileScalarWhereInput | CommunityProfileScalarWhereInput[]
  }

  export type BookmarkUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<BookmarkCreateWithoutUsersInput, BookmarkUncheckedCreateWithoutUsersInput> | BookmarkCreateWithoutUsersInput[] | BookmarkUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUsersInput | BookmarkCreateOrConnectWithoutUsersInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutUsersInput | BookmarkUpsertWithWhereUniqueWithoutUsersInput[]
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutUsersInput | BookmarkUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutUsersInput | BookmarkUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type UserTagUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<UserTagCreateWithoutUserProfileInput, UserTagUncheckedCreateWithoutUserProfileInput> | UserTagCreateWithoutUserProfileInput[] | UserTagUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: UserTagCreateOrConnectWithoutUserProfileInput | UserTagCreateOrConnectWithoutUserProfileInput[]
    upsert?: UserTagUpsertWithWhereUniqueWithoutUserProfileInput | UserTagUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: UserTagCreateManyUserProfileInputEnvelope
    set?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    disconnect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    delete?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    connect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    update?: UserTagUpdateWithWhereUniqueWithoutUserProfileInput | UserTagUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: UserTagUpdateManyWithWhereWithoutUserProfileInput | UserTagUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: UserTagScalarWhereInput | UserTagScalarWhereInput[]
  }

  export type PublicationUncheckedUpdateManyWithoutAdminsNestedInput = {
    create?: XOR<PublicationCreateWithoutAdminsInput, PublicationUncheckedCreateWithoutAdminsInput> | PublicationCreateWithoutAdminsInput[] | PublicationUncheckedCreateWithoutAdminsInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutAdminsInput | PublicationCreateOrConnectWithoutAdminsInput[]
    upsert?: PublicationUpsertWithWhereUniqueWithoutAdminsInput | PublicationUpsertWithWhereUniqueWithoutAdminsInput[]
    set?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    disconnect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    delete?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    update?: PublicationUpdateWithWhereUniqueWithoutAdminsInput | PublicationUpdateWithWhereUniqueWithoutAdminsInput[]
    updateMany?: PublicationUpdateManyWithWhereWithoutAdminsInput | PublicationUpdateManyWithWhereWithoutAdminsInput[]
    deleteMany?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
  }

  export type PublicationUncheckedUpdateManyWithoutEditorsNestedInput = {
    create?: XOR<PublicationCreateWithoutEditorsInput, PublicationUncheckedCreateWithoutEditorsInput> | PublicationCreateWithoutEditorsInput[] | PublicationUncheckedCreateWithoutEditorsInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutEditorsInput | PublicationCreateOrConnectWithoutEditorsInput[]
    upsert?: PublicationUpsertWithWhereUniqueWithoutEditorsInput | PublicationUpsertWithWhereUniqueWithoutEditorsInput[]
    set?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    disconnect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    delete?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    update?: PublicationUpdateWithWhereUniqueWithoutEditorsInput | PublicationUpdateWithWhereUniqueWithoutEditorsInput[]
    updateMany?: PublicationUpdateManyWithWhereWithoutEditorsInput | PublicationUpdateManyWithWhereWithoutEditorsInput[]
    deleteMany?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput = {
    create?: XOR<BlockCreateWithoutBlockedProfileInput, BlockUncheckedCreateWithoutBlockedProfileInput> | BlockCreateWithoutBlockedProfileInput[] | BlockUncheckedCreateWithoutBlockedProfileInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedProfileInput | BlockCreateOrConnectWithoutBlockedProfileInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockedProfileInput | BlockUpsertWithWhereUniqueWithoutBlockedProfileInput[]
    createMany?: BlockCreateManyBlockedProfileInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockedProfileInput | BlockUpdateWithWhereUniqueWithoutBlockedProfileInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockedProfileInput | BlockUpdateManyWithWhereWithoutBlockedProfileInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput = {
    create?: XOR<BlockCreateWithoutBlockingProfileInput, BlockUncheckedCreateWithoutBlockingProfileInput> | BlockCreateWithoutBlockingProfileInput[] | BlockUncheckedCreateWithoutBlockingProfileInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockingProfileInput | BlockCreateOrConnectWithoutBlockingProfileInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockingProfileInput | BlockUpsertWithWhereUniqueWithoutBlockingProfileInput[]
    createMany?: BlockCreateManyBlockingProfileInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockingProfileInput | BlockUpdateWithWhereUniqueWithoutBlockingProfileInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockingProfileInput | BlockUpdateManyWithWhereWithoutBlockingProfileInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput = {
    create?: XOR<FollowCreateWithoutFollowedProfileInput, FollowUncheckedCreateWithoutFollowedProfileInput> | FollowCreateWithoutFollowedProfileInput[] | FollowUncheckedCreateWithoutFollowedProfileInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowedProfileInput | FollowCreateOrConnectWithoutFollowedProfileInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowedProfileInput | FollowUpsertWithWhereUniqueWithoutFollowedProfileInput[]
    createMany?: FollowCreateManyFollowedProfileInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowedProfileInput | FollowUpdateWithWhereUniqueWithoutFollowedProfileInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowedProfileInput | FollowUpdateManyWithWhereWithoutFollowedProfileInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingProfileInput, FollowUncheckedCreateWithoutFollowingProfileInput> | FollowCreateWithoutFollowingProfileInput[] | FollowUncheckedCreateWithoutFollowingProfileInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingProfileInput | FollowCreateOrConnectWithoutFollowingProfileInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingProfileInput | FollowUpsertWithWhereUniqueWithoutFollowingProfileInput[]
    createMany?: FollowCreateManyFollowingProfileInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingProfileInput | FollowUpdateWithWhereUniqueWithoutFollowingProfileInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingProfileInput | FollowUpdateManyWithWhereWithoutFollowingProfileInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<CommentCreateWithoutUserProfileInput, CommentUncheckedCreateWithoutUserProfileInput> | CommentCreateWithoutUserProfileInput[] | CommentUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserProfileInput | CommentCreateOrConnectWithoutUserProfileInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserProfileInput | CommentUpsertWithWhereUniqueWithoutUserProfileInput[]
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserProfileInput | CommentUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserProfileInput | CommentUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutUserInput | ReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutUserInput | ReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutUserInput | ReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutSubmitterNestedInput = {
    create?: XOR<ReportCreateWithoutSubmitterInput, ReportUncheckedCreateWithoutSubmitterInput> | ReportCreateWithoutSubmitterInput[] | ReportUncheckedCreateWithoutSubmitterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutSubmitterInput | ReportCreateOrConnectWithoutSubmitterInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutSubmitterInput | ReportUpsertWithWhereUniqueWithoutSubmitterInput[]
    createMany?: ReportCreateManySubmitterInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutSubmitterInput | ReportUpdateWithWhereUniqueWithoutSubmitterInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutSubmitterInput | ReportUpdateManyWithWhereWithoutSubmitterInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReportedUserNestedInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedUserInput | ReportUpsertWithWhereUniqueWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedUserInput | ReportUpdateWithWhereUniqueWithoutReportedUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedUserInput | ReportUpdateManyWithWhereWithoutReportedUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput = {
    create?: XOR<CommunityProfileCreateWithoutModeratorsInput, CommunityProfileUncheckedCreateWithoutModeratorsInput> | CommunityProfileCreateWithoutModeratorsInput[] | CommunityProfileUncheckedCreateWithoutModeratorsInput[]
    connectOrCreate?: CommunityProfileCreateOrConnectWithoutModeratorsInput | CommunityProfileCreateOrConnectWithoutModeratorsInput[]
    upsert?: CommunityProfileUpsertWithWhereUniqueWithoutModeratorsInput | CommunityProfileUpsertWithWhereUniqueWithoutModeratorsInput[]
    set?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
    disconnect?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
    delete?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
    connect?: CommunityProfileWhereUniqueInput | CommunityProfileWhereUniqueInput[]
    update?: CommunityProfileUpdateWithWhereUniqueWithoutModeratorsInput | CommunityProfileUpdateWithWhereUniqueWithoutModeratorsInput[]
    updateMany?: CommunityProfileUpdateManyWithWhereWithoutModeratorsInput | CommunityProfileUpdateManyWithWhereWithoutModeratorsInput[]
    deleteMany?: CommunityProfileScalarWhereInput | CommunityProfileScalarWhereInput[]
  }

  export type VirtualProfileCreateNestedOneWithoutCommunityProfileInput = {
    create?: XOR<VirtualProfileCreateWithoutCommunityProfileInput, VirtualProfileUncheckedCreateWithoutCommunityProfileInput>
    connectOrCreate?: VirtualProfileCreateOrConnectWithoutCommunityProfileInput
    connect?: VirtualProfileWhereUniqueInput
  }

  export type TopicCreateNestedManyWithoutCommunityProfileInput = {
    create?: XOR<TopicCreateWithoutCommunityProfileInput, TopicUncheckedCreateWithoutCommunityProfileInput> | TopicCreateWithoutCommunityProfileInput[] | TopicUncheckedCreateWithoutCommunityProfileInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutCommunityProfileInput | TopicCreateOrConnectWithoutCommunityProfileInput[]
    createMany?: TopicCreateManyCommunityProfileInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutCommunityInput = {
    create?: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput> | PostCreateWithoutCommunityInput[] | PostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCommunityInput | PostCreateOrConnectWithoutCommunityInput[]
    createMany?: PostCreateManyCommunityInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type UserProfileCreateNestedManyWithoutModeratedCommunitiesInput = {
    create?: XOR<UserProfileCreateWithoutModeratedCommunitiesInput, UserProfileUncheckedCreateWithoutModeratedCommunitiesInput> | UserProfileCreateWithoutModeratedCommunitiesInput[] | UserProfileUncheckedCreateWithoutModeratedCommunitiesInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutModeratedCommunitiesInput | UserProfileCreateOrConnectWithoutModeratedCommunitiesInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutCommunityProfileInput = {
    create?: XOR<TopicCreateWithoutCommunityProfileInput, TopicUncheckedCreateWithoutCommunityProfileInput> | TopicCreateWithoutCommunityProfileInput[] | TopicUncheckedCreateWithoutCommunityProfileInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutCommunityProfileInput | TopicCreateOrConnectWithoutCommunityProfileInput[]
    createMany?: TopicCreateManyCommunityProfileInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput> | PostCreateWithoutCommunityInput[] | PostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCommunityInput | PostCreateOrConnectWithoutCommunityInput[]
    createMany?: PostCreateManyCommunityInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedManyWithoutModeratedCommunitiesInput = {
    create?: XOR<UserProfileCreateWithoutModeratedCommunitiesInput, UserProfileUncheckedCreateWithoutModeratedCommunitiesInput> | UserProfileCreateWithoutModeratedCommunitiesInput[] | UserProfileUncheckedCreateWithoutModeratedCommunitiesInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutModeratedCommunitiesInput | UserProfileCreateOrConnectWithoutModeratedCommunitiesInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
  }

  export type VirtualProfileUpdateOneRequiredWithoutCommunityProfileNestedInput = {
    create?: XOR<VirtualProfileCreateWithoutCommunityProfileInput, VirtualProfileUncheckedCreateWithoutCommunityProfileInput>
    connectOrCreate?: VirtualProfileCreateOrConnectWithoutCommunityProfileInput
    upsert?: VirtualProfileUpsertWithoutCommunityProfileInput
    connect?: VirtualProfileWhereUniqueInput
    update?: XOR<XOR<VirtualProfileUpdateToOneWithWhereWithoutCommunityProfileInput, VirtualProfileUpdateWithoutCommunityProfileInput>, VirtualProfileUncheckedUpdateWithoutCommunityProfileInput>
  }

  export type TopicUpdateManyWithoutCommunityProfileNestedInput = {
    create?: XOR<TopicCreateWithoutCommunityProfileInput, TopicUncheckedCreateWithoutCommunityProfileInput> | TopicCreateWithoutCommunityProfileInput[] | TopicUncheckedCreateWithoutCommunityProfileInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutCommunityProfileInput | TopicCreateOrConnectWithoutCommunityProfileInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutCommunityProfileInput | TopicUpsertWithWhereUniqueWithoutCommunityProfileInput[]
    createMany?: TopicCreateManyCommunityProfileInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutCommunityProfileInput | TopicUpdateWithWhereUniqueWithoutCommunityProfileInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutCommunityProfileInput | TopicUpdateManyWithWhereWithoutCommunityProfileInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type PostUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput> | PostCreateWithoutCommunityInput[] | PostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCommunityInput | PostCreateOrConnectWithoutCommunityInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutCommunityInput | PostUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: PostCreateManyCommunityInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutCommunityInput | PostUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: PostUpdateManyWithWhereWithoutCommunityInput | PostUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type UserProfileUpdateManyWithoutModeratedCommunitiesNestedInput = {
    create?: XOR<UserProfileCreateWithoutModeratedCommunitiesInput, UserProfileUncheckedCreateWithoutModeratedCommunitiesInput> | UserProfileCreateWithoutModeratedCommunitiesInput[] | UserProfileUncheckedCreateWithoutModeratedCommunitiesInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutModeratedCommunitiesInput | UserProfileCreateOrConnectWithoutModeratedCommunitiesInput[]
    upsert?: UserProfileUpsertWithWhereUniqueWithoutModeratedCommunitiesInput | UserProfileUpsertWithWhereUniqueWithoutModeratedCommunitiesInput[]
    set?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    disconnect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    delete?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    update?: UserProfileUpdateWithWhereUniqueWithoutModeratedCommunitiesInput | UserProfileUpdateWithWhereUniqueWithoutModeratedCommunitiesInput[]
    updateMany?: UserProfileUpdateManyWithWhereWithoutModeratedCommunitiesInput | UserProfileUpdateManyWithWhereWithoutModeratedCommunitiesInput[]
    deleteMany?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutCommunityProfileNestedInput = {
    create?: XOR<TopicCreateWithoutCommunityProfileInput, TopicUncheckedCreateWithoutCommunityProfileInput> | TopicCreateWithoutCommunityProfileInput[] | TopicUncheckedCreateWithoutCommunityProfileInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutCommunityProfileInput | TopicCreateOrConnectWithoutCommunityProfileInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutCommunityProfileInput | TopicUpsertWithWhereUniqueWithoutCommunityProfileInput[]
    createMany?: TopicCreateManyCommunityProfileInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutCommunityProfileInput | TopicUpdateWithWhereUniqueWithoutCommunityProfileInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutCommunityProfileInput | TopicUpdateManyWithWhereWithoutCommunityProfileInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput> | PostCreateWithoutCommunityInput[] | PostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCommunityInput | PostCreateOrConnectWithoutCommunityInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutCommunityInput | PostUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: PostCreateManyCommunityInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutCommunityInput | PostUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: PostUpdateManyWithWhereWithoutCommunityInput | PostUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateManyWithoutModeratedCommunitiesNestedInput = {
    create?: XOR<UserProfileCreateWithoutModeratedCommunitiesInput, UserProfileUncheckedCreateWithoutModeratedCommunitiesInput> | UserProfileCreateWithoutModeratedCommunitiesInput[] | UserProfileUncheckedCreateWithoutModeratedCommunitiesInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutModeratedCommunitiesInput | UserProfileCreateOrConnectWithoutModeratedCommunitiesInput[]
    upsert?: UserProfileUpsertWithWhereUniqueWithoutModeratedCommunitiesInput | UserProfileUpsertWithWhereUniqueWithoutModeratedCommunitiesInput[]
    set?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    disconnect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    delete?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    update?: UserProfileUpdateWithWhereUniqueWithoutModeratedCommunitiesInput | UserProfileUpdateWithWhereUniqueWithoutModeratedCommunitiesInput[]
    updateMany?: UserProfileUpdateManyWithWhereWithoutModeratedCommunitiesInput | UserProfileUpdateManyWithWhereWithoutModeratedCommunitiesInput[]
    deleteMany?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
  }

  export type CommunityProfileCreateNestedOneWithoutTopicsInput = {
    create?: XOR<CommunityProfileCreateWithoutTopicsInput, CommunityProfileUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: CommunityProfileCreateOrConnectWithoutTopicsInput
    connect?: CommunityProfileWhereUniqueInput
  }

  export type CommunityProfileUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<CommunityProfileCreateWithoutTopicsInput, CommunityProfileUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: CommunityProfileCreateOrConnectWithoutTopicsInput
    upsert?: CommunityProfileUpsertWithoutTopicsInput
    connect?: CommunityProfileWhereUniqueInput
    update?: XOR<XOR<CommunityProfileUpdateToOneWithWhereWithoutTopicsInput, CommunityProfileUpdateWithoutTopicsInput>, CommunityProfileUncheckedUpdateWithoutTopicsInput>
  }

  export type PublicationCreatepostIdsInput = {
    set: string[]
  }

  export type PublicationCreatesubjectsInput = {
    set: string[]
  }

  export type PublicationCreatetagsInput = {
    set: string[]
  }

  export type BookmarkCreateNestedManyWithoutPublicationsInput = {
    create?: XOR<BookmarkCreateWithoutPublicationsInput, BookmarkUncheckedCreateWithoutPublicationsInput> | BookmarkCreateWithoutPublicationsInput[] | BookmarkUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutPublicationsInput | BookmarkCreateOrConnectWithoutPublicationsInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type UserProfileCreateNestedManyWithoutAdminPublicationsInput = {
    create?: XOR<UserProfileCreateWithoutAdminPublicationsInput, UserProfileUncheckedCreateWithoutAdminPublicationsInput> | UserProfileCreateWithoutAdminPublicationsInput[] | UserProfileUncheckedCreateWithoutAdminPublicationsInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutAdminPublicationsInput | UserProfileCreateOrConnectWithoutAdminPublicationsInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
  }

  export type UserProfileCreateNestedManyWithoutEditorPublicationsInput = {
    create?: XOR<UserProfileCreateWithoutEditorPublicationsInput, UserProfileUncheckedCreateWithoutEditorPublicationsInput> | UserProfileCreateWithoutEditorPublicationsInput[] | UserProfileUncheckedCreateWithoutEditorPublicationsInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutEditorPublicationsInput | UserProfileCreateOrConnectWithoutEditorPublicationsInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutPublicationsInput = {
    create?: XOR<PostCreateWithoutPublicationsInput, PostUncheckedCreateWithoutPublicationsInput> | PostCreateWithoutPublicationsInput[] | PostUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutPublicationsInput | PostCreateOrConnectWithoutPublicationsInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type BookmarkUncheckedCreateNestedManyWithoutPublicationsInput = {
    create?: XOR<BookmarkCreateWithoutPublicationsInput, BookmarkUncheckedCreateWithoutPublicationsInput> | BookmarkCreateWithoutPublicationsInput[] | BookmarkUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutPublicationsInput | BookmarkCreateOrConnectWithoutPublicationsInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedManyWithoutAdminPublicationsInput = {
    create?: XOR<UserProfileCreateWithoutAdminPublicationsInput, UserProfileUncheckedCreateWithoutAdminPublicationsInput> | UserProfileCreateWithoutAdminPublicationsInput[] | UserProfileUncheckedCreateWithoutAdminPublicationsInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutAdminPublicationsInput | UserProfileCreateOrConnectWithoutAdminPublicationsInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedManyWithoutEditorPublicationsInput = {
    create?: XOR<UserProfileCreateWithoutEditorPublicationsInput, UserProfileUncheckedCreateWithoutEditorPublicationsInput> | UserProfileCreateWithoutEditorPublicationsInput[] | UserProfileUncheckedCreateWithoutEditorPublicationsInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutEditorPublicationsInput | UserProfileCreateOrConnectWithoutEditorPublicationsInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutPublicationsInput = {
    create?: XOR<PostCreateWithoutPublicationsInput, PostUncheckedCreateWithoutPublicationsInput> | PostCreateWithoutPublicationsInput[] | PostUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutPublicationsInput | PostCreateOrConnectWithoutPublicationsInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PublicationUpdatepostIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PublicationUpdatesubjectsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PublicationUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BookmarkUpdateManyWithoutPublicationsNestedInput = {
    create?: XOR<BookmarkCreateWithoutPublicationsInput, BookmarkUncheckedCreateWithoutPublicationsInput> | BookmarkCreateWithoutPublicationsInput[] | BookmarkUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutPublicationsInput | BookmarkCreateOrConnectWithoutPublicationsInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutPublicationsInput | BookmarkUpsertWithWhereUniqueWithoutPublicationsInput[]
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutPublicationsInput | BookmarkUpdateWithWhereUniqueWithoutPublicationsInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutPublicationsInput | BookmarkUpdateManyWithWhereWithoutPublicationsInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type UserProfileUpdateManyWithoutAdminPublicationsNestedInput = {
    create?: XOR<UserProfileCreateWithoutAdminPublicationsInput, UserProfileUncheckedCreateWithoutAdminPublicationsInput> | UserProfileCreateWithoutAdminPublicationsInput[] | UserProfileUncheckedCreateWithoutAdminPublicationsInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutAdminPublicationsInput | UserProfileCreateOrConnectWithoutAdminPublicationsInput[]
    upsert?: UserProfileUpsertWithWhereUniqueWithoutAdminPublicationsInput | UserProfileUpsertWithWhereUniqueWithoutAdminPublicationsInput[]
    set?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    disconnect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    delete?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    update?: UserProfileUpdateWithWhereUniqueWithoutAdminPublicationsInput | UserProfileUpdateWithWhereUniqueWithoutAdminPublicationsInput[]
    updateMany?: UserProfileUpdateManyWithWhereWithoutAdminPublicationsInput | UserProfileUpdateManyWithWhereWithoutAdminPublicationsInput[]
    deleteMany?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
  }

  export type UserProfileUpdateManyWithoutEditorPublicationsNestedInput = {
    create?: XOR<UserProfileCreateWithoutEditorPublicationsInput, UserProfileUncheckedCreateWithoutEditorPublicationsInput> | UserProfileCreateWithoutEditorPublicationsInput[] | UserProfileUncheckedCreateWithoutEditorPublicationsInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutEditorPublicationsInput | UserProfileCreateOrConnectWithoutEditorPublicationsInput[]
    upsert?: UserProfileUpsertWithWhereUniqueWithoutEditorPublicationsInput | UserProfileUpsertWithWhereUniqueWithoutEditorPublicationsInput[]
    set?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    disconnect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    delete?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    update?: UserProfileUpdateWithWhereUniqueWithoutEditorPublicationsInput | UserProfileUpdateWithWhereUniqueWithoutEditorPublicationsInput[]
    updateMany?: UserProfileUpdateManyWithWhereWithoutEditorPublicationsInput | UserProfileUpdateManyWithWhereWithoutEditorPublicationsInput[]
    deleteMany?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
  }

  export type PostUpdateManyWithoutPublicationsNestedInput = {
    create?: XOR<PostCreateWithoutPublicationsInput, PostUncheckedCreateWithoutPublicationsInput> | PostCreateWithoutPublicationsInput[] | PostUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutPublicationsInput | PostCreateOrConnectWithoutPublicationsInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutPublicationsInput | PostUpsertWithWhereUniqueWithoutPublicationsInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutPublicationsInput | PostUpdateWithWhereUniqueWithoutPublicationsInput[]
    updateMany?: PostUpdateManyWithWhereWithoutPublicationsInput | PostUpdateManyWithWhereWithoutPublicationsInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type BookmarkUncheckedUpdateManyWithoutPublicationsNestedInput = {
    create?: XOR<BookmarkCreateWithoutPublicationsInput, BookmarkUncheckedCreateWithoutPublicationsInput> | BookmarkCreateWithoutPublicationsInput[] | BookmarkUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutPublicationsInput | BookmarkCreateOrConnectWithoutPublicationsInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutPublicationsInput | BookmarkUpsertWithWhereUniqueWithoutPublicationsInput[]
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutPublicationsInput | BookmarkUpdateWithWhereUniqueWithoutPublicationsInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutPublicationsInput | BookmarkUpdateManyWithWhereWithoutPublicationsInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateManyWithoutAdminPublicationsNestedInput = {
    create?: XOR<UserProfileCreateWithoutAdminPublicationsInput, UserProfileUncheckedCreateWithoutAdminPublicationsInput> | UserProfileCreateWithoutAdminPublicationsInput[] | UserProfileUncheckedCreateWithoutAdminPublicationsInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutAdminPublicationsInput | UserProfileCreateOrConnectWithoutAdminPublicationsInput[]
    upsert?: UserProfileUpsertWithWhereUniqueWithoutAdminPublicationsInput | UserProfileUpsertWithWhereUniqueWithoutAdminPublicationsInput[]
    set?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    disconnect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    delete?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    update?: UserProfileUpdateWithWhereUniqueWithoutAdminPublicationsInput | UserProfileUpdateWithWhereUniqueWithoutAdminPublicationsInput[]
    updateMany?: UserProfileUpdateManyWithWhereWithoutAdminPublicationsInput | UserProfileUpdateManyWithWhereWithoutAdminPublicationsInput[]
    deleteMany?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateManyWithoutEditorPublicationsNestedInput = {
    create?: XOR<UserProfileCreateWithoutEditorPublicationsInput, UserProfileUncheckedCreateWithoutEditorPublicationsInput> | UserProfileCreateWithoutEditorPublicationsInput[] | UserProfileUncheckedCreateWithoutEditorPublicationsInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutEditorPublicationsInput | UserProfileCreateOrConnectWithoutEditorPublicationsInput[]
    upsert?: UserProfileUpsertWithWhereUniqueWithoutEditorPublicationsInput | UserProfileUpsertWithWhereUniqueWithoutEditorPublicationsInput[]
    set?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    disconnect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    delete?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    update?: UserProfileUpdateWithWhereUniqueWithoutEditorPublicationsInput | UserProfileUpdateWithWhereUniqueWithoutEditorPublicationsInput[]
    updateMany?: UserProfileUpdateManyWithWhereWithoutEditorPublicationsInput | UserProfileUpdateManyWithWhereWithoutEditorPublicationsInput[]
    deleteMany?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutPublicationsNestedInput = {
    create?: XOR<PostCreateWithoutPublicationsInput, PostUncheckedCreateWithoutPublicationsInput> | PostCreateWithoutPublicationsInput[] | PostUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutPublicationsInput | PostCreateOrConnectWithoutPublicationsInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutPublicationsInput | PostUpsertWithWhereUniqueWithoutPublicationsInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutPublicationsInput | PostUpdateWithWhereUniqueWithoutPublicationsInput[]
    updateMany?: PostUpdateManyWithWhereWithoutPublicationsInput | PostUpdateManyWithWhereWithoutPublicationsInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentReplyCreateNestedManyWithoutMediaInput = {
    create?: XOR<CommentReplyCreateWithoutMediaInput, CommentReplyUncheckedCreateWithoutMediaInput> | CommentReplyCreateWithoutMediaInput[] | CommentReplyUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutMediaInput | CommentReplyCreateOrConnectWithoutMediaInput[]
    createMany?: CommentReplyCreateManyMediaInputEnvelope
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutMediaInput = {
    create?: XOR<PostCreateWithoutMediaInput, PostUncheckedCreateWithoutMediaInput> | PostCreateWithoutMediaInput[] | PostUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: PostCreateOrConnectWithoutMediaInput | PostCreateOrConnectWithoutMediaInput[]
    createMany?: PostCreateManyMediaInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutMediaInput = {
    create?: XOR<CommentCreateWithoutMediaInput, CommentUncheckedCreateWithoutMediaInput> | CommentCreateWithoutMediaInput[] | CommentUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutMediaInput | CommentCreateOrConnectWithoutMediaInput[]
    createMany?: CommentCreateManyMediaInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PollPostCreateNestedManyWithoutMediaInput = {
    create?: XOR<PollPostCreateWithoutMediaInput, PollPostUncheckedCreateWithoutMediaInput> | PollPostCreateWithoutMediaInput[] | PollPostUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: PollPostCreateOrConnectWithoutMediaInput | PollPostCreateOrConnectWithoutMediaInput[]
    createMany?: PollPostCreateManyMediaInputEnvelope
    connect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutMediaInput = {
    create?: XOR<NoteCreateWithoutMediaInput, NoteUncheckedCreateWithoutMediaInput> | NoteCreateWithoutMediaInput[] | NoteUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutMediaInput | NoteCreateOrConnectWithoutMediaInput[]
    createMany?: NoteCreateManyMediaInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type CommentReplyUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<CommentReplyCreateWithoutMediaInput, CommentReplyUncheckedCreateWithoutMediaInput> | CommentReplyCreateWithoutMediaInput[] | CommentReplyUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutMediaInput | CommentReplyCreateOrConnectWithoutMediaInput[]
    createMany?: CommentReplyCreateManyMediaInputEnvelope
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<PostCreateWithoutMediaInput, PostUncheckedCreateWithoutMediaInput> | PostCreateWithoutMediaInput[] | PostUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: PostCreateOrConnectWithoutMediaInput | PostCreateOrConnectWithoutMediaInput[]
    createMany?: PostCreateManyMediaInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<CommentCreateWithoutMediaInput, CommentUncheckedCreateWithoutMediaInput> | CommentCreateWithoutMediaInput[] | CommentUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutMediaInput | CommentCreateOrConnectWithoutMediaInput[]
    createMany?: CommentCreateManyMediaInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PollPostUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<PollPostCreateWithoutMediaInput, PollPostUncheckedCreateWithoutMediaInput> | PollPostCreateWithoutMediaInput[] | PollPostUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: PollPostCreateOrConnectWithoutMediaInput | PollPostCreateOrConnectWithoutMediaInput[]
    createMany?: PollPostCreateManyMediaInputEnvelope
    connect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<NoteCreateWithoutMediaInput, NoteUncheckedCreateWithoutMediaInput> | NoteCreateWithoutMediaInput[] | NoteUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutMediaInput | NoteCreateOrConnectWithoutMediaInput[]
    createMany?: NoteCreateManyMediaInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type CommentReplyUpdateManyWithoutMediaNestedInput = {
    create?: XOR<CommentReplyCreateWithoutMediaInput, CommentReplyUncheckedCreateWithoutMediaInput> | CommentReplyCreateWithoutMediaInput[] | CommentReplyUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutMediaInput | CommentReplyCreateOrConnectWithoutMediaInput[]
    upsert?: CommentReplyUpsertWithWhereUniqueWithoutMediaInput | CommentReplyUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: CommentReplyCreateManyMediaInputEnvelope
    set?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    disconnect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    delete?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    update?: CommentReplyUpdateWithWhereUniqueWithoutMediaInput | CommentReplyUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: CommentReplyUpdateManyWithWhereWithoutMediaInput | CommentReplyUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
  }

  export type PostUpdateManyWithoutMediaNestedInput = {
    create?: XOR<PostCreateWithoutMediaInput, PostUncheckedCreateWithoutMediaInput> | PostCreateWithoutMediaInput[] | PostUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: PostCreateOrConnectWithoutMediaInput | PostCreateOrConnectWithoutMediaInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutMediaInput | PostUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: PostCreateManyMediaInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutMediaInput | PostUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: PostUpdateManyWithWhereWithoutMediaInput | PostUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutMediaNestedInput = {
    create?: XOR<CommentCreateWithoutMediaInput, CommentUncheckedCreateWithoutMediaInput> | CommentCreateWithoutMediaInput[] | CommentUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutMediaInput | CommentCreateOrConnectWithoutMediaInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutMediaInput | CommentUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: CommentCreateManyMediaInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutMediaInput | CommentUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutMediaInput | CommentUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PollPostUpdateManyWithoutMediaNestedInput = {
    create?: XOR<PollPostCreateWithoutMediaInput, PollPostUncheckedCreateWithoutMediaInput> | PollPostCreateWithoutMediaInput[] | PollPostUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: PollPostCreateOrConnectWithoutMediaInput | PollPostCreateOrConnectWithoutMediaInput[]
    upsert?: PollPostUpsertWithWhereUniqueWithoutMediaInput | PollPostUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: PollPostCreateManyMediaInputEnvelope
    set?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    disconnect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    delete?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    connect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    update?: PollPostUpdateWithWhereUniqueWithoutMediaInput | PollPostUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: PollPostUpdateManyWithWhereWithoutMediaInput | PollPostUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: PollPostScalarWhereInput | PollPostScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutMediaNestedInput = {
    create?: XOR<NoteCreateWithoutMediaInput, NoteUncheckedCreateWithoutMediaInput> | NoteCreateWithoutMediaInput[] | NoteUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutMediaInput | NoteCreateOrConnectWithoutMediaInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutMediaInput | NoteUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: NoteCreateManyMediaInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutMediaInput | NoteUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutMediaInput | NoteUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type CommentReplyUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<CommentReplyCreateWithoutMediaInput, CommentReplyUncheckedCreateWithoutMediaInput> | CommentReplyCreateWithoutMediaInput[] | CommentReplyUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutMediaInput | CommentReplyCreateOrConnectWithoutMediaInput[]
    upsert?: CommentReplyUpsertWithWhereUniqueWithoutMediaInput | CommentReplyUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: CommentReplyCreateManyMediaInputEnvelope
    set?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    disconnect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    delete?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    update?: CommentReplyUpdateWithWhereUniqueWithoutMediaInput | CommentReplyUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: CommentReplyUpdateManyWithWhereWithoutMediaInput | CommentReplyUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<PostCreateWithoutMediaInput, PostUncheckedCreateWithoutMediaInput> | PostCreateWithoutMediaInput[] | PostUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: PostCreateOrConnectWithoutMediaInput | PostCreateOrConnectWithoutMediaInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutMediaInput | PostUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: PostCreateManyMediaInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutMediaInput | PostUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: PostUpdateManyWithWhereWithoutMediaInput | PostUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<CommentCreateWithoutMediaInput, CommentUncheckedCreateWithoutMediaInput> | CommentCreateWithoutMediaInput[] | CommentUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutMediaInput | CommentCreateOrConnectWithoutMediaInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutMediaInput | CommentUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: CommentCreateManyMediaInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutMediaInput | CommentUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutMediaInput | CommentUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PollPostUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<PollPostCreateWithoutMediaInput, PollPostUncheckedCreateWithoutMediaInput> | PollPostCreateWithoutMediaInput[] | PollPostUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: PollPostCreateOrConnectWithoutMediaInput | PollPostCreateOrConnectWithoutMediaInput[]
    upsert?: PollPostUpsertWithWhereUniqueWithoutMediaInput | PollPostUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: PollPostCreateManyMediaInputEnvelope
    set?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    disconnect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    delete?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    connect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    update?: PollPostUpdateWithWhereUniqueWithoutMediaInput | PollPostUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: PollPostUpdateManyWithWhereWithoutMediaInput | PollPostUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: PollPostScalarWhereInput | PollPostScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<NoteCreateWithoutMediaInput, NoteUncheckedCreateWithoutMediaInput> | NoteCreateWithoutMediaInput[] | NoteUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutMediaInput | NoteCreateOrConnectWithoutMediaInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutMediaInput | NoteUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: NoteCreateManyMediaInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutMediaInput | NoteUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutMediaInput | NoteUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type PostCreatetagsInput = {
    set: string[]
  }

  export type PostCreatementionsInput = {
    set: string[]
  }

  export type PostCreatehashtagsInput = {
    set: string[]
  }

  export type MediaCreateNestedOneWithoutPostsInput = {
    create?: XOR<MediaCreateWithoutPostsInput, MediaUncheckedCreateWithoutPostsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutPostsInput
    connect?: MediaWhereUniqueInput
  }

  export type FileCreateNestedManyWithoutPostsInput = {
    create?: XOR<FileCreateWithoutPostsInput, FileUncheckedCreateWithoutPostsInput> | FileCreateWithoutPostsInput[] | FileUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: FileCreateOrConnectWithoutPostsInput | FileCreateOrConnectWithoutPostsInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type UserProfileCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserProfileCreateWithoutPostsInput, UserProfileUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutPostsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type CommunityProfileCreateNestedOneWithoutPostsInput = {
    create?: XOR<CommunityProfileCreateWithoutPostsInput, CommunityProfileUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CommunityProfileCreateOrConnectWithoutPostsInput
    connect?: CommunityProfileWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReactionCreateNestedManyWithoutPostInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput> | ReactionCreateWithoutPostInput[] | ReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput | ReactionCreateOrConnectWithoutPostInput[]
    createMany?: ReactionCreateManyPostInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type BookmarkCreateNestedManyWithoutPostsInput = {
    create?: XOR<BookmarkCreateWithoutPostsInput, BookmarkUncheckedCreateWithoutPostsInput> | BookmarkCreateWithoutPostsInput[] | BookmarkUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutPostsInput | BookmarkCreateOrConnectWithoutPostsInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type PublicationCreateNestedManyWithoutPostsInput = {
    create?: XOR<PublicationCreateWithoutPostsInput, PublicationUncheckedCreateWithoutPostsInput> | PublicationCreateWithoutPostsInput[] | PublicationUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutPostsInput | PublicationCreateOrConnectWithoutPostsInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutReportedPostInput = {
    create?: XOR<ReportCreateWithoutReportedPostInput, ReportUncheckedCreateWithoutReportedPostInput> | ReportCreateWithoutReportedPostInput[] | ReportUncheckedCreateWithoutReportedPostInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedPostInput | ReportCreateOrConnectWithoutReportedPostInput[]
    createMany?: ReportCreateManyReportedPostInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutPostInput = {
    create?: XOR<NoteCreateWithoutPostInput, NoteUncheckedCreateWithoutPostInput> | NoteCreateWithoutPostInput[] | NoteUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutPostInput | NoteCreateOrConnectWithoutPostInput[]
    createMany?: NoteCreateManyPostInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type ThreadCreateNestedOneWithoutPostsInput = {
    create?: XOR<ThreadCreateWithoutPostsInput, ThreadUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutPostsInput
    connect?: ThreadWhereUniqueInput
  }

  export type SpaceCreateNestedOneWithoutPostsInput = {
    create?: XOR<SpaceCreateWithoutPostsInput, SpaceUncheckedCreateWithoutPostsInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutPostsInput
    connect?: SpaceWhereUniqueInput
  }

  export type ChannelCreateNestedOneWithoutPostsInput = {
    create?: XOR<ChannelCreateWithoutPostsInput, ChannelUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutPostsInput
    connect?: ChannelWhereUniqueInput
  }

  export type FileUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<FileCreateWithoutPostsInput, FileUncheckedCreateWithoutPostsInput> | FileCreateWithoutPostsInput[] | FileUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: FileCreateOrConnectWithoutPostsInput | FileCreateOrConnectWithoutPostsInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReactionUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput> | ReactionCreateWithoutPostInput[] | ReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput | ReactionCreateOrConnectWithoutPostInput[]
    createMany?: ReactionCreateManyPostInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type BookmarkUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<BookmarkCreateWithoutPostsInput, BookmarkUncheckedCreateWithoutPostsInput> | BookmarkCreateWithoutPostsInput[] | BookmarkUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutPostsInput | BookmarkCreateOrConnectWithoutPostsInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type PublicationUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<PublicationCreateWithoutPostsInput, PublicationUncheckedCreateWithoutPostsInput> | PublicationCreateWithoutPostsInput[] | PublicationUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutPostsInput | PublicationCreateOrConnectWithoutPostsInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReportedPostInput = {
    create?: XOR<ReportCreateWithoutReportedPostInput, ReportUncheckedCreateWithoutReportedPostInput> | ReportCreateWithoutReportedPostInput[] | ReportUncheckedCreateWithoutReportedPostInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedPostInput | ReportCreateOrConnectWithoutReportedPostInput[]
    createMany?: ReportCreateManyReportedPostInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<NoteCreateWithoutPostInput, NoteUncheckedCreateWithoutPostInput> | NoteCreateWithoutPostInput[] | NoteUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutPostInput | NoteCreateOrConnectWithoutPostInput[]
    createMany?: NoteCreateManyPostInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type EnumPostStatusFieldUpdateOperationsInput = {
    set?: $Enums.PostStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumPostTypeFieldUpdateOperationsInput = {
    set?: $Enums.PostType
  }

  export type NullableEnumCategoryFieldUpdateOperationsInput = {
    set?: $Enums.Category | null
  }

  export type NullableEnumThreadParticipantTypeFieldUpdateOperationsInput = {
    set?: $Enums.ThreadParticipantType | null
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type PostUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PostUpdatementionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PostUpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.Visibility
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MediaUpdateOneWithoutPostsNestedInput = {
    create?: XOR<MediaCreateWithoutPostsInput, MediaUncheckedCreateWithoutPostsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutPostsInput
    upsert?: MediaUpsertWithoutPostsInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutPostsInput, MediaUpdateWithoutPostsInput>, MediaUncheckedUpdateWithoutPostsInput>
  }

  export type FileUpdateManyWithoutPostsNestedInput = {
    create?: XOR<FileCreateWithoutPostsInput, FileUncheckedCreateWithoutPostsInput> | FileCreateWithoutPostsInput[] | FileUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: FileCreateOrConnectWithoutPostsInput | FileCreateOrConnectWithoutPostsInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutPostsInput | FileUpsertWithWhereUniqueWithoutPostsInput[]
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutPostsInput | FileUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: FileUpdateManyWithWhereWithoutPostsInput | FileUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type UserProfileUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserProfileCreateWithoutPostsInput, UserProfileUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutPostsInput
    upsert?: UserProfileUpsertWithoutPostsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutPostsInput, UserProfileUpdateWithoutPostsInput>, UserProfileUncheckedUpdateWithoutPostsInput>
  }

  export type CommunityProfileUpdateOneWithoutPostsNestedInput = {
    create?: XOR<CommunityProfileCreateWithoutPostsInput, CommunityProfileUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CommunityProfileCreateOrConnectWithoutPostsInput
    upsert?: CommunityProfileUpsertWithoutPostsInput
    disconnect?: CommunityProfileWhereInput | boolean
    delete?: CommunityProfileWhereInput | boolean
    connect?: CommunityProfileWhereUniqueInput
    update?: XOR<XOR<CommunityProfileUpdateToOneWithWhereWithoutPostsInput, CommunityProfileUpdateWithoutPostsInput>, CommunityProfileUncheckedUpdateWithoutPostsInput>
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReactionUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput> | ReactionCreateWithoutPostInput[] | ReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput | ReactionCreateOrConnectWithoutPostInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutPostInput | ReactionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReactionCreateManyPostInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutPostInput | ReactionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutPostInput | ReactionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type BookmarkUpdateManyWithoutPostsNestedInput = {
    create?: XOR<BookmarkCreateWithoutPostsInput, BookmarkUncheckedCreateWithoutPostsInput> | BookmarkCreateWithoutPostsInput[] | BookmarkUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutPostsInput | BookmarkCreateOrConnectWithoutPostsInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutPostsInput | BookmarkUpsertWithWhereUniqueWithoutPostsInput[]
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutPostsInput | BookmarkUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutPostsInput | BookmarkUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type PublicationUpdateManyWithoutPostsNestedInput = {
    create?: XOR<PublicationCreateWithoutPostsInput, PublicationUncheckedCreateWithoutPostsInput> | PublicationCreateWithoutPostsInput[] | PublicationUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutPostsInput | PublicationCreateOrConnectWithoutPostsInput[]
    upsert?: PublicationUpsertWithWhereUniqueWithoutPostsInput | PublicationUpsertWithWhereUniqueWithoutPostsInput[]
    set?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    disconnect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    delete?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    update?: PublicationUpdateWithWhereUniqueWithoutPostsInput | PublicationUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: PublicationUpdateManyWithWhereWithoutPostsInput | PublicationUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutReportedPostNestedInput = {
    create?: XOR<ReportCreateWithoutReportedPostInput, ReportUncheckedCreateWithoutReportedPostInput> | ReportCreateWithoutReportedPostInput[] | ReportUncheckedCreateWithoutReportedPostInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedPostInput | ReportCreateOrConnectWithoutReportedPostInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedPostInput | ReportUpsertWithWhereUniqueWithoutReportedPostInput[]
    createMany?: ReportCreateManyReportedPostInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedPostInput | ReportUpdateWithWhereUniqueWithoutReportedPostInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedPostInput | ReportUpdateManyWithWhereWithoutReportedPostInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutPostNestedInput = {
    create?: XOR<NoteCreateWithoutPostInput, NoteUncheckedCreateWithoutPostInput> | NoteCreateWithoutPostInput[] | NoteUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutPostInput | NoteCreateOrConnectWithoutPostInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutPostInput | NoteUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: NoteCreateManyPostInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutPostInput | NoteUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutPostInput | NoteUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type ThreadUpdateOneWithoutPostsNestedInput = {
    create?: XOR<ThreadCreateWithoutPostsInput, ThreadUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutPostsInput
    upsert?: ThreadUpsertWithoutPostsInput
    disconnect?: ThreadWhereInput | boolean
    delete?: ThreadWhereInput | boolean
    connect?: ThreadWhereUniqueInput
    update?: XOR<XOR<ThreadUpdateToOneWithWhereWithoutPostsInput, ThreadUpdateWithoutPostsInput>, ThreadUncheckedUpdateWithoutPostsInput>
  }

  export type SpaceUpdateOneWithoutPostsNestedInput = {
    create?: XOR<SpaceCreateWithoutPostsInput, SpaceUncheckedCreateWithoutPostsInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutPostsInput
    upsert?: SpaceUpsertWithoutPostsInput
    disconnect?: SpaceWhereInput | boolean
    delete?: SpaceWhereInput | boolean
    connect?: SpaceWhereUniqueInput
    update?: XOR<XOR<SpaceUpdateToOneWithWhereWithoutPostsInput, SpaceUpdateWithoutPostsInput>, SpaceUncheckedUpdateWithoutPostsInput>
  }

  export type ChannelUpdateOneWithoutPostsNestedInput = {
    create?: XOR<ChannelCreateWithoutPostsInput, ChannelUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutPostsInput
    upsert?: ChannelUpsertWithoutPostsInput
    disconnect?: ChannelWhereInput | boolean
    delete?: ChannelWhereInput | boolean
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutPostsInput, ChannelUpdateWithoutPostsInput>, ChannelUncheckedUpdateWithoutPostsInput>
  }

  export type FileUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<FileCreateWithoutPostsInput, FileUncheckedCreateWithoutPostsInput> | FileCreateWithoutPostsInput[] | FileUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: FileCreateOrConnectWithoutPostsInput | FileCreateOrConnectWithoutPostsInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutPostsInput | FileUpsertWithWhereUniqueWithoutPostsInput[]
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutPostsInput | FileUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: FileUpdateManyWithWhereWithoutPostsInput | FileUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReactionUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput> | ReactionCreateWithoutPostInput[] | ReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput | ReactionCreateOrConnectWithoutPostInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutPostInput | ReactionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReactionCreateManyPostInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutPostInput | ReactionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutPostInput | ReactionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type BookmarkUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<BookmarkCreateWithoutPostsInput, BookmarkUncheckedCreateWithoutPostsInput> | BookmarkCreateWithoutPostsInput[] | BookmarkUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutPostsInput | BookmarkCreateOrConnectWithoutPostsInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutPostsInput | BookmarkUpsertWithWhereUniqueWithoutPostsInput[]
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutPostsInput | BookmarkUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutPostsInput | BookmarkUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type PublicationUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<PublicationCreateWithoutPostsInput, PublicationUncheckedCreateWithoutPostsInput> | PublicationCreateWithoutPostsInput[] | PublicationUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutPostsInput | PublicationCreateOrConnectWithoutPostsInput[]
    upsert?: PublicationUpsertWithWhereUniqueWithoutPostsInput | PublicationUpsertWithWhereUniqueWithoutPostsInput[]
    set?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    disconnect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    delete?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    update?: PublicationUpdateWithWhereUniqueWithoutPostsInput | PublicationUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: PublicationUpdateManyWithWhereWithoutPostsInput | PublicationUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReportedPostNestedInput = {
    create?: XOR<ReportCreateWithoutReportedPostInput, ReportUncheckedCreateWithoutReportedPostInput> | ReportCreateWithoutReportedPostInput[] | ReportUncheckedCreateWithoutReportedPostInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedPostInput | ReportCreateOrConnectWithoutReportedPostInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedPostInput | ReportUpsertWithWhereUniqueWithoutReportedPostInput[]
    createMany?: ReportCreateManyReportedPostInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedPostInput | ReportUpdateWithWhereUniqueWithoutReportedPostInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedPostInput | ReportUpdateManyWithWhereWithoutReportedPostInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<NoteCreateWithoutPostInput, NoteUncheckedCreateWithoutPostInput> | NoteCreateWithoutPostInput[] | NoteUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutPostInput | NoteCreateOrConnectWithoutPostInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutPostInput | NoteUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: NoteCreateManyPostInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutPostInput | NoteUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutPostInput | NoteUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type PollPostCreatepollOptionsInput = {
    set: string[]
  }

  export type PollPostCreatementionsInput = {
    set: string[]
  }

  export type PollPostCreatehashtagsInput = {
    set: string[]
  }

  export type PollPostCreatetagsInput = {
    set: string[]
  }

  export type MediaCreateNestedOneWithoutPollPostsInput = {
    create?: XOR<MediaCreateWithoutPollPostsInput, MediaUncheckedCreateWithoutPollPostsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutPollPostsInput
    connect?: MediaWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutPollPostInput = {
    create?: XOR<CommentCreateWithoutPollPostInput, CommentUncheckedCreateWithoutPollPostInput> | CommentCreateWithoutPollPostInput[] | CommentUncheckedCreateWithoutPollPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPollPostInput | CommentCreateOrConnectWithoutPollPostInput[]
    createMany?: CommentCreateManyPollPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ThreadCreateNestedOneWithoutPollPostsInput = {
    create?: XOR<ThreadCreateWithoutPollPostsInput, ThreadUncheckedCreateWithoutPollPostsInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutPollPostsInput
    connect?: ThreadWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutPollPostInput = {
    create?: XOR<CommentCreateWithoutPollPostInput, CommentUncheckedCreateWithoutPollPostInput> | CommentCreateWithoutPollPostInput[] | CommentUncheckedCreateWithoutPollPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPollPostInput | CommentCreateOrConnectWithoutPollPostInput[]
    createMany?: CommentCreateManyPollPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PollPostUpdatepollOptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PollPostUpdatementionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PollPostUpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PollPostUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MediaUpdateOneWithoutPollPostsNestedInput = {
    create?: XOR<MediaCreateWithoutPollPostsInput, MediaUncheckedCreateWithoutPollPostsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutPollPostsInput
    upsert?: MediaUpsertWithoutPollPostsInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutPollPostsInput, MediaUpdateWithoutPollPostsInput>, MediaUncheckedUpdateWithoutPollPostsInput>
  }

  export type CommentUpdateManyWithoutPollPostNestedInput = {
    create?: XOR<CommentCreateWithoutPollPostInput, CommentUncheckedCreateWithoutPollPostInput> | CommentCreateWithoutPollPostInput[] | CommentUncheckedCreateWithoutPollPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPollPostInput | CommentCreateOrConnectWithoutPollPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPollPostInput | CommentUpsertWithWhereUniqueWithoutPollPostInput[]
    createMany?: CommentCreateManyPollPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPollPostInput | CommentUpdateWithWhereUniqueWithoutPollPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPollPostInput | CommentUpdateManyWithWhereWithoutPollPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ThreadUpdateOneWithoutPollPostsNestedInput = {
    create?: XOR<ThreadCreateWithoutPollPostsInput, ThreadUncheckedCreateWithoutPollPostsInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutPollPostsInput
    upsert?: ThreadUpsertWithoutPollPostsInput
    disconnect?: ThreadWhereInput | boolean
    delete?: ThreadWhereInput | boolean
    connect?: ThreadWhereUniqueInput
    update?: XOR<XOR<ThreadUpdateToOneWithWhereWithoutPollPostsInput, ThreadUpdateWithoutPollPostsInput>, ThreadUncheckedUpdateWithoutPollPostsInput>
  }

  export type CommentUncheckedUpdateManyWithoutPollPostNestedInput = {
    create?: XOR<CommentCreateWithoutPollPostInput, CommentUncheckedCreateWithoutPollPostInput> | CommentCreateWithoutPollPostInput[] | CommentUncheckedCreateWithoutPollPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPollPostInput | CommentCreateOrConnectWithoutPollPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPollPostInput | CommentUpsertWithWhereUniqueWithoutPollPostInput[]
    createMany?: CommentCreateManyPollPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPollPostInput | CommentUpdateWithWhereUniqueWithoutPollPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPollPostInput | CommentUpdateManyWithWhereWithoutPollPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentCreatementionsInput = {
    set: string[]
  }

  export type CommentCreatehashtagsInput = {
    set: string[]
  }

  export type MediaCreateNestedOneWithoutCommentsInput = {
    create?: XOR<MediaCreateWithoutCommentsInput, MediaUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutCommentsInput
    connect?: MediaWhereUniqueInput
  }

  export type CommentReplyCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput> | CommentReplyCreateWithoutCommentInput[] | CommentReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutCommentInput | CommentReplyCreateOrConnectWithoutCommentInput[]
    createMany?: CommentReplyCreateManyCommentInputEnvelope
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutCommentInput = {
    create?: XOR<NoteCreateWithoutCommentInput, NoteUncheckedCreateWithoutCommentInput> | NoteCreateWithoutCommentInput[] | NoteUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutCommentInput | NoteCreateOrConnectWithoutCommentInput[]
    createMany?: NoteCreateManyCommentInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type PollPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PollPostCreateWithoutCommentsInput, PollPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PollPostCreateOrConnectWithoutCommentsInput
    connect?: PollPostWhereUniqueInput
  }

  export type ReportCreateNestedManyWithoutReportedCommentInput = {
    create?: XOR<ReportCreateWithoutReportedCommentInput, ReportUncheckedCreateWithoutReportedCommentInput> | ReportCreateWithoutReportedCommentInput[] | ReportUncheckedCreateWithoutReportedCommentInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedCommentInput | ReportCreateOrConnectWithoutReportedCommentInput[]
    createMany?: ReportCreateManyReportedCommentInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReactionCreateNestedManyWithoutCommentInput = {
    create?: XOR<ReactionCreateWithoutCommentInput, ReactionUncheckedCreateWithoutCommentInput> | ReactionCreateWithoutCommentInput[] | ReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutCommentInput | ReactionCreateOrConnectWithoutCommentInput[]
    createMany?: ReactionCreateManyCommentInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type UserProfileCreateNestedManyWithoutCommentsInput = {
    create?: XOR<UserProfileCreateWithoutCommentsInput, UserProfileUncheckedCreateWithoutCommentsInput> | UserProfileCreateWithoutCommentsInput[] | UserProfileUncheckedCreateWithoutCommentsInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutCommentsInput | UserProfileCreateOrConnectWithoutCommentsInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
  }

  export type CommentReplyUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput> | CommentReplyCreateWithoutCommentInput[] | CommentReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutCommentInput | CommentReplyCreateOrConnectWithoutCommentInput[]
    createMany?: CommentReplyCreateManyCommentInputEnvelope
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<NoteCreateWithoutCommentInput, NoteUncheckedCreateWithoutCommentInput> | NoteCreateWithoutCommentInput[] | NoteUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutCommentInput | NoteCreateOrConnectWithoutCommentInput[]
    createMany?: NoteCreateManyCommentInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReportedCommentInput = {
    create?: XOR<ReportCreateWithoutReportedCommentInput, ReportUncheckedCreateWithoutReportedCommentInput> | ReportCreateWithoutReportedCommentInput[] | ReportUncheckedCreateWithoutReportedCommentInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedCommentInput | ReportCreateOrConnectWithoutReportedCommentInput[]
    createMany?: ReportCreateManyReportedCommentInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReactionUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<ReactionCreateWithoutCommentInput, ReactionUncheckedCreateWithoutCommentInput> | ReactionCreateWithoutCommentInput[] | ReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutCommentInput | ReactionCreateOrConnectWithoutCommentInput[]
    createMany?: ReactionCreateManyCommentInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedManyWithoutCommentsInput = {
    create?: XOR<UserProfileCreateWithoutCommentsInput, UserProfileUncheckedCreateWithoutCommentsInput> | UserProfileCreateWithoutCommentsInput[] | UserProfileUncheckedCreateWithoutCommentsInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutCommentsInput | UserProfileCreateOrConnectWithoutCommentsInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
  }

  export type CommentUpdatementionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CommentUpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MediaUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<MediaCreateWithoutCommentsInput, MediaUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutCommentsInput
    upsert?: MediaUpsertWithoutCommentsInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutCommentsInput, MediaUpdateWithoutCommentsInput>, MediaUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentReplyUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput> | CommentReplyCreateWithoutCommentInput[] | CommentReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutCommentInput | CommentReplyCreateOrConnectWithoutCommentInput[]
    upsert?: CommentReplyUpsertWithWhereUniqueWithoutCommentInput | CommentReplyUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentReplyCreateManyCommentInputEnvelope
    set?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    disconnect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    delete?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    update?: CommentReplyUpdateWithWhereUniqueWithoutCommentInput | CommentReplyUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentReplyUpdateManyWithWhereWithoutCommentInput | CommentReplyUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutCommentNestedInput = {
    create?: XOR<NoteCreateWithoutCommentInput, NoteUncheckedCreateWithoutCommentInput> | NoteCreateWithoutCommentInput[] | NoteUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutCommentInput | NoteCreateOrConnectWithoutCommentInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutCommentInput | NoteUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: NoteCreateManyCommentInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutCommentInput | NoteUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutCommentInput | NoteUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PollPostUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<PollPostCreateWithoutCommentsInput, PollPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PollPostCreateOrConnectWithoutCommentsInput
    upsert?: PollPostUpsertWithoutCommentsInput
    disconnect?: PollPostWhereInput | boolean
    delete?: PollPostWhereInput | boolean
    connect?: PollPostWhereUniqueInput
    update?: XOR<XOR<PollPostUpdateToOneWithWhereWithoutCommentsInput, PollPostUpdateWithoutCommentsInput>, PollPostUncheckedUpdateWithoutCommentsInput>
  }

  export type ReportUpdateManyWithoutReportedCommentNestedInput = {
    create?: XOR<ReportCreateWithoutReportedCommentInput, ReportUncheckedCreateWithoutReportedCommentInput> | ReportCreateWithoutReportedCommentInput[] | ReportUncheckedCreateWithoutReportedCommentInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedCommentInput | ReportCreateOrConnectWithoutReportedCommentInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedCommentInput | ReportUpsertWithWhereUniqueWithoutReportedCommentInput[]
    createMany?: ReportCreateManyReportedCommentInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedCommentInput | ReportUpdateWithWhereUniqueWithoutReportedCommentInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedCommentInput | ReportUpdateManyWithWhereWithoutReportedCommentInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReactionUpdateManyWithoutCommentNestedInput = {
    create?: XOR<ReactionCreateWithoutCommentInput, ReactionUncheckedCreateWithoutCommentInput> | ReactionCreateWithoutCommentInput[] | ReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutCommentInput | ReactionCreateOrConnectWithoutCommentInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutCommentInput | ReactionUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: ReactionCreateManyCommentInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutCommentInput | ReactionUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutCommentInput | ReactionUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type UserProfileUpdateManyWithoutCommentsNestedInput = {
    create?: XOR<UserProfileCreateWithoutCommentsInput, UserProfileUncheckedCreateWithoutCommentsInput> | UserProfileCreateWithoutCommentsInput[] | UserProfileUncheckedCreateWithoutCommentsInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutCommentsInput | UserProfileCreateOrConnectWithoutCommentsInput[]
    upsert?: UserProfileUpsertWithWhereUniqueWithoutCommentsInput | UserProfileUpsertWithWhereUniqueWithoutCommentsInput[]
    set?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    disconnect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    delete?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    update?: UserProfileUpdateWithWhereUniqueWithoutCommentsInput | UserProfileUpdateWithWhereUniqueWithoutCommentsInput[]
    updateMany?: UserProfileUpdateManyWithWhereWithoutCommentsInput | UserProfileUpdateManyWithWhereWithoutCommentsInput[]
    deleteMany?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
  }

  export type CommentReplyUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput> | CommentReplyCreateWithoutCommentInput[] | CommentReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutCommentInput | CommentReplyCreateOrConnectWithoutCommentInput[]
    upsert?: CommentReplyUpsertWithWhereUniqueWithoutCommentInput | CommentReplyUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentReplyCreateManyCommentInputEnvelope
    set?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    disconnect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    delete?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    update?: CommentReplyUpdateWithWhereUniqueWithoutCommentInput | CommentReplyUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentReplyUpdateManyWithWhereWithoutCommentInput | CommentReplyUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<NoteCreateWithoutCommentInput, NoteUncheckedCreateWithoutCommentInput> | NoteCreateWithoutCommentInput[] | NoteUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutCommentInput | NoteCreateOrConnectWithoutCommentInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutCommentInput | NoteUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: NoteCreateManyCommentInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutCommentInput | NoteUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutCommentInput | NoteUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReportedCommentNestedInput = {
    create?: XOR<ReportCreateWithoutReportedCommentInput, ReportUncheckedCreateWithoutReportedCommentInput> | ReportCreateWithoutReportedCommentInput[] | ReportUncheckedCreateWithoutReportedCommentInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedCommentInput | ReportCreateOrConnectWithoutReportedCommentInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedCommentInput | ReportUpsertWithWhereUniqueWithoutReportedCommentInput[]
    createMany?: ReportCreateManyReportedCommentInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedCommentInput | ReportUpdateWithWhereUniqueWithoutReportedCommentInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedCommentInput | ReportUpdateManyWithWhereWithoutReportedCommentInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReactionUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<ReactionCreateWithoutCommentInput, ReactionUncheckedCreateWithoutCommentInput> | ReactionCreateWithoutCommentInput[] | ReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutCommentInput | ReactionCreateOrConnectWithoutCommentInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutCommentInput | ReactionUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: ReactionCreateManyCommentInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutCommentInput | ReactionUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutCommentInput | ReactionUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateManyWithoutCommentsNestedInput = {
    create?: XOR<UserProfileCreateWithoutCommentsInput, UserProfileUncheckedCreateWithoutCommentsInput> | UserProfileCreateWithoutCommentsInput[] | UserProfileUncheckedCreateWithoutCommentsInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutCommentsInput | UserProfileCreateOrConnectWithoutCommentsInput[]
    upsert?: UserProfileUpsertWithWhereUniqueWithoutCommentsInput | UserProfileUpsertWithWhereUniqueWithoutCommentsInput[]
    set?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    disconnect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    delete?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    update?: UserProfileUpdateWithWhereUniqueWithoutCommentsInput | UserProfileUpdateWithWhereUniqueWithoutCommentsInput[]
    updateMany?: UserProfileUpdateManyWithWhereWithoutCommentsInput | UserProfileUpdateManyWithWhereWithoutCommentsInput[]
    deleteMany?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
  }

  export type CommentReplyCreatementionsInput = {
    set: string[]
  }

  export type CommentReplyCreatehashtagsInput = {
    set: string[]
  }

  export type MediaCreateNestedOneWithoutCommentRepliesInput = {
    create?: XOR<MediaCreateWithoutCommentRepliesInput, MediaUncheckedCreateWithoutCommentRepliesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutCommentRepliesInput
    connect?: MediaWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentReplyUpdatementionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CommentReplyUpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MediaUpdateOneWithoutCommentRepliesNestedInput = {
    create?: XOR<MediaCreateWithoutCommentRepliesInput, MediaUncheckedCreateWithoutCommentRepliesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutCommentRepliesInput
    upsert?: MediaUpsertWithoutCommentRepliesInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutCommentRepliesInput, MediaUpdateWithoutCommentRepliesInput>, MediaUncheckedUpdateWithoutCommentRepliesInput>
  }

  export type CommentUpdateOneRequiredWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type UserProfileCreateNestedOneWithoutReactionsInput = {
    create?: XOR<UserProfileCreateWithoutReactionsInput, UserProfileUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutReactionsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutReactionsInput = {
    create?: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: PostCreateOrConnectWithoutReactionsInput
    connect?: PostWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutReactionInput = {
    create?: XOR<CommentCreateWithoutReactionInput, CommentUncheckedCreateWithoutReactionInput>
    connectOrCreate?: CommentCreateOrConnectWithoutReactionInput
    connect?: CommentWhereUniqueInput
  }

  export type EnumReactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReactionType
  }

  export type UserProfileUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<UserProfileCreateWithoutReactionsInput, UserProfileUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutReactionsInput
    upsert?: UserProfileUpsertWithoutReactionsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutReactionsInput, UserProfileUpdateWithoutReactionsInput>, UserProfileUncheckedUpdateWithoutReactionsInput>
  }

  export type PostUpdateOneWithoutReactionsNestedInput = {
    create?: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: PostCreateOrConnectWithoutReactionsInput
    upsert?: PostUpsertWithoutReactionsInput
    disconnect?: PostWhereInput | boolean
    delete?: PostWhereInput | boolean
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutReactionsInput, PostUpdateWithoutReactionsInput>, PostUncheckedUpdateWithoutReactionsInput>
  }

  export type CommentUpdateOneWithoutReactionNestedInput = {
    create?: XOR<CommentCreateWithoutReactionInput, CommentUncheckedCreateWithoutReactionInput>
    connectOrCreate?: CommentCreateOrConnectWithoutReactionInput
    upsert?: CommentUpsertWithoutReactionInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutReactionInput, CommentUpdateWithoutReactionInput>, CommentUncheckedUpdateWithoutReactionInput>
  }

  export type BookmarkCreatepostIdsInput = {
    set: string[]
  }

  export type PublicationCreateNestedManyWithoutBookmarksInput = {
    create?: XOR<PublicationCreateWithoutBookmarksInput, PublicationUncheckedCreateWithoutBookmarksInput> | PublicationCreateWithoutBookmarksInput[] | PublicationUncheckedCreateWithoutBookmarksInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutBookmarksInput | PublicationCreateOrConnectWithoutBookmarksInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
  }

  export type UserProfileCreateNestedManyWithoutBookmarksInput = {
    create?: XOR<UserProfileCreateWithoutBookmarksInput, UserProfileUncheckedCreateWithoutBookmarksInput> | UserProfileCreateWithoutBookmarksInput[] | UserProfileUncheckedCreateWithoutBookmarksInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutBookmarksInput | UserProfileCreateOrConnectWithoutBookmarksInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutBookmarksInput = {
    create?: XOR<PostCreateWithoutBookmarksInput, PostUncheckedCreateWithoutBookmarksInput> | PostCreateWithoutBookmarksInput[] | PostUncheckedCreateWithoutBookmarksInput[]
    connectOrCreate?: PostCreateOrConnectWithoutBookmarksInput | PostCreateOrConnectWithoutBookmarksInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PublicationUncheckedCreateNestedManyWithoutBookmarksInput = {
    create?: XOR<PublicationCreateWithoutBookmarksInput, PublicationUncheckedCreateWithoutBookmarksInput> | PublicationCreateWithoutBookmarksInput[] | PublicationUncheckedCreateWithoutBookmarksInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutBookmarksInput | PublicationCreateOrConnectWithoutBookmarksInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedManyWithoutBookmarksInput = {
    create?: XOR<UserProfileCreateWithoutBookmarksInput, UserProfileUncheckedCreateWithoutBookmarksInput> | UserProfileCreateWithoutBookmarksInput[] | UserProfileUncheckedCreateWithoutBookmarksInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutBookmarksInput | UserProfileCreateOrConnectWithoutBookmarksInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutBookmarksInput = {
    create?: XOR<PostCreateWithoutBookmarksInput, PostUncheckedCreateWithoutBookmarksInput> | PostCreateWithoutBookmarksInput[] | PostUncheckedCreateWithoutBookmarksInput[]
    connectOrCreate?: PostCreateOrConnectWithoutBookmarksInput | PostCreateOrConnectWithoutBookmarksInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type BookmarkUpdatepostIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PublicationUpdateManyWithoutBookmarksNestedInput = {
    create?: XOR<PublicationCreateWithoutBookmarksInput, PublicationUncheckedCreateWithoutBookmarksInput> | PublicationCreateWithoutBookmarksInput[] | PublicationUncheckedCreateWithoutBookmarksInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutBookmarksInput | PublicationCreateOrConnectWithoutBookmarksInput[]
    upsert?: PublicationUpsertWithWhereUniqueWithoutBookmarksInput | PublicationUpsertWithWhereUniqueWithoutBookmarksInput[]
    set?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    disconnect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    delete?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    update?: PublicationUpdateWithWhereUniqueWithoutBookmarksInput | PublicationUpdateWithWhereUniqueWithoutBookmarksInput[]
    updateMany?: PublicationUpdateManyWithWhereWithoutBookmarksInput | PublicationUpdateManyWithWhereWithoutBookmarksInput[]
    deleteMany?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
  }

  export type UserProfileUpdateManyWithoutBookmarksNestedInput = {
    create?: XOR<UserProfileCreateWithoutBookmarksInput, UserProfileUncheckedCreateWithoutBookmarksInput> | UserProfileCreateWithoutBookmarksInput[] | UserProfileUncheckedCreateWithoutBookmarksInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutBookmarksInput | UserProfileCreateOrConnectWithoutBookmarksInput[]
    upsert?: UserProfileUpsertWithWhereUniqueWithoutBookmarksInput | UserProfileUpsertWithWhereUniqueWithoutBookmarksInput[]
    set?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    disconnect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    delete?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    update?: UserProfileUpdateWithWhereUniqueWithoutBookmarksInput | UserProfileUpdateWithWhereUniqueWithoutBookmarksInput[]
    updateMany?: UserProfileUpdateManyWithWhereWithoutBookmarksInput | UserProfileUpdateManyWithWhereWithoutBookmarksInput[]
    deleteMany?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
  }

  export type PostUpdateManyWithoutBookmarksNestedInput = {
    create?: XOR<PostCreateWithoutBookmarksInput, PostUncheckedCreateWithoutBookmarksInput> | PostCreateWithoutBookmarksInput[] | PostUncheckedCreateWithoutBookmarksInput[]
    connectOrCreate?: PostCreateOrConnectWithoutBookmarksInput | PostCreateOrConnectWithoutBookmarksInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutBookmarksInput | PostUpsertWithWhereUniqueWithoutBookmarksInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutBookmarksInput | PostUpdateWithWhereUniqueWithoutBookmarksInput[]
    updateMany?: PostUpdateManyWithWhereWithoutBookmarksInput | PostUpdateManyWithWhereWithoutBookmarksInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PublicationUncheckedUpdateManyWithoutBookmarksNestedInput = {
    create?: XOR<PublicationCreateWithoutBookmarksInput, PublicationUncheckedCreateWithoutBookmarksInput> | PublicationCreateWithoutBookmarksInput[] | PublicationUncheckedCreateWithoutBookmarksInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutBookmarksInput | PublicationCreateOrConnectWithoutBookmarksInput[]
    upsert?: PublicationUpsertWithWhereUniqueWithoutBookmarksInput | PublicationUpsertWithWhereUniqueWithoutBookmarksInput[]
    set?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    disconnect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    delete?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    update?: PublicationUpdateWithWhereUniqueWithoutBookmarksInput | PublicationUpdateWithWhereUniqueWithoutBookmarksInput[]
    updateMany?: PublicationUpdateManyWithWhereWithoutBookmarksInput | PublicationUpdateManyWithWhereWithoutBookmarksInput[]
    deleteMany?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateManyWithoutBookmarksNestedInput = {
    create?: XOR<UserProfileCreateWithoutBookmarksInput, UserProfileUncheckedCreateWithoutBookmarksInput> | UserProfileCreateWithoutBookmarksInput[] | UserProfileUncheckedCreateWithoutBookmarksInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutBookmarksInput | UserProfileCreateOrConnectWithoutBookmarksInput[]
    upsert?: UserProfileUpsertWithWhereUniqueWithoutBookmarksInput | UserProfileUpsertWithWhereUniqueWithoutBookmarksInput[]
    set?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    disconnect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    delete?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    update?: UserProfileUpdateWithWhereUniqueWithoutBookmarksInput | UserProfileUpdateWithWhereUniqueWithoutBookmarksInput[]
    updateMany?: UserProfileUpdateManyWithWhereWithoutBookmarksInput | UserProfileUpdateManyWithWhereWithoutBookmarksInput[]
    deleteMany?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutBookmarksNestedInput = {
    create?: XOR<PostCreateWithoutBookmarksInput, PostUncheckedCreateWithoutBookmarksInput> | PostCreateWithoutBookmarksInput[] | PostUncheckedCreateWithoutBookmarksInput[]
    connectOrCreate?: PostCreateOrConnectWithoutBookmarksInput | PostCreateOrConnectWithoutBookmarksInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutBookmarksInput | PostUpsertWithWhereUniqueWithoutBookmarksInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutBookmarksInput | PostUpdateWithWhereUniqueWithoutBookmarksInput[]
    updateMany?: PostUpdateManyWithWhereWithoutBookmarksInput | PostUpdateManyWithWhereWithoutBookmarksInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type UserProfileCreateNestedOneWithoutBlockingInput = {
    create?: XOR<UserProfileCreateWithoutBlockingInput, UserProfileUncheckedCreateWithoutBlockingInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutBlockingInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileCreateNestedOneWithoutBlockedByInput = {
    create?: XOR<UserProfileCreateWithoutBlockedByInput, UserProfileUncheckedCreateWithoutBlockedByInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutBlockedByInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutBlockingNestedInput = {
    create?: XOR<UserProfileCreateWithoutBlockingInput, UserProfileUncheckedCreateWithoutBlockingInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutBlockingInput
    upsert?: UserProfileUpsertWithoutBlockingInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutBlockingInput, UserProfileUpdateWithoutBlockingInput>, UserProfileUncheckedUpdateWithoutBlockingInput>
  }

  export type UserProfileUpdateOneRequiredWithoutBlockedByNestedInput = {
    create?: XOR<UserProfileCreateWithoutBlockedByInput, UserProfileUncheckedCreateWithoutBlockedByInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutBlockedByInput
    upsert?: UserProfileUpsertWithoutBlockedByInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutBlockedByInput, UserProfileUpdateWithoutBlockedByInput>, UserProfileUncheckedUpdateWithoutBlockedByInput>
  }

  export type UserProfileCreateNestedOneWithoutFollowingInput = {
    create?: XOR<UserProfileCreateWithoutFollowingInput, UserProfileUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutFollowingInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileCreateNestedOneWithoutFollowersInput = {
    create?: XOR<UserProfileCreateWithoutFollowersInput, UserProfileUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutFollowersInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<UserProfileCreateWithoutFollowingInput, UserProfileUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutFollowingInput
    upsert?: UserProfileUpsertWithoutFollowingInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutFollowingInput, UserProfileUpdateWithoutFollowingInput>, UserProfileUncheckedUpdateWithoutFollowingInput>
  }

  export type UserProfileUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<UserProfileCreateWithoutFollowersInput, UserProfileUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutFollowersInput
    upsert?: UserProfileUpsertWithoutFollowersInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutFollowersInput, UserProfileUpdateWithoutFollowersInput>, UserProfileUncheckedUpdateWithoutFollowersInput>
  }

  export type UserProfileCreateNestedOneWithoutTagsInput = {
    create?: XOR<UserProfileCreateWithoutTagsInput, UserProfileUncheckedCreateWithoutTagsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutTagsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<UserProfileCreateWithoutTagsInput, UserProfileUncheckedCreateWithoutTagsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutTagsInput
    upsert?: UserProfileUpsertWithoutTagsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutTagsInput, UserProfileUpdateWithoutTagsInput>, UserProfileUncheckedUpdateWithoutTagsInput>
  }

  export type UserProfileCreateNestedOneWithoutReportsSubmittedInput = {
    create?: XOR<UserProfileCreateWithoutReportsSubmittedInput, UserProfileUncheckedCreateWithoutReportsSubmittedInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutReportsSubmittedInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileCreateNestedOneWithoutReportedContentInput = {
    create?: XOR<UserProfileCreateWithoutReportedContentInput, UserProfileUncheckedCreateWithoutReportedContentInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutReportedContentInput
    connect?: UserProfileWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutReportsInput = {
    create?: XOR<PostCreateWithoutReportsInput, PostUncheckedCreateWithoutReportsInput>
    connectOrCreate?: PostCreateOrConnectWithoutReportsInput
    connect?: PostWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutReportInput = {
    create?: XOR<CommentCreateWithoutReportInput, CommentUncheckedCreateWithoutReportInput>
    connectOrCreate?: CommentCreateOrConnectWithoutReportInput
    connect?: CommentWhereUniqueInput
  }

  export type EnumReportReasonFieldUpdateOperationsInput = {
    set?: $Enums.ReportReason
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type UserProfileUpdateOneRequiredWithoutReportsSubmittedNestedInput = {
    create?: XOR<UserProfileCreateWithoutReportsSubmittedInput, UserProfileUncheckedCreateWithoutReportsSubmittedInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutReportsSubmittedInput
    upsert?: UserProfileUpsertWithoutReportsSubmittedInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutReportsSubmittedInput, UserProfileUpdateWithoutReportsSubmittedInput>, UserProfileUncheckedUpdateWithoutReportsSubmittedInput>
  }

  export type UserProfileUpdateOneWithoutReportedContentNestedInput = {
    create?: XOR<UserProfileCreateWithoutReportedContentInput, UserProfileUncheckedCreateWithoutReportedContentInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutReportedContentInput
    upsert?: UserProfileUpsertWithoutReportedContentInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutReportedContentInput, UserProfileUpdateWithoutReportedContentInput>, UserProfileUncheckedUpdateWithoutReportedContentInput>
  }

  export type PostUpdateOneWithoutReportsNestedInput = {
    create?: XOR<PostCreateWithoutReportsInput, PostUncheckedCreateWithoutReportsInput>
    connectOrCreate?: PostCreateOrConnectWithoutReportsInput
    upsert?: PostUpsertWithoutReportsInput
    disconnect?: PostWhereInput | boolean
    delete?: PostWhereInput | boolean
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutReportsInput, PostUpdateWithoutReportsInput>, PostUncheckedUpdateWithoutReportsInput>
  }

  export type CommentUpdateOneWithoutReportNestedInput = {
    create?: XOR<CommentCreateWithoutReportInput, CommentUncheckedCreateWithoutReportInput>
    connectOrCreate?: CommentCreateOrConnectWithoutReportInput
    upsert?: CommentUpsertWithoutReportInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutReportInput, CommentUpdateWithoutReportInput>, CommentUncheckedUpdateWithoutReportInput>
  }

  export type UserProfileCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserProfileCreateWithoutNotificationsInput, UserProfileUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutNotificationsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserProfileUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserProfileCreateWithoutNotificationsInput, UserProfileUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutNotificationsInput
    upsert?: UserProfileUpsertWithoutNotificationsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutNotificationsInput, UserProfileUpdateWithoutNotificationsInput>, UserProfileUncheckedUpdateWithoutNotificationsInput>
  }

  export type SpaceCreatetagsInput = {
    set: string[]
  }

  export type SpaceMemberCreateNestedManyWithoutSpaceInput = {
    create?: XOR<SpaceMemberCreateWithoutSpaceInput, SpaceMemberUncheckedCreateWithoutSpaceInput> | SpaceMemberCreateWithoutSpaceInput[] | SpaceMemberUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: SpaceMemberCreateOrConnectWithoutSpaceInput | SpaceMemberCreateOrConnectWithoutSpaceInput[]
    createMany?: SpaceMemberCreateManySpaceInputEnvelope
    connect?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
  }

  export type ChannelCreateNestedManyWithoutSpaceInput = {
    create?: XOR<ChannelCreateWithoutSpaceInput, ChannelUncheckedCreateWithoutSpaceInput> | ChannelCreateWithoutSpaceInput[] | ChannelUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutSpaceInput | ChannelCreateOrConnectWithoutSpaceInput[]
    createMany?: ChannelCreateManySpaceInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutSpaceInput = {
    create?: XOR<PostCreateWithoutSpaceInput, PostUncheckedCreateWithoutSpaceInput> | PostCreateWithoutSpaceInput[] | PostUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: PostCreateOrConnectWithoutSpaceInput | PostCreateOrConnectWithoutSpaceInput[]
    createMany?: PostCreateManySpaceInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutSpaceInput = {
    create?: XOR<FileCreateWithoutSpaceInput, FileUncheckedCreateWithoutSpaceInput> | FileCreateWithoutSpaceInput[] | FileUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: FileCreateOrConnectWithoutSpaceInput | FileCreateOrConnectWithoutSpaceInput[]
    createMany?: FileCreateManySpaceInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type SpaceCreateNestedOneWithoutChildSpacesInput = {
    create?: XOR<SpaceCreateWithoutChildSpacesInput, SpaceUncheckedCreateWithoutChildSpacesInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutChildSpacesInput
    connect?: SpaceWhereUniqueInput
  }

  export type SpaceCreateNestedManyWithoutParentSpaceInput = {
    create?: XOR<SpaceCreateWithoutParentSpaceInput, SpaceUncheckedCreateWithoutParentSpaceInput> | SpaceCreateWithoutParentSpaceInput[] | SpaceUncheckedCreateWithoutParentSpaceInput[]
    connectOrCreate?: SpaceCreateOrConnectWithoutParentSpaceInput | SpaceCreateOrConnectWithoutParentSpaceInput[]
    createMany?: SpaceCreateManyParentSpaceInputEnvelope
    connect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
  }

  export type SpaceMemberUncheckedCreateNestedManyWithoutSpaceInput = {
    create?: XOR<SpaceMemberCreateWithoutSpaceInput, SpaceMemberUncheckedCreateWithoutSpaceInput> | SpaceMemberCreateWithoutSpaceInput[] | SpaceMemberUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: SpaceMemberCreateOrConnectWithoutSpaceInput | SpaceMemberCreateOrConnectWithoutSpaceInput[]
    createMany?: SpaceMemberCreateManySpaceInputEnvelope
    connect?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
  }

  export type ChannelUncheckedCreateNestedManyWithoutSpaceInput = {
    create?: XOR<ChannelCreateWithoutSpaceInput, ChannelUncheckedCreateWithoutSpaceInput> | ChannelCreateWithoutSpaceInput[] | ChannelUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutSpaceInput | ChannelCreateOrConnectWithoutSpaceInput[]
    createMany?: ChannelCreateManySpaceInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutSpaceInput = {
    create?: XOR<PostCreateWithoutSpaceInput, PostUncheckedCreateWithoutSpaceInput> | PostCreateWithoutSpaceInput[] | PostUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: PostCreateOrConnectWithoutSpaceInput | PostCreateOrConnectWithoutSpaceInput[]
    createMany?: PostCreateManySpaceInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutSpaceInput = {
    create?: XOR<FileCreateWithoutSpaceInput, FileUncheckedCreateWithoutSpaceInput> | FileCreateWithoutSpaceInput[] | FileUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: FileCreateOrConnectWithoutSpaceInput | FileCreateOrConnectWithoutSpaceInput[]
    createMany?: FileCreateManySpaceInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type SpaceUncheckedCreateNestedManyWithoutParentSpaceInput = {
    create?: XOR<SpaceCreateWithoutParentSpaceInput, SpaceUncheckedCreateWithoutParentSpaceInput> | SpaceCreateWithoutParentSpaceInput[] | SpaceUncheckedCreateWithoutParentSpaceInput[]
    connectOrCreate?: SpaceCreateOrConnectWithoutParentSpaceInput | SpaceCreateOrConnectWithoutParentSpaceInput[]
    createMany?: SpaceCreateManyParentSpaceInputEnvelope
    connect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
  }

  export type EnumSpaceTypeFieldUpdateOperationsInput = {
    set?: $Enums.SpaceType
  }

  export type EnumAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.AccessLevel
  }

  export type SpaceUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SpaceMemberUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<SpaceMemberCreateWithoutSpaceInput, SpaceMemberUncheckedCreateWithoutSpaceInput> | SpaceMemberCreateWithoutSpaceInput[] | SpaceMemberUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: SpaceMemberCreateOrConnectWithoutSpaceInput | SpaceMemberCreateOrConnectWithoutSpaceInput[]
    upsert?: SpaceMemberUpsertWithWhereUniqueWithoutSpaceInput | SpaceMemberUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: SpaceMemberCreateManySpaceInputEnvelope
    set?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
    disconnect?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
    delete?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
    connect?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
    update?: SpaceMemberUpdateWithWhereUniqueWithoutSpaceInput | SpaceMemberUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: SpaceMemberUpdateManyWithWhereWithoutSpaceInput | SpaceMemberUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: SpaceMemberScalarWhereInput | SpaceMemberScalarWhereInput[]
  }

  export type ChannelUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<ChannelCreateWithoutSpaceInput, ChannelUncheckedCreateWithoutSpaceInput> | ChannelCreateWithoutSpaceInput[] | ChannelUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutSpaceInput | ChannelCreateOrConnectWithoutSpaceInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutSpaceInput | ChannelUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: ChannelCreateManySpaceInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutSpaceInput | ChannelUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutSpaceInput | ChannelUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type PostUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<PostCreateWithoutSpaceInput, PostUncheckedCreateWithoutSpaceInput> | PostCreateWithoutSpaceInput[] | PostUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: PostCreateOrConnectWithoutSpaceInput | PostCreateOrConnectWithoutSpaceInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutSpaceInput | PostUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: PostCreateManySpaceInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutSpaceInput | PostUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: PostUpdateManyWithWhereWithoutSpaceInput | PostUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type FileUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<FileCreateWithoutSpaceInput, FileUncheckedCreateWithoutSpaceInput> | FileCreateWithoutSpaceInput[] | FileUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: FileCreateOrConnectWithoutSpaceInput | FileCreateOrConnectWithoutSpaceInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutSpaceInput | FileUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: FileCreateManySpaceInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutSpaceInput | FileUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: FileUpdateManyWithWhereWithoutSpaceInput | FileUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type SpaceUpdateOneWithoutChildSpacesNestedInput = {
    create?: XOR<SpaceCreateWithoutChildSpacesInput, SpaceUncheckedCreateWithoutChildSpacesInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutChildSpacesInput
    upsert?: SpaceUpsertWithoutChildSpacesInput
    disconnect?: SpaceWhereInput | boolean
    delete?: SpaceWhereInput | boolean
    connect?: SpaceWhereUniqueInput
    update?: XOR<XOR<SpaceUpdateToOneWithWhereWithoutChildSpacesInput, SpaceUpdateWithoutChildSpacesInput>, SpaceUncheckedUpdateWithoutChildSpacesInput>
  }

  export type SpaceUpdateManyWithoutParentSpaceNestedInput = {
    create?: XOR<SpaceCreateWithoutParentSpaceInput, SpaceUncheckedCreateWithoutParentSpaceInput> | SpaceCreateWithoutParentSpaceInput[] | SpaceUncheckedCreateWithoutParentSpaceInput[]
    connectOrCreate?: SpaceCreateOrConnectWithoutParentSpaceInput | SpaceCreateOrConnectWithoutParentSpaceInput[]
    upsert?: SpaceUpsertWithWhereUniqueWithoutParentSpaceInput | SpaceUpsertWithWhereUniqueWithoutParentSpaceInput[]
    createMany?: SpaceCreateManyParentSpaceInputEnvelope
    set?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    disconnect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    delete?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    connect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    update?: SpaceUpdateWithWhereUniqueWithoutParentSpaceInput | SpaceUpdateWithWhereUniqueWithoutParentSpaceInput[]
    updateMany?: SpaceUpdateManyWithWhereWithoutParentSpaceInput | SpaceUpdateManyWithWhereWithoutParentSpaceInput[]
    deleteMany?: SpaceScalarWhereInput | SpaceScalarWhereInput[]
  }

  export type SpaceMemberUncheckedUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<SpaceMemberCreateWithoutSpaceInput, SpaceMemberUncheckedCreateWithoutSpaceInput> | SpaceMemberCreateWithoutSpaceInput[] | SpaceMemberUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: SpaceMemberCreateOrConnectWithoutSpaceInput | SpaceMemberCreateOrConnectWithoutSpaceInput[]
    upsert?: SpaceMemberUpsertWithWhereUniqueWithoutSpaceInput | SpaceMemberUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: SpaceMemberCreateManySpaceInputEnvelope
    set?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
    disconnect?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
    delete?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
    connect?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
    update?: SpaceMemberUpdateWithWhereUniqueWithoutSpaceInput | SpaceMemberUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: SpaceMemberUpdateManyWithWhereWithoutSpaceInput | SpaceMemberUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: SpaceMemberScalarWhereInput | SpaceMemberScalarWhereInput[]
  }

  export type ChannelUncheckedUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<ChannelCreateWithoutSpaceInput, ChannelUncheckedCreateWithoutSpaceInput> | ChannelCreateWithoutSpaceInput[] | ChannelUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutSpaceInput | ChannelCreateOrConnectWithoutSpaceInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutSpaceInput | ChannelUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: ChannelCreateManySpaceInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutSpaceInput | ChannelUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutSpaceInput | ChannelUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<PostCreateWithoutSpaceInput, PostUncheckedCreateWithoutSpaceInput> | PostCreateWithoutSpaceInput[] | PostUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: PostCreateOrConnectWithoutSpaceInput | PostCreateOrConnectWithoutSpaceInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutSpaceInput | PostUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: PostCreateManySpaceInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutSpaceInput | PostUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: PostUpdateManyWithWhereWithoutSpaceInput | PostUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<FileCreateWithoutSpaceInput, FileUncheckedCreateWithoutSpaceInput> | FileCreateWithoutSpaceInput[] | FileUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: FileCreateOrConnectWithoutSpaceInput | FileCreateOrConnectWithoutSpaceInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutSpaceInput | FileUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: FileCreateManySpaceInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutSpaceInput | FileUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: FileUpdateManyWithWhereWithoutSpaceInput | FileUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type SpaceUncheckedUpdateManyWithoutParentSpaceNestedInput = {
    create?: XOR<SpaceCreateWithoutParentSpaceInput, SpaceUncheckedCreateWithoutParentSpaceInput> | SpaceCreateWithoutParentSpaceInput[] | SpaceUncheckedCreateWithoutParentSpaceInput[]
    connectOrCreate?: SpaceCreateOrConnectWithoutParentSpaceInput | SpaceCreateOrConnectWithoutParentSpaceInput[]
    upsert?: SpaceUpsertWithWhereUniqueWithoutParentSpaceInput | SpaceUpsertWithWhereUniqueWithoutParentSpaceInput[]
    createMany?: SpaceCreateManyParentSpaceInputEnvelope
    set?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    disconnect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    delete?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    connect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    update?: SpaceUpdateWithWhereUniqueWithoutParentSpaceInput | SpaceUpdateWithWhereUniqueWithoutParentSpaceInput[]
    updateMany?: SpaceUpdateManyWithWhereWithoutParentSpaceInput | SpaceUpdateManyWithWhereWithoutParentSpaceInput[]
    deleteMany?: SpaceScalarWhereInput | SpaceScalarWhereInput[]
  }

  export type ChannelCreatepinnedPostsInput = {
    set: string[]
  }

  export type SpaceCreateNestedOneWithoutChannelsInput = {
    create?: XOR<SpaceCreateWithoutChannelsInput, SpaceUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutChannelsInput
    connect?: SpaceWhereUniqueInput
  }

  export type PostCreateNestedManyWithoutChannelInput = {
    create?: XOR<PostCreateWithoutChannelInput, PostUncheckedCreateWithoutChannelInput> | PostCreateWithoutChannelInput[] | PostUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: PostCreateOrConnectWithoutChannelInput | PostCreateOrConnectWithoutChannelInput[]
    createMany?: PostCreateManyChannelInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutChannelInput = {
    create?: XOR<FileCreateWithoutChannelInput, FileUncheckedCreateWithoutChannelInput> | FileCreateWithoutChannelInput[] | FileUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: FileCreateOrConnectWithoutChannelInput | FileCreateOrConnectWithoutChannelInput[]
    createMany?: FileCreateManyChannelInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ChannelMemberCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelMemberCreateWithoutChannelInput, ChannelMemberUncheckedCreateWithoutChannelInput> | ChannelMemberCreateWithoutChannelInput[] | ChannelMemberUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelMemberCreateOrConnectWithoutChannelInput | ChannelMemberCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelMemberCreateManyChannelInputEnvelope
    connect?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<PostCreateWithoutChannelInput, PostUncheckedCreateWithoutChannelInput> | PostCreateWithoutChannelInput[] | PostUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: PostCreateOrConnectWithoutChannelInput | PostCreateOrConnectWithoutChannelInput[]
    createMany?: PostCreateManyChannelInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<FileCreateWithoutChannelInput, FileUncheckedCreateWithoutChannelInput> | FileCreateWithoutChannelInput[] | FileUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: FileCreateOrConnectWithoutChannelInput | FileCreateOrConnectWithoutChannelInput[]
    createMany?: FileCreateManyChannelInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ChannelMemberUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelMemberCreateWithoutChannelInput, ChannelMemberUncheckedCreateWithoutChannelInput> | ChannelMemberCreateWithoutChannelInput[] | ChannelMemberUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelMemberCreateOrConnectWithoutChannelInput | ChannelMemberCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelMemberCreateManyChannelInputEnvelope
    connect?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
  }

  export type ChannelUpdatepinnedPostsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SpaceUpdateOneRequiredWithoutChannelsNestedInput = {
    create?: XOR<SpaceCreateWithoutChannelsInput, SpaceUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutChannelsInput
    upsert?: SpaceUpsertWithoutChannelsInput
    connect?: SpaceWhereUniqueInput
    update?: XOR<XOR<SpaceUpdateToOneWithWhereWithoutChannelsInput, SpaceUpdateWithoutChannelsInput>, SpaceUncheckedUpdateWithoutChannelsInput>
  }

  export type PostUpdateManyWithoutChannelNestedInput = {
    create?: XOR<PostCreateWithoutChannelInput, PostUncheckedCreateWithoutChannelInput> | PostCreateWithoutChannelInput[] | PostUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: PostCreateOrConnectWithoutChannelInput | PostCreateOrConnectWithoutChannelInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutChannelInput | PostUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: PostCreateManyChannelInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutChannelInput | PostUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: PostUpdateManyWithWhereWithoutChannelInput | PostUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type FileUpdateManyWithoutChannelNestedInput = {
    create?: XOR<FileCreateWithoutChannelInput, FileUncheckedCreateWithoutChannelInput> | FileCreateWithoutChannelInput[] | FileUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: FileCreateOrConnectWithoutChannelInput | FileCreateOrConnectWithoutChannelInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutChannelInput | FileUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: FileCreateManyChannelInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutChannelInput | FileUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: FileUpdateManyWithWhereWithoutChannelInput | FileUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ChannelMemberUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelMemberCreateWithoutChannelInput, ChannelMemberUncheckedCreateWithoutChannelInput> | ChannelMemberCreateWithoutChannelInput[] | ChannelMemberUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelMemberCreateOrConnectWithoutChannelInput | ChannelMemberCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelMemberUpsertWithWhereUniqueWithoutChannelInput | ChannelMemberUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelMemberCreateManyChannelInputEnvelope
    set?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
    disconnect?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
    delete?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
    connect?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
    update?: ChannelMemberUpdateWithWhereUniqueWithoutChannelInput | ChannelMemberUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelMemberUpdateManyWithWhereWithoutChannelInput | ChannelMemberUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelMemberScalarWhereInput | ChannelMemberScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<PostCreateWithoutChannelInput, PostUncheckedCreateWithoutChannelInput> | PostCreateWithoutChannelInput[] | PostUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: PostCreateOrConnectWithoutChannelInput | PostCreateOrConnectWithoutChannelInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutChannelInput | PostUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: PostCreateManyChannelInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutChannelInput | PostUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: PostUpdateManyWithWhereWithoutChannelInput | PostUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<FileCreateWithoutChannelInput, FileUncheckedCreateWithoutChannelInput> | FileCreateWithoutChannelInput[] | FileUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: FileCreateOrConnectWithoutChannelInput | FileCreateOrConnectWithoutChannelInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutChannelInput | FileUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: FileCreateManyChannelInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutChannelInput | FileUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: FileUpdateManyWithWhereWithoutChannelInput | FileUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ChannelMemberUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelMemberCreateWithoutChannelInput, ChannelMemberUncheckedCreateWithoutChannelInput> | ChannelMemberCreateWithoutChannelInput[] | ChannelMemberUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelMemberCreateOrConnectWithoutChannelInput | ChannelMemberCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelMemberUpsertWithWhereUniqueWithoutChannelInput | ChannelMemberUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelMemberCreateManyChannelInputEnvelope
    set?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
    disconnect?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
    delete?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
    connect?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
    update?: ChannelMemberUpdateWithWhereUniqueWithoutChannelInput | ChannelMemberUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelMemberUpdateManyWithWhereWithoutChannelInput | ChannelMemberUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelMemberScalarWhereInput | ChannelMemberScalarWhereInput[]
  }

  export type ThreadCreatepostIdsInput = {
    set: string[]
  }

  export type PostCreateNestedManyWithoutThreadInput = {
    create?: XOR<PostCreateWithoutThreadInput, PostUncheckedCreateWithoutThreadInput> | PostCreateWithoutThreadInput[] | PostUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: PostCreateOrConnectWithoutThreadInput | PostCreateOrConnectWithoutThreadInput[]
    createMany?: PostCreateManyThreadInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PollPostCreateNestedManyWithoutThreadInput = {
    create?: XOR<PollPostCreateWithoutThreadInput, PollPostUncheckedCreateWithoutThreadInput> | PollPostCreateWithoutThreadInput[] | PollPostUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: PollPostCreateOrConnectWithoutThreadInput | PollPostCreateOrConnectWithoutThreadInput[]
    createMany?: PollPostCreateManyThreadInputEnvelope
    connect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<PostCreateWithoutThreadInput, PostUncheckedCreateWithoutThreadInput> | PostCreateWithoutThreadInput[] | PostUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: PostCreateOrConnectWithoutThreadInput | PostCreateOrConnectWithoutThreadInput[]
    createMany?: PostCreateManyThreadInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PollPostUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<PollPostCreateWithoutThreadInput, PollPostUncheckedCreateWithoutThreadInput> | PollPostCreateWithoutThreadInput[] | PollPostUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: PollPostCreateOrConnectWithoutThreadInput | PollPostCreateOrConnectWithoutThreadInput[]
    createMany?: PollPostCreateManyThreadInputEnvelope
    connect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
  }

  export type ThreadUpdatepostIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PostUpdateManyWithoutThreadNestedInput = {
    create?: XOR<PostCreateWithoutThreadInput, PostUncheckedCreateWithoutThreadInput> | PostCreateWithoutThreadInput[] | PostUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: PostCreateOrConnectWithoutThreadInput | PostCreateOrConnectWithoutThreadInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutThreadInput | PostUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: PostCreateManyThreadInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutThreadInput | PostUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: PostUpdateManyWithWhereWithoutThreadInput | PostUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PollPostUpdateManyWithoutThreadNestedInput = {
    create?: XOR<PollPostCreateWithoutThreadInput, PollPostUncheckedCreateWithoutThreadInput> | PollPostCreateWithoutThreadInput[] | PollPostUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: PollPostCreateOrConnectWithoutThreadInput | PollPostCreateOrConnectWithoutThreadInput[]
    upsert?: PollPostUpsertWithWhereUniqueWithoutThreadInput | PollPostUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: PollPostCreateManyThreadInputEnvelope
    set?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    disconnect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    delete?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    connect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    update?: PollPostUpdateWithWhereUniqueWithoutThreadInput | PollPostUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: PollPostUpdateManyWithWhereWithoutThreadInput | PollPostUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: PollPostScalarWhereInput | PollPostScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<PostCreateWithoutThreadInput, PostUncheckedCreateWithoutThreadInput> | PostCreateWithoutThreadInput[] | PostUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: PostCreateOrConnectWithoutThreadInput | PostCreateOrConnectWithoutThreadInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutThreadInput | PostUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: PostCreateManyThreadInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutThreadInput | PostUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: PostUpdateManyWithWhereWithoutThreadInput | PostUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PollPostUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<PollPostCreateWithoutThreadInput, PollPostUncheckedCreateWithoutThreadInput> | PollPostCreateWithoutThreadInput[] | PollPostUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: PollPostCreateOrConnectWithoutThreadInput | PollPostCreateOrConnectWithoutThreadInput[]
    upsert?: PollPostUpsertWithWhereUniqueWithoutThreadInput | PollPostUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: PollPostCreateManyThreadInputEnvelope
    set?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    disconnect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    delete?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    connect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    update?: PollPostUpdateWithWhereUniqueWithoutThreadInput | PollPostUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: PollPostUpdateManyWithWhereWithoutThreadInput | PollPostUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: PollPostScalarWhereInput | PollPostScalarWhereInput[]
  }

  export type NoteCreatementionsInput = {
    set: string[]
  }

  export type NoteCreatehashtagsInput = {
    set: string[]
  }

  export type MediaCreateNestedOneWithoutNotesInput = {
    create?: XOR<MediaCreateWithoutNotesInput, MediaUncheckedCreateWithoutNotesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutNotesInput
    connect?: MediaWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutNotesInput = {
    create?: XOR<PostCreateWithoutNotesInput, PostUncheckedCreateWithoutNotesInput>
    connectOrCreate?: PostCreateOrConnectWithoutNotesInput
    connect?: PostWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutNotesInput = {
    create?: XOR<CommentCreateWithoutNotesInput, CommentUncheckedCreateWithoutNotesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutNotesInput
    connect?: CommentWhereUniqueInput
  }

  export type NoteUpdatementionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NoteUpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MediaUpdateOneWithoutNotesNestedInput = {
    create?: XOR<MediaCreateWithoutNotesInput, MediaUncheckedCreateWithoutNotesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutNotesInput
    upsert?: MediaUpsertWithoutNotesInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutNotesInput, MediaUpdateWithoutNotesInput>, MediaUncheckedUpdateWithoutNotesInput>
  }

  export type PostUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<PostCreateWithoutNotesInput, PostUncheckedCreateWithoutNotesInput>
    connectOrCreate?: PostCreateOrConnectWithoutNotesInput
    upsert?: PostUpsertWithoutNotesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutNotesInput, PostUpdateWithoutNotesInput>, PostUncheckedUpdateWithoutNotesInput>
  }

  export type CommentUpdateOneWithoutNotesNestedInput = {
    create?: XOR<CommentCreateWithoutNotesInput, CommentUncheckedCreateWithoutNotesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutNotesInput
    upsert?: CommentUpsertWithoutNotesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutNotesInput, CommentUpdateWithoutNotesInput>, CommentUncheckedUpdateWithoutNotesInput>
  }

  export type SpaceMemberCreatepermissionsInput = {
    set: string[]
  }

  export type SpaceCreateNestedOneWithoutMembersInput = {
    create?: XOR<SpaceCreateWithoutMembersInput, SpaceUncheckedCreateWithoutMembersInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutMembersInput
    connect?: SpaceWhereUniqueInput
  }

  export type SpaceMemberUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SpaceUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<SpaceCreateWithoutMembersInput, SpaceUncheckedCreateWithoutMembersInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutMembersInput
    upsert?: SpaceUpsertWithoutMembersInput
    connect?: SpaceWhereUniqueInput
    update?: XOR<XOR<SpaceUpdateToOneWithWhereWithoutMembersInput, SpaceUpdateWithoutMembersInput>, SpaceUncheckedUpdateWithoutMembersInput>
  }

  export type ChannelCreateNestedOneWithoutMembersInput = {
    create?: XOR<ChannelCreateWithoutMembersInput, ChannelUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutMembersInput
    connect?: ChannelWhereUniqueInput
  }

  export type ChannelUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ChannelCreateWithoutMembersInput, ChannelUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutMembersInput
    upsert?: ChannelUpsertWithoutMembersInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutMembersInput, ChannelUpdateWithoutMembersInput>, ChannelUncheckedUpdateWithoutMembersInput>
  }

  export type PostCreateNestedManyWithoutFilesInput = {
    create?: XOR<PostCreateWithoutFilesInput, PostUncheckedCreateWithoutFilesInput> | PostCreateWithoutFilesInput[] | PostUncheckedCreateWithoutFilesInput[]
    connectOrCreate?: PostCreateOrConnectWithoutFilesInput | PostCreateOrConnectWithoutFilesInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type SpaceCreateNestedOneWithoutFilesInput = {
    create?: XOR<SpaceCreateWithoutFilesInput, SpaceUncheckedCreateWithoutFilesInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutFilesInput
    connect?: SpaceWhereUniqueInput
  }

  export type ChannelCreateNestedOneWithoutFilesInput = {
    create?: XOR<ChannelCreateWithoutFilesInput, ChannelUncheckedCreateWithoutFilesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutFilesInput
    connect?: ChannelWhereUniqueInput
  }

  export type PostUncheckedCreateNestedManyWithoutFilesInput = {
    create?: XOR<PostCreateWithoutFilesInput, PostUncheckedCreateWithoutFilesInput> | PostCreateWithoutFilesInput[] | PostUncheckedCreateWithoutFilesInput[]
    connectOrCreate?: PostCreateOrConnectWithoutFilesInput | PostCreateOrConnectWithoutFilesInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PostUpdateManyWithoutFilesNestedInput = {
    create?: XOR<PostCreateWithoutFilesInput, PostUncheckedCreateWithoutFilesInput> | PostCreateWithoutFilesInput[] | PostUncheckedCreateWithoutFilesInput[]
    connectOrCreate?: PostCreateOrConnectWithoutFilesInput | PostCreateOrConnectWithoutFilesInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutFilesInput | PostUpsertWithWhereUniqueWithoutFilesInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutFilesInput | PostUpdateWithWhereUniqueWithoutFilesInput[]
    updateMany?: PostUpdateManyWithWhereWithoutFilesInput | PostUpdateManyWithWhereWithoutFilesInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type SpaceUpdateOneWithoutFilesNestedInput = {
    create?: XOR<SpaceCreateWithoutFilesInput, SpaceUncheckedCreateWithoutFilesInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutFilesInput
    upsert?: SpaceUpsertWithoutFilesInput
    disconnect?: SpaceWhereInput | boolean
    delete?: SpaceWhereInput | boolean
    connect?: SpaceWhereUniqueInput
    update?: XOR<XOR<SpaceUpdateToOneWithWhereWithoutFilesInput, SpaceUpdateWithoutFilesInput>, SpaceUncheckedUpdateWithoutFilesInput>
  }

  export type ChannelUpdateOneWithoutFilesNestedInput = {
    create?: XOR<ChannelCreateWithoutFilesInput, ChannelUncheckedCreateWithoutFilesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutFilesInput
    upsert?: ChannelUpsertWithoutFilesInput
    disconnect?: ChannelWhereInput | boolean
    delete?: ChannelWhereInput | boolean
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutFilesInput, ChannelUpdateWithoutFilesInput>, ChannelUncheckedUpdateWithoutFilesInput>
  }

  export type PostUncheckedUpdateManyWithoutFilesNestedInput = {
    create?: XOR<PostCreateWithoutFilesInput, PostUncheckedCreateWithoutFilesInput> | PostCreateWithoutFilesInput[] | PostUncheckedCreateWithoutFilesInput[]
    connectOrCreate?: PostCreateOrConnectWithoutFilesInput | PostCreateOrConnectWithoutFilesInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutFilesInput | PostUpsertWithWhereUniqueWithoutFilesInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutFilesInput | PostUpdateWithWhereUniqueWithoutFilesInput[]
    updateMany?: PostUpdateManyWithWhereWithoutFilesInput | PostUpdateManyWithWhereWithoutFilesInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedEnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeFilter<$PrismaModel> | $Enums.PostType
  }

  export type NestedEnumCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableFilter<$PrismaModel> | $Enums.Category | null
  }

  export type NestedEnumThreadParticipantTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreadParticipantType | EnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ThreadParticipantType[] | ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ThreadParticipantType[] | ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumThreadParticipantTypeNullableFilter<$PrismaModel> | $Enums.ThreadParticipantType | null
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedEnumVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityFilter<$PrismaModel> | $Enums.Visibility
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeWithAggregatesFilter<$PrismaModel> | $Enums.PostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostTypeFilter<$PrismaModel>
    _max?: NestedEnumPostTypeFilter<$PrismaModel>
  }

  export type NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.Category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumCategoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumThreadParticipantTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreadParticipantType | EnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ThreadParticipantType[] | ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ThreadParticipantType[] | ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumThreadParticipantTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ThreadParticipantType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumThreadParticipantTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumThreadParticipantTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedEnumVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Visibility | EnumVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Visibility[] | ListEnumVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.Visibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisibilityFilter<$PrismaModel>
    _max?: NestedEnumVisibilityFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeFilter<$PrismaModel> | $Enums.ReactionType
  }

  export type NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumReportReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportReason | EnumReportReasonFieldRefInput<$PrismaModel>
    in?: $Enums.ReportReason[] | ListEnumReportReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportReason[] | ListEnumReportReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumReportReasonFilter<$PrismaModel> | $Enums.ReportReason
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportReason | EnumReportReasonFieldRefInput<$PrismaModel>
    in?: $Enums.ReportReason[] | ListEnumReportReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportReason[] | ListEnumReportReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumReportReasonWithAggregatesFilter<$PrismaModel> | $Enums.ReportReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportReasonFilter<$PrismaModel>
    _max?: NestedEnumReportReasonFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumSpaceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SpaceType | EnumSpaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SpaceType[] | ListEnumSpaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpaceType[] | ListEnumSpaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpaceTypeFilter<$PrismaModel> | $Enums.SpaceType
  }

  export type NestedEnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }

  export type NestedEnumSpaceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SpaceType | EnumSpaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SpaceType[] | ListEnumSpaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpaceType[] | ListEnumSpaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpaceTypeWithAggregatesFilter<$PrismaModel> | $Enums.SpaceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpaceTypeFilter<$PrismaModel>
    _max?: NestedEnumSpaceTypeFilter<$PrismaModel>
  }

  export type NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserProfileCreateWithoutVirtualProfileInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkCreateNestedManyWithoutUsersInput
    tags?: UserTagCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowCreateNestedManyWithoutFollowedProfileInput
    following?: FollowCreateNestedManyWithoutFollowingProfileInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUncheckedCreateWithoutVirtualProfileInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUsersInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationUncheckedCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationUncheckedCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowedProfileInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportUncheckedCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileCreateOrConnectWithoutVirtualProfileInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutVirtualProfileInput, UserProfileUncheckedCreateWithoutVirtualProfileInput>
  }

  export type UserProfileCreateManyVirtualProfileInputEnvelope = {
    data: UserProfileCreateManyVirtualProfileInput | UserProfileCreateManyVirtualProfileInput[]
    skipDuplicates?: boolean
  }

  export type CommunityProfileCreateWithoutVirtualProfileInput = {
    id?: string
    name?: string | null
    description?: string | null
    communityRules?: string | null
    profileImageUrl?: string | null
    private?: boolean | null
    visible?: boolean | null
    followers?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicCreateNestedManyWithoutCommunityProfileInput
    posts?: PostCreateNestedManyWithoutCommunityInput
    moderators?: UserProfileCreateNestedManyWithoutModeratedCommunitiesInput
  }

  export type CommunityProfileUncheckedCreateWithoutVirtualProfileInput = {
    id?: string
    name?: string | null
    description?: string | null
    communityRules?: string | null
    profileImageUrl?: string | null
    private?: boolean | null
    visible?: boolean | null
    followers?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutCommunityProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutCommunityInput
    moderators?: UserProfileUncheckedCreateNestedManyWithoutModeratedCommunitiesInput
  }

  export type CommunityProfileCreateOrConnectWithoutVirtualProfileInput = {
    where: CommunityProfileWhereUniqueInput
    create: XOR<CommunityProfileCreateWithoutVirtualProfileInput, CommunityProfileUncheckedCreateWithoutVirtualProfileInput>
  }

  export type CommunityProfileCreateManyVirtualProfileInputEnvelope = {
    data: CommunityProfileCreateManyVirtualProfileInput | CommunityProfileCreateManyVirtualProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithWhereUniqueWithoutVirtualProfileInput = {
    where: UserProfileWhereUniqueInput
    update: XOR<UserProfileUpdateWithoutVirtualProfileInput, UserProfileUncheckedUpdateWithoutVirtualProfileInput>
    create: XOR<UserProfileCreateWithoutVirtualProfileInput, UserProfileUncheckedCreateWithoutVirtualProfileInput>
  }

  export type UserProfileUpdateWithWhereUniqueWithoutVirtualProfileInput = {
    where: UserProfileWhereUniqueInput
    data: XOR<UserProfileUpdateWithoutVirtualProfileInput, UserProfileUncheckedUpdateWithoutVirtualProfileInput>
  }

  export type UserProfileUpdateManyWithWhereWithoutVirtualProfileInput = {
    where: UserProfileScalarWhereInput
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyWithoutVirtualProfileInput>
  }

  export type UserProfileScalarWhereInput = {
    AND?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
    OR?: UserProfileScalarWhereInput[]
    NOT?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
    id?: StringFilter<"UserProfile"> | string
    virtualProfileId?: StringFilter<"UserProfile"> | string
    name?: StringNullableFilter<"UserProfile"> | string | null
    profileImageUrl?: StringNullableFilter<"UserProfile"> | string | null
    bio?: StringNullableFilter<"UserProfile"> | string | null
    private?: BoolNullableFilter<"UserProfile"> | boolean | null
    followersCount?: IntFilter<"UserProfile"> | number
    followingCount?: IntFilter<"UserProfile"> | number
    newsFeedTimelineId?: StringNullableFilter<"UserProfile"> | string | null
    personalFeedTimelineId?: StringNullableFilter<"UserProfile"> | string | null
    notificationFeedTimelineId?: StringNullableFilter<"UserProfile"> | string | null
    algoliaId?: StringNullableFilter<"UserProfile"> | string | null
    metadata?: JsonNullableFilter<"UserProfile">
    settings?: JsonNullableFilter<"UserProfile">
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
  }

  export type CommunityProfileUpsertWithWhereUniqueWithoutVirtualProfileInput = {
    where: CommunityProfileWhereUniqueInput
    update: XOR<CommunityProfileUpdateWithoutVirtualProfileInput, CommunityProfileUncheckedUpdateWithoutVirtualProfileInput>
    create: XOR<CommunityProfileCreateWithoutVirtualProfileInput, CommunityProfileUncheckedCreateWithoutVirtualProfileInput>
  }

  export type CommunityProfileUpdateWithWhereUniqueWithoutVirtualProfileInput = {
    where: CommunityProfileWhereUniqueInput
    data: XOR<CommunityProfileUpdateWithoutVirtualProfileInput, CommunityProfileUncheckedUpdateWithoutVirtualProfileInput>
  }

  export type CommunityProfileUpdateManyWithWhereWithoutVirtualProfileInput = {
    where: CommunityProfileScalarWhereInput
    data: XOR<CommunityProfileUpdateManyMutationInput, CommunityProfileUncheckedUpdateManyWithoutVirtualProfileInput>
  }

  export type CommunityProfileScalarWhereInput = {
    AND?: CommunityProfileScalarWhereInput | CommunityProfileScalarWhereInput[]
    OR?: CommunityProfileScalarWhereInput[]
    NOT?: CommunityProfileScalarWhereInput | CommunityProfileScalarWhereInput[]
    id?: StringFilter<"CommunityProfile"> | string
    virtualProfileId?: StringFilter<"CommunityProfile"> | string
    name?: StringNullableFilter<"CommunityProfile"> | string | null
    description?: StringNullableFilter<"CommunityProfile"> | string | null
    communityRules?: StringNullableFilter<"CommunityProfile"> | string | null
    profileImageUrl?: StringNullableFilter<"CommunityProfile"> | string | null
    private?: BoolNullableFilter<"CommunityProfile"> | boolean | null
    visible?: BoolNullableFilter<"CommunityProfile"> | boolean | null
    followers?: IntFilter<"CommunityProfile"> | number
    newsFeedTimelineId?: StringNullableFilter<"CommunityProfile"> | string | null
    personalFeedTimelineId?: StringNullableFilter<"CommunityProfile"> | string | null
    notificationFeedTimelineId?: StringNullableFilter<"CommunityProfile"> | string | null
    algoliaId?: StringNullableFilter<"CommunityProfile"> | string | null
    metadata?: JsonNullableFilter<"CommunityProfile">
    settings?: JsonNullableFilter<"CommunityProfile">
    createdAt?: DateTimeFilter<"CommunityProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityProfile"> | Date | string
  }

  export type VirtualProfileCreateWithoutUserProfileInput = {
    id?: string
    userId?: string | null
    profileType?: string | null
    activated?: boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    communityProfile?: CommunityProfileCreateNestedManyWithoutVirtualProfileInput
  }

  export type VirtualProfileUncheckedCreateWithoutUserProfileInput = {
    id?: string
    userId?: string | null
    profileType?: string | null
    activated?: boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    communityProfile?: CommunityProfileUncheckedCreateNestedManyWithoutVirtualProfileInput
  }

  export type VirtualProfileCreateOrConnectWithoutUserProfileInput = {
    where: VirtualProfileWhereUniqueInput
    create: XOR<VirtualProfileCreateWithoutUserProfileInput, VirtualProfileUncheckedCreateWithoutUserProfileInput>
  }

  export type BookmarkCreateWithoutUsersInput = {
    id?: string
    postIds?: BookmarkCreatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    publications?: PublicationCreateNestedManyWithoutBookmarksInput
    posts?: PostCreateNestedManyWithoutBookmarksInput
  }

  export type BookmarkUncheckedCreateWithoutUsersInput = {
    id?: string
    postIds?: BookmarkCreatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    publications?: PublicationUncheckedCreateNestedManyWithoutBookmarksInput
    posts?: PostUncheckedCreateNestedManyWithoutBookmarksInput
  }

  export type BookmarkCreateOrConnectWithoutUsersInput = {
    where: BookmarkWhereUniqueInput
    create: XOR<BookmarkCreateWithoutUsersInput, BookmarkUncheckedCreateWithoutUsersInput>
  }

  export type UserTagCreateWithoutUserProfileInput = {
    id?: string
    tagName?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagUncheckedCreateWithoutUserProfileInput = {
    id?: string
    tagName?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagCreateOrConnectWithoutUserProfileInput = {
    where: UserTagWhereUniqueInput
    create: XOR<UserTagCreateWithoutUserProfileInput, UserTagUncheckedCreateWithoutUserProfileInput>
  }

  export type UserTagCreateManyUserProfileInputEnvelope = {
    data: UserTagCreateManyUserProfileInput | UserTagCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type PublicationCreateWithoutAdminsInput = {
    id?: string
    publicationName?: string | null
    description?: string | null
    type?: string | null
    postIds?: PublicationCreatepostIdsInput | string[]
    subjects?: PublicationCreatesubjectsInput | string[]
    tags?: PublicationCreatetagsInput | string[]
    adminBackendPlatformUserId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkCreateNestedManyWithoutPublicationsInput
    editors?: UserProfileCreateNestedManyWithoutEditorPublicationsInput
    posts?: PostCreateNestedManyWithoutPublicationsInput
  }

  export type PublicationUncheckedCreateWithoutAdminsInput = {
    id?: string
    publicationName?: string | null
    description?: string | null
    type?: string | null
    postIds?: PublicationCreatepostIdsInput | string[]
    subjects?: PublicationCreatesubjectsInput | string[]
    tags?: PublicationCreatetagsInput | string[]
    adminBackendPlatformUserId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPublicationsInput
    editors?: UserProfileUncheckedCreateNestedManyWithoutEditorPublicationsInput
    posts?: PostUncheckedCreateNestedManyWithoutPublicationsInput
  }

  export type PublicationCreateOrConnectWithoutAdminsInput = {
    where: PublicationWhereUniqueInput
    create: XOR<PublicationCreateWithoutAdminsInput, PublicationUncheckedCreateWithoutAdminsInput>
  }

  export type PublicationCreateWithoutEditorsInput = {
    id?: string
    publicationName?: string | null
    description?: string | null
    type?: string | null
    postIds?: PublicationCreatepostIdsInput | string[]
    subjects?: PublicationCreatesubjectsInput | string[]
    tags?: PublicationCreatetagsInput | string[]
    adminBackendPlatformUserId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkCreateNestedManyWithoutPublicationsInput
    admins?: UserProfileCreateNestedManyWithoutAdminPublicationsInput
    posts?: PostCreateNestedManyWithoutPublicationsInput
  }

  export type PublicationUncheckedCreateWithoutEditorsInput = {
    id?: string
    publicationName?: string | null
    description?: string | null
    type?: string | null
    postIds?: PublicationCreatepostIdsInput | string[]
    subjects?: PublicationCreatesubjectsInput | string[]
    tags?: PublicationCreatetagsInput | string[]
    adminBackendPlatformUserId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPublicationsInput
    admins?: UserProfileUncheckedCreateNestedManyWithoutAdminPublicationsInput
    posts?: PostUncheckedCreateNestedManyWithoutPublicationsInput
  }

  export type PublicationCreateOrConnectWithoutEditorsInput = {
    where: PublicationWhereUniqueInput
    create: XOR<PublicationCreateWithoutEditorsInput, PublicationUncheckedCreateWithoutEditorsInput>
  }

  export type BlockCreateWithoutBlockedProfileInput = {
    id?: string
    profileBlockingType: string
    profileBlockedType: string
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    blockingProfile: UserProfileCreateNestedOneWithoutBlockingInput
  }

  export type BlockUncheckedCreateWithoutBlockedProfileInput = {
    id?: string
    profileBlockingId: string
    profileBlockingType: string
    profileBlockedType: string
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BlockCreateOrConnectWithoutBlockedProfileInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutBlockedProfileInput, BlockUncheckedCreateWithoutBlockedProfileInput>
  }

  export type BlockCreateManyBlockedProfileInputEnvelope = {
    data: BlockCreateManyBlockedProfileInput | BlockCreateManyBlockedProfileInput[]
    skipDuplicates?: boolean
  }

  export type BlockCreateWithoutBlockingProfileInput = {
    id?: string
    profileBlockingType: string
    profileBlockedType: string
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    blockedProfile: UserProfileCreateNestedOneWithoutBlockedByInput
  }

  export type BlockUncheckedCreateWithoutBlockingProfileInput = {
    id?: string
    profileBlockedId: string
    profileBlockingType: string
    profileBlockedType: string
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BlockCreateOrConnectWithoutBlockingProfileInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutBlockingProfileInput, BlockUncheckedCreateWithoutBlockingProfileInput>
  }

  export type BlockCreateManyBlockingProfileInputEnvelope = {
    data: BlockCreateManyBlockingProfileInput | BlockCreateManyBlockingProfileInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowedProfileInput = {
    id?: string
    targetFollowerType: string
    requestApproved?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    approvedAt?: Date | string | null
    followingProfile: UserProfileCreateNestedOneWithoutFollowingInput
  }

  export type FollowUncheckedCreateWithoutFollowedProfileInput = {
    id?: string
    profileFollowingId: string
    targetFollowerType: string
    requestApproved?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type FollowCreateOrConnectWithoutFollowedProfileInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowedProfileInput, FollowUncheckedCreateWithoutFollowedProfileInput>
  }

  export type FollowCreateManyFollowedProfileInputEnvelope = {
    data: FollowCreateManyFollowedProfileInput | FollowCreateManyFollowedProfileInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowingProfileInput = {
    id?: string
    targetFollowerType: string
    requestApproved?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    approvedAt?: Date | string | null
    followedProfile: UserProfileCreateNestedOneWithoutFollowersInput
  }

  export type FollowUncheckedCreateWithoutFollowingProfileInput = {
    id?: string
    profileFollowedId: string
    targetFollowerType: string
    requestApproved?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type FollowCreateOrConnectWithoutFollowingProfileInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowingProfileInput, FollowUncheckedCreateWithoutFollowingProfileInput>
  }

  export type FollowCreateManyFollowingProfileInputEnvelope = {
    data: FollowCreateManyFollowingProfileInput | FollowCreateManyFollowingProfileInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutAuthorInput = {
    id?: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    media?: MediaCreateNestedOneWithoutPostsInput
    files?: FileCreateNestedManyWithoutPostsInput
    community?: CommunityProfileCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkCreateNestedManyWithoutPostsInput
    publications?: PublicationCreateNestedManyWithoutPostsInput
    reports?: ReportCreateNestedManyWithoutReportedPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    files?: FileUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPostsInput
    publications?: PublicationUncheckedCreateNestedManyWithoutPostsInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserProfileInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaCreateNestedOneWithoutCommentsInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    notes?: NoteCreateNestedManyWithoutCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    pollPost?: PollPostCreateNestedOneWithoutCommentsInput
    Report?: ReportCreateNestedManyWithoutReportedCommentInput
    Reaction?: ReactionCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutUserProfileInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    pollPostId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
    notes?: NoteUncheckedCreateNestedManyWithoutCommentInput
    Report?: ReportUncheckedCreateNestedManyWithoutReportedCommentInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutUserProfileInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserProfileInput, CommentUncheckedCreateWithoutUserProfileInput>
  }

  export type ReactionCreateWithoutUserInput = {
    id?: string
    type: $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    post?: PostCreateNestedOneWithoutReactionsInput
    comment?: CommentCreateNestedOneWithoutReactionInput
  }

  export type ReactionUncheckedCreateWithoutUserInput = {
    id?: string
    postId?: string | null
    commentId?: string | null
    type: $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReactionCreateOrConnectWithoutUserInput = {
    where: ReactionWhereUniqueInput
    create: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput>
  }

  export type ReactionCreateManyUserInputEnvelope = {
    data: ReactionCreateManyUserInput | ReactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutSubmitterInput = {
    id?: string
    reason: $Enums.ReportReason
    description?: string | null
    status?: $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    reportedUser?: UserProfileCreateNestedOneWithoutReportedContentInput
    reportedPost?: PostCreateNestedOneWithoutReportsInput
    reportedComment?: CommentCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutSubmitterInput = {
    id?: string
    postId?: string | null
    commentId?: string | null
    userId?: string | null
    reason: $Enums.ReportReason
    description?: string | null
    status?: $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ReportCreateOrConnectWithoutSubmitterInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutSubmitterInput, ReportUncheckedCreateWithoutSubmitterInput>
  }

  export type ReportCreateManySubmitterInputEnvelope = {
    data: ReportCreateManySubmitterInput | ReportCreateManySubmitterInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutReportedUserInput = {
    id?: string
    reason: $Enums.ReportReason
    description?: string | null
    status?: $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    submitter: UserProfileCreateNestedOneWithoutReportsSubmittedInput
    reportedPost?: PostCreateNestedOneWithoutReportsInput
    reportedComment?: CommentCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutReportedUserInput = {
    id?: string
    submitterId: string
    postId?: string | null
    commentId?: string | null
    reason: $Enums.ReportReason
    description?: string | null
    status?: $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ReportCreateOrConnectWithoutReportedUserInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput>
  }

  export type ReportCreateManyReportedUserInputEnvelope = {
    data: ReportCreateManyReportedUserInput | ReportCreateManyReportedUserInput[]
    skipDuplicates?: boolean
  }

  export type CommunityProfileCreateWithoutModeratorsInput = {
    id?: string
    name?: string | null
    description?: string | null
    communityRules?: string | null
    profileImageUrl?: string | null
    private?: boolean | null
    visible?: boolean | null
    followers?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutCommunityProfileInput
    topics?: TopicCreateNestedManyWithoutCommunityProfileInput
    posts?: PostCreateNestedManyWithoutCommunityInput
  }

  export type CommunityProfileUncheckedCreateWithoutModeratorsInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    description?: string | null
    communityRules?: string | null
    profileImageUrl?: string | null
    private?: boolean | null
    visible?: boolean | null
    followers?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutCommunityProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityProfileCreateOrConnectWithoutModeratorsInput = {
    where: CommunityProfileWhereUniqueInput
    create: XOR<CommunityProfileCreateWithoutModeratorsInput, CommunityProfileUncheckedCreateWithoutModeratorsInput>
  }

  export type VirtualProfileUpsertWithoutUserProfileInput = {
    update: XOR<VirtualProfileUpdateWithoutUserProfileInput, VirtualProfileUncheckedUpdateWithoutUserProfileInput>
    create: XOR<VirtualProfileCreateWithoutUserProfileInput, VirtualProfileUncheckedCreateWithoutUserProfileInput>
    where?: VirtualProfileWhereInput
  }

  export type VirtualProfileUpdateToOneWithWhereWithoutUserProfileInput = {
    where?: VirtualProfileWhereInput
    data: XOR<VirtualProfileUpdateWithoutUserProfileInput, VirtualProfileUncheckedUpdateWithoutUserProfileInput>
  }

  export type VirtualProfileUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    profileType?: NullableStringFieldUpdateOperationsInput | string | null
    activated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityProfile?: CommunityProfileUpdateManyWithoutVirtualProfileNestedInput
  }

  export type VirtualProfileUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    profileType?: NullableStringFieldUpdateOperationsInput | string | null
    activated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityProfile?: CommunityProfileUncheckedUpdateManyWithoutVirtualProfileNestedInput
  }

  export type BookmarkUpsertWithWhereUniqueWithoutUsersInput = {
    where: BookmarkWhereUniqueInput
    update: XOR<BookmarkUpdateWithoutUsersInput, BookmarkUncheckedUpdateWithoutUsersInput>
    create: XOR<BookmarkCreateWithoutUsersInput, BookmarkUncheckedCreateWithoutUsersInput>
  }

  export type BookmarkUpdateWithWhereUniqueWithoutUsersInput = {
    where: BookmarkWhereUniqueInput
    data: XOR<BookmarkUpdateWithoutUsersInput, BookmarkUncheckedUpdateWithoutUsersInput>
  }

  export type BookmarkUpdateManyWithWhereWithoutUsersInput = {
    where: BookmarkScalarWhereInput
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyWithoutUsersInput>
  }

  export type BookmarkScalarWhereInput = {
    AND?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
    OR?: BookmarkScalarWhereInput[]
    NOT?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
    id?: StringFilter<"Bookmark"> | string
    postIds?: StringNullableListFilter<"Bookmark">
    metadata?: JsonNullableFilter<"Bookmark">
    createdAt?: DateTimeFilter<"Bookmark"> | Date | string
    updatedAt?: DateTimeFilter<"Bookmark"> | Date | string
  }

  export type UserTagUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: UserTagWhereUniqueInput
    update: XOR<UserTagUpdateWithoutUserProfileInput, UserTagUncheckedUpdateWithoutUserProfileInput>
    create: XOR<UserTagCreateWithoutUserProfileInput, UserTagUncheckedCreateWithoutUserProfileInput>
  }

  export type UserTagUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: UserTagWhereUniqueInput
    data: XOR<UserTagUpdateWithoutUserProfileInput, UserTagUncheckedUpdateWithoutUserProfileInput>
  }

  export type UserTagUpdateManyWithWhereWithoutUserProfileInput = {
    where: UserTagScalarWhereInput
    data: XOR<UserTagUpdateManyMutationInput, UserTagUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type UserTagScalarWhereInput = {
    AND?: UserTagScalarWhereInput | UserTagScalarWhereInput[]
    OR?: UserTagScalarWhereInput[]
    NOT?: UserTagScalarWhereInput | UserTagScalarWhereInput[]
    id?: StringFilter<"UserTag"> | string
    userProfileId?: StringFilter<"UserTag"> | string
    tagName?: StringNullableFilter<"UserTag"> | string | null
    description?: StringNullableFilter<"UserTag"> | string | null
    metadata?: JsonNullableFilter<"UserTag">
    createdAt?: DateTimeFilter<"UserTag"> | Date | string
    updatedAt?: DateTimeFilter<"UserTag"> | Date | string
  }

  export type PublicationUpsertWithWhereUniqueWithoutAdminsInput = {
    where: PublicationWhereUniqueInput
    update: XOR<PublicationUpdateWithoutAdminsInput, PublicationUncheckedUpdateWithoutAdminsInput>
    create: XOR<PublicationCreateWithoutAdminsInput, PublicationUncheckedCreateWithoutAdminsInput>
  }

  export type PublicationUpdateWithWhereUniqueWithoutAdminsInput = {
    where: PublicationWhereUniqueInput
    data: XOR<PublicationUpdateWithoutAdminsInput, PublicationUncheckedUpdateWithoutAdminsInput>
  }

  export type PublicationUpdateManyWithWhereWithoutAdminsInput = {
    where: PublicationScalarWhereInput
    data: XOR<PublicationUpdateManyMutationInput, PublicationUncheckedUpdateManyWithoutAdminsInput>
  }

  export type PublicationScalarWhereInput = {
    AND?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
    OR?: PublicationScalarWhereInput[]
    NOT?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
    id?: StringFilter<"Publication"> | string
    publicationName?: StringNullableFilter<"Publication"> | string | null
    description?: StringNullableFilter<"Publication"> | string | null
    type?: StringNullableFilter<"Publication"> | string | null
    postIds?: StringNullableListFilter<"Publication">
    subjects?: StringNullableListFilter<"Publication">
    tags?: StringNullableListFilter<"Publication">
    adminBackendPlatformUserId?: StringNullableFilter<"Publication"> | string | null
    metadata?: JsonNullableFilter<"Publication">
    createdAt?: DateTimeFilter<"Publication"> | Date | string
    updatedAt?: DateTimeFilter<"Publication"> | Date | string
  }

  export type PublicationUpsertWithWhereUniqueWithoutEditorsInput = {
    where: PublicationWhereUniqueInput
    update: XOR<PublicationUpdateWithoutEditorsInput, PublicationUncheckedUpdateWithoutEditorsInput>
    create: XOR<PublicationCreateWithoutEditorsInput, PublicationUncheckedCreateWithoutEditorsInput>
  }

  export type PublicationUpdateWithWhereUniqueWithoutEditorsInput = {
    where: PublicationWhereUniqueInput
    data: XOR<PublicationUpdateWithoutEditorsInput, PublicationUncheckedUpdateWithoutEditorsInput>
  }

  export type PublicationUpdateManyWithWhereWithoutEditorsInput = {
    where: PublicationScalarWhereInput
    data: XOR<PublicationUpdateManyMutationInput, PublicationUncheckedUpdateManyWithoutEditorsInput>
  }

  export type BlockUpsertWithWhereUniqueWithoutBlockedProfileInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutBlockedProfileInput, BlockUncheckedUpdateWithoutBlockedProfileInput>
    create: XOR<BlockCreateWithoutBlockedProfileInput, BlockUncheckedCreateWithoutBlockedProfileInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutBlockedProfileInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutBlockedProfileInput, BlockUncheckedUpdateWithoutBlockedProfileInput>
  }

  export type BlockUpdateManyWithWhereWithoutBlockedProfileInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutBlockedProfileInput>
  }

  export type BlockScalarWhereInput = {
    AND?: BlockScalarWhereInput | BlockScalarWhereInput[]
    OR?: BlockScalarWhereInput[]
    NOT?: BlockScalarWhereInput | BlockScalarWhereInput[]
    id?: StringFilter<"Block"> | string
    profileBlockingId?: StringFilter<"Block"> | string
    profileBlockedId?: StringFilter<"Block"> | string
    profileBlockingType?: StringFilter<"Block"> | string
    profileBlockedType?: StringFilter<"Block"> | string
    reason?: StringNullableFilter<"Block"> | string | null
    metadata?: JsonNullableFilter<"Block">
    createdAt?: DateTimeFilter<"Block"> | Date | string
  }

  export type BlockUpsertWithWhereUniqueWithoutBlockingProfileInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutBlockingProfileInput, BlockUncheckedUpdateWithoutBlockingProfileInput>
    create: XOR<BlockCreateWithoutBlockingProfileInput, BlockUncheckedCreateWithoutBlockingProfileInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutBlockingProfileInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutBlockingProfileInput, BlockUncheckedUpdateWithoutBlockingProfileInput>
  }

  export type BlockUpdateManyWithWhereWithoutBlockingProfileInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutBlockingProfileInput>
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowedProfileInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowedProfileInput, FollowUncheckedUpdateWithoutFollowedProfileInput>
    create: XOR<FollowCreateWithoutFollowedProfileInput, FollowUncheckedCreateWithoutFollowedProfileInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowedProfileInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowedProfileInput, FollowUncheckedUpdateWithoutFollowedProfileInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowedProfileInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowedProfileInput>
  }

  export type FollowScalarWhereInput = {
    AND?: FollowScalarWhereInput | FollowScalarWhereInput[]
    OR?: FollowScalarWhereInput[]
    NOT?: FollowScalarWhereInput | FollowScalarWhereInput[]
    id?: StringFilter<"Follow"> | string
    profileFollowingId?: StringFilter<"Follow"> | string
    profileFollowedId?: StringFilter<"Follow"> | string
    targetFollowerType?: StringFilter<"Follow"> | string
    requestApproved?: BoolFilter<"Follow"> | boolean
    metadata?: JsonNullableFilter<"Follow">
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Follow"> | Date | string | null
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowingProfileInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowingProfileInput, FollowUncheckedUpdateWithoutFollowingProfileInput>
    create: XOR<FollowCreateWithoutFollowingProfileInput, FollowUncheckedCreateWithoutFollowingProfileInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowingProfileInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowingProfileInput, FollowUncheckedUpdateWithoutFollowingProfileInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowingProfileInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowingProfileInput>
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    authorId?: StringFilter<"Post"> | string
    communityId?: StringNullableFilter<"Post"> | string | null
    parentSpaceId?: StringNullableFilter<"Post"> | string | null
    title?: StringNullableFilter<"Post"> | string | null
    content?: StringFilter<"Post"> | string
    description?: StringNullableFilter<"Post"> | string | null
    status?: EnumPostStatusFilter<"Post"> | $Enums.PostStatus
    workflowStatus?: StringNullableFilter<"Post"> | string | null
    assignedTo?: StringNullableFilter<"Post"> | string | null
    contentFormat?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    postType?: EnumPostTypeFilter<"Post"> | $Enums.PostType
    category?: EnumCategoryNullableFilter<"Post"> | $Enums.Category | null
    threadParticipantType?: EnumThreadParticipantTypeNullableFilter<"Post"> | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFilter<"Post"> | string
    profileId?: IntFilter<"Post"> | number
    authorUsername?: StringFilter<"Post"> | string
    authorProfileImage?: StringNullableFilter<"Post"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Post"> | $Enums.AccountType
    tags?: StringNullableListFilter<"Post">
    mentions?: StringNullableListFilter<"Post">
    hashtags?: StringNullableListFilter<"Post">
    topicName?: StringNullableFilter<"Post"> | string | null
    mediaId?: StringNullableFilter<"Post"> | string | null
    backgroundImageUrl?: StringNullableFilter<"Post"> | string | null
    affinityScore?: IntFilter<"Post"> | number
    qualityScore?: IntFilter<"Post"> | number
    viewCount?: IntFilter<"Post"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"Post">
    userIdToReportsMap?: JsonNullableFilter<"Post">
    userIdToReactionMap?: JsonNullableFilter<"Post">
    insights?: JsonNullableFilter<"Post">
    readingTime?: StringNullableFilter<"Post"> | string | null
    aiGeneratedQuestionResponse?: StringNullableFilter<"Post"> | string | null
    aiAnalysis?: JsonNullableFilter<"Post">
    searchMetadata?: JsonNullableFilter<"Post">
    metadata?: JsonNullableFilter<"Post">
    threadId?: StringNullableFilter<"Post"> | string | null
    spaceId?: StringNullableFilter<"Post"> | string | null
    channelId?: StringNullableFilter<"Post"> | string | null
    extra?: JsonNullableFilter<"Post">
    visibility?: EnumVisibilityFilter<"Post"> | $Enums.Visibility
    isPinned?: BoolFilter<"Post"> | boolean
    isArchived?: BoolFilter<"Post"> | boolean
    workflow?: JsonNullableFilter<"Post">
    version?: IntFilter<"Post"> | number
  }

  export type CommentUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserProfileInput, CommentUncheckedUpdateWithoutUserProfileInput>
    create: XOR<CommentCreateWithoutUserProfileInput, CommentUncheckedCreateWithoutUserProfileInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserProfileInput, CommentUncheckedUpdateWithoutUserProfileInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserProfileInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    backendPlatformUserId?: StringFilter<"Comment"> | string
    profileId?: IntFilter<"Comment"> | number
    authorUsername?: StringFilter<"Comment"> | string
    authorProfileImage?: StringNullableFilter<"Comment"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Comment"> | $Enums.AccountType
    affinityScore?: IntFilter<"Comment"> | number
    qualityScore?: IntFilter<"Comment"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"Comment">
    userIdToReportsMap?: JsonNullableFilter<"Comment">
    userIdToReactionMap?: JsonNullableFilter<"Comment">
    mentions?: StringNullableListFilter<"Comment">
    hashtags?: StringNullableListFilter<"Comment">
    mediaId?: StringNullableFilter<"Comment"> | string | null
    postId?: StringFilter<"Comment"> | string
    pollPostId?: StringNullableFilter<"Comment"> | string | null
    extra?: JsonNullableFilter<"Comment">
    aiAnalysis?: JsonNullableFilter<"Comment">
  }

  export type ReactionUpsertWithWhereUniqueWithoutUserInput = {
    where: ReactionWhereUniqueInput
    update: XOR<ReactionUpdateWithoutUserInput, ReactionUncheckedUpdateWithoutUserInput>
    create: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput>
  }

  export type ReactionUpdateWithWhereUniqueWithoutUserInput = {
    where: ReactionWhereUniqueInput
    data: XOR<ReactionUpdateWithoutUserInput, ReactionUncheckedUpdateWithoutUserInput>
  }

  export type ReactionUpdateManyWithWhereWithoutUserInput = {
    where: ReactionScalarWhereInput
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyWithoutUserInput>
  }

  export type ReactionScalarWhereInput = {
    AND?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
    OR?: ReactionScalarWhereInput[]
    NOT?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
    id?: StringFilter<"Reaction"> | string
    userId?: StringFilter<"Reaction"> | string
    postId?: StringNullableFilter<"Reaction"> | string | null
    commentId?: StringNullableFilter<"Reaction"> | string | null
    type?: EnumReactionTypeFilter<"Reaction"> | $Enums.ReactionType
    metadata?: JsonNullableFilter<"Reaction">
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type ReportUpsertWithWhereUniqueWithoutSubmitterInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutSubmitterInput, ReportUncheckedUpdateWithoutSubmitterInput>
    create: XOR<ReportCreateWithoutSubmitterInput, ReportUncheckedCreateWithoutSubmitterInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutSubmitterInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutSubmitterInput, ReportUncheckedUpdateWithoutSubmitterInput>
  }

  export type ReportUpdateManyWithWhereWithoutSubmitterInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutSubmitterInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    submitterId?: StringFilter<"Report"> | string
    postId?: StringNullableFilter<"Report"> | string | null
    commentId?: StringNullableFilter<"Report"> | string | null
    userId?: StringNullableFilter<"Report"> | string | null
    reason?: EnumReportReasonFilter<"Report"> | $Enums.ReportReason
    description?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    metadata?: JsonNullableFilter<"Report">
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
  }

  export type ReportUpsertWithWhereUniqueWithoutReportedUserInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReportedUserInput, ReportUncheckedUpdateWithoutReportedUserInput>
    create: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReportedUserInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReportedUserInput, ReportUncheckedUpdateWithoutReportedUserInput>
  }

  export type ReportUpdateManyWithWhereWithoutReportedUserInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReportedUserInput>
  }

  export type CommunityProfileUpsertWithWhereUniqueWithoutModeratorsInput = {
    where: CommunityProfileWhereUniqueInput
    update: XOR<CommunityProfileUpdateWithoutModeratorsInput, CommunityProfileUncheckedUpdateWithoutModeratorsInput>
    create: XOR<CommunityProfileCreateWithoutModeratorsInput, CommunityProfileUncheckedCreateWithoutModeratorsInput>
  }

  export type CommunityProfileUpdateWithWhereUniqueWithoutModeratorsInput = {
    where: CommunityProfileWhereUniqueInput
    data: XOR<CommunityProfileUpdateWithoutModeratorsInput, CommunityProfileUncheckedUpdateWithoutModeratorsInput>
  }

  export type CommunityProfileUpdateManyWithWhereWithoutModeratorsInput = {
    where: CommunityProfileScalarWhereInput
    data: XOR<CommunityProfileUpdateManyMutationInput, CommunityProfileUncheckedUpdateManyWithoutModeratorsInput>
  }

  export type VirtualProfileCreateWithoutCommunityProfileInput = {
    id?: string
    userId?: string | null
    profileType?: string | null
    activated?: boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userProfile?: UserProfileCreateNestedManyWithoutVirtualProfileInput
  }

  export type VirtualProfileUncheckedCreateWithoutCommunityProfileInput = {
    id?: string
    userId?: string | null
    profileType?: string | null
    activated?: boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userProfile?: UserProfileUncheckedCreateNestedManyWithoutVirtualProfileInput
  }

  export type VirtualProfileCreateOrConnectWithoutCommunityProfileInput = {
    where: VirtualProfileWhereUniqueInput
    create: XOR<VirtualProfileCreateWithoutCommunityProfileInput, VirtualProfileUncheckedCreateWithoutCommunityProfileInput>
  }

  export type TopicCreateWithoutCommunityProfileInput = {
    id?: string
    topicName?: string | null
    description?: string | null
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicUncheckedCreateWithoutCommunityProfileInput = {
    id?: string
    topicName?: string | null
    description?: string | null
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicCreateOrConnectWithoutCommunityProfileInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutCommunityProfileInput, TopicUncheckedCreateWithoutCommunityProfileInput>
  }

  export type TopicCreateManyCommunityProfileInputEnvelope = {
    data: TopicCreateManyCommunityProfileInput | TopicCreateManyCommunityProfileInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutCommunityInput = {
    id?: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    media?: MediaCreateNestedOneWithoutPostsInput
    files?: FileCreateNestedManyWithoutPostsInput
    author: UserProfileCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkCreateNestedManyWithoutPostsInput
    publications?: PublicationCreateNestedManyWithoutPostsInput
    reports?: ReportCreateNestedManyWithoutReportedPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutCommunityInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    files?: FileUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPostsInput
    publications?: PublicationUncheckedCreateNestedManyWithoutPostsInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommunityInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput>
  }

  export type PostCreateManyCommunityInputEnvelope = {
    data: PostCreateManyCommunityInput | PostCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileCreateWithoutModeratedCommunitiesInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutUserProfileInput
    bookmarks?: BookmarkCreateNestedManyWithoutUsersInput
    tags?: UserTagCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowCreateNestedManyWithoutFollowedProfileInput
    following?: FollowCreateNestedManyWithoutFollowingProfileInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportCreateNestedManyWithoutReportedUserInput
  }

  export type UserProfileUncheckedCreateWithoutModeratedCommunitiesInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUsersInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationUncheckedCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationUncheckedCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowedProfileInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportUncheckedCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
  }

  export type UserProfileCreateOrConnectWithoutModeratedCommunitiesInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutModeratedCommunitiesInput, UserProfileUncheckedCreateWithoutModeratedCommunitiesInput>
  }

  export type VirtualProfileUpsertWithoutCommunityProfileInput = {
    update: XOR<VirtualProfileUpdateWithoutCommunityProfileInput, VirtualProfileUncheckedUpdateWithoutCommunityProfileInput>
    create: XOR<VirtualProfileCreateWithoutCommunityProfileInput, VirtualProfileUncheckedCreateWithoutCommunityProfileInput>
    where?: VirtualProfileWhereInput
  }

  export type VirtualProfileUpdateToOneWithWhereWithoutCommunityProfileInput = {
    where?: VirtualProfileWhereInput
    data: XOR<VirtualProfileUpdateWithoutCommunityProfileInput, VirtualProfileUncheckedUpdateWithoutCommunityProfileInput>
  }

  export type VirtualProfileUpdateWithoutCommunityProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    profileType?: NullableStringFieldUpdateOperationsInput | string | null
    activated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUpdateManyWithoutVirtualProfileNestedInput
  }

  export type VirtualProfileUncheckedUpdateWithoutCommunityProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    profileType?: NullableStringFieldUpdateOperationsInput | string | null
    activated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUncheckedUpdateManyWithoutVirtualProfileNestedInput
  }

  export type TopicUpsertWithWhereUniqueWithoutCommunityProfileInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutCommunityProfileInput, TopicUncheckedUpdateWithoutCommunityProfileInput>
    create: XOR<TopicCreateWithoutCommunityProfileInput, TopicUncheckedCreateWithoutCommunityProfileInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutCommunityProfileInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutCommunityProfileInput, TopicUncheckedUpdateWithoutCommunityProfileInput>
  }

  export type TopicUpdateManyWithWhereWithoutCommunityProfileInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutCommunityProfileInput>
  }

  export type TopicScalarWhereInput = {
    AND?: TopicScalarWhereInput | TopicScalarWhereInput[]
    OR?: TopicScalarWhereInput[]
    NOT?: TopicScalarWhereInput | TopicScalarWhereInput[]
    id?: StringFilter<"Topic"> | string
    communityProfileId?: StringFilter<"Topic"> | string
    topicName?: StringNullableFilter<"Topic"> | string | null
    description?: StringNullableFilter<"Topic"> | string | null
    imageUrl?: StringNullableFilter<"Topic"> | string | null
    metadata?: JsonNullableFilter<"Topic">
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
  }

  export type PostUpsertWithWhereUniqueWithoutCommunityInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutCommunityInput, PostUncheckedUpdateWithoutCommunityInput>
    create: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput>
  }

  export type PostUpdateWithWhereUniqueWithoutCommunityInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutCommunityInput, PostUncheckedUpdateWithoutCommunityInput>
  }

  export type PostUpdateManyWithWhereWithoutCommunityInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutCommunityInput>
  }

  export type UserProfileUpsertWithWhereUniqueWithoutModeratedCommunitiesInput = {
    where: UserProfileWhereUniqueInput
    update: XOR<UserProfileUpdateWithoutModeratedCommunitiesInput, UserProfileUncheckedUpdateWithoutModeratedCommunitiesInput>
    create: XOR<UserProfileCreateWithoutModeratedCommunitiesInput, UserProfileUncheckedCreateWithoutModeratedCommunitiesInput>
  }

  export type UserProfileUpdateWithWhereUniqueWithoutModeratedCommunitiesInput = {
    where: UserProfileWhereUniqueInput
    data: XOR<UserProfileUpdateWithoutModeratedCommunitiesInput, UserProfileUncheckedUpdateWithoutModeratedCommunitiesInput>
  }

  export type UserProfileUpdateManyWithWhereWithoutModeratedCommunitiesInput = {
    where: UserProfileScalarWhereInput
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyWithoutModeratedCommunitiesInput>
  }

  export type CommunityProfileCreateWithoutTopicsInput = {
    id?: string
    name?: string | null
    description?: string | null
    communityRules?: string | null
    profileImageUrl?: string | null
    private?: boolean | null
    visible?: boolean | null
    followers?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutCommunityProfileInput
    posts?: PostCreateNestedManyWithoutCommunityInput
    moderators?: UserProfileCreateNestedManyWithoutModeratedCommunitiesInput
  }

  export type CommunityProfileUncheckedCreateWithoutTopicsInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    description?: string | null
    communityRules?: string | null
    profileImageUrl?: string | null
    private?: boolean | null
    visible?: boolean | null
    followers?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutCommunityInput
    moderators?: UserProfileUncheckedCreateNestedManyWithoutModeratedCommunitiesInput
  }

  export type CommunityProfileCreateOrConnectWithoutTopicsInput = {
    where: CommunityProfileWhereUniqueInput
    create: XOR<CommunityProfileCreateWithoutTopicsInput, CommunityProfileUncheckedCreateWithoutTopicsInput>
  }

  export type CommunityProfileUpsertWithoutTopicsInput = {
    update: XOR<CommunityProfileUpdateWithoutTopicsInput, CommunityProfileUncheckedUpdateWithoutTopicsInput>
    create: XOR<CommunityProfileCreateWithoutTopicsInput, CommunityProfileUncheckedCreateWithoutTopicsInput>
    where?: CommunityProfileWhereInput
  }

  export type CommunityProfileUpdateToOneWithWhereWithoutTopicsInput = {
    where?: CommunityProfileWhereInput
    data: XOR<CommunityProfileUpdateWithoutTopicsInput, CommunityProfileUncheckedUpdateWithoutTopicsInput>
  }

  export type CommunityProfileUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    communityRules?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    visible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followers?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutCommunityProfileNestedInput
    posts?: PostUpdateManyWithoutCommunityNestedInput
    moderators?: UserProfileUpdateManyWithoutModeratedCommunitiesNestedInput
  }

  export type CommunityProfileUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    communityRules?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    visible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followers?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutCommunityNestedInput
    moderators?: UserProfileUncheckedUpdateManyWithoutModeratedCommunitiesNestedInput
  }

  export type BookmarkCreateWithoutPublicationsInput = {
    id?: string
    postIds?: BookmarkCreatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserProfileCreateNestedManyWithoutBookmarksInput
    posts?: PostCreateNestedManyWithoutBookmarksInput
  }

  export type BookmarkUncheckedCreateWithoutPublicationsInput = {
    id?: string
    postIds?: BookmarkCreatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserProfileUncheckedCreateNestedManyWithoutBookmarksInput
    posts?: PostUncheckedCreateNestedManyWithoutBookmarksInput
  }

  export type BookmarkCreateOrConnectWithoutPublicationsInput = {
    where: BookmarkWhereUniqueInput
    create: XOR<BookmarkCreateWithoutPublicationsInput, BookmarkUncheckedCreateWithoutPublicationsInput>
  }

  export type UserProfileCreateWithoutAdminPublicationsInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutUserProfileInput
    bookmarks?: BookmarkCreateNestedManyWithoutUsersInput
    tags?: UserTagCreateNestedManyWithoutUserProfileInput
    editorPublications?: PublicationCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowCreateNestedManyWithoutFollowedProfileInput
    following?: FollowCreateNestedManyWithoutFollowingProfileInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUncheckedCreateWithoutAdminPublicationsInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUsersInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserProfileInput
    editorPublications?: PublicationUncheckedCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowedProfileInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportUncheckedCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileCreateOrConnectWithoutAdminPublicationsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutAdminPublicationsInput, UserProfileUncheckedCreateWithoutAdminPublicationsInput>
  }

  export type UserProfileCreateWithoutEditorPublicationsInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutUserProfileInput
    bookmarks?: BookmarkCreateNestedManyWithoutUsersInput
    tags?: UserTagCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationCreateNestedManyWithoutAdminsInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowCreateNestedManyWithoutFollowedProfileInput
    following?: FollowCreateNestedManyWithoutFollowingProfileInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUncheckedCreateWithoutEditorPublicationsInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUsersInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationUncheckedCreateNestedManyWithoutAdminsInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowedProfileInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportUncheckedCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileCreateOrConnectWithoutEditorPublicationsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutEditorPublicationsInput, UserProfileUncheckedCreateWithoutEditorPublicationsInput>
  }

  export type PostCreateWithoutPublicationsInput = {
    id?: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    media?: MediaCreateNestedOneWithoutPostsInput
    files?: FileCreateNestedManyWithoutPostsInput
    author: UserProfileCreateNestedOneWithoutPostsInput
    community?: CommunityProfileCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkCreateNestedManyWithoutPostsInput
    reports?: ReportCreateNestedManyWithoutReportedPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutPublicationsInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    files?: FileUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPostsInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutPublicationsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPublicationsInput, PostUncheckedCreateWithoutPublicationsInput>
  }

  export type BookmarkUpsertWithWhereUniqueWithoutPublicationsInput = {
    where: BookmarkWhereUniqueInput
    update: XOR<BookmarkUpdateWithoutPublicationsInput, BookmarkUncheckedUpdateWithoutPublicationsInput>
    create: XOR<BookmarkCreateWithoutPublicationsInput, BookmarkUncheckedCreateWithoutPublicationsInput>
  }

  export type BookmarkUpdateWithWhereUniqueWithoutPublicationsInput = {
    where: BookmarkWhereUniqueInput
    data: XOR<BookmarkUpdateWithoutPublicationsInput, BookmarkUncheckedUpdateWithoutPublicationsInput>
  }

  export type BookmarkUpdateManyWithWhereWithoutPublicationsInput = {
    where: BookmarkScalarWhereInput
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyWithoutPublicationsInput>
  }

  export type UserProfileUpsertWithWhereUniqueWithoutAdminPublicationsInput = {
    where: UserProfileWhereUniqueInput
    update: XOR<UserProfileUpdateWithoutAdminPublicationsInput, UserProfileUncheckedUpdateWithoutAdminPublicationsInput>
    create: XOR<UserProfileCreateWithoutAdminPublicationsInput, UserProfileUncheckedCreateWithoutAdminPublicationsInput>
  }

  export type UserProfileUpdateWithWhereUniqueWithoutAdminPublicationsInput = {
    where: UserProfileWhereUniqueInput
    data: XOR<UserProfileUpdateWithoutAdminPublicationsInput, UserProfileUncheckedUpdateWithoutAdminPublicationsInput>
  }

  export type UserProfileUpdateManyWithWhereWithoutAdminPublicationsInput = {
    where: UserProfileScalarWhereInput
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyWithoutAdminPublicationsInput>
  }

  export type UserProfileUpsertWithWhereUniqueWithoutEditorPublicationsInput = {
    where: UserProfileWhereUniqueInput
    update: XOR<UserProfileUpdateWithoutEditorPublicationsInput, UserProfileUncheckedUpdateWithoutEditorPublicationsInput>
    create: XOR<UserProfileCreateWithoutEditorPublicationsInput, UserProfileUncheckedCreateWithoutEditorPublicationsInput>
  }

  export type UserProfileUpdateWithWhereUniqueWithoutEditorPublicationsInput = {
    where: UserProfileWhereUniqueInput
    data: XOR<UserProfileUpdateWithoutEditorPublicationsInput, UserProfileUncheckedUpdateWithoutEditorPublicationsInput>
  }

  export type UserProfileUpdateManyWithWhereWithoutEditorPublicationsInput = {
    where: UserProfileScalarWhereInput
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyWithoutEditorPublicationsInput>
  }

  export type PostUpsertWithWhereUniqueWithoutPublicationsInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutPublicationsInput, PostUncheckedUpdateWithoutPublicationsInput>
    create: XOR<PostCreateWithoutPublicationsInput, PostUncheckedCreateWithoutPublicationsInput>
  }

  export type PostUpdateWithWhereUniqueWithoutPublicationsInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutPublicationsInput, PostUncheckedUpdateWithoutPublicationsInput>
  }

  export type PostUpdateManyWithWhereWithoutPublicationsInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutPublicationsInput>
  }

  export type CommentReplyCreateWithoutMediaInput = {
    id?: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    comment: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentReplyUncheckedCreateWithoutMediaInput = {
    id?: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    commentId: string
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentReplyCreateOrConnectWithoutMediaInput = {
    where: CommentReplyWhereUniqueInput
    create: XOR<CommentReplyCreateWithoutMediaInput, CommentReplyUncheckedCreateWithoutMediaInput>
  }

  export type CommentReplyCreateManyMediaInputEnvelope = {
    data: CommentReplyCreateManyMediaInput | CommentReplyCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutMediaInput = {
    id?: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    files?: FileCreateNestedManyWithoutPostsInput
    author: UserProfileCreateNestedOneWithoutPostsInput
    community?: CommunityProfileCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkCreateNestedManyWithoutPostsInput
    publications?: PublicationCreateNestedManyWithoutPostsInput
    reports?: ReportCreateNestedManyWithoutReportedPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutMediaInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    files?: FileUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPostsInput
    publications?: PublicationUncheckedCreateNestedManyWithoutPostsInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutMediaInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutMediaInput, PostUncheckedCreateWithoutMediaInput>
  }

  export type PostCreateManyMediaInputEnvelope = {
    data: PostCreateManyMediaInput | PostCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutMediaInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    notes?: NoteCreateNestedManyWithoutCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    pollPost?: PollPostCreateNestedOneWithoutCommentsInput
    Report?: ReportCreateNestedManyWithoutReportedCommentInput
    Reaction?: ReactionCreateNestedManyWithoutCommentInput
    UserProfile?: UserProfileCreateNestedManyWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutMediaInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    postId: string
    pollPostId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
    notes?: NoteUncheckedCreateNestedManyWithoutCommentInput
    Report?: ReportUncheckedCreateNestedManyWithoutReportedCommentInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutCommentInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutCommentsInput
  }

  export type CommentCreateOrConnectWithoutMediaInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutMediaInput, CommentUncheckedCreateWithoutMediaInput>
  }

  export type CommentCreateManyMediaInputEnvelope = {
    data: CommentCreateManyMediaInput | CommentCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type PollPostCreateWithoutMediaInput = {
    id?: string
    createdAt?: Date | string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentCreateNestedManyWithoutPollPostInput
    thread?: ThreadCreateNestedOneWithoutPollPostsInput
  }

  export type PollPostUncheckedCreateWithoutMediaInput = {
    id?: string
    createdAt?: Date | string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    threadId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentUncheckedCreateNestedManyWithoutPollPostInput
  }

  export type PollPostCreateOrConnectWithoutMediaInput = {
    where: PollPostWhereUniqueInput
    create: XOR<PollPostCreateWithoutMediaInput, PollPostUncheckedCreateWithoutMediaInput>
  }

  export type PollPostCreateManyMediaInputEnvelope = {
    data: PollPostCreateManyMediaInput | PollPostCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutMediaInput = {
    id?: string
    content: string
    createdAt?: Date | string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    post: PostCreateNestedOneWithoutNotesInput
    comment?: CommentCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutMediaInput = {
    id?: string
    content: string
    createdAt?: Date | string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    postId: string
    commentId?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NoteCreateOrConnectWithoutMediaInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutMediaInput, NoteUncheckedCreateWithoutMediaInput>
  }

  export type NoteCreateManyMediaInputEnvelope = {
    data: NoteCreateManyMediaInput | NoteCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type CommentReplyUpsertWithWhereUniqueWithoutMediaInput = {
    where: CommentReplyWhereUniqueInput
    update: XOR<CommentReplyUpdateWithoutMediaInput, CommentReplyUncheckedUpdateWithoutMediaInput>
    create: XOR<CommentReplyCreateWithoutMediaInput, CommentReplyUncheckedCreateWithoutMediaInput>
  }

  export type CommentReplyUpdateWithWhereUniqueWithoutMediaInput = {
    where: CommentReplyWhereUniqueInput
    data: XOR<CommentReplyUpdateWithoutMediaInput, CommentReplyUncheckedUpdateWithoutMediaInput>
  }

  export type CommentReplyUpdateManyWithWhereWithoutMediaInput = {
    where: CommentReplyScalarWhereInput
    data: XOR<CommentReplyUpdateManyMutationInput, CommentReplyUncheckedUpdateManyWithoutMediaInput>
  }

  export type CommentReplyScalarWhereInput = {
    AND?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
    OR?: CommentReplyScalarWhereInput[]
    NOT?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
    id?: StringFilter<"CommentReply"> | string
    content?: StringFilter<"CommentReply"> | string
    createdAt?: DateTimeFilter<"CommentReply"> | Date | string
    backendPlatformUserId?: StringFilter<"CommentReply"> | string
    profileId?: IntFilter<"CommentReply"> | number
    authorUsername?: StringFilter<"CommentReply"> | string
    authorProfileImage?: StringNullableFilter<"CommentReply"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"CommentReply"> | $Enums.AccountType
    affinityScore?: IntFilter<"CommentReply"> | number
    qualityScore?: IntFilter<"CommentReply"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"CommentReply">
    userIdToReportsMap?: JsonNullableFilter<"CommentReply">
    userIdToReactionMap?: JsonNullableFilter<"CommentReply">
    mentions?: StringNullableListFilter<"CommentReply">
    hashtags?: StringNullableListFilter<"CommentReply">
    mediaId?: StringNullableFilter<"CommentReply"> | string | null
    commentId?: StringFilter<"CommentReply"> | string
    extra?: JsonNullableFilter<"CommentReply">
    aiAnalysis?: JsonNullableFilter<"CommentReply">
  }

  export type PostUpsertWithWhereUniqueWithoutMediaInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutMediaInput, PostUncheckedUpdateWithoutMediaInput>
    create: XOR<PostCreateWithoutMediaInput, PostUncheckedCreateWithoutMediaInput>
  }

  export type PostUpdateWithWhereUniqueWithoutMediaInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutMediaInput, PostUncheckedUpdateWithoutMediaInput>
  }

  export type PostUpdateManyWithWhereWithoutMediaInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutMediaInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutMediaInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutMediaInput, CommentUncheckedUpdateWithoutMediaInput>
    create: XOR<CommentCreateWithoutMediaInput, CommentUncheckedCreateWithoutMediaInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutMediaInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutMediaInput, CommentUncheckedUpdateWithoutMediaInput>
  }

  export type CommentUpdateManyWithWhereWithoutMediaInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutMediaInput>
  }

  export type PollPostUpsertWithWhereUniqueWithoutMediaInput = {
    where: PollPostWhereUniqueInput
    update: XOR<PollPostUpdateWithoutMediaInput, PollPostUncheckedUpdateWithoutMediaInput>
    create: XOR<PollPostCreateWithoutMediaInput, PollPostUncheckedCreateWithoutMediaInput>
  }

  export type PollPostUpdateWithWhereUniqueWithoutMediaInput = {
    where: PollPostWhereUniqueInput
    data: XOR<PollPostUpdateWithoutMediaInput, PollPostUncheckedUpdateWithoutMediaInput>
  }

  export type PollPostUpdateManyWithWhereWithoutMediaInput = {
    where: PollPostScalarWhereInput
    data: XOR<PollPostUpdateManyMutationInput, PollPostUncheckedUpdateManyWithoutMediaInput>
  }

  export type PollPostScalarWhereInput = {
    AND?: PollPostScalarWhereInput | PollPostScalarWhereInput[]
    OR?: PollPostScalarWhereInput[]
    NOT?: PollPostScalarWhereInput | PollPostScalarWhereInput[]
    id?: StringFilter<"PollPost"> | string
    createdAt?: DateTimeFilter<"PollPost"> | Date | string
    action?: EnumPostTypeFilter<"PollPost"> | $Enums.PostType
    content?: StringFilter<"PollPost"> | string
    title?: StringNullableFilter<"PollPost"> | string | null
    pollOptions?: StringNullableListFilter<"PollPost">
    pollDistribution?: JsonNullableFilter<"PollPost">
    userIdToPollResponsesMap?: JsonNullableFilter<"PollPost">
    pollEndDate?: DateTimeFilter<"PollPost"> | Date | string
    mentions?: StringNullableListFilter<"PollPost">
    hashtags?: StringNullableListFilter<"PollPost">
    tags?: StringNullableListFilter<"PollPost">
    topicName?: StringNullableFilter<"PollPost"> | string | null
    backendPlatformUserId?: StringFilter<"PollPost"> | string
    profileId?: IntFilter<"PollPost"> | number
    mediaId?: StringNullableFilter<"PollPost"> | string | null
    threadId?: StringNullableFilter<"PollPost"> | string | null
    extra?: JsonNullableFilter<"PollPost">
    searchMetadata?: JsonNullableFilter<"PollPost">
    aiAnalysis?: JsonNullableFilter<"PollPost">
  }

  export type NoteUpsertWithWhereUniqueWithoutMediaInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutMediaInput, NoteUncheckedUpdateWithoutMediaInput>
    create: XOR<NoteCreateWithoutMediaInput, NoteUncheckedCreateWithoutMediaInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutMediaInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutMediaInput, NoteUncheckedUpdateWithoutMediaInput>
  }

  export type NoteUpdateManyWithWhereWithoutMediaInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutMediaInput>
  }

  export type NoteScalarWhereInput = {
    AND?: NoteScalarWhereInput | NoteScalarWhereInput[]
    OR?: NoteScalarWhereInput[]
    NOT?: NoteScalarWhereInput | NoteScalarWhereInput[]
    id?: StringFilter<"Note"> | string
    content?: StringFilter<"Note"> | string
    createdAt?: DateTimeFilter<"Note"> | Date | string
    authorId?: StringFilter<"Note"> | string
    backendPlatformUserId?: StringFilter<"Note"> | string
    profileId?: IntFilter<"Note"> | number
    authorUserName?: StringFilter<"Note"> | string
    authorProfileImage?: StringNullableFilter<"Note"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Note"> | $Enums.AccountType
    mentions?: StringNullableListFilter<"Note">
    hashtags?: StringNullableListFilter<"Note">
    mediaId?: StringNullableFilter<"Note"> | string | null
    postId?: StringFilter<"Note"> | string
    commentId?: StringNullableFilter<"Note"> | string | null
    searchMetadata?: JsonNullableFilter<"Note">
    aiAnalysis?: JsonNullableFilter<"Note">
  }

  export type MediaCreateWithoutPostsInput = {
    id?: string
    mediaType: $Enums.MediaType
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    commentReplies?: CommentReplyCreateNestedManyWithoutMediaInput
    comments?: CommentCreateNestedManyWithoutMediaInput
    pollPosts?: PollPostCreateNestedManyWithoutMediaInput
    notes?: NoteCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutPostsInput = {
    id?: string
    mediaType: $Enums.MediaType
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutMediaInput
    comments?: CommentUncheckedCreateNestedManyWithoutMediaInput
    pollPosts?: PollPostUncheckedCreateNestedManyWithoutMediaInput
    notes?: NoteUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutPostsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutPostsInput, MediaUncheckedCreateWithoutPostsInput>
  }

  export type FileCreateWithoutPostsInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    space?: SpaceCreateNestedOneWithoutFilesInput
    channel?: ChannelCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    spaceId?: string | null
    channelId?: string | null
  }

  export type FileCreateOrConnectWithoutPostsInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutPostsInput, FileUncheckedCreateWithoutPostsInput>
  }

  export type UserProfileCreateWithoutPostsInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutUserProfileInput
    bookmarks?: BookmarkCreateNestedManyWithoutUsersInput
    tags?: UserTagCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowCreateNestedManyWithoutFollowedProfileInput
    following?: FollowCreateNestedManyWithoutFollowingProfileInput
    comments?: CommentCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUncheckedCreateWithoutPostsInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUsersInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationUncheckedCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationUncheckedCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowedProfileInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingProfileInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportUncheckedCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileCreateOrConnectWithoutPostsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutPostsInput, UserProfileUncheckedCreateWithoutPostsInput>
  }

  export type CommunityProfileCreateWithoutPostsInput = {
    id?: string
    name?: string | null
    description?: string | null
    communityRules?: string | null
    profileImageUrl?: string | null
    private?: boolean | null
    visible?: boolean | null
    followers?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutCommunityProfileInput
    topics?: TopicCreateNestedManyWithoutCommunityProfileInput
    moderators?: UserProfileCreateNestedManyWithoutModeratedCommunitiesInput
  }

  export type CommunityProfileUncheckedCreateWithoutPostsInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    description?: string | null
    communityRules?: string | null
    profileImageUrl?: string | null
    private?: boolean | null
    visible?: boolean | null
    followers?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    topics?: TopicUncheckedCreateNestedManyWithoutCommunityProfileInput
    moderators?: UserProfileUncheckedCreateNestedManyWithoutModeratedCommunitiesInput
  }

  export type CommunityProfileCreateOrConnectWithoutPostsInput = {
    where: CommunityProfileWhereUniqueInput
    create: XOR<CommunityProfileCreateWithoutPostsInput, CommunityProfileUncheckedCreateWithoutPostsInput>
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaCreateNestedOneWithoutCommentsInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    notes?: NoteCreateNestedManyWithoutCommentInput
    pollPost?: PollPostCreateNestedOneWithoutCommentsInput
    Report?: ReportCreateNestedManyWithoutReportedCommentInput
    Reaction?: ReactionCreateNestedManyWithoutCommentInput
    UserProfile?: UserProfileCreateNestedManyWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    mediaId?: string | null
    pollPostId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
    notes?: NoteUncheckedCreateNestedManyWithoutCommentInput
    Report?: ReportUncheckedCreateNestedManyWithoutReportedCommentInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutCommentInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutCommentsInput
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type ReactionCreateWithoutPostInput = {
    id?: string
    type: $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserProfileCreateNestedOneWithoutReactionsInput
    comment?: CommentCreateNestedOneWithoutReactionInput
  }

  export type ReactionUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    commentId?: string | null
    type: $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReactionCreateOrConnectWithoutPostInput = {
    where: ReactionWhereUniqueInput
    create: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput>
  }

  export type ReactionCreateManyPostInputEnvelope = {
    data: ReactionCreateManyPostInput | ReactionCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type BookmarkCreateWithoutPostsInput = {
    id?: string
    postIds?: BookmarkCreatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    publications?: PublicationCreateNestedManyWithoutBookmarksInput
    users?: UserProfileCreateNestedManyWithoutBookmarksInput
  }

  export type BookmarkUncheckedCreateWithoutPostsInput = {
    id?: string
    postIds?: BookmarkCreatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    publications?: PublicationUncheckedCreateNestedManyWithoutBookmarksInput
    users?: UserProfileUncheckedCreateNestedManyWithoutBookmarksInput
  }

  export type BookmarkCreateOrConnectWithoutPostsInput = {
    where: BookmarkWhereUniqueInput
    create: XOR<BookmarkCreateWithoutPostsInput, BookmarkUncheckedCreateWithoutPostsInput>
  }

  export type PublicationCreateWithoutPostsInput = {
    id?: string
    publicationName?: string | null
    description?: string | null
    type?: string | null
    postIds?: PublicationCreatepostIdsInput | string[]
    subjects?: PublicationCreatesubjectsInput | string[]
    tags?: PublicationCreatetagsInput | string[]
    adminBackendPlatformUserId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkCreateNestedManyWithoutPublicationsInput
    admins?: UserProfileCreateNestedManyWithoutAdminPublicationsInput
    editors?: UserProfileCreateNestedManyWithoutEditorPublicationsInput
  }

  export type PublicationUncheckedCreateWithoutPostsInput = {
    id?: string
    publicationName?: string | null
    description?: string | null
    type?: string | null
    postIds?: PublicationCreatepostIdsInput | string[]
    subjects?: PublicationCreatesubjectsInput | string[]
    tags?: PublicationCreatetagsInput | string[]
    adminBackendPlatformUserId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPublicationsInput
    admins?: UserProfileUncheckedCreateNestedManyWithoutAdminPublicationsInput
    editors?: UserProfileUncheckedCreateNestedManyWithoutEditorPublicationsInput
  }

  export type PublicationCreateOrConnectWithoutPostsInput = {
    where: PublicationWhereUniqueInput
    create: XOR<PublicationCreateWithoutPostsInput, PublicationUncheckedCreateWithoutPostsInput>
  }

  export type ReportCreateWithoutReportedPostInput = {
    id?: string
    reason: $Enums.ReportReason
    description?: string | null
    status?: $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    submitter: UserProfileCreateNestedOneWithoutReportsSubmittedInput
    reportedUser?: UserProfileCreateNestedOneWithoutReportedContentInput
    reportedComment?: CommentCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutReportedPostInput = {
    id?: string
    submitterId: string
    commentId?: string | null
    userId?: string | null
    reason: $Enums.ReportReason
    description?: string | null
    status?: $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ReportCreateOrConnectWithoutReportedPostInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReportedPostInput, ReportUncheckedCreateWithoutReportedPostInput>
  }

  export type ReportCreateManyReportedPostInputEnvelope = {
    data: ReportCreateManyReportedPostInput | ReportCreateManyReportedPostInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutPostInput = {
    id?: string
    content: string
    createdAt?: Date | string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaCreateNestedOneWithoutNotesInput
    comment?: CommentCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutPostInput = {
    id?: string
    content: string
    createdAt?: Date | string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    mediaId?: string | null
    commentId?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NoteCreateOrConnectWithoutPostInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutPostInput, NoteUncheckedCreateWithoutPostInput>
  }

  export type NoteCreateManyPostInputEnvelope = {
    data: NoteCreateManyPostInput | NoteCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type ThreadCreateWithoutPostsInput = {
    id?: string
    postIds?: ThreadCreatepostIdsInput | string[]
    parentPostId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isLocked?: boolean
    pollPosts?: PollPostCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateWithoutPostsInput = {
    id?: string
    postIds?: ThreadCreatepostIdsInput | string[]
    parentPostId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isLocked?: boolean
    pollPosts?: PollPostUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadCreateOrConnectWithoutPostsInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutPostsInput, ThreadUncheckedCreateWithoutPostsInput>
  }

  export type SpaceCreateWithoutPostsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberCreateNestedManyWithoutSpaceInput
    channels?: ChannelCreateNestedManyWithoutSpaceInput
    files?: FileCreateNestedManyWithoutSpaceInput
    parentSpace?: SpaceCreateNestedOneWithoutChildSpacesInput
    childSpaces?: SpaceCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    parentSpaceId?: string | null
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberUncheckedCreateNestedManyWithoutSpaceInput
    channels?: ChannelUncheckedCreateNestedManyWithoutSpaceInput
    files?: FileUncheckedCreateNestedManyWithoutSpaceInput
    childSpaces?: SpaceUncheckedCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceCreateOrConnectWithoutPostsInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutPostsInput, SpaceUncheckedCreateWithoutPostsInput>
  }

  export type ChannelCreateWithoutPostsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    space: SpaceCreateNestedOneWithoutChannelsInput
    files?: FileCreateNestedManyWithoutChannelInput
    members?: ChannelMemberCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    description?: string | null
    spaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    files?: FileUncheckedCreateNestedManyWithoutChannelInput
    members?: ChannelMemberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutPostsInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutPostsInput, ChannelUncheckedCreateWithoutPostsInput>
  }

  export type MediaUpsertWithoutPostsInput = {
    update: XOR<MediaUpdateWithoutPostsInput, MediaUncheckedUpdateWithoutPostsInput>
    create: XOR<MediaCreateWithoutPostsInput, MediaUncheckedCreateWithoutPostsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutPostsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutPostsInput, MediaUncheckedUpdateWithoutPostsInput>
  }

  export type MediaUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentReplies?: CommentReplyUpdateManyWithoutMediaNestedInput
    comments?: CommentUpdateManyWithoutMediaNestedInput
    pollPosts?: PollPostUpdateManyWithoutMediaNestedInput
    notes?: NoteUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutMediaNestedInput
    comments?: CommentUncheckedUpdateManyWithoutMediaNestedInput
    pollPosts?: PollPostUncheckedUpdateManyWithoutMediaNestedInput
    notes?: NoteUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type FileUpsertWithWhereUniqueWithoutPostsInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutPostsInput, FileUncheckedUpdateWithoutPostsInput>
    create: XOR<FileCreateWithoutPostsInput, FileUncheckedCreateWithoutPostsInput>
  }

  export type FileUpdateWithWhereUniqueWithoutPostsInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutPostsInput, FileUncheckedUpdateWithoutPostsInput>
  }

  export type FileUpdateManyWithWhereWithoutPostsInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutPostsInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: StringFilter<"File"> | string
    name?: StringFilter<"File"> | string
    type?: EnumMediaTypeFilter<"File"> | $Enums.MediaType
    url?: StringFilter<"File"> | string
    metadata?: JsonFilter<"File">
    uploadedBy?: StringFilter<"File"> | string
    uploadedAt?: DateTimeFilter<"File"> | Date | string
    size?: IntFilter<"File"> | number
    status?: StringFilter<"File"> | string
    preview?: StringNullableFilter<"File"> | string | null
    thumbnail?: StringNullableFilter<"File"> | string | null
    searchMetadata?: JsonNullableFilter<"File">
    aiAnalysis?: JsonNullableFilter<"File">
    spaceId?: StringNullableFilter<"File"> | string | null
    channelId?: StringNullableFilter<"File"> | string | null
  }

  export type UserProfileUpsertWithoutPostsInput = {
    update: XOR<UserProfileUpdateWithoutPostsInput, UserProfileUncheckedUpdateWithoutPostsInput>
    create: XOR<UserProfileCreateWithoutPostsInput, UserProfileUncheckedCreateWithoutPostsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutPostsInput, UserProfileUncheckedUpdateWithoutPostsInput>
  }

  export type UserProfileUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUsersNestedInput
    tags?: UserTagUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUpdateManyWithoutFollowingProfileNestedInput
    comments?: CommentUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUsersNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUncheckedUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUncheckedUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUncheckedUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput
  }

  export type CommunityProfileUpsertWithoutPostsInput = {
    update: XOR<CommunityProfileUpdateWithoutPostsInput, CommunityProfileUncheckedUpdateWithoutPostsInput>
    create: XOR<CommunityProfileCreateWithoutPostsInput, CommunityProfileUncheckedCreateWithoutPostsInput>
    where?: CommunityProfileWhereInput
  }

  export type CommunityProfileUpdateToOneWithWhereWithoutPostsInput = {
    where?: CommunityProfileWhereInput
    data: XOR<CommunityProfileUpdateWithoutPostsInput, CommunityProfileUncheckedUpdateWithoutPostsInput>
  }

  export type CommunityProfileUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    communityRules?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    visible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followers?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutCommunityProfileNestedInput
    topics?: TopicUpdateManyWithoutCommunityProfileNestedInput
    moderators?: UserProfileUpdateManyWithoutModeratedCommunitiesNestedInput
  }

  export type CommunityProfileUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    communityRules?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    visible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followers?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutCommunityProfileNestedInput
    moderators?: UserProfileUncheckedUpdateManyWithoutModeratedCommunitiesNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type ReactionUpsertWithWhereUniqueWithoutPostInput = {
    where: ReactionWhereUniqueInput
    update: XOR<ReactionUpdateWithoutPostInput, ReactionUncheckedUpdateWithoutPostInput>
    create: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput>
  }

  export type ReactionUpdateWithWhereUniqueWithoutPostInput = {
    where: ReactionWhereUniqueInput
    data: XOR<ReactionUpdateWithoutPostInput, ReactionUncheckedUpdateWithoutPostInput>
  }

  export type ReactionUpdateManyWithWhereWithoutPostInput = {
    where: ReactionScalarWhereInput
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyWithoutPostInput>
  }

  export type BookmarkUpsertWithWhereUniqueWithoutPostsInput = {
    where: BookmarkWhereUniqueInput
    update: XOR<BookmarkUpdateWithoutPostsInput, BookmarkUncheckedUpdateWithoutPostsInput>
    create: XOR<BookmarkCreateWithoutPostsInput, BookmarkUncheckedCreateWithoutPostsInput>
  }

  export type BookmarkUpdateWithWhereUniqueWithoutPostsInput = {
    where: BookmarkWhereUniqueInput
    data: XOR<BookmarkUpdateWithoutPostsInput, BookmarkUncheckedUpdateWithoutPostsInput>
  }

  export type BookmarkUpdateManyWithWhereWithoutPostsInput = {
    where: BookmarkScalarWhereInput
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyWithoutPostsInput>
  }

  export type PublicationUpsertWithWhereUniqueWithoutPostsInput = {
    where: PublicationWhereUniqueInput
    update: XOR<PublicationUpdateWithoutPostsInput, PublicationUncheckedUpdateWithoutPostsInput>
    create: XOR<PublicationCreateWithoutPostsInput, PublicationUncheckedCreateWithoutPostsInput>
  }

  export type PublicationUpdateWithWhereUniqueWithoutPostsInput = {
    where: PublicationWhereUniqueInput
    data: XOR<PublicationUpdateWithoutPostsInput, PublicationUncheckedUpdateWithoutPostsInput>
  }

  export type PublicationUpdateManyWithWhereWithoutPostsInput = {
    where: PublicationScalarWhereInput
    data: XOR<PublicationUpdateManyMutationInput, PublicationUncheckedUpdateManyWithoutPostsInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutReportedPostInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReportedPostInput, ReportUncheckedUpdateWithoutReportedPostInput>
    create: XOR<ReportCreateWithoutReportedPostInput, ReportUncheckedCreateWithoutReportedPostInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReportedPostInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReportedPostInput, ReportUncheckedUpdateWithoutReportedPostInput>
  }

  export type ReportUpdateManyWithWhereWithoutReportedPostInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReportedPostInput>
  }

  export type NoteUpsertWithWhereUniqueWithoutPostInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutPostInput, NoteUncheckedUpdateWithoutPostInput>
    create: XOR<NoteCreateWithoutPostInput, NoteUncheckedCreateWithoutPostInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutPostInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutPostInput, NoteUncheckedUpdateWithoutPostInput>
  }

  export type NoteUpdateManyWithWhereWithoutPostInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutPostInput>
  }

  export type ThreadUpsertWithoutPostsInput = {
    update: XOR<ThreadUpdateWithoutPostsInput, ThreadUncheckedUpdateWithoutPostsInput>
    create: XOR<ThreadCreateWithoutPostsInput, ThreadUncheckedCreateWithoutPostsInput>
    where?: ThreadWhereInput
  }

  export type ThreadUpdateToOneWithWhereWithoutPostsInput = {
    where?: ThreadWhereInput
    data: XOR<ThreadUpdateWithoutPostsInput, ThreadUncheckedUpdateWithoutPostsInput>
  }

  export type ThreadUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: ThreadUpdatepostIdsInput | string[]
    parentPostId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    pollPosts?: PollPostUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: ThreadUpdatepostIdsInput | string[]
    parentPostId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    pollPosts?: PollPostUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type SpaceUpsertWithoutPostsInput = {
    update: XOR<SpaceUpdateWithoutPostsInput, SpaceUncheckedUpdateWithoutPostsInput>
    create: XOR<SpaceCreateWithoutPostsInput, SpaceUncheckedCreateWithoutPostsInput>
    where?: SpaceWhereInput
  }

  export type SpaceUpdateToOneWithWhereWithoutPostsInput = {
    where?: SpaceWhereInput
    data: XOR<SpaceUpdateWithoutPostsInput, SpaceUncheckedUpdateWithoutPostsInput>
  }

  export type SpaceUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUpdateManyWithoutSpaceNestedInput
    files?: FileUpdateManyWithoutSpaceNestedInput
    parentSpace?: SpaceUpdateOneWithoutChildSpacesNestedInput
    childSpaces?: SpaceUpdateManyWithoutParentSpaceNestedInput
  }

  export type SpaceUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUncheckedUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutSpaceNestedInput
    files?: FileUncheckedUpdateManyWithoutSpaceNestedInput
    childSpaces?: SpaceUncheckedUpdateManyWithoutParentSpaceNestedInput
  }

  export type ChannelUpsertWithoutPostsInput = {
    update: XOR<ChannelUpdateWithoutPostsInput, ChannelUncheckedUpdateWithoutPostsInput>
    create: XOR<ChannelCreateWithoutPostsInput, ChannelUncheckedCreateWithoutPostsInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutPostsInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutPostsInput, ChannelUncheckedUpdateWithoutPostsInput>
  }

  export type ChannelUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    space?: SpaceUpdateOneRequiredWithoutChannelsNestedInput
    files?: FileUpdateManyWithoutChannelNestedInput
    members?: ChannelMemberUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    files?: FileUncheckedUpdateManyWithoutChannelNestedInput
    members?: ChannelMemberUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type MediaCreateWithoutPollPostsInput = {
    id?: string
    mediaType: $Enums.MediaType
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    commentReplies?: CommentReplyCreateNestedManyWithoutMediaInput
    posts?: PostCreateNestedManyWithoutMediaInput
    comments?: CommentCreateNestedManyWithoutMediaInput
    notes?: NoteCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutPollPostsInput = {
    id?: string
    mediaType: $Enums.MediaType
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutMediaInput
    posts?: PostUncheckedCreateNestedManyWithoutMediaInput
    comments?: CommentUncheckedCreateNestedManyWithoutMediaInput
    notes?: NoteUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutPollPostsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutPollPostsInput, MediaUncheckedCreateWithoutPollPostsInput>
  }

  export type CommentCreateWithoutPollPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaCreateNestedOneWithoutCommentsInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    notes?: NoteCreateNestedManyWithoutCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    Report?: ReportCreateNestedManyWithoutReportedCommentInput
    Reaction?: ReactionCreateNestedManyWithoutCommentInput
    UserProfile?: UserProfileCreateNestedManyWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutPollPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
    notes?: NoteUncheckedCreateNestedManyWithoutCommentInput
    Report?: ReportUncheckedCreateNestedManyWithoutReportedCommentInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutCommentInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutCommentsInput
  }

  export type CommentCreateOrConnectWithoutPollPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPollPostInput, CommentUncheckedCreateWithoutPollPostInput>
  }

  export type CommentCreateManyPollPostInputEnvelope = {
    data: CommentCreateManyPollPostInput | CommentCreateManyPollPostInput[]
    skipDuplicates?: boolean
  }

  export type ThreadCreateWithoutPollPostsInput = {
    id?: string
    postIds?: ThreadCreatepostIdsInput | string[]
    parentPostId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isLocked?: boolean
    posts?: PostCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateWithoutPollPostsInput = {
    id?: string
    postIds?: ThreadCreatepostIdsInput | string[]
    parentPostId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isLocked?: boolean
    posts?: PostUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadCreateOrConnectWithoutPollPostsInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutPollPostsInput, ThreadUncheckedCreateWithoutPollPostsInput>
  }

  export type MediaUpsertWithoutPollPostsInput = {
    update: XOR<MediaUpdateWithoutPollPostsInput, MediaUncheckedUpdateWithoutPollPostsInput>
    create: XOR<MediaCreateWithoutPollPostsInput, MediaUncheckedCreateWithoutPollPostsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutPollPostsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutPollPostsInput, MediaUncheckedUpdateWithoutPollPostsInput>
  }

  export type MediaUpdateWithoutPollPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentReplies?: CommentReplyUpdateManyWithoutMediaNestedInput
    posts?: PostUpdateManyWithoutMediaNestedInput
    comments?: CommentUpdateManyWithoutMediaNestedInput
    notes?: NoteUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutPollPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutMediaNestedInput
    posts?: PostUncheckedUpdateManyWithoutMediaNestedInput
    comments?: CommentUncheckedUpdateManyWithoutMediaNestedInput
    notes?: NoteUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutPollPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPollPostInput, CommentUncheckedUpdateWithoutPollPostInput>
    create: XOR<CommentCreateWithoutPollPostInput, CommentUncheckedCreateWithoutPollPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPollPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPollPostInput, CommentUncheckedUpdateWithoutPollPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPollPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPollPostInput>
  }

  export type ThreadUpsertWithoutPollPostsInput = {
    update: XOR<ThreadUpdateWithoutPollPostsInput, ThreadUncheckedUpdateWithoutPollPostsInput>
    create: XOR<ThreadCreateWithoutPollPostsInput, ThreadUncheckedCreateWithoutPollPostsInput>
    where?: ThreadWhereInput
  }

  export type ThreadUpdateToOneWithWhereWithoutPollPostsInput = {
    where?: ThreadWhereInput
    data: XOR<ThreadUpdateWithoutPollPostsInput, ThreadUncheckedUpdateWithoutPollPostsInput>
  }

  export type ThreadUpdateWithoutPollPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: ThreadUpdatepostIdsInput | string[]
    parentPostId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateWithoutPollPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: ThreadUpdatepostIdsInput | string[]
    parentPostId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type MediaCreateWithoutCommentsInput = {
    id?: string
    mediaType: $Enums.MediaType
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    commentReplies?: CommentReplyCreateNestedManyWithoutMediaInput
    posts?: PostCreateNestedManyWithoutMediaInput
    pollPosts?: PollPostCreateNestedManyWithoutMediaInput
    notes?: NoteCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutCommentsInput = {
    id?: string
    mediaType: $Enums.MediaType
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutMediaInput
    posts?: PostUncheckedCreateNestedManyWithoutMediaInput
    pollPosts?: PollPostUncheckedCreateNestedManyWithoutMediaInput
    notes?: NoteUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutCommentsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutCommentsInput, MediaUncheckedCreateWithoutCommentsInput>
  }

  export type CommentReplyCreateWithoutCommentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaCreateNestedOneWithoutCommentRepliesInput
  }

  export type CommentReplyUncheckedCreateWithoutCommentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    mediaId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentReplyCreateOrConnectWithoutCommentInput = {
    where: CommentReplyWhereUniqueInput
    create: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput>
  }

  export type CommentReplyCreateManyCommentInputEnvelope = {
    data: CommentReplyCreateManyCommentInput | CommentReplyCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutCommentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaCreateNestedOneWithoutNotesInput
    post: PostCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutCommentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NoteCreateOrConnectWithoutCommentInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutCommentInput, NoteUncheckedCreateWithoutCommentInput>
  }

  export type NoteCreateManyCommentInputEnvelope = {
    data: NoteCreateManyCommentInput | NoteCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutCommentsInput = {
    id?: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    media?: MediaCreateNestedOneWithoutPostsInput
    files?: FileCreateNestedManyWithoutPostsInput
    author: UserProfileCreateNestedOneWithoutPostsInput
    community?: CommunityProfileCreateNestedOneWithoutPostsInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkCreateNestedManyWithoutPostsInput
    publications?: PublicationCreateNestedManyWithoutPostsInput
    reports?: ReportCreateNestedManyWithoutReportedPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    files?: FileUncheckedCreateNestedManyWithoutPostsInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPostsInput
    publications?: PublicationUncheckedCreateNestedManyWithoutPostsInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type PollPostCreateWithoutCommentsInput = {
    id?: string
    createdAt?: Date | string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaCreateNestedOneWithoutPollPostsInput
    thread?: ThreadCreateNestedOneWithoutPollPostsInput
  }

  export type PollPostUncheckedCreateWithoutCommentsInput = {
    id?: string
    createdAt?: Date | string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    mediaId?: string | null
    threadId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PollPostCreateOrConnectWithoutCommentsInput = {
    where: PollPostWhereUniqueInput
    create: XOR<PollPostCreateWithoutCommentsInput, PollPostUncheckedCreateWithoutCommentsInput>
  }

  export type ReportCreateWithoutReportedCommentInput = {
    id?: string
    reason: $Enums.ReportReason
    description?: string | null
    status?: $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    submitter: UserProfileCreateNestedOneWithoutReportsSubmittedInput
    reportedUser?: UserProfileCreateNestedOneWithoutReportedContentInput
    reportedPost?: PostCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutReportedCommentInput = {
    id?: string
    submitterId: string
    postId?: string | null
    userId?: string | null
    reason: $Enums.ReportReason
    description?: string | null
    status?: $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ReportCreateOrConnectWithoutReportedCommentInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReportedCommentInput, ReportUncheckedCreateWithoutReportedCommentInput>
  }

  export type ReportCreateManyReportedCommentInputEnvelope = {
    data: ReportCreateManyReportedCommentInput | ReportCreateManyReportedCommentInput[]
    skipDuplicates?: boolean
  }

  export type ReactionCreateWithoutCommentInput = {
    id?: string
    type: $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserProfileCreateNestedOneWithoutReactionsInput
    post?: PostCreateNestedOneWithoutReactionsInput
  }

  export type ReactionUncheckedCreateWithoutCommentInput = {
    id?: string
    userId: string
    postId?: string | null
    type: $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReactionCreateOrConnectWithoutCommentInput = {
    where: ReactionWhereUniqueInput
    create: XOR<ReactionCreateWithoutCommentInput, ReactionUncheckedCreateWithoutCommentInput>
  }

  export type ReactionCreateManyCommentInputEnvelope = {
    data: ReactionCreateManyCommentInput | ReactionCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileCreateWithoutCommentsInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutUserProfileInput
    bookmarks?: BookmarkCreateNestedManyWithoutUsersInput
    tags?: UserTagCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowCreateNestedManyWithoutFollowedProfileInput
    following?: FollowCreateNestedManyWithoutFollowingProfileInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUncheckedCreateWithoutCommentsInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUsersInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationUncheckedCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationUncheckedCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowedProfileInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportUncheckedCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileCreateOrConnectWithoutCommentsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutCommentsInput, UserProfileUncheckedCreateWithoutCommentsInput>
  }

  export type MediaUpsertWithoutCommentsInput = {
    update: XOR<MediaUpdateWithoutCommentsInput, MediaUncheckedUpdateWithoutCommentsInput>
    create: XOR<MediaCreateWithoutCommentsInput, MediaUncheckedCreateWithoutCommentsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutCommentsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutCommentsInput, MediaUncheckedUpdateWithoutCommentsInput>
  }

  export type MediaUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentReplies?: CommentReplyUpdateManyWithoutMediaNestedInput
    posts?: PostUpdateManyWithoutMediaNestedInput
    pollPosts?: PollPostUpdateManyWithoutMediaNestedInput
    notes?: NoteUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutMediaNestedInput
    posts?: PostUncheckedUpdateManyWithoutMediaNestedInput
    pollPosts?: PollPostUncheckedUpdateManyWithoutMediaNestedInput
    notes?: NoteUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type CommentReplyUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentReplyWhereUniqueInput
    update: XOR<CommentReplyUpdateWithoutCommentInput, CommentReplyUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput>
  }

  export type CommentReplyUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentReplyWhereUniqueInput
    data: XOR<CommentReplyUpdateWithoutCommentInput, CommentReplyUncheckedUpdateWithoutCommentInput>
  }

  export type CommentReplyUpdateManyWithWhereWithoutCommentInput = {
    where: CommentReplyScalarWhereInput
    data: XOR<CommentReplyUpdateManyMutationInput, CommentReplyUncheckedUpdateManyWithoutCommentInput>
  }

  export type NoteUpsertWithWhereUniqueWithoutCommentInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutCommentInput, NoteUncheckedUpdateWithoutCommentInput>
    create: XOR<NoteCreateWithoutCommentInput, NoteUncheckedCreateWithoutCommentInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutCommentInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutCommentInput, NoteUncheckedUpdateWithoutCommentInput>
  }

  export type NoteUpdateManyWithWhereWithoutCommentInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutCommentInput>
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostsNestedInput
    files?: FileUpdateManyWithoutPostsNestedInput
    author?: UserProfileUpdateOneRequiredWithoutPostsNestedInput
    community?: CommunityProfileUpdateOneWithoutPostsNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUpdateManyWithoutPostsNestedInput
    publications?: PublicationUpdateManyWithoutPostsNestedInput
    reports?: ReportUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    files?: FileUncheckedUpdateManyWithoutPostsNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPostsNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutPostsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PollPostUpsertWithoutCommentsInput = {
    update: XOR<PollPostUpdateWithoutCommentsInput, PollPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PollPostCreateWithoutCommentsInput, PollPostUncheckedCreateWithoutCommentsInput>
    where?: PollPostWhereInput
  }

  export type PollPostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PollPostWhereInput
    data: XOR<PollPostUpdateWithoutCommentsInput, PollPostUncheckedUpdateWithoutCommentsInput>
  }

  export type PollPostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaUpdateOneWithoutPollPostsNestedInput
    thread?: ThreadUpdateOneWithoutPollPostsNestedInput
  }

  export type PollPostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportUpsertWithWhereUniqueWithoutReportedCommentInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReportedCommentInput, ReportUncheckedUpdateWithoutReportedCommentInput>
    create: XOR<ReportCreateWithoutReportedCommentInput, ReportUncheckedCreateWithoutReportedCommentInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReportedCommentInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReportedCommentInput, ReportUncheckedUpdateWithoutReportedCommentInput>
  }

  export type ReportUpdateManyWithWhereWithoutReportedCommentInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReportedCommentInput>
  }

  export type ReactionUpsertWithWhereUniqueWithoutCommentInput = {
    where: ReactionWhereUniqueInput
    update: XOR<ReactionUpdateWithoutCommentInput, ReactionUncheckedUpdateWithoutCommentInput>
    create: XOR<ReactionCreateWithoutCommentInput, ReactionUncheckedCreateWithoutCommentInput>
  }

  export type ReactionUpdateWithWhereUniqueWithoutCommentInput = {
    where: ReactionWhereUniqueInput
    data: XOR<ReactionUpdateWithoutCommentInput, ReactionUncheckedUpdateWithoutCommentInput>
  }

  export type ReactionUpdateManyWithWhereWithoutCommentInput = {
    where: ReactionScalarWhereInput
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyWithoutCommentInput>
  }

  export type UserProfileUpsertWithWhereUniqueWithoutCommentsInput = {
    where: UserProfileWhereUniqueInput
    update: XOR<UserProfileUpdateWithoutCommentsInput, UserProfileUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserProfileCreateWithoutCommentsInput, UserProfileUncheckedCreateWithoutCommentsInput>
  }

  export type UserProfileUpdateWithWhereUniqueWithoutCommentsInput = {
    where: UserProfileWhereUniqueInput
    data: XOR<UserProfileUpdateWithoutCommentsInput, UserProfileUncheckedUpdateWithoutCommentsInput>
  }

  export type UserProfileUpdateManyWithWhereWithoutCommentsInput = {
    where: UserProfileScalarWhereInput
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyWithoutCommentsInput>
  }

  export type MediaCreateWithoutCommentRepliesInput = {
    id?: string
    mediaType: $Enums.MediaType
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    posts?: PostCreateNestedManyWithoutMediaInput
    comments?: CommentCreateNestedManyWithoutMediaInput
    pollPosts?: PollPostCreateNestedManyWithoutMediaInput
    notes?: NoteCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutCommentRepliesInput = {
    id?: string
    mediaType: $Enums.MediaType
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutMediaInput
    comments?: CommentUncheckedCreateNestedManyWithoutMediaInput
    pollPosts?: PollPostUncheckedCreateNestedManyWithoutMediaInput
    notes?: NoteUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutCommentRepliesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutCommentRepliesInput, MediaUncheckedCreateWithoutCommentRepliesInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaCreateNestedOneWithoutCommentsInput
    notes?: NoteCreateNestedManyWithoutCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    pollPost?: PollPostCreateNestedOneWithoutCommentsInput
    Report?: ReportCreateNestedManyWithoutReportedCommentInput
    Reaction?: ReactionCreateNestedManyWithoutCommentInput
    UserProfile?: UserProfileCreateNestedManyWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    pollPostId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    notes?: NoteUncheckedCreateNestedManyWithoutCommentInput
    Report?: ReportUncheckedCreateNestedManyWithoutReportedCommentInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutCommentInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutCommentsInput
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type MediaUpsertWithoutCommentRepliesInput = {
    update: XOR<MediaUpdateWithoutCommentRepliesInput, MediaUncheckedUpdateWithoutCommentRepliesInput>
    create: XOR<MediaCreateWithoutCommentRepliesInput, MediaUncheckedCreateWithoutCommentRepliesInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutCommentRepliesInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutCommentRepliesInput, MediaUncheckedUpdateWithoutCommentRepliesInput>
  }

  export type MediaUpdateWithoutCommentRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutMediaNestedInput
    comments?: CommentUpdateManyWithoutMediaNestedInput
    pollPosts?: PollPostUpdateManyWithoutMediaNestedInput
    notes?: NoteUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutCommentRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutMediaNestedInput
    comments?: CommentUncheckedUpdateManyWithoutMediaNestedInput
    pollPosts?: PollPostUncheckedUpdateManyWithoutMediaNestedInput
    notes?: NoteUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaUpdateOneWithoutCommentsNestedInput
    notes?: NoteUpdateManyWithoutCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    pollPost?: PollPostUpdateOneWithoutCommentsNestedInput
    Report?: ReportUpdateManyWithoutReportedCommentNestedInput
    Reaction?: ReactionUpdateManyWithoutCommentNestedInput
    UserProfile?: UserProfileUpdateManyWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    notes?: NoteUncheckedUpdateManyWithoutCommentNestedInput
    Report?: ReportUncheckedUpdateManyWithoutReportedCommentNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutCommentNestedInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutCommentsNestedInput
  }

  export type UserProfileCreateWithoutReactionsInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutUserProfileInput
    bookmarks?: BookmarkCreateNestedManyWithoutUsersInput
    tags?: UserTagCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowCreateNestedManyWithoutFollowedProfileInput
    following?: FollowCreateNestedManyWithoutFollowingProfileInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserProfileInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUncheckedCreateWithoutReactionsInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUsersInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationUncheckedCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationUncheckedCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowedProfileInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportUncheckedCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileCreateOrConnectWithoutReactionsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutReactionsInput, UserProfileUncheckedCreateWithoutReactionsInput>
  }

  export type PostCreateWithoutReactionsInput = {
    id?: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    media?: MediaCreateNestedOneWithoutPostsInput
    files?: FileCreateNestedManyWithoutPostsInput
    author: UserProfileCreateNestedOneWithoutPostsInput
    community?: CommunityProfileCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkCreateNestedManyWithoutPostsInput
    publications?: PublicationCreateNestedManyWithoutPostsInput
    reports?: ReportCreateNestedManyWithoutReportedPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutReactionsInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    files?: FileUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPostsInput
    publications?: PublicationUncheckedCreateNestedManyWithoutPostsInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutReactionsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
  }

  export type CommentCreateWithoutReactionInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaCreateNestedOneWithoutCommentsInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    notes?: NoteCreateNestedManyWithoutCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    pollPost?: PollPostCreateNestedOneWithoutCommentsInput
    Report?: ReportCreateNestedManyWithoutReportedCommentInput
    UserProfile?: UserProfileCreateNestedManyWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutReactionInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    pollPostId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
    notes?: NoteUncheckedCreateNestedManyWithoutCommentInput
    Report?: ReportUncheckedCreateNestedManyWithoutReportedCommentInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutCommentsInput
  }

  export type CommentCreateOrConnectWithoutReactionInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutReactionInput, CommentUncheckedCreateWithoutReactionInput>
  }

  export type UserProfileUpsertWithoutReactionsInput = {
    update: XOR<UserProfileUpdateWithoutReactionsInput, UserProfileUncheckedUpdateWithoutReactionsInput>
    create: XOR<UserProfileCreateWithoutReactionsInput, UserProfileUncheckedCreateWithoutReactionsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutReactionsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutReactionsInput, UserProfileUncheckedUpdateWithoutReactionsInput>
  }

  export type UserProfileUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUsersNestedInput
    tags?: UserTagUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserProfileNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUsersNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUncheckedUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUncheckedUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUncheckedUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput
  }

  export type PostUpsertWithoutReactionsInput = {
    update: XOR<PostUpdateWithoutReactionsInput, PostUncheckedUpdateWithoutReactionsInput>
    create: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutReactionsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutReactionsInput, PostUncheckedUpdateWithoutReactionsInput>
  }

  export type PostUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostsNestedInput
    files?: FileUpdateManyWithoutPostsNestedInput
    author?: UserProfileUpdateOneRequiredWithoutPostsNestedInput
    community?: CommunityProfileUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUpdateManyWithoutPostsNestedInput
    publications?: PublicationUpdateManyWithoutPostsNestedInput
    reports?: ReportUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    files?: FileUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPostsNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutPostsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CommentUpsertWithoutReactionInput = {
    update: XOR<CommentUpdateWithoutReactionInput, CommentUncheckedUpdateWithoutReactionInput>
    create: XOR<CommentCreateWithoutReactionInput, CommentUncheckedCreateWithoutReactionInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutReactionInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutReactionInput, CommentUncheckedUpdateWithoutReactionInput>
  }

  export type CommentUpdateWithoutReactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaUpdateOneWithoutCommentsNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    notes?: NoteUpdateManyWithoutCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    pollPost?: PollPostUpdateOneWithoutCommentsNestedInput
    Report?: ReportUpdateManyWithoutReportedCommentNestedInput
    UserProfile?: UserProfileUpdateManyWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutReactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutCommentNestedInput
    Report?: ReportUncheckedUpdateManyWithoutReportedCommentNestedInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutCommentsNestedInput
  }

  export type PublicationCreateWithoutBookmarksInput = {
    id?: string
    publicationName?: string | null
    description?: string | null
    type?: string | null
    postIds?: PublicationCreatepostIdsInput | string[]
    subjects?: PublicationCreatesubjectsInput | string[]
    tags?: PublicationCreatetagsInput | string[]
    adminBackendPlatformUserId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: UserProfileCreateNestedManyWithoutAdminPublicationsInput
    editors?: UserProfileCreateNestedManyWithoutEditorPublicationsInput
    posts?: PostCreateNestedManyWithoutPublicationsInput
  }

  export type PublicationUncheckedCreateWithoutBookmarksInput = {
    id?: string
    publicationName?: string | null
    description?: string | null
    type?: string | null
    postIds?: PublicationCreatepostIdsInput | string[]
    subjects?: PublicationCreatesubjectsInput | string[]
    tags?: PublicationCreatetagsInput | string[]
    adminBackendPlatformUserId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    admins?: UserProfileUncheckedCreateNestedManyWithoutAdminPublicationsInput
    editors?: UserProfileUncheckedCreateNestedManyWithoutEditorPublicationsInput
    posts?: PostUncheckedCreateNestedManyWithoutPublicationsInput
  }

  export type PublicationCreateOrConnectWithoutBookmarksInput = {
    where: PublicationWhereUniqueInput
    create: XOR<PublicationCreateWithoutBookmarksInput, PublicationUncheckedCreateWithoutBookmarksInput>
  }

  export type UserProfileCreateWithoutBookmarksInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutUserProfileInput
    tags?: UserTagCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowCreateNestedManyWithoutFollowedProfileInput
    following?: FollowCreateNestedManyWithoutFollowingProfileInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUncheckedCreateWithoutBookmarksInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: UserTagUncheckedCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationUncheckedCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationUncheckedCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowedProfileInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportUncheckedCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileCreateOrConnectWithoutBookmarksInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutBookmarksInput, UserProfileUncheckedCreateWithoutBookmarksInput>
  }

  export type PostCreateWithoutBookmarksInput = {
    id?: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    media?: MediaCreateNestedOneWithoutPostsInput
    files?: FileCreateNestedManyWithoutPostsInput
    author: UserProfileCreateNestedOneWithoutPostsInput
    community?: CommunityProfileCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    publications?: PublicationCreateNestedManyWithoutPostsInput
    reports?: ReportCreateNestedManyWithoutReportedPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutBookmarksInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    files?: FileUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    publications?: PublicationUncheckedCreateNestedManyWithoutPostsInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutBookmarksInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutBookmarksInput, PostUncheckedCreateWithoutBookmarksInput>
  }

  export type PublicationUpsertWithWhereUniqueWithoutBookmarksInput = {
    where: PublicationWhereUniqueInput
    update: XOR<PublicationUpdateWithoutBookmarksInput, PublicationUncheckedUpdateWithoutBookmarksInput>
    create: XOR<PublicationCreateWithoutBookmarksInput, PublicationUncheckedCreateWithoutBookmarksInput>
  }

  export type PublicationUpdateWithWhereUniqueWithoutBookmarksInput = {
    where: PublicationWhereUniqueInput
    data: XOR<PublicationUpdateWithoutBookmarksInput, PublicationUncheckedUpdateWithoutBookmarksInput>
  }

  export type PublicationUpdateManyWithWhereWithoutBookmarksInput = {
    where: PublicationScalarWhereInput
    data: XOR<PublicationUpdateManyMutationInput, PublicationUncheckedUpdateManyWithoutBookmarksInput>
  }

  export type UserProfileUpsertWithWhereUniqueWithoutBookmarksInput = {
    where: UserProfileWhereUniqueInput
    update: XOR<UserProfileUpdateWithoutBookmarksInput, UserProfileUncheckedUpdateWithoutBookmarksInput>
    create: XOR<UserProfileCreateWithoutBookmarksInput, UserProfileUncheckedCreateWithoutBookmarksInput>
  }

  export type UserProfileUpdateWithWhereUniqueWithoutBookmarksInput = {
    where: UserProfileWhereUniqueInput
    data: XOR<UserProfileUpdateWithoutBookmarksInput, UserProfileUncheckedUpdateWithoutBookmarksInput>
  }

  export type UserProfileUpdateManyWithWhereWithoutBookmarksInput = {
    where: UserProfileScalarWhereInput
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyWithoutBookmarksInput>
  }

  export type PostUpsertWithWhereUniqueWithoutBookmarksInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutBookmarksInput, PostUncheckedUpdateWithoutBookmarksInput>
    create: XOR<PostCreateWithoutBookmarksInput, PostUncheckedCreateWithoutBookmarksInput>
  }

  export type PostUpdateWithWhereUniqueWithoutBookmarksInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutBookmarksInput, PostUncheckedUpdateWithoutBookmarksInput>
  }

  export type PostUpdateManyWithWhereWithoutBookmarksInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutBookmarksInput>
  }

  export type UserProfileCreateWithoutBlockingInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutUserProfileInput
    bookmarks?: BookmarkCreateNestedManyWithoutUsersInput
    tags?: UserTagCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedProfileInput
    followers?: FollowCreateNestedManyWithoutFollowedProfileInput
    following?: FollowCreateNestedManyWithoutFollowingProfileInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUncheckedCreateWithoutBlockingInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUsersInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationUncheckedCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationUncheckedCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedProfileInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowedProfileInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportUncheckedCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileCreateOrConnectWithoutBlockingInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutBlockingInput, UserProfileUncheckedCreateWithoutBlockingInput>
  }

  export type UserProfileCreateWithoutBlockedByInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutUserProfileInput
    bookmarks?: BookmarkCreateNestedManyWithoutUsersInput
    tags?: UserTagCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationCreateNestedManyWithoutEditorsInput
    blocking?: BlockCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowCreateNestedManyWithoutFollowedProfileInput
    following?: FollowCreateNestedManyWithoutFollowingProfileInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUncheckedCreateWithoutBlockedByInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUsersInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationUncheckedCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationUncheckedCreateNestedManyWithoutEditorsInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowedProfileInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportUncheckedCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileCreateOrConnectWithoutBlockedByInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutBlockedByInput, UserProfileUncheckedCreateWithoutBlockedByInput>
  }

  export type UserProfileUpsertWithoutBlockingInput = {
    update: XOR<UserProfileUpdateWithoutBlockingInput, UserProfileUncheckedUpdateWithoutBlockingInput>
    create: XOR<UserProfileCreateWithoutBlockingInput, UserProfileUncheckedCreateWithoutBlockingInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutBlockingInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutBlockingInput, UserProfileUncheckedUpdateWithoutBlockingInput>
  }

  export type UserProfileUpdateWithoutBlockingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUsersNestedInput
    tags?: UserTagUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedProfileNestedInput
    followers?: FollowUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutBlockingInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUsersNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUncheckedUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUncheckedUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUncheckedUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUpsertWithoutBlockedByInput = {
    update: XOR<UserProfileUpdateWithoutBlockedByInput, UserProfileUncheckedUpdateWithoutBlockedByInput>
    create: XOR<UserProfileCreateWithoutBlockedByInput, UserProfileUncheckedCreateWithoutBlockedByInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutBlockedByInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutBlockedByInput, UserProfileUncheckedUpdateWithoutBlockedByInput>
  }

  export type UserProfileUpdateWithoutBlockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUsersNestedInput
    tags?: UserTagUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUpdateManyWithoutEditorsNestedInput
    blocking?: BlockUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutBlockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUsersNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUncheckedUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUncheckedUpdateManyWithoutEditorsNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUncheckedUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileCreateWithoutFollowingInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutUserProfileInput
    bookmarks?: BookmarkCreateNestedManyWithoutUsersInput
    tags?: UserTagCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowCreateNestedManyWithoutFollowedProfileInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUncheckedCreateWithoutFollowingInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUsersInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationUncheckedCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationUncheckedCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowedProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportUncheckedCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileCreateOrConnectWithoutFollowingInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutFollowingInput, UserProfileUncheckedCreateWithoutFollowingInput>
  }

  export type UserProfileCreateWithoutFollowersInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutUserProfileInput
    bookmarks?: BookmarkCreateNestedManyWithoutUsersInput
    tags?: UserTagCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockCreateNestedManyWithoutBlockingProfileInput
    following?: FollowCreateNestedManyWithoutFollowingProfileInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUncheckedCreateWithoutFollowersInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUsersInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationUncheckedCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationUncheckedCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockingProfileInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportUncheckedCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileCreateOrConnectWithoutFollowersInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutFollowersInput, UserProfileUncheckedCreateWithoutFollowersInput>
  }

  export type UserProfileUpsertWithoutFollowingInput = {
    update: XOR<UserProfileUpdateWithoutFollowingInput, UserProfileUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserProfileCreateWithoutFollowingInput, UserProfileUncheckedCreateWithoutFollowingInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutFollowingInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutFollowingInput, UserProfileUncheckedUpdateWithoutFollowingInput>
  }

  export type UserProfileUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUsersNestedInput
    tags?: UserTagUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUpdateManyWithoutFollowedProfileNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUsersNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUncheckedUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUncheckedUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUncheckedUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUpsertWithoutFollowersInput = {
    update: XOR<UserProfileUpdateWithoutFollowersInput, UserProfileUncheckedUpdateWithoutFollowersInput>
    create: XOR<UserProfileCreateWithoutFollowersInput, UserProfileUncheckedCreateWithoutFollowersInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutFollowersInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutFollowersInput, UserProfileUncheckedUpdateWithoutFollowersInput>
  }

  export type UserProfileUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUsersNestedInput
    tags?: UserTagUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUpdateManyWithoutBlockingProfileNestedInput
    following?: FollowUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUsersNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUncheckedUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUncheckedUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUncheckedUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileCreateWithoutTagsInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutUserProfileInput
    bookmarks?: BookmarkCreateNestedManyWithoutUsersInput
    adminPublications?: PublicationCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowCreateNestedManyWithoutFollowedProfileInput
    following?: FollowCreateNestedManyWithoutFollowingProfileInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUncheckedCreateWithoutTagsInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUsersInput
    adminPublications?: PublicationUncheckedCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationUncheckedCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowedProfileInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportUncheckedCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileCreateOrConnectWithoutTagsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutTagsInput, UserProfileUncheckedCreateWithoutTagsInput>
  }

  export type UserProfileUpsertWithoutTagsInput = {
    update: XOR<UserProfileUpdateWithoutTagsInput, UserProfileUncheckedUpdateWithoutTagsInput>
    create: XOR<UserProfileCreateWithoutTagsInput, UserProfileUncheckedCreateWithoutTagsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutTagsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutTagsInput, UserProfileUncheckedUpdateWithoutTagsInput>
  }

  export type UserProfileUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUsersNestedInput
    adminPublications?: PublicationUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUsersNestedInput
    adminPublications?: PublicationUncheckedUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUncheckedUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUncheckedUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileCreateWithoutReportsSubmittedInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutUserProfileInput
    bookmarks?: BookmarkCreateNestedManyWithoutUsersInput
    tags?: UserTagCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowCreateNestedManyWithoutFollowedProfileInput
    following?: FollowCreateNestedManyWithoutFollowingProfileInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reportedContent?: ReportCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUncheckedCreateWithoutReportsSubmittedInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUsersInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationUncheckedCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationUncheckedCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowedProfileInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reportedContent?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileCreateOrConnectWithoutReportsSubmittedInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutReportsSubmittedInput, UserProfileUncheckedCreateWithoutReportsSubmittedInput>
  }

  export type UserProfileCreateWithoutReportedContentInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutUserProfileInput
    bookmarks?: BookmarkCreateNestedManyWithoutUsersInput
    tags?: UserTagCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowCreateNestedManyWithoutFollowedProfileInput
    following?: FollowCreateNestedManyWithoutFollowingProfileInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportCreateNestedManyWithoutSubmitterInput
    moderatedCommunities?: CommunityProfileCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUncheckedCreateWithoutReportedContentInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUsersInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationUncheckedCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationUncheckedCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowedProfileInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportUncheckedCreateNestedManyWithoutSubmitterInput
    moderatedCommunities?: CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileCreateOrConnectWithoutReportedContentInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutReportedContentInput, UserProfileUncheckedCreateWithoutReportedContentInput>
  }

  export type PostCreateWithoutReportsInput = {
    id?: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    media?: MediaCreateNestedOneWithoutPostsInput
    files?: FileCreateNestedManyWithoutPostsInput
    author: UserProfileCreateNestedOneWithoutPostsInput
    community?: CommunityProfileCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkCreateNestedManyWithoutPostsInput
    publications?: PublicationCreateNestedManyWithoutPostsInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutReportsInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    files?: FileUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPostsInput
    publications?: PublicationUncheckedCreateNestedManyWithoutPostsInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutReportsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutReportsInput, PostUncheckedCreateWithoutReportsInput>
  }

  export type CommentCreateWithoutReportInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaCreateNestedOneWithoutCommentsInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    notes?: NoteCreateNestedManyWithoutCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    pollPost?: PollPostCreateNestedOneWithoutCommentsInput
    Reaction?: ReactionCreateNestedManyWithoutCommentInput
    UserProfile?: UserProfileCreateNestedManyWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutReportInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    pollPostId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
    notes?: NoteUncheckedCreateNestedManyWithoutCommentInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutCommentInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutCommentsInput
  }

  export type CommentCreateOrConnectWithoutReportInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutReportInput, CommentUncheckedCreateWithoutReportInput>
  }

  export type UserProfileUpsertWithoutReportsSubmittedInput = {
    update: XOR<UserProfileUpdateWithoutReportsSubmittedInput, UserProfileUncheckedUpdateWithoutReportsSubmittedInput>
    create: XOR<UserProfileCreateWithoutReportsSubmittedInput, UserProfileUncheckedCreateWithoutReportsSubmittedInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutReportsSubmittedInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutReportsSubmittedInput, UserProfileUncheckedUpdateWithoutReportsSubmittedInput>
  }

  export type UserProfileUpdateWithoutReportsSubmittedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUsersNestedInput
    tags?: UserTagUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reportedContent?: ReportUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutReportsSubmittedInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUsersNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUncheckedUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUncheckedUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reportedContent?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUpsertWithoutReportedContentInput = {
    update: XOR<UserProfileUpdateWithoutReportedContentInput, UserProfileUncheckedUpdateWithoutReportedContentInput>
    create: XOR<UserProfileCreateWithoutReportedContentInput, UserProfileUncheckedCreateWithoutReportedContentInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutReportedContentInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutReportedContentInput, UserProfileUncheckedUpdateWithoutReportedContentInput>
  }

  export type UserProfileUpdateWithoutReportedContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUsersNestedInput
    tags?: UserTagUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUpdateManyWithoutSubmitterNestedInput
    moderatedCommunities?: CommunityProfileUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutReportedContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUsersNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUncheckedUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUncheckedUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUncheckedUpdateManyWithoutSubmitterNestedInput
    moderatedCommunities?: CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput
  }

  export type PostUpsertWithoutReportsInput = {
    update: XOR<PostUpdateWithoutReportsInput, PostUncheckedUpdateWithoutReportsInput>
    create: XOR<PostCreateWithoutReportsInput, PostUncheckedCreateWithoutReportsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutReportsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutReportsInput, PostUncheckedUpdateWithoutReportsInput>
  }

  export type PostUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostsNestedInput
    files?: FileUpdateManyWithoutPostsNestedInput
    author?: UserProfileUpdateOneRequiredWithoutPostsNestedInput
    community?: CommunityProfileUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUpdateManyWithoutPostsNestedInput
    publications?: PublicationUpdateManyWithoutPostsNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    files?: FileUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPostsNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutPostsNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CommentUpsertWithoutReportInput = {
    update: XOR<CommentUpdateWithoutReportInput, CommentUncheckedUpdateWithoutReportInput>
    create: XOR<CommentCreateWithoutReportInput, CommentUncheckedCreateWithoutReportInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutReportInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutReportInput, CommentUncheckedUpdateWithoutReportInput>
  }

  export type CommentUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaUpdateOneWithoutCommentsNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    notes?: NoteUpdateManyWithoutCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    pollPost?: PollPostUpdateOneWithoutCommentsNestedInput
    Reaction?: ReactionUpdateManyWithoutCommentNestedInput
    UserProfile?: UserProfileUpdateManyWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutCommentNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutCommentNestedInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutCommentsNestedInput
  }

  export type UserProfileCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    virtualProfile: VirtualProfileCreateNestedOneWithoutUserProfileInput
    bookmarks?: BookmarkCreateNestedManyWithoutUsersInput
    tags?: UserTagCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowCreateNestedManyWithoutFollowedProfileInput
    following?: FollowCreateNestedManyWithoutFollowingProfileInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileUncheckedCreateWithoutNotificationsInput = {
    id?: string
    virtualProfileId: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUsersInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserProfileInput
    adminPublications?: PublicationUncheckedCreateNestedManyWithoutAdminsInput
    editorPublications?: PublicationUncheckedCreateNestedManyWithoutEditorsInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedProfileInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockingProfileInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowedProfileInput
    following?: FollowUncheckedCreateNestedManyWithoutFollowingProfileInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserProfileInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    reportsSubmitted?: ReportUncheckedCreateNestedManyWithoutSubmitterInput
    reportedContent?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    moderatedCommunities?: CommunityProfileUncheckedCreateNestedManyWithoutModeratorsInput
  }

  export type UserProfileCreateOrConnectWithoutNotificationsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutNotificationsInput, UserProfileUncheckedCreateWithoutNotificationsInput>
  }

  export type UserProfileUpsertWithoutNotificationsInput = {
    update: XOR<UserProfileUpdateWithoutNotificationsInput, UserProfileUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserProfileCreateWithoutNotificationsInput, UserProfileUncheckedCreateWithoutNotificationsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutNotificationsInput, UserProfileUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserProfileUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUsersNestedInput
    tags?: UserTagUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUsersNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUncheckedUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUncheckedUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUncheckedUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput
  }

  export type SpaceMemberCreateWithoutSpaceInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    status?: string
    permissions?: SpaceMemberCreatepermissionsInput | string[]
  }

  export type SpaceMemberUncheckedCreateWithoutSpaceInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    status?: string
    permissions?: SpaceMemberCreatepermissionsInput | string[]
  }

  export type SpaceMemberCreateOrConnectWithoutSpaceInput = {
    where: SpaceMemberWhereUniqueInput
    create: XOR<SpaceMemberCreateWithoutSpaceInput, SpaceMemberUncheckedCreateWithoutSpaceInput>
  }

  export type SpaceMemberCreateManySpaceInputEnvelope = {
    data: SpaceMemberCreateManySpaceInput | SpaceMemberCreateManySpaceInput[]
    skipDuplicates?: boolean
  }

  export type ChannelCreateWithoutSpaceInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    posts?: PostCreateNestedManyWithoutChannelInput
    files?: FileCreateNestedManyWithoutChannelInput
    members?: ChannelMemberCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutSpaceInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    posts?: PostUncheckedCreateNestedManyWithoutChannelInput
    files?: FileUncheckedCreateNestedManyWithoutChannelInput
    members?: ChannelMemberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutSpaceInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutSpaceInput, ChannelUncheckedCreateWithoutSpaceInput>
  }

  export type ChannelCreateManySpaceInputEnvelope = {
    data: ChannelCreateManySpaceInput | ChannelCreateManySpaceInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutSpaceInput = {
    id?: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    media?: MediaCreateNestedOneWithoutPostsInput
    files?: FileCreateNestedManyWithoutPostsInput
    author: UserProfileCreateNestedOneWithoutPostsInput
    community?: CommunityProfileCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkCreateNestedManyWithoutPostsInput
    publications?: PublicationCreateNestedManyWithoutPostsInput
    reports?: ReportCreateNestedManyWithoutReportedPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutSpaceInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    files?: FileUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPostsInput
    publications?: PublicationUncheckedCreateNestedManyWithoutPostsInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutSpaceInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutSpaceInput, PostUncheckedCreateWithoutSpaceInput>
  }

  export type PostCreateManySpaceInputEnvelope = {
    data: PostCreateManySpaceInput | PostCreateManySpaceInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutSpaceInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    posts?: PostCreateNestedManyWithoutFilesInput
    channel?: ChannelCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutSpaceInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    channelId?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutFilesInput
  }

  export type FileCreateOrConnectWithoutSpaceInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutSpaceInput, FileUncheckedCreateWithoutSpaceInput>
  }

  export type FileCreateManySpaceInputEnvelope = {
    data: FileCreateManySpaceInput | FileCreateManySpaceInput[]
    skipDuplicates?: boolean
  }

  export type SpaceCreateWithoutChildSpacesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberCreateNestedManyWithoutSpaceInput
    channels?: ChannelCreateNestedManyWithoutSpaceInput
    posts?: PostCreateNestedManyWithoutSpaceInput
    files?: FileCreateNestedManyWithoutSpaceInput
    parentSpace?: SpaceCreateNestedOneWithoutChildSpacesInput
  }

  export type SpaceUncheckedCreateWithoutChildSpacesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    parentSpaceId?: string | null
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberUncheckedCreateNestedManyWithoutSpaceInput
    channels?: ChannelUncheckedCreateNestedManyWithoutSpaceInput
    posts?: PostUncheckedCreateNestedManyWithoutSpaceInput
    files?: FileUncheckedCreateNestedManyWithoutSpaceInput
  }

  export type SpaceCreateOrConnectWithoutChildSpacesInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutChildSpacesInput, SpaceUncheckedCreateWithoutChildSpacesInput>
  }

  export type SpaceCreateWithoutParentSpaceInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberCreateNestedManyWithoutSpaceInput
    channels?: ChannelCreateNestedManyWithoutSpaceInput
    posts?: PostCreateNestedManyWithoutSpaceInput
    files?: FileCreateNestedManyWithoutSpaceInput
    childSpaces?: SpaceCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceUncheckedCreateWithoutParentSpaceInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberUncheckedCreateNestedManyWithoutSpaceInput
    channels?: ChannelUncheckedCreateNestedManyWithoutSpaceInput
    posts?: PostUncheckedCreateNestedManyWithoutSpaceInput
    files?: FileUncheckedCreateNestedManyWithoutSpaceInput
    childSpaces?: SpaceUncheckedCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceCreateOrConnectWithoutParentSpaceInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutParentSpaceInput, SpaceUncheckedCreateWithoutParentSpaceInput>
  }

  export type SpaceCreateManyParentSpaceInputEnvelope = {
    data: SpaceCreateManyParentSpaceInput | SpaceCreateManyParentSpaceInput[]
    skipDuplicates?: boolean
  }

  export type SpaceMemberUpsertWithWhereUniqueWithoutSpaceInput = {
    where: SpaceMemberWhereUniqueInput
    update: XOR<SpaceMemberUpdateWithoutSpaceInput, SpaceMemberUncheckedUpdateWithoutSpaceInput>
    create: XOR<SpaceMemberCreateWithoutSpaceInput, SpaceMemberUncheckedCreateWithoutSpaceInput>
  }

  export type SpaceMemberUpdateWithWhereUniqueWithoutSpaceInput = {
    where: SpaceMemberWhereUniqueInput
    data: XOR<SpaceMemberUpdateWithoutSpaceInput, SpaceMemberUncheckedUpdateWithoutSpaceInput>
  }

  export type SpaceMemberUpdateManyWithWhereWithoutSpaceInput = {
    where: SpaceMemberScalarWhereInput
    data: XOR<SpaceMemberUpdateManyMutationInput, SpaceMemberUncheckedUpdateManyWithoutSpaceInput>
  }

  export type SpaceMemberScalarWhereInput = {
    AND?: SpaceMemberScalarWhereInput | SpaceMemberScalarWhereInput[]
    OR?: SpaceMemberScalarWhereInput[]
    NOT?: SpaceMemberScalarWhereInput | SpaceMemberScalarWhereInput[]
    id?: StringFilter<"SpaceMember"> | string
    spaceId?: StringFilter<"SpaceMember"> | string
    userId?: StringFilter<"SpaceMember"> | string
    role?: StringFilter<"SpaceMember"> | string
    joinedAt?: DateTimeFilter<"SpaceMember"> | Date | string
    status?: StringFilter<"SpaceMember"> | string
    permissions?: StringNullableListFilter<"SpaceMember">
  }

  export type ChannelUpsertWithWhereUniqueWithoutSpaceInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutSpaceInput, ChannelUncheckedUpdateWithoutSpaceInput>
    create: XOR<ChannelCreateWithoutSpaceInput, ChannelUncheckedCreateWithoutSpaceInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutSpaceInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutSpaceInput, ChannelUncheckedUpdateWithoutSpaceInput>
  }

  export type ChannelUpdateManyWithWhereWithoutSpaceInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutSpaceInput>
  }

  export type ChannelScalarWhereInput = {
    AND?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
    OR?: ChannelScalarWhereInput[]
    NOT?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
    id?: StringFilter<"Channel"> | string
    name?: StringFilter<"Channel"> | string
    description?: StringNullableFilter<"Channel"> | string | null
    spaceId?: StringFilter<"Channel"> | string
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
    status?: StringFilter<"Channel"> | string
    pinnedPosts?: StringNullableListFilter<"Channel">
    isPrivate?: BoolFilter<"Channel"> | boolean
    metadata?: JsonNullableFilter<"Channel">
    settings?: JsonNullableFilter<"Channel">
  }

  export type PostUpsertWithWhereUniqueWithoutSpaceInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutSpaceInput, PostUncheckedUpdateWithoutSpaceInput>
    create: XOR<PostCreateWithoutSpaceInput, PostUncheckedCreateWithoutSpaceInput>
  }

  export type PostUpdateWithWhereUniqueWithoutSpaceInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutSpaceInput, PostUncheckedUpdateWithoutSpaceInput>
  }

  export type PostUpdateManyWithWhereWithoutSpaceInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutSpaceInput>
  }

  export type FileUpsertWithWhereUniqueWithoutSpaceInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutSpaceInput, FileUncheckedUpdateWithoutSpaceInput>
    create: XOR<FileCreateWithoutSpaceInput, FileUncheckedCreateWithoutSpaceInput>
  }

  export type FileUpdateWithWhereUniqueWithoutSpaceInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutSpaceInput, FileUncheckedUpdateWithoutSpaceInput>
  }

  export type FileUpdateManyWithWhereWithoutSpaceInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutSpaceInput>
  }

  export type SpaceUpsertWithoutChildSpacesInput = {
    update: XOR<SpaceUpdateWithoutChildSpacesInput, SpaceUncheckedUpdateWithoutChildSpacesInput>
    create: XOR<SpaceCreateWithoutChildSpacesInput, SpaceUncheckedCreateWithoutChildSpacesInput>
    where?: SpaceWhereInput
  }

  export type SpaceUpdateToOneWithWhereWithoutChildSpacesInput = {
    where?: SpaceWhereInput
    data: XOR<SpaceUpdateWithoutChildSpacesInput, SpaceUncheckedUpdateWithoutChildSpacesInput>
  }

  export type SpaceUpdateWithoutChildSpacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUpdateManyWithoutSpaceNestedInput
    posts?: PostUpdateManyWithoutSpaceNestedInput
    files?: FileUpdateManyWithoutSpaceNestedInput
    parentSpace?: SpaceUpdateOneWithoutChildSpacesNestedInput
  }

  export type SpaceUncheckedUpdateWithoutChildSpacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUncheckedUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutSpaceNestedInput
    posts?: PostUncheckedUpdateManyWithoutSpaceNestedInput
    files?: FileUncheckedUpdateManyWithoutSpaceNestedInput
  }

  export type SpaceUpsertWithWhereUniqueWithoutParentSpaceInput = {
    where: SpaceWhereUniqueInput
    update: XOR<SpaceUpdateWithoutParentSpaceInput, SpaceUncheckedUpdateWithoutParentSpaceInput>
    create: XOR<SpaceCreateWithoutParentSpaceInput, SpaceUncheckedCreateWithoutParentSpaceInput>
  }

  export type SpaceUpdateWithWhereUniqueWithoutParentSpaceInput = {
    where: SpaceWhereUniqueInput
    data: XOR<SpaceUpdateWithoutParentSpaceInput, SpaceUncheckedUpdateWithoutParentSpaceInput>
  }

  export type SpaceUpdateManyWithWhereWithoutParentSpaceInput = {
    where: SpaceScalarWhereInput
    data: XOR<SpaceUpdateManyMutationInput, SpaceUncheckedUpdateManyWithoutParentSpaceInput>
  }

  export type SpaceScalarWhereInput = {
    AND?: SpaceScalarWhereInput | SpaceScalarWhereInput[]
    OR?: SpaceScalarWhereInput[]
    NOT?: SpaceScalarWhereInput | SpaceScalarWhereInput[]
    id?: StringFilter<"Space"> | string
    name?: StringFilter<"Space"> | string
    description?: StringNullableFilter<"Space"> | string | null
    type?: EnumSpaceTypeFilter<"Space"> | $Enums.SpaceType
    createdAt?: DateTimeFilter<"Space"> | Date | string
    updatedAt?: DateTimeFilter<"Space"> | Date | string
    spaceType?: StringFilter<"Space"> | string
    status?: StringFilter<"Space"> | string
    visibility?: EnumVisibilityFilter<"Space"> | $Enums.Visibility
    parentSpaceId?: StringNullableFilter<"Space"> | string | null
    isPrivate?: BoolFilter<"Space"> | boolean
    metadata?: JsonNullableFilter<"Space">
    settings?: JsonNullableFilter<"Space">
    accessLevel?: EnumAccessLevelFilter<"Space"> | $Enums.AccessLevel
    searchMetadata?: JsonNullableFilter<"Space">
    tags?: StringNullableListFilter<"Space">
  }

  export type SpaceCreateWithoutChannelsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberCreateNestedManyWithoutSpaceInput
    posts?: PostCreateNestedManyWithoutSpaceInput
    files?: FileCreateNestedManyWithoutSpaceInput
    parentSpace?: SpaceCreateNestedOneWithoutChildSpacesInput
    childSpaces?: SpaceCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceUncheckedCreateWithoutChannelsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    parentSpaceId?: string | null
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberUncheckedCreateNestedManyWithoutSpaceInput
    posts?: PostUncheckedCreateNestedManyWithoutSpaceInput
    files?: FileUncheckedCreateNestedManyWithoutSpaceInput
    childSpaces?: SpaceUncheckedCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceCreateOrConnectWithoutChannelsInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutChannelsInput, SpaceUncheckedCreateWithoutChannelsInput>
  }

  export type PostCreateWithoutChannelInput = {
    id?: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    media?: MediaCreateNestedOneWithoutPostsInput
    files?: FileCreateNestedManyWithoutPostsInput
    author: UserProfileCreateNestedOneWithoutPostsInput
    community?: CommunityProfileCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkCreateNestedManyWithoutPostsInput
    publications?: PublicationCreateNestedManyWithoutPostsInput
    reports?: ReportCreateNestedManyWithoutReportedPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutChannelInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    files?: FileUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPostsInput
    publications?: PublicationUncheckedCreateNestedManyWithoutPostsInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutChannelInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutChannelInput, PostUncheckedCreateWithoutChannelInput>
  }

  export type PostCreateManyChannelInputEnvelope = {
    data: PostCreateManyChannelInput | PostCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutChannelInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    posts?: PostCreateNestedManyWithoutFilesInput
    space?: SpaceCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutChannelInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    spaceId?: string | null
    posts?: PostUncheckedCreateNestedManyWithoutFilesInput
  }

  export type FileCreateOrConnectWithoutChannelInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutChannelInput, FileUncheckedCreateWithoutChannelInput>
  }

  export type FileCreateManyChannelInputEnvelope = {
    data: FileCreateManyChannelInput | FileCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type ChannelMemberCreateWithoutChannelInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    lastRead?: Date | string | null
  }

  export type ChannelMemberUncheckedCreateWithoutChannelInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    lastRead?: Date | string | null
  }

  export type ChannelMemberCreateOrConnectWithoutChannelInput = {
    where: ChannelMemberWhereUniqueInput
    create: XOR<ChannelMemberCreateWithoutChannelInput, ChannelMemberUncheckedCreateWithoutChannelInput>
  }

  export type ChannelMemberCreateManyChannelInputEnvelope = {
    data: ChannelMemberCreateManyChannelInput | ChannelMemberCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type SpaceUpsertWithoutChannelsInput = {
    update: XOR<SpaceUpdateWithoutChannelsInput, SpaceUncheckedUpdateWithoutChannelsInput>
    create: XOR<SpaceCreateWithoutChannelsInput, SpaceUncheckedCreateWithoutChannelsInput>
    where?: SpaceWhereInput
  }

  export type SpaceUpdateToOneWithWhereWithoutChannelsInput = {
    where?: SpaceWhereInput
    data: XOR<SpaceUpdateWithoutChannelsInput, SpaceUncheckedUpdateWithoutChannelsInput>
  }

  export type SpaceUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUpdateManyWithoutSpaceNestedInput
    posts?: PostUpdateManyWithoutSpaceNestedInput
    files?: FileUpdateManyWithoutSpaceNestedInput
    parentSpace?: SpaceUpdateOneWithoutChildSpacesNestedInput
    childSpaces?: SpaceUpdateManyWithoutParentSpaceNestedInput
  }

  export type SpaceUncheckedUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUncheckedUpdateManyWithoutSpaceNestedInput
    posts?: PostUncheckedUpdateManyWithoutSpaceNestedInput
    files?: FileUncheckedUpdateManyWithoutSpaceNestedInput
    childSpaces?: SpaceUncheckedUpdateManyWithoutParentSpaceNestedInput
  }

  export type PostUpsertWithWhereUniqueWithoutChannelInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutChannelInput, PostUncheckedUpdateWithoutChannelInput>
    create: XOR<PostCreateWithoutChannelInput, PostUncheckedCreateWithoutChannelInput>
  }

  export type PostUpdateWithWhereUniqueWithoutChannelInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutChannelInput, PostUncheckedUpdateWithoutChannelInput>
  }

  export type PostUpdateManyWithWhereWithoutChannelInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutChannelInput>
  }

  export type FileUpsertWithWhereUniqueWithoutChannelInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutChannelInput, FileUncheckedUpdateWithoutChannelInput>
    create: XOR<FileCreateWithoutChannelInput, FileUncheckedCreateWithoutChannelInput>
  }

  export type FileUpdateWithWhereUniqueWithoutChannelInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutChannelInput, FileUncheckedUpdateWithoutChannelInput>
  }

  export type FileUpdateManyWithWhereWithoutChannelInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutChannelInput>
  }

  export type ChannelMemberUpsertWithWhereUniqueWithoutChannelInput = {
    where: ChannelMemberWhereUniqueInput
    update: XOR<ChannelMemberUpdateWithoutChannelInput, ChannelMemberUncheckedUpdateWithoutChannelInput>
    create: XOR<ChannelMemberCreateWithoutChannelInput, ChannelMemberUncheckedCreateWithoutChannelInput>
  }

  export type ChannelMemberUpdateWithWhereUniqueWithoutChannelInput = {
    where: ChannelMemberWhereUniqueInput
    data: XOR<ChannelMemberUpdateWithoutChannelInput, ChannelMemberUncheckedUpdateWithoutChannelInput>
  }

  export type ChannelMemberUpdateManyWithWhereWithoutChannelInput = {
    where: ChannelMemberScalarWhereInput
    data: XOR<ChannelMemberUpdateManyMutationInput, ChannelMemberUncheckedUpdateManyWithoutChannelInput>
  }

  export type ChannelMemberScalarWhereInput = {
    AND?: ChannelMemberScalarWhereInput | ChannelMemberScalarWhereInput[]
    OR?: ChannelMemberScalarWhereInput[]
    NOT?: ChannelMemberScalarWhereInput | ChannelMemberScalarWhereInput[]
    id?: StringFilter<"ChannelMember"> | string
    channelId?: StringFilter<"ChannelMember"> | string
    userId?: StringFilter<"ChannelMember"> | string
    role?: StringFilter<"ChannelMember"> | string
    joinedAt?: DateTimeFilter<"ChannelMember"> | Date | string
    lastRead?: DateTimeNullableFilter<"ChannelMember"> | Date | string | null
  }

  export type PostCreateWithoutThreadInput = {
    id?: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    media?: MediaCreateNestedOneWithoutPostsInput
    files?: FileCreateNestedManyWithoutPostsInput
    author: UserProfileCreateNestedOneWithoutPostsInput
    community?: CommunityProfileCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkCreateNestedManyWithoutPostsInput
    publications?: PublicationCreateNestedManyWithoutPostsInput
    reports?: ReportCreateNestedManyWithoutReportedPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutThreadInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    files?: FileUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPostsInput
    publications?: PublicationUncheckedCreateNestedManyWithoutPostsInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutThreadInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutThreadInput, PostUncheckedCreateWithoutThreadInput>
  }

  export type PostCreateManyThreadInputEnvelope = {
    data: PostCreateManyThreadInput | PostCreateManyThreadInput[]
    skipDuplicates?: boolean
  }

  export type PollPostCreateWithoutThreadInput = {
    id?: string
    createdAt?: Date | string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaCreateNestedOneWithoutPollPostsInput
    comments?: CommentCreateNestedManyWithoutPollPostInput
  }

  export type PollPostUncheckedCreateWithoutThreadInput = {
    id?: string
    createdAt?: Date | string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    mediaId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentUncheckedCreateNestedManyWithoutPollPostInput
  }

  export type PollPostCreateOrConnectWithoutThreadInput = {
    where: PollPostWhereUniqueInput
    create: XOR<PollPostCreateWithoutThreadInput, PollPostUncheckedCreateWithoutThreadInput>
  }

  export type PollPostCreateManyThreadInputEnvelope = {
    data: PollPostCreateManyThreadInput | PollPostCreateManyThreadInput[]
    skipDuplicates?: boolean
  }

  export type PostUpsertWithWhereUniqueWithoutThreadInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutThreadInput, PostUncheckedUpdateWithoutThreadInput>
    create: XOR<PostCreateWithoutThreadInput, PostUncheckedCreateWithoutThreadInput>
  }

  export type PostUpdateWithWhereUniqueWithoutThreadInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutThreadInput, PostUncheckedUpdateWithoutThreadInput>
  }

  export type PostUpdateManyWithWhereWithoutThreadInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutThreadInput>
  }

  export type PollPostUpsertWithWhereUniqueWithoutThreadInput = {
    where: PollPostWhereUniqueInput
    update: XOR<PollPostUpdateWithoutThreadInput, PollPostUncheckedUpdateWithoutThreadInput>
    create: XOR<PollPostCreateWithoutThreadInput, PollPostUncheckedCreateWithoutThreadInput>
  }

  export type PollPostUpdateWithWhereUniqueWithoutThreadInput = {
    where: PollPostWhereUniqueInput
    data: XOR<PollPostUpdateWithoutThreadInput, PollPostUncheckedUpdateWithoutThreadInput>
  }

  export type PollPostUpdateManyWithWhereWithoutThreadInput = {
    where: PollPostScalarWhereInput
    data: XOR<PollPostUpdateManyMutationInput, PollPostUncheckedUpdateManyWithoutThreadInput>
  }

  export type MediaCreateWithoutNotesInput = {
    id?: string
    mediaType: $Enums.MediaType
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    commentReplies?: CommentReplyCreateNestedManyWithoutMediaInput
    posts?: PostCreateNestedManyWithoutMediaInput
    comments?: CommentCreateNestedManyWithoutMediaInput
    pollPosts?: PollPostCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutNotesInput = {
    id?: string
    mediaType: $Enums.MediaType
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    commentReplies?: CommentReplyUncheckedCreateNestedManyWithoutMediaInput
    posts?: PostUncheckedCreateNestedManyWithoutMediaInput
    comments?: CommentUncheckedCreateNestedManyWithoutMediaInput
    pollPosts?: PollPostUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutNotesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutNotesInput, MediaUncheckedCreateWithoutNotesInput>
  }

  export type PostCreateWithoutNotesInput = {
    id?: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    media?: MediaCreateNestedOneWithoutPostsInput
    files?: FileCreateNestedManyWithoutPostsInput
    author: UserProfileCreateNestedOneWithoutPostsInput
    community?: CommunityProfileCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkCreateNestedManyWithoutPostsInput
    publications?: PublicationCreateNestedManyWithoutPostsInput
    reports?: ReportCreateNestedManyWithoutReportedPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutNotesInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    files?: FileUncheckedCreateNestedManyWithoutPostsInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPostsInput
    publications?: PublicationUncheckedCreateNestedManyWithoutPostsInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedPostInput
  }

  export type PostCreateOrConnectWithoutNotesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutNotesInput, PostUncheckedCreateWithoutNotesInput>
  }

  export type CommentCreateWithoutNotesInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaCreateNestedOneWithoutCommentsInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    pollPost?: PollPostCreateNestedOneWithoutCommentsInput
    Report?: ReportCreateNestedManyWithoutReportedCommentInput
    Reaction?: ReactionCreateNestedManyWithoutCommentInput
    UserProfile?: UserProfileCreateNestedManyWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutNotesInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    pollPostId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
    Report?: ReportUncheckedCreateNestedManyWithoutReportedCommentInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutCommentInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutCommentsInput
  }

  export type CommentCreateOrConnectWithoutNotesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutNotesInput, CommentUncheckedCreateWithoutNotesInput>
  }

  export type MediaUpsertWithoutNotesInput = {
    update: XOR<MediaUpdateWithoutNotesInput, MediaUncheckedUpdateWithoutNotesInput>
    create: XOR<MediaCreateWithoutNotesInput, MediaUncheckedCreateWithoutNotesInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutNotesInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutNotesInput, MediaUncheckedUpdateWithoutNotesInput>
  }

  export type MediaUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentReplies?: CommentReplyUpdateManyWithoutMediaNestedInput
    posts?: PostUpdateManyWithoutMediaNestedInput
    comments?: CommentUpdateManyWithoutMediaNestedInput
    pollPosts?: PollPostUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentReplies?: CommentReplyUncheckedUpdateManyWithoutMediaNestedInput
    posts?: PostUncheckedUpdateManyWithoutMediaNestedInput
    comments?: CommentUncheckedUpdateManyWithoutMediaNestedInput
    pollPosts?: PollPostUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type PostUpsertWithoutNotesInput = {
    update: XOR<PostUpdateWithoutNotesInput, PostUncheckedUpdateWithoutNotesInput>
    create: XOR<PostCreateWithoutNotesInput, PostUncheckedCreateWithoutNotesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutNotesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutNotesInput, PostUncheckedUpdateWithoutNotesInput>
  }

  export type PostUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostsNestedInput
    files?: FileUpdateManyWithoutPostsNestedInput
    author?: UserProfileUpdateOneRequiredWithoutPostsNestedInput
    community?: CommunityProfileUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUpdateManyWithoutPostsNestedInput
    publications?: PublicationUpdateManyWithoutPostsNestedInput
    reports?: ReportUpdateManyWithoutReportedPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    files?: FileUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPostsNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutPostsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedPostNestedInput
  }

  export type CommentUpsertWithoutNotesInput = {
    update: XOR<CommentUpdateWithoutNotesInput, CommentUncheckedUpdateWithoutNotesInput>
    create: XOR<CommentCreateWithoutNotesInput, CommentUncheckedCreateWithoutNotesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutNotesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutNotesInput, CommentUncheckedUpdateWithoutNotesInput>
  }

  export type CommentUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaUpdateOneWithoutCommentsNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    pollPost?: PollPostUpdateOneWithoutCommentsNestedInput
    Report?: ReportUpdateManyWithoutReportedCommentNestedInput
    Reaction?: ReactionUpdateManyWithoutCommentNestedInput
    UserProfile?: UserProfileUpdateManyWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
    Report?: ReportUncheckedUpdateManyWithoutReportedCommentNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutCommentNestedInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutCommentsNestedInput
  }

  export type SpaceCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceCreatetagsInput | string[]
    channels?: ChannelCreateNestedManyWithoutSpaceInput
    posts?: PostCreateNestedManyWithoutSpaceInput
    files?: FileCreateNestedManyWithoutSpaceInput
    parentSpace?: SpaceCreateNestedOneWithoutChildSpacesInput
    childSpaces?: SpaceCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    parentSpaceId?: string | null
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceCreatetagsInput | string[]
    channels?: ChannelUncheckedCreateNestedManyWithoutSpaceInput
    posts?: PostUncheckedCreateNestedManyWithoutSpaceInput
    files?: FileUncheckedCreateNestedManyWithoutSpaceInput
    childSpaces?: SpaceUncheckedCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceCreateOrConnectWithoutMembersInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutMembersInput, SpaceUncheckedCreateWithoutMembersInput>
  }

  export type SpaceUpsertWithoutMembersInput = {
    update: XOR<SpaceUpdateWithoutMembersInput, SpaceUncheckedUpdateWithoutMembersInput>
    create: XOR<SpaceCreateWithoutMembersInput, SpaceUncheckedCreateWithoutMembersInput>
    where?: SpaceWhereInput
  }

  export type SpaceUpdateToOneWithWhereWithoutMembersInput = {
    where?: SpaceWhereInput
    data: XOR<SpaceUpdateWithoutMembersInput, SpaceUncheckedUpdateWithoutMembersInput>
  }

  export type SpaceUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
    channels?: ChannelUpdateManyWithoutSpaceNestedInput
    posts?: PostUpdateManyWithoutSpaceNestedInput
    files?: FileUpdateManyWithoutSpaceNestedInput
    parentSpace?: SpaceUpdateOneWithoutChildSpacesNestedInput
    childSpaces?: SpaceUpdateManyWithoutParentSpaceNestedInput
  }

  export type SpaceUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
    channels?: ChannelUncheckedUpdateManyWithoutSpaceNestedInput
    posts?: PostUncheckedUpdateManyWithoutSpaceNestedInput
    files?: FileUncheckedUpdateManyWithoutSpaceNestedInput
    childSpaces?: SpaceUncheckedUpdateManyWithoutParentSpaceNestedInput
  }

  export type ChannelCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    space: SpaceCreateNestedOneWithoutChannelsInput
    posts?: PostCreateNestedManyWithoutChannelInput
    files?: FileCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    spaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    posts?: PostUncheckedCreateNestedManyWithoutChannelInput
    files?: FileUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutMembersInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutMembersInput, ChannelUncheckedCreateWithoutMembersInput>
  }

  export type ChannelUpsertWithoutMembersInput = {
    update: XOR<ChannelUpdateWithoutMembersInput, ChannelUncheckedUpdateWithoutMembersInput>
    create: XOR<ChannelCreateWithoutMembersInput, ChannelUncheckedCreateWithoutMembersInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutMembersInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutMembersInput, ChannelUncheckedUpdateWithoutMembersInput>
  }

  export type ChannelUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    space?: SpaceUpdateOneRequiredWithoutChannelsNestedInput
    posts?: PostUpdateManyWithoutChannelNestedInput
    files?: FileUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    posts?: PostUncheckedUpdateManyWithoutChannelNestedInput
    files?: FileUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type PostCreateWithoutFilesInput = {
    id?: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    media?: MediaCreateNestedOneWithoutPostsInput
    author: UserProfileCreateNestedOneWithoutPostsInput
    community?: CommunityProfileCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkCreateNestedManyWithoutPostsInput
    publications?: PublicationCreateNestedManyWithoutPostsInput
    reports?: ReportCreateNestedManyWithoutReportedPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutFilesInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutPostsInput
    publications?: PublicationUncheckedCreateNestedManyWithoutPostsInput
    reports?: ReportUncheckedCreateNestedManyWithoutReportedPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutFilesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutFilesInput, PostUncheckedCreateWithoutFilesInput>
  }

  export type SpaceCreateWithoutFilesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberCreateNestedManyWithoutSpaceInput
    channels?: ChannelCreateNestedManyWithoutSpaceInput
    posts?: PostCreateNestedManyWithoutSpaceInput
    parentSpace?: SpaceCreateNestedOneWithoutChildSpacesInput
    childSpaces?: SpaceCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    parentSpaceId?: string | null
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberUncheckedCreateNestedManyWithoutSpaceInput
    channels?: ChannelUncheckedCreateNestedManyWithoutSpaceInput
    posts?: PostUncheckedCreateNestedManyWithoutSpaceInput
    childSpaces?: SpaceUncheckedCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceCreateOrConnectWithoutFilesInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutFilesInput, SpaceUncheckedCreateWithoutFilesInput>
  }

  export type ChannelCreateWithoutFilesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    space: SpaceCreateNestedOneWithoutChannelsInput
    posts?: PostCreateNestedManyWithoutChannelInput
    members?: ChannelMemberCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    description?: string | null
    spaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    posts?: PostUncheckedCreateNestedManyWithoutChannelInput
    members?: ChannelMemberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutFilesInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutFilesInput, ChannelUncheckedCreateWithoutFilesInput>
  }

  export type PostUpsertWithWhereUniqueWithoutFilesInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutFilesInput, PostUncheckedUpdateWithoutFilesInput>
    create: XOR<PostCreateWithoutFilesInput, PostUncheckedCreateWithoutFilesInput>
  }

  export type PostUpdateWithWhereUniqueWithoutFilesInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutFilesInput, PostUncheckedUpdateWithoutFilesInput>
  }

  export type PostUpdateManyWithWhereWithoutFilesInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutFilesInput>
  }

  export type SpaceUpsertWithoutFilesInput = {
    update: XOR<SpaceUpdateWithoutFilesInput, SpaceUncheckedUpdateWithoutFilesInput>
    create: XOR<SpaceCreateWithoutFilesInput, SpaceUncheckedCreateWithoutFilesInput>
    where?: SpaceWhereInput
  }

  export type SpaceUpdateToOneWithWhereWithoutFilesInput = {
    where?: SpaceWhereInput
    data: XOR<SpaceUpdateWithoutFilesInput, SpaceUncheckedUpdateWithoutFilesInput>
  }

  export type SpaceUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUpdateManyWithoutSpaceNestedInput
    posts?: PostUpdateManyWithoutSpaceNestedInput
    parentSpace?: SpaceUpdateOneWithoutChildSpacesNestedInput
    childSpaces?: SpaceUpdateManyWithoutParentSpaceNestedInput
  }

  export type SpaceUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUncheckedUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutSpaceNestedInput
    posts?: PostUncheckedUpdateManyWithoutSpaceNestedInput
    childSpaces?: SpaceUncheckedUpdateManyWithoutParentSpaceNestedInput
  }

  export type ChannelUpsertWithoutFilesInput = {
    update: XOR<ChannelUpdateWithoutFilesInput, ChannelUncheckedUpdateWithoutFilesInput>
    create: XOR<ChannelCreateWithoutFilesInput, ChannelUncheckedCreateWithoutFilesInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutFilesInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutFilesInput, ChannelUncheckedUpdateWithoutFilesInput>
  }

  export type ChannelUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    space?: SpaceUpdateOneRequiredWithoutChannelsNestedInput
    posts?: PostUpdateManyWithoutChannelNestedInput
    members?: ChannelMemberUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    posts?: PostUncheckedUpdateManyWithoutChannelNestedInput
    members?: ChannelMemberUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type UserProfileCreateManyVirtualProfileInput = {
    id?: string
    name?: string | null
    profileImageUrl?: string | null
    bio?: string | null
    private?: boolean | null
    followersCount?: number
    followingCount?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityProfileCreateManyVirtualProfileInput = {
    id?: string
    name?: string | null
    description?: string | null
    communityRules?: string | null
    profileImageUrl?: string | null
    private?: boolean | null
    visible?: boolean | null
    followers?: number
    newsFeedTimelineId?: string | null
    personalFeedTimelineId?: string | null
    notificationFeedTimelineId?: string | null
    algoliaId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateWithoutVirtualProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUpdateManyWithoutUsersNestedInput
    tags?: UserTagUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutVirtualProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUsersNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUncheckedUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUncheckedUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUncheckedUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateManyWithoutVirtualProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityProfileUpdateWithoutVirtualProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    communityRules?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    visible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followers?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUpdateManyWithoutCommunityProfileNestedInput
    posts?: PostUpdateManyWithoutCommunityNestedInput
    moderators?: UserProfileUpdateManyWithoutModeratedCommunitiesNestedInput
  }

  export type CommunityProfileUncheckedUpdateWithoutVirtualProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    communityRules?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    visible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followers?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutCommunityProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutCommunityNestedInput
    moderators?: UserProfileUncheckedUpdateManyWithoutModeratedCommunitiesNestedInput
  }

  export type CommunityProfileUncheckedUpdateManyWithoutVirtualProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    communityRules?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    visible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followers?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagCreateManyUserProfileInput = {
    id?: string
    tagName?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockCreateManyBlockedProfileInput = {
    id?: string
    profileBlockingId: string
    profileBlockingType: string
    profileBlockedType: string
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BlockCreateManyBlockingProfileInput = {
    id?: string
    profileBlockedId: string
    profileBlockingType: string
    profileBlockedType: string
    reason?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FollowCreateManyFollowedProfileInput = {
    id?: string
    profileFollowingId: string
    targetFollowerType: string
    requestApproved?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type FollowCreateManyFollowingProfileInput = {
    id?: string
    profileFollowedId: string
    targetFollowerType: string
    requestApproved?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type PostCreateManyAuthorInput = {
    id?: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
  }

  export type ReactionCreateManyUserInput = {
    id?: string
    postId?: string | null
    commentId?: string | null
    type: $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    content: string
    isRead?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type ReportCreateManySubmitterInput = {
    id?: string
    postId?: string | null
    commentId?: string | null
    userId?: string | null
    reason: $Enums.ReportReason
    description?: string | null
    status?: $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ReportCreateManyReportedUserInput = {
    id?: string
    submitterId: string
    postId?: string | null
    commentId?: string | null
    reason: $Enums.ReportReason
    description?: string | null
    status?: $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type BookmarkUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: BookmarkUpdatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publications?: PublicationUpdateManyWithoutBookmarksNestedInput
    posts?: PostUpdateManyWithoutBookmarksNestedInput
  }

  export type BookmarkUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: BookmarkUpdatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publications?: PublicationUncheckedUpdateManyWithoutBookmarksNestedInput
    posts?: PostUncheckedUpdateManyWithoutBookmarksNestedInput
  }

  export type BookmarkUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: BookmarkUpdatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationUpdateWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    postIds?: PublicationUpdatepostIdsInput | string[]
    subjects?: PublicationUpdatesubjectsInput | string[]
    tags?: PublicationUpdatetagsInput | string[]
    adminBackendPlatformUserId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUpdateManyWithoutPublicationsNestedInput
    editors?: UserProfileUpdateManyWithoutEditorPublicationsNestedInput
    posts?: PostUpdateManyWithoutPublicationsNestedInput
  }

  export type PublicationUncheckedUpdateWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    postIds?: PublicationUpdatepostIdsInput | string[]
    subjects?: PublicationUpdatesubjectsInput | string[]
    tags?: PublicationUpdatetagsInput | string[]
    adminBackendPlatformUserId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPublicationsNestedInput
    editors?: UserProfileUncheckedUpdateManyWithoutEditorPublicationsNestedInput
    posts?: PostUncheckedUpdateManyWithoutPublicationsNestedInput
  }

  export type PublicationUncheckedUpdateManyWithoutAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    postIds?: PublicationUpdatepostIdsInput | string[]
    subjects?: PublicationUpdatesubjectsInput | string[]
    tags?: PublicationUpdatetagsInput | string[]
    adminBackendPlatformUserId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationUpdateWithoutEditorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    postIds?: PublicationUpdatepostIdsInput | string[]
    subjects?: PublicationUpdatesubjectsInput | string[]
    tags?: PublicationUpdatetagsInput | string[]
    adminBackendPlatformUserId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUpdateManyWithoutPublicationsNestedInput
    admins?: UserProfileUpdateManyWithoutAdminPublicationsNestedInput
    posts?: PostUpdateManyWithoutPublicationsNestedInput
  }

  export type PublicationUncheckedUpdateWithoutEditorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    postIds?: PublicationUpdatepostIdsInput | string[]
    subjects?: PublicationUpdatesubjectsInput | string[]
    tags?: PublicationUpdatetagsInput | string[]
    adminBackendPlatformUserId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPublicationsNestedInput
    admins?: UserProfileUncheckedUpdateManyWithoutAdminPublicationsNestedInput
    posts?: PostUncheckedUpdateManyWithoutPublicationsNestedInput
  }

  export type PublicationUncheckedUpdateManyWithoutEditorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    postIds?: PublicationUpdatepostIdsInput | string[]
    subjects?: PublicationUpdatesubjectsInput | string[]
    tags?: PublicationUpdatetagsInput | string[]
    adminBackendPlatformUserId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUpdateWithoutBlockedProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileBlockingType?: StringFieldUpdateOperationsInput | string
    profileBlockedType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockingProfile?: UserProfileUpdateOneRequiredWithoutBlockingNestedInput
  }

  export type BlockUncheckedUpdateWithoutBlockedProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileBlockingId?: StringFieldUpdateOperationsInput | string
    profileBlockingType?: StringFieldUpdateOperationsInput | string
    profileBlockedType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyWithoutBlockedProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileBlockingId?: StringFieldUpdateOperationsInput | string
    profileBlockingType?: StringFieldUpdateOperationsInput | string
    profileBlockedType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUpdateWithoutBlockingProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileBlockingType?: StringFieldUpdateOperationsInput | string
    profileBlockedType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedProfile?: UserProfileUpdateOneRequiredWithoutBlockedByNestedInput
  }

  export type BlockUncheckedUpdateWithoutBlockingProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileBlockedId?: StringFieldUpdateOperationsInput | string
    profileBlockingType?: StringFieldUpdateOperationsInput | string
    profileBlockedType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyWithoutBlockingProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileBlockedId?: StringFieldUpdateOperationsInput | string
    profileBlockingType?: StringFieldUpdateOperationsInput | string
    profileBlockedType?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowedProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetFollowerType?: StringFieldUpdateOperationsInput | string
    requestApproved?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followingProfile?: UserProfileUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowedProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileFollowingId?: StringFieldUpdateOperationsInput | string
    targetFollowerType?: StringFieldUpdateOperationsInput | string
    requestApproved?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FollowUncheckedUpdateManyWithoutFollowedProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileFollowingId?: StringFieldUpdateOperationsInput | string
    targetFollowerType?: StringFieldUpdateOperationsInput | string
    requestApproved?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FollowUpdateWithoutFollowingProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetFollowerType?: StringFieldUpdateOperationsInput | string
    requestApproved?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followedProfile?: UserProfileUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowingProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileFollowedId?: StringFieldUpdateOperationsInput | string
    targetFollowerType?: StringFieldUpdateOperationsInput | string
    requestApproved?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FollowUncheckedUpdateManyWithoutFollowingProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileFollowedId?: StringFieldUpdateOperationsInput | string
    targetFollowerType?: StringFieldUpdateOperationsInput | string
    requestApproved?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostsNestedInput
    files?: FileUpdateManyWithoutPostsNestedInput
    community?: CommunityProfileUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUpdateManyWithoutPostsNestedInput
    publications?: PublicationUpdateManyWithoutPostsNestedInput
    reports?: ReportUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    files?: FileUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPostsNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutPostsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaUpdateOneWithoutCommentsNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    notes?: NoteUpdateManyWithoutCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    pollPost?: PollPostUpdateOneWithoutCommentsNestedInput
    Report?: ReportUpdateManyWithoutReportedCommentNestedInput
    Reaction?: ReactionUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutCommentNestedInput
    Report?: ReportUncheckedUpdateManyWithoutReportedCommentNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneWithoutReactionsNestedInput
    comment?: CommentUpdateOneWithoutReactionNestedInput
  }

  export type ReactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUpdateWithoutSubmitterInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportedUser?: UserProfileUpdateOneWithoutReportedContentNestedInput
    reportedPost?: PostUpdateOneWithoutReportsNestedInput
    reportedComment?: CommentUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutSubmitterInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyWithoutSubmitterInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUpdateWithoutReportedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submitter?: UserProfileUpdateOneRequiredWithoutReportsSubmittedNestedInput
    reportedPost?: PostUpdateOneWithoutReportsNestedInput
    reportedComment?: CommentUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutReportedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    submitterId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyWithoutReportedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    submitterId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommunityProfileUpdateWithoutModeratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    communityRules?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    visible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followers?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutCommunityProfileNestedInput
    topics?: TopicUpdateManyWithoutCommunityProfileNestedInput
    posts?: PostUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityProfileUncheckedUpdateWithoutModeratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    communityRules?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    visible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followers?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: TopicUncheckedUpdateManyWithoutCommunityProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityProfileUncheckedUpdateManyWithoutModeratorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    communityRules?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    visible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followers?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicCreateManyCommunityProfileInput = {
    id?: string
    topicName?: string | null
    description?: string | null
    imageUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateManyCommunityInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
  }

  export type TopicUpdateWithoutCommunityProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUncheckedUpdateWithoutCommunityProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUncheckedUpdateManyWithoutCommunityProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostsNestedInput
    files?: FileUpdateManyWithoutPostsNestedInput
    author?: UserProfileUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUpdateManyWithoutPostsNestedInput
    publications?: PublicationUpdateManyWithoutPostsNestedInput
    reports?: ReportUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    files?: FileUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPostsNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutPostsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type UserProfileUpdateWithoutModeratedCommunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUsersNestedInput
    tags?: UserTagUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUpdateManyWithoutReportedUserNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutModeratedCommunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUsersNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUncheckedUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUncheckedUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUncheckedUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
  }

  export type UserProfileUncheckedUpdateManyWithoutModeratedCommunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUpdateWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: BookmarkUpdatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserProfileUpdateManyWithoutBookmarksNestedInput
    posts?: PostUpdateManyWithoutBookmarksNestedInput
  }

  export type BookmarkUncheckedUpdateWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: BookmarkUpdatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserProfileUncheckedUpdateManyWithoutBookmarksNestedInput
    posts?: PostUncheckedUpdateManyWithoutBookmarksNestedInput
  }

  export type BookmarkUncheckedUpdateManyWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: BookmarkUpdatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUpdateWithoutAdminPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUsersNestedInput
    tags?: UserTagUpdateManyWithoutUserProfileNestedInput
    editorPublications?: PublicationUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutAdminPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUsersNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserProfileNestedInput
    editorPublications?: PublicationUncheckedUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUncheckedUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateManyWithoutAdminPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUpdateWithoutEditorPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUsersNestedInput
    tags?: UserTagUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUpdateManyWithoutAdminsNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutEditorPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUsersNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUncheckedUpdateManyWithoutAdminsNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUncheckedUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateManyWithoutEditorPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostsNestedInput
    files?: FileUpdateManyWithoutPostsNestedInput
    author?: UserProfileUpdateOneRequiredWithoutPostsNestedInput
    community?: CommunityProfileUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUpdateManyWithoutPostsNestedInput
    reports?: ReportUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    files?: FileUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPostsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type CommentReplyCreateManyMediaInput = {
    id?: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    commentId: string
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PostCreateManyMediaInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
  }

  export type CommentCreateManyMediaInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    postId: string
    pollPostId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PollPostCreateManyMediaInput = {
    id?: string
    createdAt?: Date | string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    threadId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NoteCreateManyMediaInput = {
    id?: string
    content: string
    createdAt?: Date | string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    postId: string
    commentId?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentReplyUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    comment?: CommentUpdateOneRequiredWithoutRepliesNestedInput
  }

  export type CommentReplyUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    commentId?: StringFieldUpdateOperationsInput | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentReplyUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    commentId?: StringFieldUpdateOperationsInput | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PostUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    files?: FileUpdateManyWithoutPostsNestedInput
    author?: UserProfileUpdateOneRequiredWithoutPostsNestedInput
    community?: CommunityProfileUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUpdateManyWithoutPostsNestedInput
    publications?: PublicationUpdateManyWithoutPostsNestedInput
    reports?: ReportUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    files?: FileUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPostsNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutPostsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    notes?: NoteUpdateManyWithoutCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    pollPost?: PollPostUpdateOneWithoutCommentsNestedInput
    Report?: ReportUpdateManyWithoutReportedCommentNestedInput
    Reaction?: ReactionUpdateManyWithoutCommentNestedInput
    UserProfile?: UserProfileUpdateManyWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    postId?: StringFieldUpdateOperationsInput | string
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutCommentNestedInput
    Report?: ReportUncheckedUpdateManyWithoutReportedCommentNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutCommentNestedInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    postId?: StringFieldUpdateOperationsInput | string
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PollPostUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentUpdateManyWithoutPollPostNestedInput
    thread?: ThreadUpdateOneWithoutPollPostsNestedInput
  }

  export type PollPostUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentUncheckedUpdateManyWithoutPollPostNestedInput
  }

  export type PollPostUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NoteUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    post?: PostUpdateOneRequiredWithoutNotesNestedInput
    comment?: CommentUpdateOneWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    postId?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NoteUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    postId?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentCreateManyPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    mediaId?: string | null
    pollPostId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReactionCreateManyPostInput = {
    id?: string
    userId: string
    commentId?: string | null
    type: $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReportCreateManyReportedPostInput = {
    id?: string
    submitterId: string
    commentId?: string | null
    userId?: string | null
    reason: $Enums.ReportReason
    description?: string | null
    status?: $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type NoteCreateManyPostInput = {
    id?: string
    content: string
    createdAt?: Date | string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    mediaId?: string | null
    commentId?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FileUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    space?: SpaceUpdateOneWithoutFilesNestedInput
    channel?: ChannelUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaUpdateOneWithoutCommentsNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    notes?: NoteUpdateManyWithoutCommentNestedInput
    pollPost?: PollPostUpdateOneWithoutCommentsNestedInput
    Report?: ReportUpdateManyWithoutReportedCommentNestedInput
    Reaction?: ReactionUpdateManyWithoutCommentNestedInput
    UserProfile?: UserProfileUpdateManyWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutCommentNestedInput
    Report?: ReportUncheckedUpdateManyWithoutReportedCommentNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutCommentNestedInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReactionUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutReactionsNestedInput
    comment?: CommentUpdateOneWithoutReactionNestedInput
  }

  export type ReactionUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: BookmarkUpdatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publications?: PublicationUpdateManyWithoutBookmarksNestedInput
    users?: UserProfileUpdateManyWithoutBookmarksNestedInput
  }

  export type BookmarkUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: BookmarkUpdatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publications?: PublicationUncheckedUpdateManyWithoutBookmarksNestedInput
    users?: UserProfileUncheckedUpdateManyWithoutBookmarksNestedInput
  }

  export type BookmarkUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postIds?: BookmarkUpdatepostIdsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    postIds?: PublicationUpdatepostIdsInput | string[]
    subjects?: PublicationUpdatesubjectsInput | string[]
    tags?: PublicationUpdatetagsInput | string[]
    adminBackendPlatformUserId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUpdateManyWithoutPublicationsNestedInput
    admins?: UserProfileUpdateManyWithoutAdminPublicationsNestedInput
    editors?: UserProfileUpdateManyWithoutEditorPublicationsNestedInput
  }

  export type PublicationUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    postIds?: PublicationUpdatepostIdsInput | string[]
    subjects?: PublicationUpdatesubjectsInput | string[]
    tags?: PublicationUpdatetagsInput | string[]
    adminBackendPlatformUserId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPublicationsNestedInput
    admins?: UserProfileUncheckedUpdateManyWithoutAdminPublicationsNestedInput
    editors?: UserProfileUncheckedUpdateManyWithoutEditorPublicationsNestedInput
  }

  export type PublicationUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    postIds?: PublicationUpdatepostIdsInput | string[]
    subjects?: PublicationUpdatesubjectsInput | string[]
    tags?: PublicationUpdatetagsInput | string[]
    adminBackendPlatformUserId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutReportedPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submitter?: UserProfileUpdateOneRequiredWithoutReportsSubmittedNestedInput
    reportedUser?: UserProfileUpdateOneWithoutReportedContentNestedInput
    reportedComment?: CommentUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutReportedPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    submitterId?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyWithoutReportedPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    submitterId?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoteUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaUpdateOneWithoutNotesNestedInput
    comment?: CommentUpdateOneWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NoteUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentCreateManyPollPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentUpdateWithoutPollPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaUpdateOneWithoutCommentsNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    notes?: NoteUpdateManyWithoutCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    Report?: ReportUpdateManyWithoutReportedCommentNestedInput
    Reaction?: ReactionUpdateManyWithoutCommentNestedInput
    UserProfile?: UserProfileUpdateManyWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutPollPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutCommentNestedInput
    Report?: ReportUncheckedUpdateManyWithoutReportedCommentNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutCommentNestedInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPollPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentReplyCreateManyCommentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore?: number
    qualityScore?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    mediaId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NoteCreateManyCommentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportCreateManyReportedCommentInput = {
    id?: string
    submitterId: string
    postId?: string | null
    userId?: string | null
    reason: $Enums.ReportReason
    description?: string | null
    status?: $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ReactionCreateManyCommentInput = {
    id?: string
    userId: string
    postId?: string | null
    type: $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CommentReplyUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaUpdateOneWithoutCommentRepliesNestedInput
  }

  export type CommentReplyUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentReplyUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NoteUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaUpdateOneWithoutNotesNestedInput
    post?: PostUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NoteUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReportUpdateWithoutReportedCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submitter?: UserProfileUpdateOneRequiredWithoutReportsSubmittedNestedInput
    reportedUser?: UserProfileUpdateOneWithoutReportedContentNestedInput
    reportedPost?: PostUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutReportedCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    submitterId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUncheckedUpdateManyWithoutReportedCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    submitterId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReactionUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutReactionsNestedInput
    post?: PostUpdateOneWithoutReactionsNestedInput
  }

  export type ReactionUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUsersNestedInput
    tags?: UserTagUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUsersNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUncheckedUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUncheckedUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUncheckedUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateManyWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    postIds?: PublicationUpdatepostIdsInput | string[]
    subjects?: PublicationUpdatesubjectsInput | string[]
    tags?: PublicationUpdatetagsInput | string[]
    adminBackendPlatformUserId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: UserProfileUpdateManyWithoutAdminPublicationsNestedInput
    editors?: UserProfileUpdateManyWithoutEditorPublicationsNestedInput
    posts?: PostUpdateManyWithoutPublicationsNestedInput
  }

  export type PublicationUncheckedUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    postIds?: PublicationUpdatepostIdsInput | string[]
    subjects?: PublicationUpdatesubjectsInput | string[]
    tags?: PublicationUpdatetagsInput | string[]
    adminBackendPlatformUserId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admins?: UserProfileUncheckedUpdateManyWithoutAdminPublicationsNestedInput
    editors?: UserProfileUncheckedUpdateManyWithoutEditorPublicationsNestedInput
    posts?: PostUncheckedUpdateManyWithoutPublicationsNestedInput
  }

  export type PublicationUncheckedUpdateManyWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    postIds?: PublicationUpdatepostIdsInput | string[]
    subjects?: PublicationUpdatesubjectsInput | string[]
    tags?: PublicationUpdatetagsInput | string[]
    adminBackendPlatformUserId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualProfile?: VirtualProfileUpdateOneRequiredWithoutUserProfileNestedInput
    tags?: UserTagUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: UserTagUncheckedUpdateManyWithoutUserProfileNestedInput
    adminPublications?: PublicationUncheckedUpdateManyWithoutAdminsNestedInput
    editorPublications?: PublicationUncheckedUpdateManyWithoutEditorsNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedProfileNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockingProfileNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowedProfileNestedInput
    following?: FollowUncheckedUpdateManyWithoutFollowingProfileNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserProfileNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reportsSubmitted?: ReportUncheckedUpdateManyWithoutSubmitterNestedInput
    reportedContent?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    moderatedCommunities?: CommunityProfileUncheckedUpdateManyWithoutModeratorsNestedInput
  }

  export type UserProfileUncheckedUpdateManyWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualProfileId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    private?: NullableBoolFieldUpdateOperationsInput | boolean | null
    followersCount?: IntFieldUpdateOperationsInput | number
    followingCount?: IntFieldUpdateOperationsInput | number
    newsFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    personalFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    notificationFeedTimelineId?: NullableStringFieldUpdateOperationsInput | string | null
    algoliaId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostsNestedInput
    files?: FileUpdateManyWithoutPostsNestedInput
    author?: UserProfileUpdateOneRequiredWithoutPostsNestedInput
    community?: CommunityProfileUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    publications?: PublicationUpdateManyWithoutPostsNestedInput
    reports?: ReportUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    files?: FileUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutPostsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type SpaceMemberCreateManySpaceInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    status?: string
    permissions?: SpaceMemberCreatepermissionsInput | string[]
  }

  export type ChannelCreateManySpaceInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PostCreateManySpaceInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
  }

  export type FileCreateManySpaceInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    channelId?: string | null
  }

  export type SpaceCreateManyParentSpaceInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: $Enums.Visibility
    isPrivate?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceCreatetagsInput | string[]
  }

  export type SpaceMemberUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    permissions?: SpaceMemberUpdatepermissionsInput | string[]
  }

  export type SpaceMemberUncheckedUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    permissions?: SpaceMemberUpdatepermissionsInput | string[]
  }

  export type SpaceMemberUncheckedUpdateManyWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    permissions?: SpaceMemberUpdatepermissionsInput | string[]
  }

  export type ChannelUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    posts?: PostUpdateManyWithoutChannelNestedInput
    files?: FileUpdateManyWithoutChannelNestedInput
    members?: ChannelMemberUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    posts?: PostUncheckedUpdateManyWithoutChannelNestedInput
    files?: FileUncheckedUpdateManyWithoutChannelNestedInput
    members?: ChannelMemberUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateManyWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PostUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostsNestedInput
    files?: FileUpdateManyWithoutPostsNestedInput
    author?: UserProfileUpdateOneRequiredWithoutPostsNestedInput
    community?: CommunityProfileUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUpdateManyWithoutPostsNestedInput
    publications?: PublicationUpdateManyWithoutPostsNestedInput
    reports?: ReportUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    files?: FileUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPostsNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutPostsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type FileUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    posts?: PostUpdateManyWithoutFilesNestedInput
    channel?: ChannelUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateManyWithoutSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpaceUpdateWithoutParentSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUpdateManyWithoutSpaceNestedInput
    posts?: PostUpdateManyWithoutSpaceNestedInput
    files?: FileUpdateManyWithoutSpaceNestedInput
    childSpaces?: SpaceUpdateManyWithoutParentSpaceNestedInput
  }

  export type SpaceUncheckedUpdateWithoutParentSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUncheckedUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutSpaceNestedInput
    posts?: PostUncheckedUpdateManyWithoutSpaceNestedInput
    files?: FileUncheckedUpdateManyWithoutSpaceNestedInput
    childSpaces?: SpaceUncheckedUpdateManyWithoutParentSpaceNestedInput
  }

  export type SpaceUncheckedUpdateManyWithoutParentSpaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: SpaceUpdatetagsInput | string[]
  }

  export type PostCreateManyChannelInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: string | null
    spaceId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
  }

  export type FileCreateManyChannelInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: JsonNullValueInput | InputJsonValue
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    spaceId?: string | null
  }

  export type ChannelMemberCreateManyChannelInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    lastRead?: Date | string | null
  }

  export type PostUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostsNestedInput
    files?: FileUpdateManyWithoutPostsNestedInput
    author?: UserProfileUpdateOneRequiredWithoutPostsNestedInput
    community?: CommunityProfileUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUpdateManyWithoutPostsNestedInput
    publications?: PublicationUpdateManyWithoutPostsNestedInput
    reports?: ReportUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    files?: FileUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPostsNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutPostsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type FileUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    posts?: PostUpdateManyWithoutFilesNestedInput
    space?: SpaceUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: PostUncheckedUpdateManyWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChannelMemberUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelMemberUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelMemberUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostCreateManyThreadInput = {
    id?: string
    authorId: string
    communityId?: string | null
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status?: $Enums.PostStatus
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore?: number
    qualityScore?: number
    viewCount?: number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    spaceId?: string | null
    channelId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.Visibility
    isPinned?: boolean
    isArchived?: boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: number
  }

  export type PollPostCreateManyThreadInput = {
    id?: string
    createdAt?: Date | string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    mediaId?: string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PostUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostsNestedInput
    files?: FileUpdateManyWithoutPostsNestedInput
    author?: UserProfileUpdateOneRequiredWithoutPostsNestedInput
    community?: CommunityProfileUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUpdateManyWithoutPostsNestedInput
    publications?: PublicationUpdateManyWithoutPostsNestedInput
    reports?: ReportUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    files?: FileUncheckedUpdateManyWithoutPostsNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPostsNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutPostsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }

  export type PollPostUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    media?: MediaUpdateOneWithoutPollPostsNestedInput
    comments?: CommentUpdateManyWithoutPollPostNestedInput
  }

  export type PollPostUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    comments?: CommentUncheckedUpdateManyWithoutPollPostNestedInput
  }

  export type PollPostUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: NullableJsonNullValueInput | InputJsonValue
    userIdToPollResponsesMap?: NullableJsonNullValueInput | InputJsonValue
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PostUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostsNestedInput
    author?: UserProfileUpdateOneRequiredWithoutPostsNestedInput
    community?: CommunityProfileUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUpdateManyWithoutPostsNestedInput
    publications?: PublicationUpdateManyWithoutPostsNestedInput
    reports?: ReportUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutPostsNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutPostsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutReportedPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    communityId?: NullableStringFieldUpdateOperationsInput | string | null
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReportsMap?: NullableJsonNullValueInput | InputJsonValue
    userIdToReactionMap?: NullableJsonNullValueInput | InputJsonValue
    insights?: NullableJsonNullValueInput | InputJsonValue
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    searchMetadata?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumVisibilityFieldUpdateOperationsInput | $Enums.Visibility
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use VirtualProfileCountOutputTypeDefaultArgs instead
     */
    export type VirtualProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VirtualProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserProfileCountOutputTypeDefaultArgs instead
     */
    export type UserProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityProfileCountOutputTypeDefaultArgs instead
     */
    export type CommunityProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PublicationCountOutputTypeDefaultArgs instead
     */
    export type PublicationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PublicationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaCountOutputTypeDefaultArgs instead
     */
    export type MediaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostCountOutputTypeDefaultArgs instead
     */
    export type PostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PollPostCountOutputTypeDefaultArgs instead
     */
    export type PollPostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PollPostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentCountOutputTypeDefaultArgs instead
     */
    export type CommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookmarkCountOutputTypeDefaultArgs instead
     */
    export type BookmarkCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookmarkCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpaceCountOutputTypeDefaultArgs instead
     */
    export type SpaceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpaceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelCountOutputTypeDefaultArgs instead
     */
    export type ChannelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ThreadCountOutputTypeDefaultArgs instead
     */
    export type ThreadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ThreadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FileCountOutputTypeDefaultArgs instead
     */
    export type FileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VirtualProfileDefaultArgs instead
     */
    export type VirtualProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VirtualProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserProfileDefaultArgs instead
     */
    export type UserProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityProfileDefaultArgs instead
     */
    export type CommunityProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TopicDefaultArgs instead
     */
    export type TopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TopicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PublicationDefaultArgs instead
     */
    export type PublicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PublicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaDefaultArgs instead
     */
    export type MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostDefaultArgs instead
     */
    export type PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PollPostDefaultArgs instead
     */
    export type PollPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PollPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentReplyDefaultArgs instead
     */
    export type CommentReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentReplyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReactionDefaultArgs instead
     */
    export type ReactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookmarkDefaultArgs instead
     */
    export type BookmarkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookmarkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockDefaultArgs instead
     */
    export type BlockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FollowDefaultArgs instead
     */
    export type FollowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FollowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserTagDefaultArgs instead
     */
    export type UserTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserTagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpaceDefaultArgs instead
     */
    export type SpaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelDefaultArgs instead
     */
    export type ChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ThreadDefaultArgs instead
     */
    export type ThreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ThreadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NoteDefaultArgs instead
     */
    export type NoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpaceMemberDefaultArgs instead
     */
    export type SpaceMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpaceMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelMemberDefaultArgs instead
     */
    export type ChannelMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FileDefaultArgs instead
     */
    export type FileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FileDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}
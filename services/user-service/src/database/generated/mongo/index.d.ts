
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Entities
 * 
 */
export type Entities = $Result.DefaultSelection<Prisma.$EntitiesPayload>
/**
 * Model Sentiment
 * 
 */
export type Sentiment = $Result.DefaultSelection<Prisma.$SentimentPayload>
/**
 * Model ContentInsights
 * 
 */
export type ContentInsights = $Result.DefaultSelection<Prisma.$ContentInsightsPayload>
/**
 * Model SearchMetadata
 * 
 */
export type SearchMetadata = $Result.DefaultSelection<Prisma.$SearchMetadataPayload>
/**
 * Model FileMetadata
 * 
 */
export type FileMetadata = $Result.DefaultSelection<Prisma.$FileMetadataPayload>
/**
 * Model Dimensions
 * 
 */
export type Dimensions = $Result.DefaultSelection<Prisma.$DimensionsPayload>
/**
 * Model AIAnalysis
 * Main AIAnalysis type
 */
export type AIAnalysis = $Result.DefaultSelection<Prisma.$AIAnalysisPayload>
/**
 * Model SentimentAnalysis
 * 
 */
export type SentimentAnalysis = $Result.DefaultSelection<Prisma.$SentimentAnalysisPayload>
/**
 * Model SentimentSegment
 * 
 */
export type SentimentSegment = $Result.DefaultSelection<Prisma.$SentimentSegmentPayload>
/**
 * Model AspectSentiment
 * 
 */
export type AspectSentiment = $Result.DefaultSelection<Prisma.$AspectSentimentPayload>
/**
 * Model NamedEntity
 * 
 */
export type NamedEntity = $Result.DefaultSelection<Prisma.$NamedEntityPayload>
/**
 * Model WikiData
 * 
 */
export type WikiData = $Result.DefaultSelection<Prisma.$WikiDataPayload>
/**
 * Model TopicAnalysis
 * 
 */
export type TopicAnalysis = $Result.DefaultSelection<Prisma.$TopicAnalysisPayload>
/**
 * Model TopicContext
 * 
 */
export type TopicContext = $Result.DefaultSelection<Prisma.$TopicContextPayload>
/**
 * Model Keyword
 * 
 */
export type Keyword = $Result.DefaultSelection<Prisma.$KeywordPayload>
/**
 * Model KeywordMetrics
 * 
 */
export type KeywordMetrics = $Result.DefaultSelection<Prisma.$KeywordMetricsPayload>
/**
 * Model KeywordLocation
 * 
 */
export type KeywordLocation = $Result.DefaultSelection<Prisma.$KeywordLocationPayload>
/**
 * Model ReadabilityMetrics
 * 
 */
export type ReadabilityMetrics = $Result.DefaultSelection<Prisma.$ReadabilityMetricsPayload>
/**
 * Model ComplexityMetrics
 * 
 */
export type ComplexityMetrics = $Result.DefaultSelection<Prisma.$ComplexityMetricsPayload>
/**
 * Model ContentQuality
 * 
 */
export type ContentQuality = $Result.DefaultSelection<Prisma.$ContentQualityPayload>
/**
 * Model SourceValidation
 * 
 */
export type SourceValidation = $Result.DefaultSelection<Prisma.$SourceValidationPayload>
/**
 * Model Citation
 * 
 */
export type Citation = $Result.DefaultSelection<Prisma.$CitationPayload>
/**
 * Model StructureAnalysis
 * 
 */
export type StructureAnalysis = $Result.DefaultSelection<Prisma.$StructureAnalysisPayload>
/**
 * Model FormattingAnalysis
 * 
 */
export type FormattingAnalysis = $Result.DefaultSelection<Prisma.$FormattingAnalysisPayload>
/**
 * Model ToxicityAnalysis
 * 
 */
export type ToxicityAnalysis = $Result.DefaultSelection<Prisma.$ToxicityAnalysisPayload>
/**
 * Model ToxicityCategories
 * 
 */
export type ToxicityCategories = $Result.DefaultSelection<Prisma.$ToxicityCategoriesPayload>
/**
 * Model ThreatDetection
 * 
 */
export type ThreatDetection = $Result.DefaultSelection<Prisma.$ThreatDetectionPayload>
/**
 * Model ModerationDecision
 * 
 */
export type ModerationDecision = $Result.DefaultSelection<Prisma.$ModerationDecisionPayload>
/**
 * Model ToxicitySeverity
 * 
 */
export type ToxicitySeverity = $Result.DefaultSelection<Prisma.$ToxicitySeverityPayload>
/**
 * Model OriginalityScore
 * 
 */
export type OriginalityScore = $Result.DefaultSelection<Prisma.$OriginalityScorePayload>
/**
 * Model SimilarityMatch
 * 
 */
export type SimilarityMatch = $Result.DefaultSelection<Prisma.$SimilarityMatchPayload>
/**
 * Model PlagiarismMetrics
 * 
 */
export type PlagiarismMetrics = $Result.DefaultSelection<Prisma.$PlagiarismMetricsPayload>
/**
 * Model LanguageAnalysis
 * 
 */
export type LanguageAnalysis = $Result.DefaultSelection<Prisma.$LanguageAnalysisPayload>
/**
 * Model LanguageAlternative
 * 
 */
export type LanguageAlternative = $Result.DefaultSelection<Prisma.$LanguageAlternativePayload>
/**
 * Model TranslationInfo
 * 
 */
export type TranslationInfo = $Result.DefaultSelection<Prisma.$TranslationInfoPayload>
/**
 * Model GrammarAnalysis
 * 
 */
export type GrammarAnalysis = $Result.DefaultSelection<Prisma.$GrammarAnalysisPayload>
/**
 * Model GrammarError
 * 
 */
export type GrammarError = $Result.DefaultSelection<Prisma.$GrammarErrorPayload>
/**
 * Model StyleSuggestion
 * 
 */
export type StyleSuggestion = $Result.DefaultSelection<Prisma.$StyleSuggestionPayload>
/**
 * Model StyleMetrics
 * 
 */
export type StyleMetrics = $Result.DefaultSelection<Prisma.$StyleMetricsPayload>
/**
 * Model VocabularyMetrics
 * 
 */
export type VocabularyMetrics = $Result.DefaultSelection<Prisma.$VocabularyMetricsPayload>
/**
 * Model IntentAnalysis
 * 
 */
export type IntentAnalysis = $Result.DefaultSelection<Prisma.$IntentAnalysisPayload>
/**
 * Model EmotionAnalysis
 * 
 */
export type EmotionAnalysis = $Result.DefaultSelection<Prisma.$EmotionAnalysisPayload>
/**
 * Model EmotionSpectrum
 * 
 */
export type EmotionSpectrum = $Result.DefaultSelection<Prisma.$EmotionSpectrumPayload>
/**
 * Model BiasAnalysis
 * 
 */
export type BiasAnalysis = $Result.DefaultSelection<Prisma.$BiasAnalysisPayload>
/**
 * Model BiasType
 * 
 */
export type BiasType = $Result.DefaultSelection<Prisma.$BiasTypePayload>
/**
 * Model ImageAnalysis
 * 
 */
export type ImageAnalysis = $Result.DefaultSelection<Prisma.$ImageAnalysisPayload>
/**
 * Model DetectedObject
 * 
 */
export type DetectedObject = $Result.DefaultSelection<Prisma.$DetectedObjectPayload>
/**
 * Model FaceAnalysis
 * 
 */
export type FaceAnalysis = $Result.DefaultSelection<Prisma.$FaceAnalysisPayload>
/**
 * Model BoundingBox
 * 
 */
export type BoundingBox = $Result.DefaultSelection<Prisma.$BoundingBoxPayload>
/**
 * Model Label
 * 
 */
export type Label = $Result.DefaultSelection<Prisma.$LabelPayload>
/**
 * Model ColorAnalysis
 * 
 */
export type ColorAnalysis = $Result.DefaultSelection<Prisma.$ColorAnalysisPayload>
/**
 * Model Color
 * 
 */
export type Color = $Result.DefaultSelection<Prisma.$ColorPayload>
/**
 * Model RGB
 * 
 */
export type RGB = $Result.DefaultSelection<Prisma.$RGBPayload>
/**
 * Model NSFWAnalysis
 * 
 */
export type NSFWAnalysis = $Result.DefaultSelection<Prisma.$NSFWAnalysisPayload>
/**
 * Model NSFWCategories
 * 
 */
export type NSFWCategories = $Result.DefaultSelection<Prisma.$NSFWCategoriesPayload>
/**
 * Model ImageQuality
 * 
 */
export type ImageQuality = $Result.DefaultSelection<Prisma.$ImageQualityPayload>
/**
 * Model Resolution
 * 
 */
export type Resolution = $Result.DefaultSelection<Prisma.$ResolutionPayload>
/**
 * Model ImageComposition
 * 
 */
export type ImageComposition = $Result.DefaultSelection<Prisma.$ImageCompositionPayload>
/**
 * Model VideoAnalysis
 * 
 */
export type VideoAnalysis = $Result.DefaultSelection<Prisma.$VideoAnalysisPayload>
/**
 * Model Scene
 * 
 */
export type Scene = $Result.DefaultSelection<Prisma.$ScenePayload>
/**
 * Model KeyFrame
 * 
 */
export type KeyFrame = $Result.DefaultSelection<Prisma.$KeyFramePayload>
/**
 * Model Action
 * 
 */
export type Action = $Result.DefaultSelection<Prisma.$ActionPayload>
/**
 * Model Caption
 * 
 */
export type Caption = $Result.DefaultSelection<Prisma.$CaptionPayload>
/**
 * Model MotionAnalysis
 * 
 */
export type MotionAnalysis = $Result.DefaultSelection<Prisma.$MotionAnalysisPayload>
/**
 * Model TrackingData
 * 
 */
export type TrackingData = $Result.DefaultSelection<Prisma.$TrackingDataPayload>
/**
 * Model AudioAnalysis
 * 
 */
export type AudioAnalysis = $Result.DefaultSelection<Prisma.$AudioAnalysisPayload>
/**
 * Model Speaker
 * 
 */
export type Speaker = $Result.DefaultSelection<Prisma.$SpeakerPayload>
/**
 * Model TimeSegment
 * 
 */
export type TimeSegment = $Result.DefaultSelection<Prisma.$TimeSegmentPayload>
/**
 * Model SpeakerCharacteristics
 * 
 */
export type SpeakerCharacteristics = $Result.DefaultSelection<Prisma.$SpeakerCharacteristicsPayload>
/**
 * Model NoiseAnalysis
 * 
 */
export type NoiseAnalysis = $Result.DefaultSelection<Prisma.$NoiseAnalysisPayload>
/**
 * Model MusicAnalysis
 * 
 */
export type MusicAnalysis = $Result.DefaultSelection<Prisma.$MusicAnalysisPayload>
/**
 * Model MarketAnalysis
 * 
 */
export type MarketAnalysis = $Result.DefaultSelection<Prisma.$MarketAnalysisPayload>
/**
 * Model Trend
 * 
 */
export type Trend = $Result.DefaultSelection<Prisma.$TrendPayload>
/**
 * Model CompetitiveAnalysis
 * 
 */
export type CompetitiveAnalysis = $Result.DefaultSelection<Prisma.$CompetitiveAnalysisPayload>
/**
 * Model ActionItem
 * 
 */
export type ActionItem = $Result.DefaultSelection<Prisma.$ActionItemPayload>
/**
 * Model ModelMetadata
 * 
 */
export type ModelMetadata = $Result.DefaultSelection<Prisma.$ModelMetadataPayload>
/**
 * Model ModelPerformance
 * 
 */
export type ModelPerformance = $Result.DefaultSelection<Prisma.$ModelPerformancePayload>
/**
 * Model ResourceMetrics
 * 
 */
export type ResourceMetrics = $Result.DefaultSelection<Prisma.$ResourceMetricsPayload>
/**
 * Model FaceAttributes
 * 
 */
export type FaceAttributes = $Result.DefaultSelection<Prisma.$FaceAttributesPayload>
/**
 * Model FaceLandmark
 * 
 */
export type FaceLandmark = $Result.DefaultSelection<Prisma.$FaceLandmarkPayload>
/**
 * Model Point
 * 
 */
export type Point = $Result.DefaultSelection<Prisma.$PointPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model Post
 * Enhanced Post model combining original and new features
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model PollPost
 * Enhanced PollPost model
 */
export type PollPost = $Result.DefaultSelection<Prisma.$PollPostPayload>
/**
 * Model Space
 * Space model for workspace organization
 */
export type Space = $Result.DefaultSelection<Prisma.$SpacePayload>
/**
 * Model Channel
 * Channel model for content organization
 */
export type Channel = $Result.DefaultSelection<Prisma.$ChannelPayload>
/**
 * Model Thread
 * Enhanced Thread model
 */
export type Thread = $Result.DefaultSelection<Prisma.$ThreadPayload>
/**
 * Model Note
 * Enhanced Note model
 */
export type Note = $Result.DefaultSelection<Prisma.$NotePayload>
/**
 * Model Comment
 * Enhanced Comment model
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model CommentReply
 * Enhanced CommentReply model
 */
export type CommentReply = $Result.DefaultSelection<Prisma.$CommentReplyPayload>
/**
 * Model SpaceMember
 * Membership Models
 */
export type SpaceMember = $Result.DefaultSelection<Prisma.$SpaceMemberPayload>
/**
 * Model ChannelMember
 * 
 */
export type ChannelMember = $Result.DefaultSelection<Prisma.$ChannelMemberPayload>
/**
 * Model File
 * File Management Model
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model FileToPost
 * Explicit many-to-many relationship model
 */
export type FileToPost = $Result.DefaultSelection<Prisma.$FileToPostPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PostType: {
  POST_TYPE_UNSPECIFIED: 'POST_TYPE_UNSPECIFIED',
  POST_TYPE_POST: 'POST_TYPE_POST',
  POST_TYPE_REPOST: 'POST_TYPE_REPOST',
  POST_TYPE_QUESTION: 'POST_TYPE_QUESTION',
  POST_TYPE_ACHIEVEMENT: 'POST_TYPE_ACHIEVEMENT',
  POST_TYPE_ANNOUNCEMENT: 'POST_TYPE_ANNOUNCEMENT',
  POST_TYPE_POLL: 'POST_TYPE_POLL',
  POST_TYPE_ARTICLE: 'POST_TYPE_ARTICLE',
  POST_TYPE_SHORT_STORY: 'POST_TYPE_SHORT_STORY'
};

export type PostType = (typeof PostType)[keyof typeof PostType]


export const Category: {
  CATEGORY_UNSPECIFIED: 'CATEGORY_UNSPECIFIED',
  CATEGORY_WORLD: 'CATEGORY_WORLD',
  CATEGORY_BUSINESS: 'CATEGORY_BUSINESS',
  CATEGORY_ECONOMICS: 'CATEGORY_ECONOMICS',
  CATEGORY_FOREIGN_POLICY: 'CATEGORY_FOREIGN_POLICY',
  CATEGORY_POLITICS: 'CATEGORY_POLITICS',
  CATEGORY_TECHNOLOGY: 'CATEGORY_TECHNOLOGY',
  CATEGORY_OTHER: 'CATEGORY_OTHER'
};

export type Category = (typeof Category)[keyof typeof Category]


export const ThreadParticipantType: {
  THREAD_PARTICIPANT_TYPE_UNSPECIFIED: 'THREAD_PARTICIPANT_TYPE_UNSPECIFIED',
  THREAD_PARTICIPANT_TYPE_PARENT: 'THREAD_PARTICIPANT_TYPE_PARENT',
  THREAD_PARTICIPANT_TYPE_PARTICIPANT: 'THREAD_PARTICIPANT_TYPE_PARTICIPANT'
};

export type ThreadParticipantType = (typeof ThreadParticipantType)[keyof typeof ThreadParticipantType]


export const AccountType: {
  ACCOUNT_TYPE_UNSPECIFIED: 'ACCOUNT_TYPE_UNSPECIFIED',
  ACCOUNT_TYPE_USER: 'ACCOUNT_TYPE_USER',
  ACCOUNT_TYPE_COMMUNITY: 'ACCOUNT_TYPE_COMMUNITY'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const SpaceType: {
  SPACE_TYPE_UNSPECIFIED: 'SPACE_TYPE_UNSPECIFIED',
  SPACE_TYPE_TEAM: 'SPACE_TYPE_TEAM',
  SPACE_TYPE_PROJECT: 'SPACE_TYPE_PROJECT',
  SPACE_TYPE_DEPARTMENT: 'SPACE_TYPE_DEPARTMENT',
  SPACE_TYPE_ANNOUNCEMENT: 'SPACE_TYPE_ANNOUNCEMENT',
  SPACE_TYPE_KNOWLEDGE_BASE: 'SPACE_TYPE_KNOWLEDGE_BASE',
  SPACE_TYPE_SOCIAL: 'SPACE_TYPE_SOCIAL',
  SPACE_TYPE_LEARNING: 'SPACE_TYPE_LEARNING',
  SPACE_TYPE_INNOVATION: 'SPACE_TYPE_INNOVATION'
};

export type SpaceType = (typeof SpaceType)[keyof typeof SpaceType]


export const AccessLevel: {
  ACCESS_LEVEL_PUBLIC: 'ACCESS_LEVEL_PUBLIC',
  ACCESS_LEVEL_PRIVATE: 'ACCESS_LEVEL_PRIVATE',
  ACCESS_LEVEL_RESTRICTED: 'ACCESS_LEVEL_RESTRICTED',
  ACCESS_LEVEL_ORGANIZATION: 'ACCESS_LEVEL_ORGANIZATION'
};

export type AccessLevel = (typeof AccessLevel)[keyof typeof AccessLevel]


export const MediaType: {
  MEDIA_TYPE_UNSPECIFIED: 'MEDIA_TYPE_UNSPECIFIED',
  MEDIA_TYPE_IMAGE: 'MEDIA_TYPE_IMAGE',
  MEDIA_TYPE_VIDEO: 'MEDIA_TYPE_VIDEO',
  MEDIA_TYPE_AUDIO: 'MEDIA_TYPE_AUDIO',
  MEDIA_TYPE_DOCUMENT: 'MEDIA_TYPE_DOCUMENT',
  MEDIA_TYPE_SPREADSHEET: 'MEDIA_TYPE_SPREADSHEET',
  MEDIA_TYPE_PRESENTATION: 'MEDIA_TYPE_PRESENTATION',
  MEDIA_TYPE_PDF: 'MEDIA_TYPE_PDF',
  MEDIA_TYPE_CODE: 'MEDIA_TYPE_CODE',
  MEDIA_TYPE_ZIP: 'MEDIA_TYPE_ZIP',
  MEDIA_TYPE_3D: 'MEDIA_TYPE_3D',
  MEDIA_TYPE_AR: 'MEDIA_TYPE_AR',
  MEDIA_TYPE_CAD: 'MEDIA_TYPE_CAD',
  MEDIA_TYPE_VECTOR: 'MEDIA_TYPE_VECTOR'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]

}

export type PostType = $Enums.PostType

export const PostType: typeof $Enums.PostType

export type Category = $Enums.Category

export const Category: typeof $Enums.Category

export type ThreadParticipantType = $Enums.ThreadParticipantType

export const ThreadParticipantType: typeof $Enums.ThreadParticipantType

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type SpaceType = $Enums.SpaceType

export const SpaceType: typeof $Enums.SpaceType

export type AccessLevel = $Enums.AccessLevel

export const AccessLevel: typeof $Enums.AccessLevel

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Media
 * const media = await prisma.media.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Media
   * const media = await prisma.media.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs>;

  /**
   * `prisma.pollPost`: Exposes CRUD operations for the **PollPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PollPosts
    * const pollPosts = await prisma.pollPost.findMany()
    * ```
    */
  get pollPost(): Prisma.PollPostDelegate<ExtArgs>;

  /**
   * `prisma.space`: Exposes CRUD operations for the **Space** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spaces
    * const spaces = await prisma.space.findMany()
    * ```
    */
  get space(): Prisma.SpaceDelegate<ExtArgs>;

  /**
   * `prisma.channel`: Exposes CRUD operations for the **Channel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channel.findMany()
    * ```
    */
  get channel(): Prisma.ChannelDelegate<ExtArgs>;

  /**
   * `prisma.thread`: Exposes CRUD operations for the **Thread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Threads
    * const threads = await prisma.thread.findMany()
    * ```
    */
  get thread(): Prisma.ThreadDelegate<ExtArgs>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.note.findMany()
    * ```
    */
  get note(): Prisma.NoteDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.commentReply`: Exposes CRUD operations for the **CommentReply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentReplies
    * const commentReplies = await prisma.commentReply.findMany()
    * ```
    */
  get commentReply(): Prisma.CommentReplyDelegate<ExtArgs>;

  /**
   * `prisma.spaceMember`: Exposes CRUD operations for the **SpaceMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpaceMembers
    * const spaceMembers = await prisma.spaceMember.findMany()
    * ```
    */
  get spaceMember(): Prisma.SpaceMemberDelegate<ExtArgs>;

  /**
   * `prisma.channelMember`: Exposes CRUD operations for the **ChannelMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChannelMembers
    * const channelMembers = await prisma.channelMember.findMany()
    * ```
    */
  get channelMember(): Prisma.ChannelMemberDelegate<ExtArgs>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs>;

  /**
   * `prisma.fileToPost`: Exposes CRUD operations for the **FileToPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileToPosts
    * const fileToPosts = await prisma.fileToPost.findMany()
    * ```
    */
  get fileToPost(): Prisma.FileToPostDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.21.1
   * Query Engine version: bf0e5e8a04cada8225617067eaa03d041e2bba36
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Media: 'Media',
    Post: 'Post',
    PollPost: 'PollPost',
    Space: 'Space',
    Channel: 'Channel',
    Thread: 'Thread',
    Note: 'Note',
    Comment: 'Comment',
    CommentReply: 'CommentReply',
    SpaceMember: 'SpaceMember',
    ChannelMember: 'ChannelMember',
    File: 'File',
    FileToPost: 'FileToPost'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "media" | "post" | "pollPost" | "space" | "channel" | "thread" | "note" | "comment" | "commentReply" | "spaceMember" | "channelMember" | "file" | "fileToPost"
      txIsolationLevel: never
    }
    model: {
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MediaFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MediaAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PostFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PostAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      PollPost: {
        payload: Prisma.$PollPostPayload<ExtArgs>
        fields: Prisma.PollPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PollPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PollPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload>
          }
          findFirst: {
            args: Prisma.PollPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PollPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload>
          }
          findMany: {
            args: Prisma.PollPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload>[]
          }
          create: {
            args: Prisma.PollPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload>
          }
          createMany: {
            args: Prisma.PollPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PollPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload>
          }
          update: {
            args: Prisma.PollPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload>
          }
          deleteMany: {
            args: Prisma.PollPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PollPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PollPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PollPostPayload>
          }
          aggregate: {
            args: Prisma.PollPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePollPost>
          }
          groupBy: {
            args: Prisma.PollPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PollPostGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PollPostFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PollPostAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PollPostCountArgs<ExtArgs>
            result: $Utils.Optional<PollPostCountAggregateOutputType> | number
          }
        }
      }
      Space: {
        payload: Prisma.$SpacePayload<ExtArgs>
        fields: Prisma.SpaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          findFirst: {
            args: Prisma.SpaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          findMany: {
            args: Prisma.SpaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>[]
          }
          create: {
            args: Prisma.SpaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          createMany: {
            args: Prisma.SpaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SpaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          update: {
            args: Prisma.SpaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          deleteMany: {
            args: Prisma.SpaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpacePayload>
          }
          aggregate: {
            args: Prisma.SpaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpace>
          }
          groupBy: {
            args: Prisma.SpaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpaceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SpaceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SpaceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SpaceCountArgs<ExtArgs>
            result: $Utils.Optional<SpaceCountAggregateOutputType> | number
          }
        }
      }
      Channel: {
        payload: Prisma.$ChannelPayload<ExtArgs>
        fields: Prisma.ChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findFirst: {
            args: Prisma.ChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findMany: {
            args: Prisma.ChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          create: {
            args: Prisma.ChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          createMany: {
            args: Prisma.ChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          update: {
            args: Prisma.ChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          deleteMany: {
            args: Prisma.ChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          aggregate: {
            args: Prisma.ChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannel>
          }
          groupBy: {
            args: Prisma.ChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ChannelFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ChannelAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ChannelCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelCountAggregateOutputType> | number
          }
        }
      }
      Thread: {
        payload: Prisma.$ThreadPayload<ExtArgs>
        fields: Prisma.ThreadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThreadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThreadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          findFirst: {
            args: Prisma.ThreadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThreadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          findMany: {
            args: Prisma.ThreadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>[]
          }
          create: {
            args: Prisma.ThreadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          createMany: {
            args: Prisma.ThreadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ThreadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          update: {
            args: Prisma.ThreadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          deleteMany: {
            args: Prisma.ThreadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ThreadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ThreadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadPayload>
          }
          aggregate: {
            args: Prisma.ThreadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThread>
          }
          groupBy: {
            args: Prisma.ThreadGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThreadGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ThreadFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ThreadAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ThreadCountArgs<ExtArgs>
            result: $Utils.Optional<ThreadCountAggregateOutputType> | number
          }
        }
      }
      Note: {
        payload: Prisma.$NotePayload<ExtArgs>
        fields: Prisma.NoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findFirst: {
            args: Prisma.NoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findMany: {
            args: Prisma.NoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          create: {
            args: Prisma.NoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          createMany: {
            args: Prisma.NoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          update: {
            args: Prisma.NoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          deleteMany: {
            args: Prisma.NoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          aggregate: {
            args: Prisma.NoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNote>
          }
          groupBy: {
            args: Prisma.NoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NoteFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.NoteAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.NoteCountArgs<ExtArgs>
            result: $Utils.Optional<NoteCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CommentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CommentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      CommentReply: {
        payload: Prisma.$CommentReplyPayload<ExtArgs>
        fields: Prisma.CommentReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentReplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentReplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          findFirst: {
            args: Prisma.CommentReplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentReplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          findMany: {
            args: Prisma.CommentReplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>[]
          }
          create: {
            args: Prisma.CommentReplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          createMany: {
            args: Prisma.CommentReplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommentReplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          update: {
            args: Prisma.CommentReplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          deleteMany: {
            args: Prisma.CommentReplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentReplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentReplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReplyPayload>
          }
          aggregate: {
            args: Prisma.CommentReplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentReply>
          }
          groupBy: {
            args: Prisma.CommentReplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentReplyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CommentReplyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CommentReplyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CommentReplyCountArgs<ExtArgs>
            result: $Utils.Optional<CommentReplyCountAggregateOutputType> | number
          }
        }
      }
      SpaceMember: {
        payload: Prisma.$SpaceMemberPayload<ExtArgs>
        fields: Prisma.SpaceMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpaceMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpaceMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload>
          }
          findFirst: {
            args: Prisma.SpaceMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpaceMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload>
          }
          findMany: {
            args: Prisma.SpaceMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload>[]
          }
          create: {
            args: Prisma.SpaceMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload>
          }
          createMany: {
            args: Prisma.SpaceMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SpaceMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload>
          }
          update: {
            args: Prisma.SpaceMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload>
          }
          deleteMany: {
            args: Prisma.SpaceMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpaceMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpaceMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpaceMemberPayload>
          }
          aggregate: {
            args: Prisma.SpaceMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpaceMember>
          }
          groupBy: {
            args: Prisma.SpaceMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpaceMemberGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SpaceMemberFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SpaceMemberAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SpaceMemberCountArgs<ExtArgs>
            result: $Utils.Optional<SpaceMemberCountAggregateOutputType> | number
          }
        }
      }
      ChannelMember: {
        payload: Prisma.$ChannelMemberPayload<ExtArgs>
        fields: Prisma.ChannelMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload>
          }
          findFirst: {
            args: Prisma.ChannelMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload>
          }
          findMany: {
            args: Prisma.ChannelMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload>[]
          }
          create: {
            args: Prisma.ChannelMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload>
          }
          createMany: {
            args: Prisma.ChannelMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChannelMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload>
          }
          update: {
            args: Prisma.ChannelMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload>
          }
          deleteMany: {
            args: Prisma.ChannelMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelMemberPayload>
          }
          aggregate: {
            args: Prisma.ChannelMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannelMember>
          }
          groupBy: {
            args: Prisma.ChannelMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelMemberGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ChannelMemberFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ChannelMemberAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ChannelMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelMemberCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FileFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FileAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      FileToPost: {
        payload: Prisma.$FileToPostPayload<ExtArgs>
        fields: Prisma.FileToPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileToPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileToPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileToPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileToPostPayload>
          }
          findFirst: {
            args: Prisma.FileToPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileToPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileToPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileToPostPayload>
          }
          findMany: {
            args: Prisma.FileToPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileToPostPayload>[]
          }
          create: {
            args: Prisma.FileToPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileToPostPayload>
          }
          createMany: {
            args: Prisma.FileToPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FileToPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileToPostPayload>
          }
          update: {
            args: Prisma.FileToPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileToPostPayload>
          }
          deleteMany: {
            args: Prisma.FileToPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileToPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FileToPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileToPostPayload>
          }
          aggregate: {
            args: Prisma.FileToPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileToPost>
          }
          groupBy: {
            args: Prisma.FileToPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileToPostGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FileToPostFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FileToPostAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FileToPostCountArgs<ExtArgs>
            result: $Utils.Optional<FileToPostCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MediaCountOutputType
   */

  export type MediaCountOutputType = {
    CommentReply: number
    Post: number
    Comment: number
    PollPost: number
    Note: number
  }

  export type MediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CommentReply?: boolean | MediaCountOutputTypeCountCommentReplyArgs
    Post?: boolean | MediaCountOutputTypeCountPostArgs
    Comment?: boolean | MediaCountOutputTypeCountCommentArgs
    PollPost?: boolean | MediaCountOutputTypeCountPollPostArgs
    Note?: boolean | MediaCountOutputTypeCountNoteArgs
  }

  // Custom InputTypes
  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCountOutputType
     */
    select?: MediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountCommentReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReplyWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountPollPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollPostWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    files: number
    comments: number
    notes: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | PostCountOutputTypeCountFilesArgs
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
    notes?: boolean | PostCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileToPostWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }


  /**
   * Count Type PollPostCountOutputType
   */

  export type PollPostCountOutputType = {
    comments: number
  }

  export type PollPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PollPostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * PollPostCountOutputType without action
   */
  export type PollPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPostCountOutputType
     */
    select?: PollPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PollPostCountOutputType without action
   */
  export type PollPostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type SpaceCountOutputType
   */

  export type SpaceCountOutputType = {
    members: number
    channels: number
    posts: number
    files: number
    childSpaces: number
  }

  export type SpaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | SpaceCountOutputTypeCountMembersArgs
    channels?: boolean | SpaceCountOutputTypeCountChannelsArgs
    posts?: boolean | SpaceCountOutputTypeCountPostsArgs
    files?: boolean | SpaceCountOutputTypeCountFilesArgs
    childSpaces?: boolean | SpaceCountOutputTypeCountChildSpacesArgs
  }

  // Custom InputTypes
  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceCountOutputType
     */
    select?: SpaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceMemberWhereInput
  }

  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeCountChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
  }

  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * SpaceCountOutputType without action
   */
  export type SpaceCountOutputTypeCountChildSpacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceWhereInput
  }


  /**
   * Count Type ChannelCountOutputType
   */

  export type ChannelCountOutputType = {
    posts: number
    files: number
    members: number
  }

  export type ChannelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | ChannelCountOutputTypeCountPostsArgs
    files?: boolean | ChannelCountOutputTypeCountFilesArgs
    members?: boolean | ChannelCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCountOutputType
     */
    select?: ChannelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelMemberWhereInput
  }


  /**
   * Count Type ThreadCountOutputType
   */

  export type ThreadCountOutputType = {
    posts: number
    pollPosts: number
  }

  export type ThreadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | ThreadCountOutputTypeCountPostsArgs
    pollPosts?: boolean | ThreadCountOutputTypeCountPollPostsArgs
  }

  // Custom InputTypes
  /**
   * ThreadCountOutputType without action
   */
  export type ThreadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadCountOutputType
     */
    select?: ThreadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ThreadCountOutputType without action
   */
  export type ThreadCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * ThreadCountOutputType without action
   */
  export type ThreadCountOutputTypeCountPollPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollPostWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
    notes: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
    notes?: boolean | CommentCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReplyWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }


  /**
   * Count Type FileCountOutputType
   */

  export type FileCountOutputType = {
    posts: number
  }

  export type FileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | FileCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCountOutputType
     */
    select?: FileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileToPostWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Entities
   */





  export type EntitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    text?: boolean
    label?: boolean
    confidence?: boolean
    startPos?: boolean
    endPos?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["entities"]>


  export type EntitiesSelectScalar = {
    text?: boolean
    label?: boolean
    confidence?: boolean
    startPos?: boolean
    endPos?: boolean
    metadata?: boolean
  }


  export type $EntitiesPayload = {
    name: "Entities"
    objects: {}
    scalars: {
      text: string
      label: string
      confidence: number | null
      startPos: number | null
      endPos: number | null
      metadata: Prisma.JsonValue | null
    }
    composites: {}
  }

  type EntitiesGetPayload<S extends boolean | null | undefined | EntitiesDefaultArgs> = $Result.GetResult<Prisma.$EntitiesPayload, S>





  /**
   * Fields of the Entities model
   */ 
  interface EntitiesFieldRefs {
    readonly text: FieldRef<"Entities", 'String'>
    readonly label: FieldRef<"Entities", 'String'>
    readonly confidence: FieldRef<"Entities", 'Float'>
    readonly startPos: FieldRef<"Entities", 'Int'>
    readonly endPos: FieldRef<"Entities", 'Int'>
    readonly metadata: FieldRef<"Entities", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Entities without action
   */
  export type EntitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entities
     */
    select?: EntitiesSelect<ExtArgs> | null
  }


  /**
   * Model Sentiment
   */





  export type SentimentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    negative?: boolean
    neutral?: boolean
    positive?: boolean
    compound?: boolean
    confidence?: boolean
  }, ExtArgs["result"]["sentiment"]>


  export type SentimentSelectScalar = {
    negative?: boolean
    neutral?: boolean
    positive?: boolean
    compound?: boolean
    confidence?: boolean
  }


  export type $SentimentPayload = {
    name: "Sentiment"
    objects: {}
    scalars: {
      negative: number
      neutral: number
      positive: number
      compound: number
      confidence: number | null
    }
    composites: {}
  }

  type SentimentGetPayload<S extends boolean | null | undefined | SentimentDefaultArgs> = $Result.GetResult<Prisma.$SentimentPayload, S>





  /**
   * Fields of the Sentiment model
   */ 
  interface SentimentFieldRefs {
    readonly negative: FieldRef<"Sentiment", 'Float'>
    readonly neutral: FieldRef<"Sentiment", 'Float'>
    readonly positive: FieldRef<"Sentiment", 'Float'>
    readonly compound: FieldRef<"Sentiment", 'Float'>
    readonly confidence: FieldRef<"Sentiment", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Sentiment without action
   */
  export type SentimentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sentiment
     */
    select?: SentimentSelect<ExtArgs> | null
  }


  /**
   * Model ContentInsights
   */





  export type ContentInsightsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sentenceCount?: boolean
    wordCount?: boolean
    language?: boolean
    languageConfidence?: boolean
    entities?: boolean | EntitiesDefaultArgs<ExtArgs>
    sentiment?: boolean | SentimentDefaultArgs<ExtArgs>
    topics?: boolean
    keywords?: boolean
    summary?: boolean
    readability?: boolean
  }, ExtArgs["result"]["contentInsights"]>


  export type ContentInsightsSelectScalar = {
    sentenceCount?: boolean
    wordCount?: boolean
    language?: boolean
    languageConfidence?: boolean
    topics?: boolean
    keywords?: boolean
    summary?: boolean
    readability?: boolean
  }

  export type ContentInsightsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContentInsightsPayload = {
    name: "ContentInsights"
    objects: {}
    scalars: {
      sentenceCount: number
      wordCount: number
      language: string
      languageConfidence: number
      topics: string[]
      keywords: string[]
      summary: string | null
      readability: number | null
    }
    composites: {
      entities: Prisma.$EntitiesPayload[]
      sentiment: Prisma.$SentimentPayload
    }
  }

  type ContentInsightsGetPayload<S extends boolean | null | undefined | ContentInsightsDefaultArgs> = $Result.GetResult<Prisma.$ContentInsightsPayload, S>





  /**
   * Fields of the ContentInsights model
   */ 
  interface ContentInsightsFieldRefs {
    readonly sentenceCount: FieldRef<"ContentInsights", 'Int'>
    readonly wordCount: FieldRef<"ContentInsights", 'Int'>
    readonly language: FieldRef<"ContentInsights", 'String'>
    readonly languageConfidence: FieldRef<"ContentInsights", 'Float'>
    readonly topics: FieldRef<"ContentInsights", 'String[]'>
    readonly keywords: FieldRef<"ContentInsights", 'String[]'>
    readonly summary: FieldRef<"ContentInsights", 'String'>
    readonly readability: FieldRef<"ContentInsights", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ContentInsights without action
   */
  export type ContentInsightsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentInsights
     */
    select?: ContentInsightsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInsightsInclude<ExtArgs> | null
  }


  /**
   * Model SearchMetadata
   */





  export type SearchMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    title?: boolean
    description?: boolean
    keywords?: boolean
    contentType?: boolean
    language?: boolean
    fileSize?: boolean
    wordCount?: boolean
    pageCount?: boolean
    duration?: boolean
    transcription?: boolean
    extractedText?: boolean
    lastIndexed?: boolean
    searchScore?: boolean
    aiTags?: boolean
    classifications?: boolean
    visibility?: boolean
    readingLevel?: boolean
    locationData?: boolean
  }, ExtArgs["result"]["searchMetadata"]>


  export type SearchMetadataSelectScalar = {
    title?: boolean
    description?: boolean
    keywords?: boolean
    contentType?: boolean
    language?: boolean
    fileSize?: boolean
    wordCount?: boolean
    pageCount?: boolean
    duration?: boolean
    transcription?: boolean
    extractedText?: boolean
    lastIndexed?: boolean
    searchScore?: boolean
    aiTags?: boolean
    classifications?: boolean
    visibility?: boolean
    readingLevel?: boolean
    locationData?: boolean
  }


  export type $SearchMetadataPayload = {
    name: "SearchMetadata"
    objects: {}
    scalars: {
      title: string
      description: string | null
      keywords: string[]
      contentType: string
      language: string
      fileSize: number | null
      wordCount: number | null
      pageCount: number | null
      duration: number | null
      transcription: string | null
      extractedText: string | null
      lastIndexed: Date
      searchScore: number
      aiTags: string[]
      classifications: string[]
      visibility: $Enums.AccessLevel
      readingLevel: string | null
      locationData: Prisma.JsonValue | null
    }
    composites: {}
  }

  type SearchMetadataGetPayload<S extends boolean | null | undefined | SearchMetadataDefaultArgs> = $Result.GetResult<Prisma.$SearchMetadataPayload, S>





  /**
   * Fields of the SearchMetadata model
   */ 
  interface SearchMetadataFieldRefs {
    readonly title: FieldRef<"SearchMetadata", 'String'>
    readonly description: FieldRef<"SearchMetadata", 'String'>
    readonly keywords: FieldRef<"SearchMetadata", 'String[]'>
    readonly contentType: FieldRef<"SearchMetadata", 'String'>
    readonly language: FieldRef<"SearchMetadata", 'String'>
    readonly fileSize: FieldRef<"SearchMetadata", 'Int'>
    readonly wordCount: FieldRef<"SearchMetadata", 'Int'>
    readonly pageCount: FieldRef<"SearchMetadata", 'Int'>
    readonly duration: FieldRef<"SearchMetadata", 'Int'>
    readonly transcription: FieldRef<"SearchMetadata", 'String'>
    readonly extractedText: FieldRef<"SearchMetadata", 'String'>
    readonly lastIndexed: FieldRef<"SearchMetadata", 'DateTime'>
    readonly searchScore: FieldRef<"SearchMetadata", 'Float'>
    readonly aiTags: FieldRef<"SearchMetadata", 'String[]'>
    readonly classifications: FieldRef<"SearchMetadata", 'String[]'>
    readonly visibility: FieldRef<"SearchMetadata", 'AccessLevel'>
    readonly readingLevel: FieldRef<"SearchMetadata", 'String'>
    readonly locationData: FieldRef<"SearchMetadata", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * SearchMetadata without action
   */
  export type SearchMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchMetadata
     */
    select?: SearchMetadataSelect<ExtArgs> | null
  }


  /**
   * Model FileMetadata
   */





  export type FileMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    extension?: boolean
    hash?: boolean
    dimensions?: boolean | DimensionsDefaultArgs<ExtArgs>
    duration?: boolean
    encoding?: boolean
    compression?: boolean
    processingStatus?: boolean
    version?: boolean
    createdBy?: boolean
    modifiedBy?: boolean
    parentFolder?: boolean
    path?: boolean
    checksum?: boolean
  }, ExtArgs["result"]["fileMetadata"]>


  export type FileMetadataSelectScalar = {
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    extension?: boolean
    hash?: boolean
    duration?: boolean
    encoding?: boolean
    compression?: boolean
    processingStatus?: boolean
    version?: boolean
    createdBy?: boolean
    modifiedBy?: boolean
    parentFolder?: boolean
    path?: boolean
    checksum?: boolean
  }

  export type FileMetadataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FileMetadataPayload = {
    name: "FileMetadata"
    objects: {}
    scalars: {
      fileName: string
      fileSize: number
      mimeType: string
      extension: string
      hash: string
      duration: number | null
      encoding: string | null
      compression: string | null
      processingStatus: string
      version: number
      createdBy: string
      modifiedBy: string
      parentFolder: string | null
      path: string
      checksum: string
    }
    composites: {
      dimensions: Prisma.$DimensionsPayload | null
    }
  }

  type FileMetadataGetPayload<S extends boolean | null | undefined | FileMetadataDefaultArgs> = $Result.GetResult<Prisma.$FileMetadataPayload, S>





  /**
   * Fields of the FileMetadata model
   */ 
  interface FileMetadataFieldRefs {
    readonly fileName: FieldRef<"FileMetadata", 'String'>
    readonly fileSize: FieldRef<"FileMetadata", 'Int'>
    readonly mimeType: FieldRef<"FileMetadata", 'String'>
    readonly extension: FieldRef<"FileMetadata", 'String'>
    readonly hash: FieldRef<"FileMetadata", 'String'>
    readonly duration: FieldRef<"FileMetadata", 'Int'>
    readonly encoding: FieldRef<"FileMetadata", 'String'>
    readonly compression: FieldRef<"FileMetadata", 'String'>
    readonly processingStatus: FieldRef<"FileMetadata", 'String'>
    readonly version: FieldRef<"FileMetadata", 'Int'>
    readonly createdBy: FieldRef<"FileMetadata", 'String'>
    readonly modifiedBy: FieldRef<"FileMetadata", 'String'>
    readonly parentFolder: FieldRef<"FileMetadata", 'String'>
    readonly path: FieldRef<"FileMetadata", 'String'>
    readonly checksum: FieldRef<"FileMetadata", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FileMetadata without action
   */
  export type FileMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
  }


  /**
   * Model Dimensions
   */





  export type DimensionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    width?: boolean
    height?: boolean
    depth?: boolean
    aspectRatio?: boolean
    resolution?: boolean
  }, ExtArgs["result"]["dimensions"]>


  export type DimensionsSelectScalar = {
    width?: boolean
    height?: boolean
    depth?: boolean
    aspectRatio?: boolean
    resolution?: boolean
  }


  export type $DimensionsPayload = {
    name: "Dimensions"
    objects: {}
    scalars: {
      width: number
      height: number
      depth: number | null
      aspectRatio: number | null
      resolution: string | null
    }
    composites: {}
  }

  type DimensionsGetPayload<S extends boolean | null | undefined | DimensionsDefaultArgs> = $Result.GetResult<Prisma.$DimensionsPayload, S>





  /**
   * Fields of the Dimensions model
   */ 
  interface DimensionsFieldRefs {
    readonly width: FieldRef<"Dimensions", 'Int'>
    readonly height: FieldRef<"Dimensions", 'Int'>
    readonly depth: FieldRef<"Dimensions", 'Int'>
    readonly aspectRatio: FieldRef<"Dimensions", 'Float'>
    readonly resolution: FieldRef<"Dimensions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Dimensions without action
   */
  export type DimensionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dimensions
     */
    select?: DimensionsSelect<ExtArgs> | null
  }


  /**
   * Model AIAnalysis
   */





  export type AIAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    summary?: boolean
    keyPoints?: boolean
    sentiment?: boolean | SentimentAnalysisDefaultArgs<ExtArgs>
    entities?: boolean | NamedEntityDefaultArgs<ExtArgs>
    topics?: boolean | TopicAnalysisDefaultArgs<ExtArgs>
    keywords?: boolean | KeywordDefaultArgs<ExtArgs>
    readabilityScore?: boolean | ReadabilityMetricsDefaultArgs<ExtArgs>
    qualityMetrics?: boolean | ContentQualityDefaultArgs<ExtArgs>
    toxicity?: boolean | ToxicityAnalysisDefaultArgs<ExtArgs>
    originality?: boolean | OriginalityScoreDefaultArgs<ExtArgs>
    language?: boolean | LanguageAnalysisDefaultArgs<ExtArgs>
    translation?: boolean | TranslationInfoDefaultArgs<ExtArgs>
    grammarCheck?: boolean | GrammarAnalysisDefaultArgs<ExtArgs>
    styleAnalysis?: boolean | StyleMetricsDefaultArgs<ExtArgs>
    intentions?: boolean | IntentAnalysisDefaultArgs<ExtArgs>
    emotions?: boolean | EmotionAnalysisDefaultArgs<ExtArgs>
    bias?: boolean | BiasAnalysisDefaultArgs<ExtArgs>
    subjectivity?: boolean
    imageAnalysis?: boolean | ImageAnalysisDefaultArgs<ExtArgs>
    videoAnalysis?: boolean | VideoAnalysisDefaultArgs<ExtArgs>
    audioAnalysis?: boolean | AudioAnalysisDefaultArgs<ExtArgs>
    marketInsights?: boolean | MarketAnalysisDefaultArgs<ExtArgs>
    competitiveInfo?: boolean | CompetitiveAnalysisDefaultArgs<ExtArgs>
    actionItems?: boolean | ActionItemDefaultArgs<ExtArgs>
    processingTime?: boolean
    confidenceScore?: boolean
    modelVersions?: boolean | ModelMetadataDefaultArgs<ExtArgs>
    timestamp?: boolean
    processingCost?: boolean
  }, ExtArgs["result"]["aIAnalysis"]>


  export type AIAnalysisSelectScalar = {
    summary?: boolean
    keyPoints?: boolean
    subjectivity?: boolean
    processingTime?: boolean
    confidenceScore?: boolean
    timestamp?: boolean
    processingCost?: boolean
  }

  export type AIAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AIAnalysisPayload = {
    name: "AIAnalysis"
    objects: {}
    scalars: {
      summary: string | null
      keyPoints: string[]
      subjectivity: number
      processingTime: number
      confidenceScore: number
      timestamp: Date
      processingCost: number
    }
    composites: {
      sentiment: Prisma.$SentimentAnalysisPayload
      entities: Prisma.$NamedEntityPayload[]
      topics: Prisma.$TopicAnalysisPayload[]
      keywords: Prisma.$KeywordPayload[]
      readabilityScore: Prisma.$ReadabilityMetricsPayload
      qualityMetrics: Prisma.$ContentQualityPayload
      toxicity: Prisma.$ToxicityAnalysisPayload
      originality: Prisma.$OriginalityScorePayload
      language: Prisma.$LanguageAnalysisPayload
      translation: Prisma.$TranslationInfoPayload
      grammarCheck: Prisma.$GrammarAnalysisPayload
      styleAnalysis: Prisma.$StyleMetricsPayload
      intentions: Prisma.$IntentAnalysisPayload[]
      emotions: Prisma.$EmotionAnalysisPayload
      bias: Prisma.$BiasAnalysisPayload
      imageAnalysis: Prisma.$ImageAnalysisPayload[]
      videoAnalysis: Prisma.$VideoAnalysisPayload[]
      audioAnalysis: Prisma.$AudioAnalysisPayload[]
      marketInsights: Prisma.$MarketAnalysisPayload
      competitiveInfo: Prisma.$CompetitiveAnalysisPayload
      actionItems: Prisma.$ActionItemPayload[]
      modelVersions: Prisma.$ModelMetadataPayload
    }
  }

  type AIAnalysisGetPayload<S extends boolean | null | undefined | AIAnalysisDefaultArgs> = $Result.GetResult<Prisma.$AIAnalysisPayload, S>





  /**
   * Fields of the AIAnalysis model
   */ 
  interface AIAnalysisFieldRefs {
    readonly summary: FieldRef<"AIAnalysis", 'String'>
    readonly keyPoints: FieldRef<"AIAnalysis", 'String[]'>
    readonly subjectivity: FieldRef<"AIAnalysis", 'Float'>
    readonly processingTime: FieldRef<"AIAnalysis", 'Int'>
    readonly confidenceScore: FieldRef<"AIAnalysis", 'Float'>
    readonly timestamp: FieldRef<"AIAnalysis", 'DateTime'>
    readonly processingCost: FieldRef<"AIAnalysis", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * AIAnalysis without action
   */
  export type AIAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAnalysis
     */
    select?: AIAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model SentimentAnalysis
   */





  export type SentimentAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    overall?: boolean
    compound?: boolean
    positive?: boolean
    negative?: boolean
    neutral?: boolean
    segments?: boolean | SentimentSegmentDefaultArgs<ExtArgs>
    confidence?: boolean
  }, ExtArgs["result"]["sentimentAnalysis"]>


  export type SentimentAnalysisSelectScalar = {
    overall?: boolean
    compound?: boolean
    positive?: boolean
    negative?: boolean
    neutral?: boolean
    confidence?: boolean
  }

  export type SentimentAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SentimentAnalysisPayload = {
    name: "SentimentAnalysis"
    objects: {}
    scalars: {
      overall: number
      compound: number
      positive: number
      negative: number
      neutral: number
      confidence: number
    }
    composites: {
      segments: Prisma.$SentimentSegmentPayload[]
    }
  }

  type SentimentAnalysisGetPayload<S extends boolean | null | undefined | SentimentAnalysisDefaultArgs> = $Result.GetResult<Prisma.$SentimentAnalysisPayload, S>





  /**
   * Fields of the SentimentAnalysis model
   */ 
  interface SentimentAnalysisFieldRefs {
    readonly overall: FieldRef<"SentimentAnalysis", 'Float'>
    readonly compound: FieldRef<"SentimentAnalysis", 'Float'>
    readonly positive: FieldRef<"SentimentAnalysis", 'Float'>
    readonly negative: FieldRef<"SentimentAnalysis", 'Float'>
    readonly neutral: FieldRef<"SentimentAnalysis", 'Float'>
    readonly confidence: FieldRef<"SentimentAnalysis", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * SentimentAnalysis without action
   */
  export type SentimentAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentimentAnalysis
     */
    select?: SentimentAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentimentAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model SentimentSegment
   */





  export type SentimentSegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    text?: boolean
    sentiment?: boolean
    startIndex?: boolean
    endIndex?: boolean
    aspects?: boolean | AspectSentimentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sentimentSegment"]>


  export type SentimentSegmentSelectScalar = {
    text?: boolean
    sentiment?: boolean
    startIndex?: boolean
    endIndex?: boolean
  }

  export type SentimentSegmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SentimentSegmentPayload = {
    name: "SentimentSegment"
    objects: {}
    scalars: {
      text: string
      sentiment: number
      startIndex: number
      endIndex: number
    }
    composites: {
      aspects: Prisma.$AspectSentimentPayload[]
    }
  }

  type SentimentSegmentGetPayload<S extends boolean | null | undefined | SentimentSegmentDefaultArgs> = $Result.GetResult<Prisma.$SentimentSegmentPayload, S>





  /**
   * Fields of the SentimentSegment model
   */ 
  interface SentimentSegmentFieldRefs {
    readonly text: FieldRef<"SentimentSegment", 'String'>
    readonly sentiment: FieldRef<"SentimentSegment", 'Float'>
    readonly startIndex: FieldRef<"SentimentSegment", 'Int'>
    readonly endIndex: FieldRef<"SentimentSegment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SentimentSegment without action
   */
  export type SentimentSegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SentimentSegment
     */
    select?: SentimentSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SentimentSegmentInclude<ExtArgs> | null
  }


  /**
   * Model AspectSentiment
   */





  export type AspectSentimentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    aspect?: boolean
    sentiment?: boolean
    confidence?: boolean
  }, ExtArgs["result"]["aspectSentiment"]>


  export type AspectSentimentSelectScalar = {
    aspect?: boolean
    sentiment?: boolean
    confidence?: boolean
  }


  export type $AspectSentimentPayload = {
    name: "AspectSentiment"
    objects: {}
    scalars: {
      aspect: string
      sentiment: number
      confidence: number
    }
    composites: {}
  }

  type AspectSentimentGetPayload<S extends boolean | null | undefined | AspectSentimentDefaultArgs> = $Result.GetResult<Prisma.$AspectSentimentPayload, S>





  /**
   * Fields of the AspectSentiment model
   */ 
  interface AspectSentimentFieldRefs {
    readonly aspect: FieldRef<"AspectSentiment", 'String'>
    readonly sentiment: FieldRef<"AspectSentiment", 'Float'>
    readonly confidence: FieldRef<"AspectSentiment", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * AspectSentiment without action
   */
  export type AspectSentimentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspectSentiment
     */
    select?: AspectSentimentSelect<ExtArgs> | null
  }


  /**
   * Model NamedEntity
   */





  export type NamedEntitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    text?: boolean
    type?: boolean
    confidence?: boolean
    startIndex?: boolean
    endIndex?: boolean
    metadata?: boolean
    wikification?: boolean | WikiDataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["namedEntity"]>


  export type NamedEntitySelectScalar = {
    text?: boolean
    type?: boolean
    confidence?: boolean
    startIndex?: boolean
    endIndex?: boolean
    metadata?: boolean
  }

  export type NamedEntityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NamedEntityPayload = {
    name: "NamedEntity"
    objects: {}
    scalars: {
      text: string
      type: string
      confidence: number
      startIndex: number
      endIndex: number
      metadata: Prisma.JsonValue | null
    }
    composites: {
      wikification: Prisma.$WikiDataPayload
    }
  }

  type NamedEntityGetPayload<S extends boolean | null | undefined | NamedEntityDefaultArgs> = $Result.GetResult<Prisma.$NamedEntityPayload, S>





  /**
   * Fields of the NamedEntity model
   */ 
  interface NamedEntityFieldRefs {
    readonly text: FieldRef<"NamedEntity", 'String'>
    readonly type: FieldRef<"NamedEntity", 'String'>
    readonly confidence: FieldRef<"NamedEntity", 'Float'>
    readonly startIndex: FieldRef<"NamedEntity", 'Int'>
    readonly endIndex: FieldRef<"NamedEntity", 'Int'>
    readonly metadata: FieldRef<"NamedEntity", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * NamedEntity without action
   */
  export type NamedEntityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NamedEntity
     */
    select?: NamedEntitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NamedEntityInclude<ExtArgs> | null
  }


  /**
   * Model WikiData
   */





  export type WikiDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entityId?: boolean
    url?: boolean
    confidence?: boolean
    description?: boolean
  }, ExtArgs["result"]["wikiData"]>


  export type WikiDataSelectScalar = {
    entityId?: boolean
    url?: boolean
    confidence?: boolean
    description?: boolean
  }


  export type $WikiDataPayload = {
    name: "WikiData"
    objects: {}
    scalars: {
      entityId: string
      url: string
      confidence: number
      description: string | null
    }
    composites: {}
  }

  type WikiDataGetPayload<S extends boolean | null | undefined | WikiDataDefaultArgs> = $Result.GetResult<Prisma.$WikiDataPayload, S>





  /**
   * Fields of the WikiData model
   */ 
  interface WikiDataFieldRefs {
    readonly entityId: FieldRef<"WikiData", 'String'>
    readonly url: FieldRef<"WikiData", 'String'>
    readonly confidence: FieldRef<"WikiData", 'Float'>
    readonly description: FieldRef<"WikiData", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WikiData without action
   */
  export type WikiDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiData
     */
    select?: WikiDataSelect<ExtArgs> | null
  }


  /**
   * Model TopicAnalysis
   */





  export type TopicAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    topic?: boolean
    confidence?: boolean
    subtopics?: boolean
    relevance?: boolean
    hierarchy?: boolean
    context?: boolean | TopicContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topicAnalysis"]>


  export type TopicAnalysisSelectScalar = {
    topic?: boolean
    confidence?: boolean
    subtopics?: boolean
    relevance?: boolean
    hierarchy?: boolean
  }

  export type TopicAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TopicAnalysisPayload = {
    name: "TopicAnalysis"
    objects: {}
    scalars: {
      topic: string
      confidence: number
      subtopics: string[]
      relevance: number
      hierarchy: string[]
    }
    composites: {
      context: Prisma.$TopicContextPayload
    }
  }

  type TopicAnalysisGetPayload<S extends boolean | null | undefined | TopicAnalysisDefaultArgs> = $Result.GetResult<Prisma.$TopicAnalysisPayload, S>





  /**
   * Fields of the TopicAnalysis model
   */ 
  interface TopicAnalysisFieldRefs {
    readonly topic: FieldRef<"TopicAnalysis", 'String'>
    readonly confidence: FieldRef<"TopicAnalysis", 'Float'>
    readonly subtopics: FieldRef<"TopicAnalysis", 'String[]'>
    readonly relevance: FieldRef<"TopicAnalysis", 'Float'>
    readonly hierarchy: FieldRef<"TopicAnalysis", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * TopicAnalysis without action
   */
  export type TopicAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicAnalysis
     */
    select?: TopicAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model TopicContext
   */





  export type TopicContextSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    domain?: boolean
    category?: boolean
    parentTopics?: boolean
    relatedTopics?: boolean
  }, ExtArgs["result"]["topicContext"]>


  export type TopicContextSelectScalar = {
    domain?: boolean
    category?: boolean
    parentTopics?: boolean
    relatedTopics?: boolean
  }


  export type $TopicContextPayload = {
    name: "TopicContext"
    objects: {}
    scalars: {
      domain: string
      category: string
      parentTopics: string[]
      relatedTopics: string[]
    }
    composites: {}
  }

  type TopicContextGetPayload<S extends boolean | null | undefined | TopicContextDefaultArgs> = $Result.GetResult<Prisma.$TopicContextPayload, S>





  /**
   * Fields of the TopicContext model
   */ 
  interface TopicContextFieldRefs {
    readonly domain: FieldRef<"TopicContext", 'String'>
    readonly category: FieldRef<"TopicContext", 'String'>
    readonly parentTopics: FieldRef<"TopicContext", 'String[]'>
    readonly relatedTopics: FieldRef<"TopicContext", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * TopicContext without action
   */
  export type TopicContextDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicContext
     */
    select?: TopicContextSelect<ExtArgs> | null
  }


  /**
   * Model Keyword
   */





  export type KeywordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    text?: boolean
    score?: boolean
    frequency?: boolean
    type?: boolean
    related?: boolean
    importance?: boolean | KeywordMetricsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyword"]>


  export type KeywordSelectScalar = {
    text?: boolean
    score?: boolean
    frequency?: boolean
    type?: boolean
    related?: boolean
  }

  export type KeywordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $KeywordPayload = {
    name: "Keyword"
    objects: {}
    scalars: {
      text: string
      score: number
      frequency: number
      type: string
      related: string[]
    }
    composites: {
      importance: Prisma.$KeywordMetricsPayload
    }
  }

  type KeywordGetPayload<S extends boolean | null | undefined | KeywordDefaultArgs> = $Result.GetResult<Prisma.$KeywordPayload, S>





  /**
   * Fields of the Keyword model
   */ 
  interface KeywordFieldRefs {
    readonly text: FieldRef<"Keyword", 'String'>
    readonly score: FieldRef<"Keyword", 'Float'>
    readonly frequency: FieldRef<"Keyword", 'Int'>
    readonly type: FieldRef<"Keyword", 'String'>
    readonly related: FieldRef<"Keyword", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Keyword without action
   */
  export type KeywordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
  }


  /**
   * Model KeywordMetrics
   */





  export type KeywordMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tfIdf?: boolean
    textRank?: boolean
    prominence?: boolean
    location?: boolean | KeywordLocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keywordMetrics"]>


  export type KeywordMetricsSelectScalar = {
    tfIdf?: boolean
    textRank?: boolean
    prominence?: boolean
  }

  export type KeywordMetricsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $KeywordMetricsPayload = {
    name: "KeywordMetrics"
    objects: {}
    scalars: {
      tfIdf: number
      textRank: number
      prominence: number
    }
    composites: {
      location: Prisma.$KeywordLocationPayload[]
    }
  }

  type KeywordMetricsGetPayload<S extends boolean | null | undefined | KeywordMetricsDefaultArgs> = $Result.GetResult<Prisma.$KeywordMetricsPayload, S>





  /**
   * Fields of the KeywordMetrics model
   */ 
  interface KeywordMetricsFieldRefs {
    readonly tfIdf: FieldRef<"KeywordMetrics", 'Float'>
    readonly textRank: FieldRef<"KeywordMetrics", 'Float'>
    readonly prominence: FieldRef<"KeywordMetrics", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * KeywordMetrics without action
   */
  export type KeywordMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordMetrics
     */
    select?: KeywordMetricsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordMetricsInclude<ExtArgs> | null
  }


  /**
   * Model KeywordLocation
   */





  export type KeywordLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    startIndex?: boolean
    endIndex?: boolean
    context?: boolean
  }, ExtArgs["result"]["keywordLocation"]>


  export type KeywordLocationSelectScalar = {
    startIndex?: boolean
    endIndex?: boolean
    context?: boolean
  }


  export type $KeywordLocationPayload = {
    name: "KeywordLocation"
    objects: {}
    scalars: {
      startIndex: number
      endIndex: number
      context: string
    }
    composites: {}
  }

  type KeywordLocationGetPayload<S extends boolean | null | undefined | KeywordLocationDefaultArgs> = $Result.GetResult<Prisma.$KeywordLocationPayload, S>





  /**
   * Fields of the KeywordLocation model
   */ 
  interface KeywordLocationFieldRefs {
    readonly startIndex: FieldRef<"KeywordLocation", 'Int'>
    readonly endIndex: FieldRef<"KeywordLocation", 'Int'>
    readonly context: FieldRef<"KeywordLocation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KeywordLocation without action
   */
  export type KeywordLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordLocation
     */
    select?: KeywordLocationSelect<ExtArgs> | null
  }


  /**
   * Model ReadabilityMetrics
   */





  export type ReadabilityMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fleschKincaid?: boolean
    gunningFog?: boolean
    smog?: boolean
    ari?: boolean
    colemanLiau?: boolean
    readingTime?: boolean
    grade?: boolean
    complexity?: boolean | ComplexityMetricsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["readabilityMetrics"]>


  export type ReadabilityMetricsSelectScalar = {
    fleschKincaid?: boolean
    gunningFog?: boolean
    smog?: boolean
    ari?: boolean
    colemanLiau?: boolean
    readingTime?: boolean
    grade?: boolean
  }

  export type ReadabilityMetricsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ReadabilityMetricsPayload = {
    name: "ReadabilityMetrics"
    objects: {}
    scalars: {
      fleschKincaid: number
      gunningFog: number
      smog: number
      ari: number
      colemanLiau: number
      readingTime: number
      grade: string
    }
    composites: {
      complexity: Prisma.$ComplexityMetricsPayload
    }
  }

  type ReadabilityMetricsGetPayload<S extends boolean | null | undefined | ReadabilityMetricsDefaultArgs> = $Result.GetResult<Prisma.$ReadabilityMetricsPayload, S>





  /**
   * Fields of the ReadabilityMetrics model
   */ 
  interface ReadabilityMetricsFieldRefs {
    readonly fleschKincaid: FieldRef<"ReadabilityMetrics", 'Float'>
    readonly gunningFog: FieldRef<"ReadabilityMetrics", 'Float'>
    readonly smog: FieldRef<"ReadabilityMetrics", 'Float'>
    readonly ari: FieldRef<"ReadabilityMetrics", 'Float'>
    readonly colemanLiau: FieldRef<"ReadabilityMetrics", 'Float'>
    readonly readingTime: FieldRef<"ReadabilityMetrics", 'Int'>
    readonly grade: FieldRef<"ReadabilityMetrics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReadabilityMetrics without action
   */
  export type ReadabilityMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReadabilityMetrics
     */
    select?: ReadabilityMetricsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadabilityMetricsInclude<ExtArgs> | null
  }


  /**
   * Model ComplexityMetrics
   */





  export type ComplexityMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sentenceComplexity?: boolean
    wordComplexity?: boolean
    technicalLevel?: boolean
    vocabularyDiversity?: boolean
  }, ExtArgs["result"]["complexityMetrics"]>


  export type ComplexityMetricsSelectScalar = {
    sentenceComplexity?: boolean
    wordComplexity?: boolean
    technicalLevel?: boolean
    vocabularyDiversity?: boolean
  }


  export type $ComplexityMetricsPayload = {
    name: "ComplexityMetrics"
    objects: {}
    scalars: {
      sentenceComplexity: number
      wordComplexity: number
      technicalLevel: string
      vocabularyDiversity: number
    }
    composites: {}
  }

  type ComplexityMetricsGetPayload<S extends boolean | null | undefined | ComplexityMetricsDefaultArgs> = $Result.GetResult<Prisma.$ComplexityMetricsPayload, S>





  /**
   * Fields of the ComplexityMetrics model
   */ 
  interface ComplexityMetricsFieldRefs {
    readonly sentenceComplexity: FieldRef<"ComplexityMetrics", 'Float'>
    readonly wordComplexity: FieldRef<"ComplexityMetrics", 'Float'>
    readonly technicalLevel: FieldRef<"ComplexityMetrics", 'String'>
    readonly vocabularyDiversity: FieldRef<"ComplexityMetrics", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ComplexityMetrics without action
   */
  export type ComplexityMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplexityMetrics
     */
    select?: ComplexityMetricsSelect<ExtArgs> | null
  }


  /**
   * Model ContentQuality
   */





  export type ContentQualitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clarity?: boolean
    coherence?: boolean
    engagement?: boolean
    expertise?: boolean
    factualAccuracy?: boolean
    sources?: boolean | SourceValidationDefaultArgs<ExtArgs>
    structure?: boolean | StructureAnalysisDefaultArgs<ExtArgs>
    formatting?: boolean | FormattingAnalysisDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentQuality"]>


  export type ContentQualitySelectScalar = {
    clarity?: boolean
    coherence?: boolean
    engagement?: boolean
    expertise?: boolean
    factualAccuracy?: boolean
  }

  export type ContentQualityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContentQualityPayload = {
    name: "ContentQuality"
    objects: {}
    scalars: {
      clarity: number
      coherence: number
      engagement: number
      expertise: number
      factualAccuracy: number
    }
    composites: {
      sources: Prisma.$SourceValidationPayload[]
      structure: Prisma.$StructureAnalysisPayload
      formatting: Prisma.$FormattingAnalysisPayload
    }
  }

  type ContentQualityGetPayload<S extends boolean | null | undefined | ContentQualityDefaultArgs> = $Result.GetResult<Prisma.$ContentQualityPayload, S>





  /**
   * Fields of the ContentQuality model
   */ 
  interface ContentQualityFieldRefs {
    readonly clarity: FieldRef<"ContentQuality", 'Float'>
    readonly coherence: FieldRef<"ContentQuality", 'Float'>
    readonly engagement: FieldRef<"ContentQuality", 'Float'>
    readonly expertise: FieldRef<"ContentQuality", 'Float'>
    readonly factualAccuracy: FieldRef<"ContentQuality", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ContentQuality without action
   */
  export type ContentQualityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentQuality
     */
    select?: ContentQualitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentQualityInclude<ExtArgs> | null
  }


  /**
   * Model SourceValidation
   */





  export type SourceValidationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    url?: boolean
    credibility?: boolean
    type?: boolean
    citations?: boolean | CitationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceValidation"]>


  export type SourceValidationSelectScalar = {
    url?: boolean
    credibility?: boolean
    type?: boolean
  }

  export type SourceValidationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SourceValidationPayload = {
    name: "SourceValidation"
    objects: {}
    scalars: {
      url: string
      credibility: number
      type: string
    }
    composites: {
      citations: Prisma.$CitationPayload[]
    }
  }

  type SourceValidationGetPayload<S extends boolean | null | undefined | SourceValidationDefaultArgs> = $Result.GetResult<Prisma.$SourceValidationPayload, S>





  /**
   * Fields of the SourceValidation model
   */ 
  interface SourceValidationFieldRefs {
    readonly url: FieldRef<"SourceValidation", 'String'>
    readonly credibility: FieldRef<"SourceValidation", 'Float'>
    readonly type: FieldRef<"SourceValidation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SourceValidation without action
   */
  export type SourceValidationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceValidation
     */
    select?: SourceValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceValidationInclude<ExtArgs> | null
  }


  /**
   * Model Citation
   */





  export type CitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    text?: boolean
    source?: boolean
    page?: boolean
    confidence?: boolean
  }, ExtArgs["result"]["citation"]>


  export type CitationSelectScalar = {
    text?: boolean
    source?: boolean
    page?: boolean
    confidence?: boolean
  }


  export type $CitationPayload = {
    name: "Citation"
    objects: {}
    scalars: {
      text: string
      source: string
      page: number | null
      confidence: number
    }
    composites: {}
  }

  type CitationGetPayload<S extends boolean | null | undefined | CitationDefaultArgs> = $Result.GetResult<Prisma.$CitationPayload, S>





  /**
   * Fields of the Citation model
   */ 
  interface CitationFieldRefs {
    readonly text: FieldRef<"Citation", 'String'>
    readonly source: FieldRef<"Citation", 'String'>
    readonly page: FieldRef<"Citation", 'Int'>
    readonly confidence: FieldRef<"Citation", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Citation without action
   */
  export type CitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Citation
     */
    select?: CitationSelect<ExtArgs> | null
  }


  /**
   * Model StructureAnalysis
   */





  export type StructureAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    paragraphFlow?: boolean
    transitionQuality?: boolean
    logicalProgression?: boolean
    sectioning?: boolean
  }, ExtArgs["result"]["structureAnalysis"]>


  export type StructureAnalysisSelectScalar = {
    paragraphFlow?: boolean
    transitionQuality?: boolean
    logicalProgression?: boolean
    sectioning?: boolean
  }


  export type $StructureAnalysisPayload = {
    name: "StructureAnalysis"
    objects: {}
    scalars: {
      paragraphFlow: number
      transitionQuality: number
      logicalProgression: number
      sectioning: number
    }
    composites: {}
  }

  type StructureAnalysisGetPayload<S extends boolean | null | undefined | StructureAnalysisDefaultArgs> = $Result.GetResult<Prisma.$StructureAnalysisPayload, S>





  /**
   * Fields of the StructureAnalysis model
   */ 
  interface StructureAnalysisFieldRefs {
    readonly paragraphFlow: FieldRef<"StructureAnalysis", 'Float'>
    readonly transitionQuality: FieldRef<"StructureAnalysis", 'Float'>
    readonly logicalProgression: FieldRef<"StructureAnalysis", 'Float'>
    readonly sectioning: FieldRef<"StructureAnalysis", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * StructureAnalysis without action
   */
  export type StructureAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StructureAnalysis
     */
    select?: StructureAnalysisSelect<ExtArgs> | null
  }


  /**
   * Model FormattingAnalysis
   */





  export type FormattingAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    consistency?: boolean
    readability?: boolean
    visualHierarchy?: boolean
    spacing?: boolean
  }, ExtArgs["result"]["formattingAnalysis"]>


  export type FormattingAnalysisSelectScalar = {
    consistency?: boolean
    readability?: boolean
    visualHierarchy?: boolean
    spacing?: boolean
  }


  export type $FormattingAnalysisPayload = {
    name: "FormattingAnalysis"
    objects: {}
    scalars: {
      consistency: number
      readability: number
      visualHierarchy: number
      spacing: number
    }
    composites: {}
  }

  type FormattingAnalysisGetPayload<S extends boolean | null | undefined | FormattingAnalysisDefaultArgs> = $Result.GetResult<Prisma.$FormattingAnalysisPayload, S>





  /**
   * Fields of the FormattingAnalysis model
   */ 
  interface FormattingAnalysisFieldRefs {
    readonly consistency: FieldRef<"FormattingAnalysis", 'Float'>
    readonly readability: FieldRef<"FormattingAnalysis", 'Float'>
    readonly visualHierarchy: FieldRef<"FormattingAnalysis", 'Float'>
    readonly spacing: FieldRef<"FormattingAnalysis", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * FormattingAnalysis without action
   */
  export type FormattingAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormattingAnalysis
     */
    select?: FormattingAnalysisSelect<ExtArgs> | null
  }


  /**
   * Model ToxicityAnalysis
   */





  export type ToxicityAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    overall?: boolean
    categories?: boolean | ToxicityCategoriesDefaultArgs<ExtArgs>
    threats?: boolean | ThreatDetectionDefaultArgs<ExtArgs>
    moderation?: boolean | ModerationDecisionDefaultArgs<ExtArgs>
    severity?: boolean | ToxicitySeverityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["toxicityAnalysis"]>


  export type ToxicityAnalysisSelectScalar = {
    overall?: boolean
  }

  export type ToxicityAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ToxicityAnalysisPayload = {
    name: "ToxicityAnalysis"
    objects: {}
    scalars: {
      overall: number
    }
    composites: {
      categories: Prisma.$ToxicityCategoriesPayload
      threats: Prisma.$ThreatDetectionPayload[]
      moderation: Prisma.$ModerationDecisionPayload
      severity: Prisma.$ToxicitySeverityPayload
    }
  }

  type ToxicityAnalysisGetPayload<S extends boolean | null | undefined | ToxicityAnalysisDefaultArgs> = $Result.GetResult<Prisma.$ToxicityAnalysisPayload, S>





  /**
   * Fields of the ToxicityAnalysis model
   */ 
  interface ToxicityAnalysisFieldRefs {
    readonly overall: FieldRef<"ToxicityAnalysis", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ToxicityAnalysis without action
   */
  export type ToxicityAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToxicityAnalysis
     */
    select?: ToxicityAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ToxicityAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model ToxicityCategories
   */





  export type ToxicityCategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hate?: boolean
    harassment?: boolean
    profanity?: boolean
    violence?: boolean
    sexual?: boolean
    spam?: boolean
    misleading?: boolean
    bias?: boolean
  }, ExtArgs["result"]["toxicityCategories"]>


  export type ToxicityCategoriesSelectScalar = {
    hate?: boolean
    harassment?: boolean
    profanity?: boolean
    violence?: boolean
    sexual?: boolean
    spam?: boolean
    misleading?: boolean
    bias?: boolean
  }


  export type $ToxicityCategoriesPayload = {
    name: "ToxicityCategories"
    objects: {}
    scalars: {
      hate: number
      harassment: number
      profanity: number
      violence: number
      sexual: number
      spam: number
      misleading: number
      bias: number
    }
    composites: {}
  }

  type ToxicityCategoriesGetPayload<S extends boolean | null | undefined | ToxicityCategoriesDefaultArgs> = $Result.GetResult<Prisma.$ToxicityCategoriesPayload, S>





  /**
   * Fields of the ToxicityCategories model
   */ 
  interface ToxicityCategoriesFieldRefs {
    readonly hate: FieldRef<"ToxicityCategories", 'Float'>
    readonly harassment: FieldRef<"ToxicityCategories", 'Float'>
    readonly profanity: FieldRef<"ToxicityCategories", 'Float'>
    readonly violence: FieldRef<"ToxicityCategories", 'Float'>
    readonly sexual: FieldRef<"ToxicityCategories", 'Float'>
    readonly spam: FieldRef<"ToxicityCategories", 'Float'>
    readonly misleading: FieldRef<"ToxicityCategories", 'Float'>
    readonly bias: FieldRef<"ToxicityCategories", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ToxicityCategories without action
   */
  export type ToxicityCategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToxicityCategories
     */
    select?: ToxicityCategoriesSelect<ExtArgs> | null
  }


  /**
   * Model ThreatDetection
   */





  export type ThreatDetectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type?: boolean
    severity?: boolean
    confidence?: boolean
    context?: boolean
  }, ExtArgs["result"]["threatDetection"]>


  export type ThreatDetectionSelectScalar = {
    type?: boolean
    severity?: boolean
    confidence?: boolean
    context?: boolean
  }


  export type $ThreatDetectionPayload = {
    name: "ThreatDetection"
    objects: {}
    scalars: {
      type: string
      severity: number
      confidence: number
      context: string
    }
    composites: {}
  }

  type ThreatDetectionGetPayload<S extends boolean | null | undefined | ThreatDetectionDefaultArgs> = $Result.GetResult<Prisma.$ThreatDetectionPayload, S>





  /**
   * Fields of the ThreatDetection model
   */ 
  interface ThreatDetectionFieldRefs {
    readonly type: FieldRef<"ThreatDetection", 'String'>
    readonly severity: FieldRef<"ThreatDetection", 'Float'>
    readonly confidence: FieldRef<"ThreatDetection", 'Float'>
    readonly context: FieldRef<"ThreatDetection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ThreatDetection without action
   */
  export type ThreatDetectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreatDetection
     */
    select?: ThreatDetectionSelect<ExtArgs> | null
  }


  /**
   * Model ModerationDecision
   */





  export type ModerationDecisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    action?: boolean
    confidence?: boolean
    reason?: boolean
    escalation?: boolean
  }, ExtArgs["result"]["moderationDecision"]>


  export type ModerationDecisionSelectScalar = {
    action?: boolean
    confidence?: boolean
    reason?: boolean
    escalation?: boolean
  }


  export type $ModerationDecisionPayload = {
    name: "ModerationDecision"
    objects: {}
    scalars: {
      action: string
      confidence: number
      reason: string
      escalation: boolean
    }
    composites: {}
  }

  type ModerationDecisionGetPayload<S extends boolean | null | undefined | ModerationDecisionDefaultArgs> = $Result.GetResult<Prisma.$ModerationDecisionPayload, S>





  /**
   * Fields of the ModerationDecision model
   */ 
  interface ModerationDecisionFieldRefs {
    readonly action: FieldRef<"ModerationDecision", 'String'>
    readonly confidence: FieldRef<"ModerationDecision", 'Float'>
    readonly reason: FieldRef<"ModerationDecision", 'String'>
    readonly escalation: FieldRef<"ModerationDecision", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ModerationDecision without action
   */
  export type ModerationDecisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModerationDecision
     */
    select?: ModerationDecisionSelect<ExtArgs> | null
  }


  /**
   * Model ToxicitySeverity
   */





  export type ToxicitySeveritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    level?: boolean
    score?: boolean
    recommendation?: boolean
  }, ExtArgs["result"]["toxicitySeverity"]>


  export type ToxicitySeveritySelectScalar = {
    level?: boolean
    score?: boolean
    recommendation?: boolean
  }


  export type $ToxicitySeverityPayload = {
    name: "ToxicitySeverity"
    objects: {}
    scalars: {
      level: string
      score: number
      recommendation: string
    }
    composites: {}
  }

  type ToxicitySeverityGetPayload<S extends boolean | null | undefined | ToxicitySeverityDefaultArgs> = $Result.GetResult<Prisma.$ToxicitySeverityPayload, S>





  /**
   * Fields of the ToxicitySeverity model
   */ 
  interface ToxicitySeverityFieldRefs {
    readonly level: FieldRef<"ToxicitySeverity", 'String'>
    readonly score: FieldRef<"ToxicitySeverity", 'Float'>
    readonly recommendation: FieldRef<"ToxicitySeverity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ToxicitySeverity without action
   */
  export type ToxicitySeverityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ToxicitySeverity
     */
    select?: ToxicitySeveritySelect<ExtArgs> | null
  }


  /**
   * Model OriginalityScore
   */





  export type OriginalityScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    overall?: boolean
    uniqueness?: boolean
    similarities?: boolean | SimilarityMatchDefaultArgs<ExtArgs>
    plagiarism?: boolean | PlagiarismMetricsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["originalityScore"]>


  export type OriginalityScoreSelectScalar = {
    overall?: boolean
    uniqueness?: boolean
  }

  export type OriginalityScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OriginalityScorePayload = {
    name: "OriginalityScore"
    objects: {}
    scalars: {
      overall: number
      uniqueness: number
    }
    composites: {
      similarities: Prisma.$SimilarityMatchPayload[]
      plagiarism: Prisma.$PlagiarismMetricsPayload
    }
  }

  type OriginalityScoreGetPayload<S extends boolean | null | undefined | OriginalityScoreDefaultArgs> = $Result.GetResult<Prisma.$OriginalityScorePayload, S>





  /**
   * Fields of the OriginalityScore model
   */ 
  interface OriginalityScoreFieldRefs {
    readonly overall: FieldRef<"OriginalityScore", 'Float'>
    readonly uniqueness: FieldRef<"OriginalityScore", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * OriginalityScore without action
   */
  export type OriginalityScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OriginalityScore
     */
    select?: OriginalityScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OriginalityScoreInclude<ExtArgs> | null
  }


  /**
   * Model SimilarityMatch
   */





  export type SimilarityMatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    text?: boolean
    source?: boolean
    confidence?: boolean
    context?: boolean
  }, ExtArgs["result"]["similarityMatch"]>


  export type SimilarityMatchSelectScalar = {
    text?: boolean
    source?: boolean
    confidence?: boolean
    context?: boolean
  }


  export type $SimilarityMatchPayload = {
    name: "SimilarityMatch"
    objects: {}
    scalars: {
      text: string
      source: string
      confidence: number
      context: string
    }
    composites: {}
  }

  type SimilarityMatchGetPayload<S extends boolean | null | undefined | SimilarityMatchDefaultArgs> = $Result.GetResult<Prisma.$SimilarityMatchPayload, S>





  /**
   * Fields of the SimilarityMatch model
   */ 
  interface SimilarityMatchFieldRefs {
    readonly text: FieldRef<"SimilarityMatch", 'String'>
    readonly source: FieldRef<"SimilarityMatch", 'String'>
    readonly confidence: FieldRef<"SimilarityMatch", 'Float'>
    readonly context: FieldRef<"SimilarityMatch", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SimilarityMatch without action
   */
  export type SimilarityMatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimilarityMatch
     */
    select?: SimilarityMatchSelect<ExtArgs> | null
  }


  /**
   * Model PlagiarismMetrics
   */





  export type PlagiarismMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    score?: boolean
    matches?: boolean
    sources?: boolean
    severity?: boolean
  }, ExtArgs["result"]["plagiarismMetrics"]>


  export type PlagiarismMetricsSelectScalar = {
    score?: boolean
    matches?: boolean
    sources?: boolean
    severity?: boolean
  }


  export type $PlagiarismMetricsPayload = {
    name: "PlagiarismMetrics"
    objects: {}
    scalars: {
      score: number
      matches: number
      sources: string[]
      severity: string
    }
    composites: {}
  }

  type PlagiarismMetricsGetPayload<S extends boolean | null | undefined | PlagiarismMetricsDefaultArgs> = $Result.GetResult<Prisma.$PlagiarismMetricsPayload, S>





  /**
   * Fields of the PlagiarismMetrics model
   */ 
  interface PlagiarismMetricsFieldRefs {
    readonly score: FieldRef<"PlagiarismMetrics", 'Float'>
    readonly matches: FieldRef<"PlagiarismMetrics", 'Int'>
    readonly sources: FieldRef<"PlagiarismMetrics", 'String[]'>
    readonly severity: FieldRef<"PlagiarismMetrics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PlagiarismMetrics without action
   */
  export type PlagiarismMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlagiarismMetrics
     */
    select?: PlagiarismMetricsSelect<ExtArgs> | null
  }


  /**
   * Model LanguageAnalysis
   */





  export type LanguageAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    detected?: boolean
    confidence?: boolean
    alternatives?: boolean | LanguageAlternativeDefaultArgs<ExtArgs>
    dialects?: boolean
    scripts?: boolean
    languageFamily?: boolean
  }, ExtArgs["result"]["languageAnalysis"]>


  export type LanguageAnalysisSelectScalar = {
    detected?: boolean
    confidence?: boolean
    dialects?: boolean
    scripts?: boolean
    languageFamily?: boolean
  }

  export type LanguageAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LanguageAnalysisPayload = {
    name: "LanguageAnalysis"
    objects: {}
    scalars: {
      detected: string
      confidence: number
      dialects: string[]
      scripts: string[]
      languageFamily: string
    }
    composites: {
      alternatives: Prisma.$LanguageAlternativePayload[]
    }
  }

  type LanguageAnalysisGetPayload<S extends boolean | null | undefined | LanguageAnalysisDefaultArgs> = $Result.GetResult<Prisma.$LanguageAnalysisPayload, S>





  /**
   * Fields of the LanguageAnalysis model
   */ 
  interface LanguageAnalysisFieldRefs {
    readonly detected: FieldRef<"LanguageAnalysis", 'String'>
    readonly confidence: FieldRef<"LanguageAnalysis", 'Float'>
    readonly dialects: FieldRef<"LanguageAnalysis", 'String[]'>
    readonly scripts: FieldRef<"LanguageAnalysis", 'String[]'>
    readonly languageFamily: FieldRef<"LanguageAnalysis", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LanguageAnalysis without action
   */
  export type LanguageAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageAnalysis
     */
    select?: LanguageAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model LanguageAlternative
   */





  export type LanguageAlternativeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    language?: boolean
    confidence?: boolean
    probability?: boolean
  }, ExtArgs["result"]["languageAlternative"]>


  export type LanguageAlternativeSelectScalar = {
    language?: boolean
    confidence?: boolean
    probability?: boolean
  }


  export type $LanguageAlternativePayload = {
    name: "LanguageAlternative"
    objects: {}
    scalars: {
      language: string
      confidence: number
      probability: number
    }
    composites: {}
  }

  type LanguageAlternativeGetPayload<S extends boolean | null | undefined | LanguageAlternativeDefaultArgs> = $Result.GetResult<Prisma.$LanguageAlternativePayload, S>





  /**
   * Fields of the LanguageAlternative model
   */ 
  interface LanguageAlternativeFieldRefs {
    readonly language: FieldRef<"LanguageAlternative", 'String'>
    readonly confidence: FieldRef<"LanguageAlternative", 'Float'>
    readonly probability: FieldRef<"LanguageAlternative", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * LanguageAlternative without action
   */
  export type LanguageAlternativeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageAlternative
     */
    select?: LanguageAlternativeSelect<ExtArgs> | null
  }


  /**
   * Model TranslationInfo
   */





  export type TranslationInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sourceLanguage?: boolean
    targetLanguage?: boolean
    quality?: boolean
    confidence?: boolean
    provider?: boolean
  }, ExtArgs["result"]["translationInfo"]>


  export type TranslationInfoSelectScalar = {
    sourceLanguage?: boolean
    targetLanguage?: boolean
    quality?: boolean
    confidence?: boolean
    provider?: boolean
  }


  export type $TranslationInfoPayload = {
    name: "TranslationInfo"
    objects: {}
    scalars: {
      sourceLanguage: string
      targetLanguage: string
      quality: number
      confidence: number
      provider: string
    }
    composites: {}
  }

  type TranslationInfoGetPayload<S extends boolean | null | undefined | TranslationInfoDefaultArgs> = $Result.GetResult<Prisma.$TranslationInfoPayload, S>





  /**
   * Fields of the TranslationInfo model
   */ 
  interface TranslationInfoFieldRefs {
    readonly sourceLanguage: FieldRef<"TranslationInfo", 'String'>
    readonly targetLanguage: FieldRef<"TranslationInfo", 'String'>
    readonly quality: FieldRef<"TranslationInfo", 'Float'>
    readonly confidence: FieldRef<"TranslationInfo", 'Float'>
    readonly provider: FieldRef<"TranslationInfo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TranslationInfo without action
   */
  export type TranslationInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranslationInfo
     */
    select?: TranslationInfoSelect<ExtArgs> | null
  }


  /**
   * Model GrammarAnalysis
   */





  export type GrammarAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    errors?: boolean | GrammarErrorDefaultArgs<ExtArgs>
    style?: boolean | StyleSuggestionDefaultArgs<ExtArgs>
    overall?: boolean
    fluency?: boolean
  }, ExtArgs["result"]["grammarAnalysis"]>


  export type GrammarAnalysisSelectScalar = {
    overall?: boolean
    fluency?: boolean
  }

  export type GrammarAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GrammarAnalysisPayload = {
    name: "GrammarAnalysis"
    objects: {}
    scalars: {
      overall: number
      fluency: number
    }
    composites: {
      errors: Prisma.$GrammarErrorPayload[]
      style: Prisma.$StyleSuggestionPayload[]
    }
  }

  type GrammarAnalysisGetPayload<S extends boolean | null | undefined | GrammarAnalysisDefaultArgs> = $Result.GetResult<Prisma.$GrammarAnalysisPayload, S>





  /**
   * Fields of the GrammarAnalysis model
   */ 
  interface GrammarAnalysisFieldRefs {
    readonly overall: FieldRef<"GrammarAnalysis", 'Float'>
    readonly fluency: FieldRef<"GrammarAnalysis", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * GrammarAnalysis without action
   */
  export type GrammarAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrammarAnalysis
     */
    select?: GrammarAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrammarAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model GrammarError
   */





  export type GrammarErrorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type?: boolean
    suggestion?: boolean
    context?: boolean
    severity?: boolean
  }, ExtArgs["result"]["grammarError"]>


  export type GrammarErrorSelectScalar = {
    type?: boolean
    suggestion?: boolean
    context?: boolean
    severity?: boolean
  }


  export type $GrammarErrorPayload = {
    name: "GrammarError"
    objects: {}
    scalars: {
      type: string
      suggestion: string
      context: string
      severity: number
    }
    composites: {}
  }

  type GrammarErrorGetPayload<S extends boolean | null | undefined | GrammarErrorDefaultArgs> = $Result.GetResult<Prisma.$GrammarErrorPayload, S>





  /**
   * Fields of the GrammarError model
   */ 
  interface GrammarErrorFieldRefs {
    readonly type: FieldRef<"GrammarError", 'String'>
    readonly suggestion: FieldRef<"GrammarError", 'String'>
    readonly context: FieldRef<"GrammarError", 'String'>
    readonly severity: FieldRef<"GrammarError", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * GrammarError without action
   */
  export type GrammarErrorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrammarError
     */
    select?: GrammarErrorSelect<ExtArgs> | null
  }


  /**
   * Model StyleSuggestion
   */





  export type StyleSuggestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type?: boolean
    suggestion?: boolean
    reason?: boolean
    importance?: boolean
  }, ExtArgs["result"]["styleSuggestion"]>


  export type StyleSuggestionSelectScalar = {
    type?: boolean
    suggestion?: boolean
    reason?: boolean
    importance?: boolean
  }


  export type $StyleSuggestionPayload = {
    name: "StyleSuggestion"
    objects: {}
    scalars: {
      type: string
      suggestion: string
      reason: string
      importance: number
    }
    composites: {}
  }

  type StyleSuggestionGetPayload<S extends boolean | null | undefined | StyleSuggestionDefaultArgs> = $Result.GetResult<Prisma.$StyleSuggestionPayload, S>





  /**
   * Fields of the StyleSuggestion model
   */ 
  interface StyleSuggestionFieldRefs {
    readonly type: FieldRef<"StyleSuggestion", 'String'>
    readonly suggestion: FieldRef<"StyleSuggestion", 'String'>
    readonly reason: FieldRef<"StyleSuggestion", 'String'>
    readonly importance: FieldRef<"StyleSuggestion", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * StyleSuggestion without action
   */
  export type StyleSuggestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StyleSuggestion
     */
    select?: StyleSuggestionSelect<ExtArgs> | null
  }


  /**
   * Model StyleMetrics
   */





  export type StyleMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    formality?: boolean
    tone?: boolean
    vocabulary?: boolean | VocabularyMetricsDefaultArgs<ExtArgs>
    voice?: boolean
  }, ExtArgs["result"]["styleMetrics"]>


  export type StyleMetricsSelectScalar = {
    formality?: boolean
    tone?: boolean
    voice?: boolean
  }

  export type StyleMetricsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StyleMetricsPayload = {
    name: "StyleMetrics"
    objects: {}
    scalars: {
      formality: number
      tone: string
      voice: string
    }
    composites: {
      vocabulary: Prisma.$VocabularyMetricsPayload
    }
  }

  type StyleMetricsGetPayload<S extends boolean | null | undefined | StyleMetricsDefaultArgs> = $Result.GetResult<Prisma.$StyleMetricsPayload, S>





  /**
   * Fields of the StyleMetrics model
   */ 
  interface StyleMetricsFieldRefs {
    readonly formality: FieldRef<"StyleMetrics", 'Float'>
    readonly tone: FieldRef<"StyleMetrics", 'String'>
    readonly voice: FieldRef<"StyleMetrics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StyleMetrics without action
   */
  export type StyleMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StyleMetrics
     */
    select?: StyleMetricsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StyleMetricsInclude<ExtArgs> | null
  }


  /**
   * Model VocabularyMetrics
   */





  export type VocabularyMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    diversity?: boolean
    sophistication?: boolean
    jargon?: boolean
    accessibility?: boolean
  }, ExtArgs["result"]["vocabularyMetrics"]>


  export type VocabularyMetricsSelectScalar = {
    diversity?: boolean
    sophistication?: boolean
    jargon?: boolean
    accessibility?: boolean
  }


  export type $VocabularyMetricsPayload = {
    name: "VocabularyMetrics"
    objects: {}
    scalars: {
      diversity: number
      sophistication: number
      jargon: number
      accessibility: number
    }
    composites: {}
  }

  type VocabularyMetricsGetPayload<S extends boolean | null | undefined | VocabularyMetricsDefaultArgs> = $Result.GetResult<Prisma.$VocabularyMetricsPayload, S>





  /**
   * Fields of the VocabularyMetrics model
   */ 
  interface VocabularyMetricsFieldRefs {
    readonly diversity: FieldRef<"VocabularyMetrics", 'Float'>
    readonly sophistication: FieldRef<"VocabularyMetrics", 'Float'>
    readonly jargon: FieldRef<"VocabularyMetrics", 'Float'>
    readonly accessibility: FieldRef<"VocabularyMetrics", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * VocabularyMetrics without action
   */
  export type VocabularyMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyMetrics
     */
    select?: VocabularyMetricsSelect<ExtArgs> | null
  }


  /**
   * Model IntentAnalysis
   */





  export type IntentAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    primary?: boolean
    confidence?: boolean
    secondary?: boolean
    context?: boolean
  }, ExtArgs["result"]["intentAnalysis"]>


  export type IntentAnalysisSelectScalar = {
    primary?: boolean
    confidence?: boolean
    secondary?: boolean
    context?: boolean
  }


  export type $IntentAnalysisPayload = {
    name: "IntentAnalysis"
    objects: {}
    scalars: {
      primary: string
      confidence: number
      secondary: string[]
      context: string
    }
    composites: {}
  }

  type IntentAnalysisGetPayload<S extends boolean | null | undefined | IntentAnalysisDefaultArgs> = $Result.GetResult<Prisma.$IntentAnalysisPayload, S>





  /**
   * Fields of the IntentAnalysis model
   */ 
  interface IntentAnalysisFieldRefs {
    readonly primary: FieldRef<"IntentAnalysis", 'String'>
    readonly confidence: FieldRef<"IntentAnalysis", 'Float'>
    readonly secondary: FieldRef<"IntentAnalysis", 'String[]'>
    readonly context: FieldRef<"IntentAnalysis", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IntentAnalysis without action
   */
  export type IntentAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentAnalysis
     */
    select?: IntentAnalysisSelect<ExtArgs> | null
  }


  /**
   * Model EmotionAnalysis
   */





  export type EmotionAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    primary?: boolean
    secondary?: boolean
    intensity?: boolean
    confidence?: boolean
    spectrum?: boolean | EmotionSpectrumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emotionAnalysis"]>


  export type EmotionAnalysisSelectScalar = {
    primary?: boolean
    secondary?: boolean
    intensity?: boolean
    confidence?: boolean
  }

  export type EmotionAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmotionAnalysisPayload = {
    name: "EmotionAnalysis"
    objects: {}
    scalars: {
      primary: string
      secondary: string[]
      intensity: number
      confidence: number
    }
    composites: {
      spectrum: Prisma.$EmotionSpectrumPayload
    }
  }

  type EmotionAnalysisGetPayload<S extends boolean | null | undefined | EmotionAnalysisDefaultArgs> = $Result.GetResult<Prisma.$EmotionAnalysisPayload, S>





  /**
   * Fields of the EmotionAnalysis model
   */ 
  interface EmotionAnalysisFieldRefs {
    readonly primary: FieldRef<"EmotionAnalysis", 'String'>
    readonly secondary: FieldRef<"EmotionAnalysis", 'String[]'>
    readonly intensity: FieldRef<"EmotionAnalysis", 'Float'>
    readonly confidence: FieldRef<"EmotionAnalysis", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * EmotionAnalysis without action
   */
  export type EmotionAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmotionAnalysis
     */
    select?: EmotionAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmotionAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model EmotionSpectrum
   */





  export type EmotionSpectrumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    joy?: boolean
    sadness?: boolean
    anger?: boolean
    fear?: boolean
    surprise?: boolean
    disgust?: boolean
  }, ExtArgs["result"]["emotionSpectrum"]>


  export type EmotionSpectrumSelectScalar = {
    joy?: boolean
    sadness?: boolean
    anger?: boolean
    fear?: boolean
    surprise?: boolean
    disgust?: boolean
  }


  export type $EmotionSpectrumPayload = {
    name: "EmotionSpectrum"
    objects: {}
    scalars: {
      joy: number
      sadness: number
      anger: number
      fear: number
      surprise: number
      disgust: number
    }
    composites: {}
  }

  type EmotionSpectrumGetPayload<S extends boolean | null | undefined | EmotionSpectrumDefaultArgs> = $Result.GetResult<Prisma.$EmotionSpectrumPayload, S>





  /**
   * Fields of the EmotionSpectrum model
   */ 
  interface EmotionSpectrumFieldRefs {
    readonly joy: FieldRef<"EmotionSpectrum", 'Float'>
    readonly sadness: FieldRef<"EmotionSpectrum", 'Float'>
    readonly anger: FieldRef<"EmotionSpectrum", 'Float'>
    readonly fear: FieldRef<"EmotionSpectrum", 'Float'>
    readonly surprise: FieldRef<"EmotionSpectrum", 'Float'>
    readonly disgust: FieldRef<"EmotionSpectrum", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * EmotionSpectrum without action
   */
  export type EmotionSpectrumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmotionSpectrum
     */
    select?: EmotionSpectrumSelect<ExtArgs> | null
  }


  /**
   * Model BiasAnalysis
   */





  export type BiasAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    overall?: boolean
    types?: boolean | BiasTypeDefaultArgs<ExtArgs>
    context?: boolean
    severity?: boolean
  }, ExtArgs["result"]["biasAnalysis"]>


  export type BiasAnalysisSelectScalar = {
    overall?: boolean
    context?: boolean
    severity?: boolean
  }

  export type BiasAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BiasAnalysisPayload = {
    name: "BiasAnalysis"
    objects: {}
    scalars: {
      overall: number
      context: string
      severity: number
    }
    composites: {
      types: Prisma.$BiasTypePayload[]
    }
  }

  type BiasAnalysisGetPayload<S extends boolean | null | undefined | BiasAnalysisDefaultArgs> = $Result.GetResult<Prisma.$BiasAnalysisPayload, S>





  /**
   * Fields of the BiasAnalysis model
   */ 
  interface BiasAnalysisFieldRefs {
    readonly overall: FieldRef<"BiasAnalysis", 'Float'>
    readonly context: FieldRef<"BiasAnalysis", 'String'>
    readonly severity: FieldRef<"BiasAnalysis", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * BiasAnalysis without action
   */
  export type BiasAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiasAnalysis
     */
    select?: BiasAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiasAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model BiasType
   */





  export type BiasTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    category?: boolean
    score?: boolean
    evidence?: boolean
  }, ExtArgs["result"]["biasType"]>


  export type BiasTypeSelectScalar = {
    category?: boolean
    score?: boolean
    evidence?: boolean
  }


  export type $BiasTypePayload = {
    name: "BiasType"
    objects: {}
    scalars: {
      category: string
      score: number
      evidence: string[]
    }
    composites: {}
  }

  type BiasTypeGetPayload<S extends boolean | null | undefined | BiasTypeDefaultArgs> = $Result.GetResult<Prisma.$BiasTypePayload, S>





  /**
   * Fields of the BiasType model
   */ 
  interface BiasTypeFieldRefs {
    readonly category: FieldRef<"BiasType", 'String'>
    readonly score: FieldRef<"BiasType", 'Float'>
    readonly evidence: FieldRef<"BiasType", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * BiasType without action
   */
  export type BiasTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiasType
     */
    select?: BiasTypeSelect<ExtArgs> | null
  }


  /**
   * Model ImageAnalysis
   */





  export type ImageAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    objects?: boolean | DetectedObjectDefaultArgs<ExtArgs>
    faces?: boolean | FaceAnalysisDefaultArgs<ExtArgs>
    text?: boolean
    labels?: boolean | LabelDefaultArgs<ExtArgs>
    colors?: boolean | ColorAnalysisDefaultArgs<ExtArgs>
    nsfw?: boolean | NSFWAnalysisDefaultArgs<ExtArgs>
    quality?: boolean | ImageQualityDefaultArgs<ExtArgs>
    composition?: boolean | ImageCompositionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imageAnalysis"]>


  export type ImageAnalysisSelectScalar = {
    text?: boolean
  }

  export type ImageAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ImageAnalysisPayload = {
    name: "ImageAnalysis"
    objects: {}
    scalars: {
      text: string | null
    }
    composites: {
      objects: Prisma.$DetectedObjectPayload[]
      faces: Prisma.$FaceAnalysisPayload[]
      labels: Prisma.$LabelPayload[]
      colors: Prisma.$ColorAnalysisPayload
      nsfw: Prisma.$NSFWAnalysisPayload
      quality: Prisma.$ImageQualityPayload
      composition: Prisma.$ImageCompositionPayload
    }
  }

  type ImageAnalysisGetPayload<S extends boolean | null | undefined | ImageAnalysisDefaultArgs> = $Result.GetResult<Prisma.$ImageAnalysisPayload, S>





  /**
   * Fields of the ImageAnalysis model
   */ 
  interface ImageAnalysisFieldRefs {
    readonly text: FieldRef<"ImageAnalysis", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ImageAnalysis without action
   */
  export type ImageAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageAnalysis
     */
    select?: ImageAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model DetectedObject
   */





  export type DetectedObjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    label?: boolean
    confidence?: boolean
    boundingBox?: boolean | BoundingBoxDefaultArgs<ExtArgs>
    attributes?: boolean
  }, ExtArgs["result"]["detectedObject"]>


  export type DetectedObjectSelectScalar = {
    label?: boolean
    confidence?: boolean
    attributes?: boolean
  }

  export type DetectedObjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DetectedObjectPayload = {
    name: "DetectedObject"
    objects: {}
    scalars: {
      label: string
      confidence: number
      attributes: Prisma.JsonValue
    }
    composites: {
      boundingBox: Prisma.$BoundingBoxPayload
    }
  }

  type DetectedObjectGetPayload<S extends boolean | null | undefined | DetectedObjectDefaultArgs> = $Result.GetResult<Prisma.$DetectedObjectPayload, S>





  /**
   * Fields of the DetectedObject model
   */ 
  interface DetectedObjectFieldRefs {
    readonly label: FieldRef<"DetectedObject", 'String'>
    readonly confidence: FieldRef<"DetectedObject", 'Float'>
    readonly attributes: FieldRef<"DetectedObject", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * DetectedObject without action
   */
  export type DetectedObjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedObject
     */
    select?: DetectedObjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedObjectInclude<ExtArgs> | null
  }


  /**
   * Model FaceAnalysis
   */





  export type FaceAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    boundingBox?: boolean | BoundingBoxDefaultArgs<ExtArgs>
    emotions?: boolean | EmotionAnalysisDefaultArgs<ExtArgs>
    attributes?: boolean | FaceAttributesDefaultArgs<ExtArgs>
    landmarks?: boolean | FaceLandmarkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faceAnalysis"]>


  export type FaceAnalysisSelectScalar = {}

  export type FaceAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FaceAnalysisPayload = {
    name: "FaceAnalysis"
    objects: {}
    scalars: {}
    composites: {
      boundingBox: Prisma.$BoundingBoxPayload
      emotions: Prisma.$EmotionAnalysisPayload
      attributes: Prisma.$FaceAttributesPayload
      landmarks: Prisma.$FaceLandmarkPayload[]
    }
  }

  type FaceAnalysisGetPayload<S extends boolean | null | undefined | FaceAnalysisDefaultArgs> = $Result.GetResult<Prisma.$FaceAnalysisPayload, S>





  /**
   * Fields of the FaceAnalysis model
   */ 
  interface FaceAnalysisFieldRefs {

  }
    

  // Custom InputTypes
  /**
   * FaceAnalysis without action
   */
  export type FaceAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaceAnalysis
     */
    select?: FaceAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaceAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model BoundingBox
   */





  export type BoundingBoxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
  }, ExtArgs["result"]["boundingBox"]>


  export type BoundingBoxSelectScalar = {
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
  }


  export type $BoundingBoxPayload = {
    name: "BoundingBox"
    objects: {}
    scalars: {
      x: number
      y: number
      width: number
      height: number
    }
    composites: {}
  }

  type BoundingBoxGetPayload<S extends boolean | null | undefined | BoundingBoxDefaultArgs> = $Result.GetResult<Prisma.$BoundingBoxPayload, S>





  /**
   * Fields of the BoundingBox model
   */ 
  interface BoundingBoxFieldRefs {
    readonly x: FieldRef<"BoundingBox", 'Float'>
    readonly y: FieldRef<"BoundingBox", 'Float'>
    readonly width: FieldRef<"BoundingBox", 'Float'>
    readonly height: FieldRef<"BoundingBox", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * BoundingBox without action
   */
  export type BoundingBoxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoundingBox
     */
    select?: BoundingBoxSelect<ExtArgs> | null
  }


  /**
   * Model Label
   */





  export type LabelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    confidence?: boolean
    parents?: boolean
  }, ExtArgs["result"]["label"]>


  export type LabelSelectScalar = {
    name?: boolean
    confidence?: boolean
    parents?: boolean
  }


  export type $LabelPayload = {
    name: "Label"
    objects: {}
    scalars: {
      name: string
      confidence: number
      parents: string[]
    }
    composites: {}
  }

  type LabelGetPayload<S extends boolean | null | undefined | LabelDefaultArgs> = $Result.GetResult<Prisma.$LabelPayload, S>





  /**
   * Fields of the Label model
   */ 
  interface LabelFieldRefs {
    readonly name: FieldRef<"Label", 'String'>
    readonly confidence: FieldRef<"Label", 'Float'>
    readonly parents: FieldRef<"Label", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Label without action
   */
  export type LabelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
  }


  /**
   * Model ColorAnalysis
   */





  export type ColorAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dominant?: boolean | ColorDefaultArgs<ExtArgs>
    palette?: boolean | ColorDefaultArgs<ExtArgs>
    brightness?: boolean
    contrast?: boolean
  }, ExtArgs["result"]["colorAnalysis"]>


  export type ColorAnalysisSelectScalar = {
    brightness?: boolean
    contrast?: boolean
  }

  export type ColorAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ColorAnalysisPayload = {
    name: "ColorAnalysis"
    objects: {}
    scalars: {
      brightness: number
      contrast: number
    }
    composites: {
      dominant: Prisma.$ColorPayload[]
      palette: Prisma.$ColorPayload[]
    }
  }

  type ColorAnalysisGetPayload<S extends boolean | null | undefined | ColorAnalysisDefaultArgs> = $Result.GetResult<Prisma.$ColorAnalysisPayload, S>





  /**
   * Fields of the ColorAnalysis model
   */ 
  interface ColorAnalysisFieldRefs {
    readonly brightness: FieldRef<"ColorAnalysis", 'Float'>
    readonly contrast: FieldRef<"ColorAnalysis", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ColorAnalysis without action
   */
  export type ColorAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorAnalysis
     */
    select?: ColorAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model Color
   */





  export type ColorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hex?: boolean
    rgb?: boolean | RGBDefaultArgs<ExtArgs>
    percentage?: boolean
  }, ExtArgs["result"]["color"]>


  export type ColorSelectScalar = {
    hex?: boolean
    percentage?: boolean
  }

  export type ColorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ColorPayload = {
    name: "Color"
    objects: {}
    scalars: {
      hex: string
      percentage: number
    }
    composites: {
      rgb: Prisma.$RGBPayload
    }
  }

  type ColorGetPayload<S extends boolean | null | undefined | ColorDefaultArgs> = $Result.GetResult<Prisma.$ColorPayload, S>





  /**
   * Fields of the Color model
   */ 
  interface ColorFieldRefs {
    readonly hex: FieldRef<"Color", 'String'>
    readonly percentage: FieldRef<"Color", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Color without action
   */
  export type ColorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
  }


  /**
   * Model RGB
   */





  export type RGBSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    red?: boolean
    green?: boolean
    blue?: boolean
  }, ExtArgs["result"]["rGB"]>


  export type RGBSelectScalar = {
    red?: boolean
    green?: boolean
    blue?: boolean
  }


  export type $RGBPayload = {
    name: "RGB"
    objects: {}
    scalars: {
      red: number
      green: number
      blue: number
    }
    composites: {}
  }

  type RGBGetPayload<S extends boolean | null | undefined | RGBDefaultArgs> = $Result.GetResult<Prisma.$RGBPayload, S>





  /**
   * Fields of the RGB model
   */ 
  interface RGBFieldRefs {
    readonly red: FieldRef<"RGB", 'Int'>
    readonly green: FieldRef<"RGB", 'Int'>
    readonly blue: FieldRef<"RGB", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RGB without action
   */
  export type RGBDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RGB
     */
    select?: RGBSelect<ExtArgs> | null
  }


  /**
   * Model NSFWAnalysis
   */





  export type NSFWAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    score?: boolean
    categories?: boolean | NSFWCategoriesDefaultArgs<ExtArgs>
    confidence?: boolean
  }, ExtArgs["result"]["nSFWAnalysis"]>


  export type NSFWAnalysisSelectScalar = {
    score?: boolean
    confidence?: boolean
  }

  export type NSFWAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NSFWAnalysisPayload = {
    name: "NSFWAnalysis"
    objects: {}
    scalars: {
      score: number
      confidence: number
    }
    composites: {
      categories: Prisma.$NSFWCategoriesPayload
    }
  }

  type NSFWAnalysisGetPayload<S extends boolean | null | undefined | NSFWAnalysisDefaultArgs> = $Result.GetResult<Prisma.$NSFWAnalysisPayload, S>





  /**
   * Fields of the NSFWAnalysis model
   */ 
  interface NSFWAnalysisFieldRefs {
    readonly score: FieldRef<"NSFWAnalysis", 'Float'>
    readonly confidence: FieldRef<"NSFWAnalysis", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * NSFWAnalysis without action
   */
  export type NSFWAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NSFWAnalysis
     */
    select?: NSFWAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NSFWAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model NSFWCategories
   */





  export type NSFWCategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    explicit?: boolean
    suggestive?: boolean
    violence?: boolean
    disturbing?: boolean
  }, ExtArgs["result"]["nSFWCategories"]>


  export type NSFWCategoriesSelectScalar = {
    explicit?: boolean
    suggestive?: boolean
    violence?: boolean
    disturbing?: boolean
  }


  export type $NSFWCategoriesPayload = {
    name: "NSFWCategories"
    objects: {}
    scalars: {
      explicit: number
      suggestive: number
      violence: number
      disturbing: number
    }
    composites: {}
  }

  type NSFWCategoriesGetPayload<S extends boolean | null | undefined | NSFWCategoriesDefaultArgs> = $Result.GetResult<Prisma.$NSFWCategoriesPayload, S>





  /**
   * Fields of the NSFWCategories model
   */ 
  interface NSFWCategoriesFieldRefs {
    readonly explicit: FieldRef<"NSFWCategories", 'Float'>
    readonly suggestive: FieldRef<"NSFWCategories", 'Float'>
    readonly violence: FieldRef<"NSFWCategories", 'Float'>
    readonly disturbing: FieldRef<"NSFWCategories", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * NSFWCategories without action
   */
  export type NSFWCategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NSFWCategories
     */
    select?: NSFWCategoriesSelect<ExtArgs> | null
  }


  /**
   * Model ImageQuality
   */





  export type ImageQualitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    resolution?: boolean | ResolutionDefaultArgs<ExtArgs>
    sharpness?: boolean
    brightness?: boolean
    noise?: boolean
  }, ExtArgs["result"]["imageQuality"]>


  export type ImageQualitySelectScalar = {
    sharpness?: boolean
    brightness?: boolean
    noise?: boolean
  }

  export type ImageQualityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ImageQualityPayload = {
    name: "ImageQuality"
    objects: {}
    scalars: {
      sharpness: number
      brightness: number
      noise: number
    }
    composites: {
      resolution: Prisma.$ResolutionPayload
    }
  }

  type ImageQualityGetPayload<S extends boolean | null | undefined | ImageQualityDefaultArgs> = $Result.GetResult<Prisma.$ImageQualityPayload, S>





  /**
   * Fields of the ImageQuality model
   */ 
  interface ImageQualityFieldRefs {
    readonly sharpness: FieldRef<"ImageQuality", 'Float'>
    readonly brightness: FieldRef<"ImageQuality", 'Float'>
    readonly noise: FieldRef<"ImageQuality", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ImageQuality without action
   */
  export type ImageQualityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageQuality
     */
    select?: ImageQualitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageQualityInclude<ExtArgs> | null
  }


  /**
   * Model Resolution
   */





  export type ResolutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    width?: boolean
    height?: boolean
    aspectRatio?: boolean
  }, ExtArgs["result"]["resolution"]>


  export type ResolutionSelectScalar = {
    width?: boolean
    height?: boolean
    aspectRatio?: boolean
  }


  export type $ResolutionPayload = {
    name: "Resolution"
    objects: {}
    scalars: {
      width: number
      height: number
      aspectRatio: number
    }
    composites: {}
  }

  type ResolutionGetPayload<S extends boolean | null | undefined | ResolutionDefaultArgs> = $Result.GetResult<Prisma.$ResolutionPayload, S>





  /**
   * Fields of the Resolution model
   */ 
  interface ResolutionFieldRefs {
    readonly width: FieldRef<"Resolution", 'Int'>
    readonly height: FieldRef<"Resolution", 'Int'>
    readonly aspectRatio: FieldRef<"Resolution", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Resolution without action
   */
  export type ResolutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resolution
     */
    select?: ResolutionSelect<ExtArgs> | null
  }


  /**
   * Model ImageComposition
   */





  export type ImageCompositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    balance?: boolean
    symmetry?: boolean
    focus?: boolean
    aesthetic?: boolean
  }, ExtArgs["result"]["imageComposition"]>


  export type ImageCompositionSelectScalar = {
    balance?: boolean
    symmetry?: boolean
    focus?: boolean
    aesthetic?: boolean
  }


  export type $ImageCompositionPayload = {
    name: "ImageComposition"
    objects: {}
    scalars: {
      balance: number
      symmetry: number
      focus: number
      aesthetic: number
    }
    composites: {}
  }

  type ImageCompositionGetPayload<S extends boolean | null | undefined | ImageCompositionDefaultArgs> = $Result.GetResult<Prisma.$ImageCompositionPayload, S>





  /**
   * Fields of the ImageComposition model
   */ 
  interface ImageCompositionFieldRefs {
    readonly balance: FieldRef<"ImageComposition", 'Float'>
    readonly symmetry: FieldRef<"ImageComposition", 'Float'>
    readonly focus: FieldRef<"ImageComposition", 'Float'>
    readonly aesthetic: FieldRef<"ImageComposition", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ImageComposition without action
   */
  export type ImageCompositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageComposition
     */
    select?: ImageCompositionSelect<ExtArgs> | null
  }


  /**
   * Model VideoAnalysis
   */





  export type VideoAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    scenes?: boolean | SceneDefaultArgs<ExtArgs>
    transcript?: boolean
    keyFrames?: boolean | KeyFrameDefaultArgs<ExtArgs>
    actions?: boolean | ActionDefaultArgs<ExtArgs>
    captions?: boolean | CaptionDefaultArgs<ExtArgs>
    motion?: boolean | MotionAnalysisDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoAnalysis"]>


  export type VideoAnalysisSelectScalar = {
    transcript?: boolean
  }

  export type VideoAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VideoAnalysisPayload = {
    name: "VideoAnalysis"
    objects: {}
    scalars: {
      transcript: string | null
    }
    composites: {
      scenes: Prisma.$ScenePayload[]
      keyFrames: Prisma.$KeyFramePayload[]
      actions: Prisma.$ActionPayload[]
      captions: Prisma.$CaptionPayload[]
      motion: Prisma.$MotionAnalysisPayload
    }
  }

  type VideoAnalysisGetPayload<S extends boolean | null | undefined | VideoAnalysisDefaultArgs> = $Result.GetResult<Prisma.$VideoAnalysisPayload, S>





  /**
   * Fields of the VideoAnalysis model
   */ 
  interface VideoAnalysisFieldRefs {
    readonly transcript: FieldRef<"VideoAnalysis", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VideoAnalysis without action
   */
  export type VideoAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoAnalysis
     */
    select?: VideoAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model Scene
   */





  export type SceneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    startTime?: boolean
    endTime?: boolean
    keyFrames?: boolean | KeyFrameDefaultArgs<ExtArgs>
    description?: boolean
  }, ExtArgs["result"]["scene"]>


  export type SceneSelectScalar = {
    startTime?: boolean
    endTime?: boolean
    description?: boolean
  }

  export type SceneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ScenePayload = {
    name: "Scene"
    objects: {}
    scalars: {
      startTime: number
      endTime: number
      description: string
    }
    composites: {
      keyFrames: Prisma.$KeyFramePayload[]
    }
  }

  type SceneGetPayload<S extends boolean | null | undefined | SceneDefaultArgs> = $Result.GetResult<Prisma.$ScenePayload, S>





  /**
   * Fields of the Scene model
   */ 
  interface SceneFieldRefs {
    readonly startTime: FieldRef<"Scene", 'Float'>
    readonly endTime: FieldRef<"Scene", 'Float'>
    readonly description: FieldRef<"Scene", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Scene without action
   */
  export type SceneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scene
     */
    select?: SceneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SceneInclude<ExtArgs> | null
  }


  /**
   * Model KeyFrame
   */





  export type KeyFrameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    timestamp?: boolean
    image?: boolean | ImageAnalysisDefaultArgs<ExtArgs>
    importance?: boolean
  }, ExtArgs["result"]["keyFrame"]>


  export type KeyFrameSelectScalar = {
    timestamp?: boolean
    importance?: boolean
  }

  export type KeyFrameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $KeyFramePayload = {
    name: "KeyFrame"
    objects: {}
    scalars: {
      timestamp: number
      importance: number
    }
    composites: {
      image: Prisma.$ImageAnalysisPayload
    }
  }

  type KeyFrameGetPayload<S extends boolean | null | undefined | KeyFrameDefaultArgs> = $Result.GetResult<Prisma.$KeyFramePayload, S>





  /**
   * Fields of the KeyFrame model
   */ 
  interface KeyFrameFieldRefs {
    readonly timestamp: FieldRef<"KeyFrame", 'Float'>
    readonly importance: FieldRef<"KeyFrame", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * KeyFrame without action
   */
  export type KeyFrameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyFrame
     */
    select?: KeyFrameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyFrameInclude<ExtArgs> | null
  }


  /**
   * Model Action
   */





  export type ActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type?: boolean
    confidence?: boolean
    startTime?: boolean
    endTime?: boolean
  }, ExtArgs["result"]["action"]>


  export type ActionSelectScalar = {
    type?: boolean
    confidence?: boolean
    startTime?: boolean
    endTime?: boolean
  }


  export type $ActionPayload = {
    name: "Action"
    objects: {}
    scalars: {
      type: string
      confidence: number
      startTime: number
      endTime: number
    }
    composites: {}
  }

  type ActionGetPayload<S extends boolean | null | undefined | ActionDefaultArgs> = $Result.GetResult<Prisma.$ActionPayload, S>





  /**
   * Fields of the Action model
   */ 
  interface ActionFieldRefs {
    readonly type: FieldRef<"Action", 'String'>
    readonly confidence: FieldRef<"Action", 'Float'>
    readonly startTime: FieldRef<"Action", 'Float'>
    readonly endTime: FieldRef<"Action", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Action without action
   */
  export type ActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
  }


  /**
   * Model Caption
   */





  export type CaptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    text?: boolean
    timestamp?: boolean
    confidence?: boolean
  }, ExtArgs["result"]["caption"]>


  export type CaptionSelectScalar = {
    text?: boolean
    timestamp?: boolean
    confidence?: boolean
  }


  export type $CaptionPayload = {
    name: "Caption"
    objects: {}
    scalars: {
      text: string
      timestamp: number
      confidence: number
    }
    composites: {}
  }

  type CaptionGetPayload<S extends boolean | null | undefined | CaptionDefaultArgs> = $Result.GetResult<Prisma.$CaptionPayload, S>





  /**
   * Fields of the Caption model
   */ 
  interface CaptionFieldRefs {
    readonly text: FieldRef<"Caption", 'String'>
    readonly timestamp: FieldRef<"Caption", 'Float'>
    readonly confidence: FieldRef<"Caption", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Caption without action
   */
  export type CaptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caption
     */
    select?: CaptionSelect<ExtArgs> | null
  }


  /**
   * Model MotionAnalysis
   */





  export type MotionAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    activity?: boolean
    stability?: boolean
    tracking?: boolean | TrackingDataDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["motionAnalysis"]>


  export type MotionAnalysisSelectScalar = {
    activity?: boolean
    stability?: boolean
  }

  export type MotionAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MotionAnalysisPayload = {
    name: "MotionAnalysis"
    objects: {}
    scalars: {
      activity: number
      stability: number
    }
    composites: {
      tracking: Prisma.$TrackingDataPayload[]
    }
  }

  type MotionAnalysisGetPayload<S extends boolean | null | undefined | MotionAnalysisDefaultArgs> = $Result.GetResult<Prisma.$MotionAnalysisPayload, S>





  /**
   * Fields of the MotionAnalysis model
   */ 
  interface MotionAnalysisFieldRefs {
    readonly activity: FieldRef<"MotionAnalysis", 'Float'>
    readonly stability: FieldRef<"MotionAnalysis", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * MotionAnalysis without action
   */
  export type MotionAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MotionAnalysis
     */
    select?: MotionAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotionAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model TrackingData
   */





  export type TrackingDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    object?: boolean
    path?: boolean
    confidence?: boolean
  }, ExtArgs["result"]["trackingData"]>


  export type TrackingDataSelectScalar = {
    object?: boolean
    path?: boolean
    confidence?: boolean
  }


  export type $TrackingDataPayload = {
    name: "TrackingData"
    objects: {}
    scalars: {
      object: string
      path: Prisma.JsonValue
      confidence: number
    }
    composites: {}
  }

  type TrackingDataGetPayload<S extends boolean | null | undefined | TrackingDataDefaultArgs> = $Result.GetResult<Prisma.$TrackingDataPayload, S>





  /**
   * Fields of the TrackingData model
   */ 
  interface TrackingDataFieldRefs {
    readonly object: FieldRef<"TrackingData", 'String'>
    readonly path: FieldRef<"TrackingData", 'Json'>
    readonly confidence: FieldRef<"TrackingData", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * TrackingData without action
   */
  export type TrackingDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingData
     */
    select?: TrackingDataSelect<ExtArgs> | null
  }


  /**
   * Model AudioAnalysis
   */





  export type AudioAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    transcript?: boolean
    speakers?: boolean | SpeakerDefaultArgs<ExtArgs>
    sentiment?: boolean | SentimentAnalysisDefaultArgs<ExtArgs>
    noise?: boolean | NoiseAnalysisDefaultArgs<ExtArgs>
    music?: boolean | MusicAnalysisDefaultArgs<ExtArgs>
    clarity?: boolean
  }, ExtArgs["result"]["audioAnalysis"]>


  export type AudioAnalysisSelectScalar = {
    transcript?: boolean
    clarity?: boolean
  }

  export type AudioAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AudioAnalysisPayload = {
    name: "AudioAnalysis"
    objects: {}
    scalars: {
      transcript: string | null
      clarity: number
    }
    composites: {
      speakers: Prisma.$SpeakerPayload[]
      sentiment: Prisma.$SentimentAnalysisPayload
      noise: Prisma.$NoiseAnalysisPayload
      music: Prisma.$MusicAnalysisPayload
    }
  }

  type AudioAnalysisGetPayload<S extends boolean | null | undefined | AudioAnalysisDefaultArgs> = $Result.GetResult<Prisma.$AudioAnalysisPayload, S>





  /**
   * Fields of the AudioAnalysis model
   */ 
  interface AudioAnalysisFieldRefs {
    readonly transcript: FieldRef<"AudioAnalysis", 'String'>
    readonly clarity: FieldRef<"AudioAnalysis", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * AudioAnalysis without action
   */
  export type AudioAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioAnalysis
     */
    select?: AudioAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model Speaker
   */





  export type SpeakerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    segments?: boolean | TimeSegmentDefaultArgs<ExtArgs>
    confidence?: boolean
    characteristics?: boolean | SpeakerCharacteristicsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speaker"]>


  export type SpeakerSelectScalar = {
    id?: boolean
    confidence?: boolean
  }

  export type SpeakerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SpeakerPayload = {
    name: "Speaker"
    objects: {}
    scalars: {
      id: string
      confidence: number
    }
    composites: {
      segments: Prisma.$TimeSegmentPayload[]
      characteristics: Prisma.$SpeakerCharacteristicsPayload
    }
  }

  type SpeakerGetPayload<S extends boolean | null | undefined | SpeakerDefaultArgs> = $Result.GetResult<Prisma.$SpeakerPayload, S>





  /**
   * Fields of the Speaker model
   */ 
  interface SpeakerFieldRefs {
    readonly id: FieldRef<"Speaker", 'String'>
    readonly confidence: FieldRef<"Speaker", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Speaker without action
   */
  export type SpeakerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
  }


  /**
   * Model TimeSegment
   */





  export type TimeSegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    startTime?: boolean
    endTime?: boolean
    text?: boolean
  }, ExtArgs["result"]["timeSegment"]>


  export type TimeSegmentSelectScalar = {
    startTime?: boolean
    endTime?: boolean
    text?: boolean
  }


  export type $TimeSegmentPayload = {
    name: "TimeSegment"
    objects: {}
    scalars: {
      startTime: number
      endTime: number
      text: string
    }
    composites: {}
  }

  type TimeSegmentGetPayload<S extends boolean | null | undefined | TimeSegmentDefaultArgs> = $Result.GetResult<Prisma.$TimeSegmentPayload, S>





  /**
   * Fields of the TimeSegment model
   */ 
  interface TimeSegmentFieldRefs {
    readonly startTime: FieldRef<"TimeSegment", 'Float'>
    readonly endTime: FieldRef<"TimeSegment", 'Float'>
    readonly text: FieldRef<"TimeSegment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TimeSegment without action
   */
  export type TimeSegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSegment
     */
    select?: TimeSegmentSelect<ExtArgs> | null
  }


  /**
   * Model SpeakerCharacteristics
   */





  export type SpeakerCharacteristicsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    gender?: boolean
    age?: boolean
    accent?: boolean
    emotion?: boolean | EmotionAnalysisDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speakerCharacteristics"]>


  export type SpeakerCharacteristicsSelectScalar = {
    gender?: boolean
    age?: boolean
    accent?: boolean
  }

  export type SpeakerCharacteristicsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SpeakerCharacteristicsPayload = {
    name: "SpeakerCharacteristics"
    objects: {}
    scalars: {
      gender: string | null
      age: string | null
      accent: string | null
    }
    composites: {
      emotion: Prisma.$EmotionAnalysisPayload
    }
  }

  type SpeakerCharacteristicsGetPayload<S extends boolean | null | undefined | SpeakerCharacteristicsDefaultArgs> = $Result.GetResult<Prisma.$SpeakerCharacteristicsPayload, S>





  /**
   * Fields of the SpeakerCharacteristics model
   */ 
  interface SpeakerCharacteristicsFieldRefs {
    readonly gender: FieldRef<"SpeakerCharacteristics", 'String'>
    readonly age: FieldRef<"SpeakerCharacteristics", 'String'>
    readonly accent: FieldRef<"SpeakerCharacteristics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SpeakerCharacteristics without action
   */
  export type SpeakerCharacteristicsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCharacteristics
     */
    select?: SpeakerCharacteristicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerCharacteristicsInclude<ExtArgs> | null
  }


  /**
   * Model NoiseAnalysis
   */





  export type NoiseAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    level?: boolean
    type?: boolean
    impact?: boolean
  }, ExtArgs["result"]["noiseAnalysis"]>


  export type NoiseAnalysisSelectScalar = {
    level?: boolean
    type?: boolean
    impact?: boolean
  }


  export type $NoiseAnalysisPayload = {
    name: "NoiseAnalysis"
    objects: {}
    scalars: {
      level: number
      type: string[]
      impact: number
    }
    composites: {}
  }

  type NoiseAnalysisGetPayload<S extends boolean | null | undefined | NoiseAnalysisDefaultArgs> = $Result.GetResult<Prisma.$NoiseAnalysisPayload, S>





  /**
   * Fields of the NoiseAnalysis model
   */ 
  interface NoiseAnalysisFieldRefs {
    readonly level: FieldRef<"NoiseAnalysis", 'Float'>
    readonly type: FieldRef<"NoiseAnalysis", 'String[]'>
    readonly impact: FieldRef<"NoiseAnalysis", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * NoiseAnalysis without action
   */
  export type NoiseAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoiseAnalysis
     */
    select?: NoiseAnalysisSelect<ExtArgs> | null
  }


  /**
   * Model MusicAnalysis
   */





  export type MusicAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    present?: boolean
    genre?: boolean
    tempo?: boolean
    mood?: boolean
  }, ExtArgs["result"]["musicAnalysis"]>


  export type MusicAnalysisSelectScalar = {
    present?: boolean
    genre?: boolean
    tempo?: boolean
    mood?: boolean
  }


  export type $MusicAnalysisPayload = {
    name: "MusicAnalysis"
    objects: {}
    scalars: {
      present: boolean
      genre: string[]
      tempo: number
      mood: string[]
    }
    composites: {}
  }

  type MusicAnalysisGetPayload<S extends boolean | null | undefined | MusicAnalysisDefaultArgs> = $Result.GetResult<Prisma.$MusicAnalysisPayload, S>





  /**
   * Fields of the MusicAnalysis model
   */ 
  interface MusicAnalysisFieldRefs {
    readonly present: FieldRef<"MusicAnalysis", 'Boolean'>
    readonly genre: FieldRef<"MusicAnalysis", 'String[]'>
    readonly tempo: FieldRef<"MusicAnalysis", 'Float'>
    readonly mood: FieldRef<"MusicAnalysis", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * MusicAnalysis without action
   */
  export type MusicAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MusicAnalysis
     */
    select?: MusicAnalysisSelect<ExtArgs> | null
  }


  /**
   * Model MarketAnalysis
   */





  export type MarketAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    trends?: boolean | TrendDefaultArgs<ExtArgs>
    sentiment?: boolean
    competition?: boolean
    opportunities?: boolean
  }, ExtArgs["result"]["marketAnalysis"]>


  export type MarketAnalysisSelectScalar = {
    sentiment?: boolean
    competition?: boolean
    opportunities?: boolean
  }

  export type MarketAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MarketAnalysisPayload = {
    name: "MarketAnalysis"
    objects: {}
    scalars: {
      sentiment: number
      competition: string[]
      opportunities: string[]
    }
    composites: {
      trends: Prisma.$TrendPayload[]
    }
  }

  type MarketAnalysisGetPayload<S extends boolean | null | undefined | MarketAnalysisDefaultArgs> = $Result.GetResult<Prisma.$MarketAnalysisPayload, S>





  /**
   * Fields of the MarketAnalysis model
   */ 
  interface MarketAnalysisFieldRefs {
    readonly sentiment: FieldRef<"MarketAnalysis", 'Float'>
    readonly competition: FieldRef<"MarketAnalysis", 'String[]'>
    readonly opportunities: FieldRef<"MarketAnalysis", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * MarketAnalysis without action
   */
  export type MarketAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketAnalysis
     */
    select?: MarketAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model Trend
   */





  export type TrendSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    strength?: boolean
    direction?: boolean
    timeframe?: boolean
  }, ExtArgs["result"]["trend"]>


  export type TrendSelectScalar = {
    name?: boolean
    strength?: boolean
    direction?: boolean
    timeframe?: boolean
  }


  export type $TrendPayload = {
    name: "Trend"
    objects: {}
    scalars: {
      name: string
      strength: number
      direction: string
      timeframe: string
    }
    composites: {}
  }

  type TrendGetPayload<S extends boolean | null | undefined | TrendDefaultArgs> = $Result.GetResult<Prisma.$TrendPayload, S>





  /**
   * Fields of the Trend model
   */ 
  interface TrendFieldRefs {
    readonly name: FieldRef<"Trend", 'String'>
    readonly strength: FieldRef<"Trend", 'Float'>
    readonly direction: FieldRef<"Trend", 'String'>
    readonly timeframe: FieldRef<"Trend", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Trend without action
   */
  export type TrendDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trend
     */
    select?: TrendSelect<ExtArgs> | null
  }


  /**
   * Model CompetitiveAnalysis
   */





  export type CompetitiveAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    positioning?: boolean
    advantages?: boolean
    threats?: boolean
    recommendations?: boolean
  }, ExtArgs["result"]["competitiveAnalysis"]>


  export type CompetitiveAnalysisSelectScalar = {
    positioning?: boolean
    advantages?: boolean
    threats?: boolean
    recommendations?: boolean
  }


  export type $CompetitiveAnalysisPayload = {
    name: "CompetitiveAnalysis"
    objects: {}
    scalars: {
      positioning: number
      advantages: string[]
      threats: string[]
      recommendations: string[]
    }
    composites: {}
  }

  type CompetitiveAnalysisGetPayload<S extends boolean | null | undefined | CompetitiveAnalysisDefaultArgs> = $Result.GetResult<Prisma.$CompetitiveAnalysisPayload, S>





  /**
   * Fields of the CompetitiveAnalysis model
   */ 
  interface CompetitiveAnalysisFieldRefs {
    readonly positioning: FieldRef<"CompetitiveAnalysis", 'Float'>
    readonly advantages: FieldRef<"CompetitiveAnalysis", 'String[]'>
    readonly threats: FieldRef<"CompetitiveAnalysis", 'String[]'>
    readonly recommendations: FieldRef<"CompetitiveAnalysis", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * CompetitiveAnalysis without action
   */
  export type CompetitiveAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitiveAnalysis
     */
    select?: CompetitiveAnalysisSelect<ExtArgs> | null
  }


  /**
   * Model ActionItem
   */





  export type ActionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    description?: boolean
    priority?: boolean
    category?: boolean
    deadline?: boolean
  }, ExtArgs["result"]["actionItem"]>


  export type ActionItemSelectScalar = {
    description?: boolean
    priority?: boolean
    category?: boolean
    deadline?: boolean
  }


  export type $ActionItemPayload = {
    name: "ActionItem"
    objects: {}
    scalars: {
      description: string
      priority: number
      category: string
      deadline: Date | null
    }
    composites: {}
  }

  type ActionItemGetPayload<S extends boolean | null | undefined | ActionItemDefaultArgs> = $Result.GetResult<Prisma.$ActionItemPayload, S>





  /**
   * Fields of the ActionItem model
   */ 
  interface ActionItemFieldRefs {
    readonly description: FieldRef<"ActionItem", 'String'>
    readonly priority: FieldRef<"ActionItem", 'Float'>
    readonly category: FieldRef<"ActionItem", 'String'>
    readonly deadline: FieldRef<"ActionItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActionItem without action
   */
  export type ActionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
  }


  /**
   * Model ModelMetadata
   */





  export type ModelMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    modelId?: boolean
    version?: boolean
    provider?: boolean
    timestamp?: boolean
    parameters?: boolean
    performance?: boolean | ModelPerformanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelMetadata"]>


  export type ModelMetadataSelectScalar = {
    modelId?: boolean
    version?: boolean
    provider?: boolean
    timestamp?: boolean
    parameters?: boolean
  }

  export type ModelMetadataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ModelMetadataPayload = {
    name: "ModelMetadata"
    objects: {}
    scalars: {
      modelId: string
      version: string
      provider: string
      timestamp: Date
      parameters: Prisma.JsonValue
    }
    composites: {
      performance: Prisma.$ModelPerformancePayload
    }
  }

  type ModelMetadataGetPayload<S extends boolean | null | undefined | ModelMetadataDefaultArgs> = $Result.GetResult<Prisma.$ModelMetadataPayload, S>





  /**
   * Fields of the ModelMetadata model
   */ 
  interface ModelMetadataFieldRefs {
    readonly modelId: FieldRef<"ModelMetadata", 'String'>
    readonly version: FieldRef<"ModelMetadata", 'String'>
    readonly provider: FieldRef<"ModelMetadata", 'String'>
    readonly timestamp: FieldRef<"ModelMetadata", 'DateTime'>
    readonly parameters: FieldRef<"ModelMetadata", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ModelMetadata without action
   */
  export type ModelMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelMetadata
     */
    select?: ModelMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelMetadataInclude<ExtArgs> | null
  }


  /**
   * Model ModelPerformance
   */





  export type ModelPerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    latency?: boolean
    accuracy?: boolean
    confidence?: boolean
    resourceUsage?: boolean | ResourceMetricsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modelPerformance"]>


  export type ModelPerformanceSelectScalar = {
    latency?: boolean
    accuracy?: boolean
    confidence?: boolean
  }

  export type ModelPerformanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ModelPerformancePayload = {
    name: "ModelPerformance"
    objects: {}
    scalars: {
      latency: number
      accuracy: number
      confidence: number
    }
    composites: {
      resourceUsage: Prisma.$ResourceMetricsPayload
    }
  }

  type ModelPerformanceGetPayload<S extends boolean | null | undefined | ModelPerformanceDefaultArgs> = $Result.GetResult<Prisma.$ModelPerformancePayload, S>





  /**
   * Fields of the ModelPerformance model
   */ 
  interface ModelPerformanceFieldRefs {
    readonly latency: FieldRef<"ModelPerformance", 'Float'>
    readonly accuracy: FieldRef<"ModelPerformance", 'Float'>
    readonly confidence: FieldRef<"ModelPerformance", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ModelPerformance without action
   */
  export type ModelPerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPerformance
     */
    select?: ModelPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelPerformanceInclude<ExtArgs> | null
  }


  /**
   * Model ResourceMetrics
   */





  export type ResourceMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cpuTime?: boolean
    memoryUsage?: boolean
    cost?: boolean
  }, ExtArgs["result"]["resourceMetrics"]>


  export type ResourceMetricsSelectScalar = {
    cpuTime?: boolean
    memoryUsage?: boolean
    cost?: boolean
  }


  export type $ResourceMetricsPayload = {
    name: "ResourceMetrics"
    objects: {}
    scalars: {
      cpuTime: number
      memoryUsage: number
      cost: number
    }
    composites: {}
  }

  type ResourceMetricsGetPayload<S extends boolean | null | undefined | ResourceMetricsDefaultArgs> = $Result.GetResult<Prisma.$ResourceMetricsPayload, S>





  /**
   * Fields of the ResourceMetrics model
   */ 
  interface ResourceMetricsFieldRefs {
    readonly cpuTime: FieldRef<"ResourceMetrics", 'Float'>
    readonly memoryUsage: FieldRef<"ResourceMetrics", 'Float'>
    readonly cost: FieldRef<"ResourceMetrics", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ResourceMetrics without action
   */
  export type ResourceMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceMetrics
     */
    select?: ResourceMetricsSelect<ExtArgs> | null
  }


  /**
   * Model FaceAttributes
   */





  export type FaceAttributesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    age?: boolean
    gender?: boolean
    expression?: boolean
    glasses?: boolean
    features?: boolean
  }, ExtArgs["result"]["faceAttributes"]>


  export type FaceAttributesSelectScalar = {
    age?: boolean
    gender?: boolean
    expression?: boolean
    glasses?: boolean
    features?: boolean
  }


  export type $FaceAttributesPayload = {
    name: "FaceAttributes"
    objects: {}
    scalars: {
      age: number | null
      gender: string | null
      expression: string | null
      glasses: boolean
      features: Prisma.JsonValue
    }
    composites: {}
  }

  type FaceAttributesGetPayload<S extends boolean | null | undefined | FaceAttributesDefaultArgs> = $Result.GetResult<Prisma.$FaceAttributesPayload, S>





  /**
   * Fields of the FaceAttributes model
   */ 
  interface FaceAttributesFieldRefs {
    readonly age: FieldRef<"FaceAttributes", 'Int'>
    readonly gender: FieldRef<"FaceAttributes", 'String'>
    readonly expression: FieldRef<"FaceAttributes", 'String'>
    readonly glasses: FieldRef<"FaceAttributes", 'Boolean'>
    readonly features: FieldRef<"FaceAttributes", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * FaceAttributes without action
   */
  export type FaceAttributesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaceAttributes
     */
    select?: FaceAttributesSelect<ExtArgs> | null
  }


  /**
   * Model FaceLandmark
   */





  export type FaceLandmarkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type?: boolean
    position?: boolean | PointDefaultArgs<ExtArgs>
    confidence?: boolean
  }, ExtArgs["result"]["faceLandmark"]>


  export type FaceLandmarkSelectScalar = {
    type?: boolean
    confidence?: boolean
  }

  export type FaceLandmarkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FaceLandmarkPayload = {
    name: "FaceLandmark"
    objects: {}
    scalars: {
      type: string
      confidence: number
    }
    composites: {
      position: Prisma.$PointPayload
    }
  }

  type FaceLandmarkGetPayload<S extends boolean | null | undefined | FaceLandmarkDefaultArgs> = $Result.GetResult<Prisma.$FaceLandmarkPayload, S>





  /**
   * Fields of the FaceLandmark model
   */ 
  interface FaceLandmarkFieldRefs {
    readonly type: FieldRef<"FaceLandmark", 'String'>
    readonly confidence: FieldRef<"FaceLandmark", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * FaceLandmark without action
   */
  export type FaceLandmarkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FaceLandmark
     */
    select?: FaceLandmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FaceLandmarkInclude<ExtArgs> | null
  }


  /**
   * Model Point
   */





  export type PointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    x?: boolean
    y?: boolean
  }, ExtArgs["result"]["point"]>


  export type PointSelectScalar = {
    x?: boolean
    y?: boolean
  }


  export type $PointPayload = {
    name: "Point"
    objects: {}
    scalars: {
      x: number
      y: number
    }
    composites: {}
  }

  type PointGetPayload<S extends boolean | null | undefined | PointDefaultArgs> = $Result.GetResult<Prisma.$PointPayload, S>





  /**
   * Fields of the Point model
   */ 
  interface PointFieldRefs {
    readonly x: FieldRef<"Point", 'Float'>
    readonly y: FieldRef<"Point", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Point without action
   */
  export type PointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Point
     */
    select?: PointSelect<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    mediaType: string | null
    status: string | null
    fileContent: string | null
    fileName: string | null
    transcription: string | null
    extractedText: string | null
    createdAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    mediaType: string | null
    status: string | null
    fileContent: string | null
    fileName: string | null
    transcription: string | null
    extractedText: string | null
    createdAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    mediaType: number
    status: number
    fileContent: number
    fileName: number
    transcription: number
    extractedText: number
    createdAt: number
    _all: number
  }


  export type MediaMinAggregateInputType = {
    id?: true
    mediaType?: true
    status?: true
    fileContent?: true
    fileName?: true
    transcription?: true
    extractedText?: true
    createdAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    mediaType?: true
    status?: true
    fileContent?: true
    fileName?: true
    transcription?: true
    extractedText?: true
    createdAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    mediaType?: true
    status?: true
    fileContent?: true
    fileName?: true
    transcription?: true
    extractedText?: true
    createdAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    mediaType: string
    status: string
    fileContent: string | null
    fileName: string
    transcription: string | null
    extractedText: string | null
    createdAt: Date
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mediaType?: boolean
    status?: boolean
    fileContent?: boolean
    fileName?: boolean
    transcription?: boolean
    extractedText?: boolean
    createdAt?: boolean
    CommentReply?: boolean | Media$CommentReplyArgs<ExtArgs>
    Post?: boolean | Media$PostArgs<ExtArgs>
    Comment?: boolean | Media$CommentArgs<ExtArgs>
    PollPost?: boolean | Media$PollPostArgs<ExtArgs>
    Note?: boolean | Media$NoteArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>


  export type MediaSelectScalar = {
    id?: boolean
    mediaType?: boolean
    status?: boolean
    fileContent?: boolean
    fileName?: boolean
    transcription?: boolean
    extractedText?: boolean
    createdAt?: boolean
  }

  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CommentReply?: boolean | Media$CommentReplyArgs<ExtArgs>
    Post?: boolean | Media$PostArgs<ExtArgs>
    Comment?: boolean | Media$CommentArgs<ExtArgs>
    PollPost?: boolean | Media$PollPostArgs<ExtArgs>
    Note?: boolean | Media$NoteArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      CommentReply: Prisma.$CommentReplyPayload<ExtArgs>[]
      Post: Prisma.$PostPayload<ExtArgs>[]
      Comment: Prisma.$CommentPayload<ExtArgs>[]
      PollPost: Prisma.$PollPostPayload<ExtArgs>[]
      Note: Prisma.$NotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mediaType: string
      status: string
      fileContent: string | null
      fileName: string
      transcription: string | null
      extractedText: string | null
      createdAt: Date
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Media that matches the filter.
     * @param {MediaFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const media = await prisma.media.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: MediaFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Media.
     * @param {MediaAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const media = await prisma.media.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MediaAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CommentReply<T extends Media$CommentReplyArgs<ExtArgs> = {}>(args?: Subset<T, Media$CommentReplyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findMany"> | Null>
    Post<T extends Media$PostArgs<ExtArgs> = {}>(args?: Subset<T, Media$PostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    Comment<T extends Media$CommentArgs<ExtArgs> = {}>(args?: Subset<T, Media$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    PollPost<T extends Media$PollPostArgs<ExtArgs> = {}>(args?: Subset<T, Media$PollPostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "findMany"> | Null>
    Note<T extends Media$NoteArgs<ExtArgs> = {}>(args?: Subset<T, Media$NoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */ 
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly mediaType: FieldRef<"Media", 'String'>
    readonly status: FieldRef<"Media", 'String'>
    readonly fileContent: FieldRef<"Media", 'String'>
    readonly fileName: FieldRef<"Media", 'String'>
    readonly transcription: FieldRef<"Media", 'String'>
    readonly extractedText: FieldRef<"Media", 'String'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
  }

  /**
   * Media findRaw
   */
  export type MediaFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Media aggregateRaw
   */
  export type MediaAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Media.CommentReply
   */
  export type Media$CommentReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    where?: CommentReplyWhereInput
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    cursor?: CommentReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentReplyScalarFieldEnum | CommentReplyScalarFieldEnum[]
  }

  /**
   * Media.Post
   */
  export type Media$PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Media.Comment
   */
  export type Media$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Media.PollPost
   */
  export type Media$PollPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    where?: PollPostWhereInput
    orderBy?: PollPostOrderByWithRelationInput | PollPostOrderByWithRelationInput[]
    cursor?: PollPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PollPostScalarFieldEnum | PollPostScalarFieldEnum[]
  }

  /**
   * Media.Note
   */
  export type Media$NoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    profileId: number | null
    affinityScore: number | null
    qualityScore: number | null
    viewCount: number | null
    version: number | null
  }

  export type PostSumAggregateOutputType = {
    profileId: number | null
    affinityScore: number | null
    qualityScore: number | null
    viewCount: number | null
    version: number | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    authorId: string | null
    parentSpaceId: string | null
    title: string | null
    content: string | null
    description: string | null
    status: string | null
    workflowStatus: string | null
    assignedTo: string | null
    contentFormat: string | null
    createdAt: string | null
    updatedAt: Date | null
    publishedAt: Date | null
    postType: $Enums.PostType | null
    category: $Enums.Category | null
    threadParticipantType: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string | null
    profileId: number | null
    authorUsername: string | null
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType | null
    topicName: string | null
    mediaId: string | null
    backgroundImageUrl: string | null
    affinityScore: number | null
    qualityScore: number | null
    viewCount: number | null
    readingTime: string | null
    aiGeneratedQuestionResponse: string | null
    threadId: string | null
    spaceId: string | null
    channelId: string | null
    visibility: string | null
    isPinned: boolean | null
    isArchived: boolean | null
    version: number | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    authorId: string | null
    parentSpaceId: string | null
    title: string | null
    content: string | null
    description: string | null
    status: string | null
    workflowStatus: string | null
    assignedTo: string | null
    contentFormat: string | null
    createdAt: string | null
    updatedAt: Date | null
    publishedAt: Date | null
    postType: $Enums.PostType | null
    category: $Enums.Category | null
    threadParticipantType: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string | null
    profileId: number | null
    authorUsername: string | null
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType | null
    topicName: string | null
    mediaId: string | null
    backgroundImageUrl: string | null
    affinityScore: number | null
    qualityScore: number | null
    viewCount: number | null
    readingTime: string | null
    aiGeneratedQuestionResponse: string | null
    threadId: string | null
    spaceId: string | null
    channelId: string | null
    visibility: string | null
    isPinned: boolean | null
    isArchived: boolean | null
    version: number | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    authorId: number
    parentSpaceId: number
    title: number
    content: number
    description: number
    status: number
    workflowStatus: number
    assignedTo: number
    contentFormat: number
    createdAt: number
    updatedAt: number
    publishedAt: number
    postType: number
    category: number
    threadParticipantType: number
    backendPlatformUserId: number
    profileId: number
    authorUsername: number
    authorProfileImage: number
    authorAccountType: number
    tags: number
    mentions: number
    hashtags: number
    topicName: number
    mediaId: number
    backgroundImageUrl: number
    affinityScore: number
    qualityScore: number
    viewCount: number
    userIdToAffinityScoreMap: number
    userIdToReportsMap: number
    userIdToReactionMap: number
    readingTime: number
    aiGeneratedQuestionResponse: number
    threadId: number
    spaceId: number
    channelId: number
    extra: number
    visibility: number
    isPinned: number
    isArchived: number
    workflow: number
    version: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    profileId?: true
    affinityScore?: true
    qualityScore?: true
    viewCount?: true
    version?: true
  }

  export type PostSumAggregateInputType = {
    profileId?: true
    affinityScore?: true
    qualityScore?: true
    viewCount?: true
    version?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    authorId?: true
    parentSpaceId?: true
    title?: true
    content?: true
    description?: true
    status?: true
    workflowStatus?: true
    assignedTo?: true
    contentFormat?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    postType?: true
    category?: true
    threadParticipantType?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    topicName?: true
    mediaId?: true
    backgroundImageUrl?: true
    affinityScore?: true
    qualityScore?: true
    viewCount?: true
    readingTime?: true
    aiGeneratedQuestionResponse?: true
    threadId?: true
    spaceId?: true
    channelId?: true
    visibility?: true
    isPinned?: true
    isArchived?: true
    version?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    authorId?: true
    parentSpaceId?: true
    title?: true
    content?: true
    description?: true
    status?: true
    workflowStatus?: true
    assignedTo?: true
    contentFormat?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    postType?: true
    category?: true
    threadParticipantType?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    topicName?: true
    mediaId?: true
    backgroundImageUrl?: true
    affinityScore?: true
    qualityScore?: true
    viewCount?: true
    readingTime?: true
    aiGeneratedQuestionResponse?: true
    threadId?: true
    spaceId?: true
    channelId?: true
    visibility?: true
    isPinned?: true
    isArchived?: true
    version?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    authorId?: true
    parentSpaceId?: true
    title?: true
    content?: true
    description?: true
    status?: true
    workflowStatus?: true
    assignedTo?: true
    contentFormat?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    postType?: true
    category?: true
    threadParticipantType?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    tags?: true
    mentions?: true
    hashtags?: true
    topicName?: true
    mediaId?: true
    backgroundImageUrl?: true
    affinityScore?: true
    qualityScore?: true
    viewCount?: true
    userIdToAffinityScoreMap?: true
    userIdToReportsMap?: true
    userIdToReactionMap?: true
    readingTime?: true
    aiGeneratedQuestionResponse?: true
    threadId?: true
    spaceId?: true
    channelId?: true
    extra?: true
    visibility?: true
    isPinned?: true
    isArchived?: true
    workflow?: true
    version?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    authorId: string
    parentSpaceId: string | null
    title: string | null
    content: string
    description: string | null
    status: string
    workflowStatus: string | null
    assignedTo: string | null
    contentFormat: string
    createdAt: string
    updatedAt: Date
    publishedAt: Date | null
    postType: $Enums.PostType
    category: $Enums.Category | null
    threadParticipantType: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType
    tags: string[]
    mentions: string[]
    hashtags: string[]
    topicName: string | null
    mediaId: string | null
    backgroundImageUrl: string | null
    affinityScore: number
    qualityScore: number
    viewCount: number
    userIdToAffinityScoreMap: JsonValue | null
    userIdToReportsMap: JsonValue | null
    userIdToReactionMap: JsonValue | null
    readingTime: string | null
    aiGeneratedQuestionResponse: string | null
    threadId: string | null
    spaceId: string | null
    channelId: string | null
    extra: JsonValue | null
    visibility: string
    isPinned: boolean
    isArchived: boolean
    workflow: JsonValue | null
    version: number
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    parentSpaceId?: boolean
    title?: boolean
    content?: boolean
    description?: boolean
    status?: boolean
    workflowStatus?: boolean
    assignedTo?: boolean
    contentFormat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    postType?: boolean
    category?: boolean
    threadParticipantType?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUsername?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    tags?: boolean
    mentions?: boolean
    hashtags?: boolean
    topicName?: boolean
    mediaId?: boolean
    backgroundImageUrl?: boolean
    affinityScore?: boolean
    qualityScore?: boolean
    viewCount?: boolean
    userIdToAffinityScoreMap?: boolean
    userIdToReportsMap?: boolean
    userIdToReactionMap?: boolean
    insights?: boolean | ContentInsightsDefaultArgs<ExtArgs>
    readingTime?: boolean
    aiGeneratedQuestionResponse?: boolean
    aiAnalysis?: boolean | AIAnalysisDefaultArgs<ExtArgs>
    searchMetadata?: boolean | SearchMetadataDefaultArgs<ExtArgs>
    threadId?: boolean
    spaceId?: boolean
    channelId?: boolean
    extra?: boolean
    visibility?: boolean
    isPinned?: boolean
    isArchived?: boolean
    workflow?: boolean
    version?: boolean
    media?: boolean | Post$mediaArgs<ExtArgs>
    files?: boolean | Post$filesArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    notes?: boolean | Post$notesArgs<ExtArgs>
    thread?: boolean | Post$threadArgs<ExtArgs>
    space?: boolean | Post$spaceArgs<ExtArgs>
    channel?: boolean | Post$channelArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>


  export type PostSelectScalar = {
    id?: boolean
    authorId?: boolean
    parentSpaceId?: boolean
    title?: boolean
    content?: boolean
    description?: boolean
    status?: boolean
    workflowStatus?: boolean
    assignedTo?: boolean
    contentFormat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    postType?: boolean
    category?: boolean
    threadParticipantType?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUsername?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    tags?: boolean
    mentions?: boolean
    hashtags?: boolean
    topicName?: boolean
    mediaId?: boolean
    backgroundImageUrl?: boolean
    affinityScore?: boolean
    qualityScore?: boolean
    viewCount?: boolean
    userIdToAffinityScoreMap?: boolean
    userIdToReportsMap?: boolean
    userIdToReactionMap?: boolean
    readingTime?: boolean
    aiGeneratedQuestionResponse?: boolean
    threadId?: boolean
    spaceId?: boolean
    channelId?: boolean
    extra?: boolean
    visibility?: boolean
    isPinned?: boolean
    isArchived?: boolean
    workflow?: boolean
    version?: boolean
  }

  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | Post$mediaArgs<ExtArgs>
    files?: boolean | Post$filesArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    notes?: boolean | Post$notesArgs<ExtArgs>
    thread?: boolean | Post$threadArgs<ExtArgs>
    space?: boolean | Post$spaceArgs<ExtArgs>
    channel?: boolean | Post$channelArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs> | null
      files: Prisma.$FileToPostPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
      thread: Prisma.$ThreadPayload<ExtArgs> | null
      space: Prisma.$SpacePayload<ExtArgs> | null
      channel: Prisma.$ChannelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authorId: string
      parentSpaceId: string | null
      title: string | null
      content: string
      description: string | null
      status: string
      workflowStatus: string | null
      assignedTo: string | null
      contentFormat: string
      createdAt: string
      updatedAt: Date
      publishedAt: Date | null
      postType: $Enums.PostType
      category: $Enums.Category | null
      threadParticipantType: $Enums.ThreadParticipantType | null
      backendPlatformUserId: string
      profileId: number
      authorUsername: string
      authorProfileImage: string | null
      authorAccountType: $Enums.AccountType
      tags: string[]
      mentions: string[]
      hashtags: string[]
      topicName: string | null
      mediaId: string | null
      backgroundImageUrl: string | null
      affinityScore: number
      qualityScore: number
      viewCount: number
      userIdToAffinityScoreMap: Prisma.JsonValue | null
      userIdToReportsMap: Prisma.JsonValue | null
      userIdToReactionMap: Prisma.JsonValue | null
      readingTime: string | null
      aiGeneratedQuestionResponse: string | null
      threadId: string | null
      spaceId: string | null
      channelId: string | null
      extra: Prisma.JsonValue | null
      visibility: string
      isPinned: boolean
      isArchived: boolean
      workflow: Prisma.JsonValue | null
      version: number
    }, ExtArgs["result"]["post"]>
    composites: {
      insights: Prisma.$ContentInsightsPayload | null
      aiAnalysis: Prisma.$AIAnalysisPayload | null
      searchMetadata: Prisma.$SearchMetadataPayload | null
    }
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * @param {PostFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const post = await prisma.post.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: PostFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Post.
     * @param {PostAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const post = await prisma.post.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PostAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends Post$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Post$mediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    files<T extends Post$filesArgs<ExtArgs> = {}>(args?: Subset<T, Post$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileToPostPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    notes<T extends Post$notesArgs<ExtArgs> = {}>(args?: Subset<T, Post$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany"> | Null>
    thread<T extends Post$threadArgs<ExtArgs> = {}>(args?: Subset<T, Post$threadArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    space<T extends Post$spaceArgs<ExtArgs> = {}>(args?: Subset<T, Post$spaceArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    channel<T extends Post$channelArgs<ExtArgs> = {}>(args?: Subset<T, Post$channelArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */ 
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly authorId: FieldRef<"Post", 'String'>
    readonly parentSpaceId: FieldRef<"Post", 'String'>
    readonly title: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly description: FieldRef<"Post", 'String'>
    readonly status: FieldRef<"Post", 'String'>
    readonly workflowStatus: FieldRef<"Post", 'String'>
    readonly assignedTo: FieldRef<"Post", 'String'>
    readonly contentFormat: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'String'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
    readonly publishedAt: FieldRef<"Post", 'DateTime'>
    readonly postType: FieldRef<"Post", 'PostType'>
    readonly category: FieldRef<"Post", 'Category'>
    readonly threadParticipantType: FieldRef<"Post", 'ThreadParticipantType'>
    readonly backendPlatformUserId: FieldRef<"Post", 'String'>
    readonly profileId: FieldRef<"Post", 'Int'>
    readonly authorUsername: FieldRef<"Post", 'String'>
    readonly authorProfileImage: FieldRef<"Post", 'String'>
    readonly authorAccountType: FieldRef<"Post", 'AccountType'>
    readonly tags: FieldRef<"Post", 'String[]'>
    readonly mentions: FieldRef<"Post", 'String[]'>
    readonly hashtags: FieldRef<"Post", 'String[]'>
    readonly topicName: FieldRef<"Post", 'String'>
    readonly mediaId: FieldRef<"Post", 'String'>
    readonly backgroundImageUrl: FieldRef<"Post", 'String'>
    readonly affinityScore: FieldRef<"Post", 'Int'>
    readonly qualityScore: FieldRef<"Post", 'Int'>
    readonly viewCount: FieldRef<"Post", 'Int'>
    readonly userIdToAffinityScoreMap: FieldRef<"Post", 'Json'>
    readonly userIdToReportsMap: FieldRef<"Post", 'Json'>
    readonly userIdToReactionMap: FieldRef<"Post", 'Json'>
    readonly readingTime: FieldRef<"Post", 'String'>
    readonly aiGeneratedQuestionResponse: FieldRef<"Post", 'String'>
    readonly threadId: FieldRef<"Post", 'String'>
    readonly spaceId: FieldRef<"Post", 'String'>
    readonly channelId: FieldRef<"Post", 'String'>
    readonly extra: FieldRef<"Post", 'Json'>
    readonly visibility: FieldRef<"Post", 'String'>
    readonly isPinned: FieldRef<"Post", 'Boolean'>
    readonly isArchived: FieldRef<"Post", 'Boolean'>
    readonly workflow: FieldRef<"Post", 'Json'>
    readonly version: FieldRef<"Post", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }

  /**
   * Post findRaw
   */
  export type PostFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Post aggregateRaw
   */
  export type PostAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Post.media
   */
  export type Post$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Post.files
   */
  export type Post$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileToPost
     */
    select?: FileToPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileToPostInclude<ExtArgs> | null
    where?: FileToPostWhereInput
    orderBy?: FileToPostOrderByWithRelationInput | FileToPostOrderByWithRelationInput[]
    cursor?: FileToPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileToPostScalarFieldEnum | FileToPostScalarFieldEnum[]
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post.notes
   */
  export type Post$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Post.thread
   */
  export type Post$threadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    where?: ThreadWhereInput
  }

  /**
   * Post.space
   */
  export type Post$spaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    where?: SpaceWhereInput
  }

  /**
   * Post.channel
   */
  export type Post$channelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model PollPost
   */

  export type AggregatePollPost = {
    _count: PollPostCountAggregateOutputType | null
    _avg: PollPostAvgAggregateOutputType | null
    _sum: PollPostSumAggregateOutputType | null
    _min: PollPostMinAggregateOutputType | null
    _max: PollPostMaxAggregateOutputType | null
  }

  export type PollPostAvgAggregateOutputType = {
    profileId: number | null
  }

  export type PollPostSumAggregateOutputType = {
    profileId: number | null
  }

  export type PollPostMinAggregateOutputType = {
    id: string | null
    createdAt: string | null
    action: $Enums.PostType | null
    content: string | null
    title: string | null
    pollEndDate: Date | null
    topicName: string | null
    backendPlatformUserId: string | null
    profileId: number | null
    mediaId: string | null
    threadId: string | null
  }

  export type PollPostMaxAggregateOutputType = {
    id: string | null
    createdAt: string | null
    action: $Enums.PostType | null
    content: string | null
    title: string | null
    pollEndDate: Date | null
    topicName: string | null
    backendPlatformUserId: string | null
    profileId: number | null
    mediaId: string | null
    threadId: string | null
  }

  export type PollPostCountAggregateOutputType = {
    id: number
    createdAt: number
    action: number
    content: number
    title: number
    pollOptions: number
    pollDistribution: number
    userIdToPollResponsesMap: number
    pollEndDate: number
    mentions: number
    hashtags: number
    tags: number
    topicName: number
    backendPlatformUserId: number
    profileId: number
    mediaId: number
    threadId: number
    extra: number
    _all: number
  }


  export type PollPostAvgAggregateInputType = {
    profileId?: true
  }

  export type PollPostSumAggregateInputType = {
    profileId?: true
  }

  export type PollPostMinAggregateInputType = {
    id?: true
    createdAt?: true
    action?: true
    content?: true
    title?: true
    pollEndDate?: true
    topicName?: true
    backendPlatformUserId?: true
    profileId?: true
    mediaId?: true
    threadId?: true
  }

  export type PollPostMaxAggregateInputType = {
    id?: true
    createdAt?: true
    action?: true
    content?: true
    title?: true
    pollEndDate?: true
    topicName?: true
    backendPlatformUserId?: true
    profileId?: true
    mediaId?: true
    threadId?: true
  }

  export type PollPostCountAggregateInputType = {
    id?: true
    createdAt?: true
    action?: true
    content?: true
    title?: true
    pollOptions?: true
    pollDistribution?: true
    userIdToPollResponsesMap?: true
    pollEndDate?: true
    mentions?: true
    hashtags?: true
    tags?: true
    topicName?: true
    backendPlatformUserId?: true
    profileId?: true
    mediaId?: true
    threadId?: true
    extra?: true
    _all?: true
  }

  export type PollPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PollPost to aggregate.
     */
    where?: PollPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollPosts to fetch.
     */
    orderBy?: PollPostOrderByWithRelationInput | PollPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PollPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PollPosts
    **/
    _count?: true | PollPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PollPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PollPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PollPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PollPostMaxAggregateInputType
  }

  export type GetPollPostAggregateType<T extends PollPostAggregateArgs> = {
        [P in keyof T & keyof AggregatePollPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePollPost[P]>
      : GetScalarType<T[P], AggregatePollPost[P]>
  }




  export type PollPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PollPostWhereInput
    orderBy?: PollPostOrderByWithAggregationInput | PollPostOrderByWithAggregationInput[]
    by: PollPostScalarFieldEnum[] | PollPostScalarFieldEnum
    having?: PollPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PollPostCountAggregateInputType | true
    _avg?: PollPostAvgAggregateInputType
    _sum?: PollPostSumAggregateInputType
    _min?: PollPostMinAggregateInputType
    _max?: PollPostMaxAggregateInputType
  }

  export type PollPostGroupByOutputType = {
    id: string
    createdAt: string
    action: $Enums.PostType
    content: string
    title: string | null
    pollOptions: string[]
    pollDistribution: JsonValue | null
    userIdToPollResponsesMap: JsonValue | null
    pollEndDate: Date
    mentions: string[]
    hashtags: string[]
    tags: string[]
    topicName: string | null
    backendPlatformUserId: string
    profileId: number
    mediaId: string | null
    threadId: string | null
    extra: JsonValue | null
    _count: PollPostCountAggregateOutputType | null
    _avg: PollPostAvgAggregateOutputType | null
    _sum: PollPostSumAggregateOutputType | null
    _min: PollPostMinAggregateOutputType | null
    _max: PollPostMaxAggregateOutputType | null
  }

  type GetPollPostGroupByPayload<T extends PollPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PollPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PollPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PollPostGroupByOutputType[P]>
            : GetScalarType<T[P], PollPostGroupByOutputType[P]>
        }
      >
    >


  export type PollPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    action?: boolean
    content?: boolean
    title?: boolean
    pollOptions?: boolean
    pollDistribution?: boolean
    userIdToPollResponsesMap?: boolean
    pollEndDate?: boolean
    mentions?: boolean
    hashtags?: boolean
    tags?: boolean
    topicName?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    mediaId?: boolean
    threadId?: boolean
    extra?: boolean
    searchMetadata?: boolean | SearchMetadataDefaultArgs<ExtArgs>
    aiAnalysis?: boolean | AIAnalysisDefaultArgs<ExtArgs>
    media?: boolean | PollPost$mediaArgs<ExtArgs>
    comments?: boolean | PollPost$commentsArgs<ExtArgs>
    thread?: boolean | PollPost$threadArgs<ExtArgs>
    _count?: boolean | PollPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pollPost"]>


  export type PollPostSelectScalar = {
    id?: boolean
    createdAt?: boolean
    action?: boolean
    content?: boolean
    title?: boolean
    pollOptions?: boolean
    pollDistribution?: boolean
    userIdToPollResponsesMap?: boolean
    pollEndDate?: boolean
    mentions?: boolean
    hashtags?: boolean
    tags?: boolean
    topicName?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    mediaId?: boolean
    threadId?: boolean
    extra?: boolean
  }

  export type PollPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | PollPost$mediaArgs<ExtArgs>
    comments?: boolean | PollPost$commentsArgs<ExtArgs>
    thread?: boolean | PollPost$threadArgs<ExtArgs>
    _count?: boolean | PollPostCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PollPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PollPost"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs> | null
      comments: Prisma.$CommentPayload<ExtArgs>[]
      thread: Prisma.$ThreadPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: string
      action: $Enums.PostType
      content: string
      title: string | null
      pollOptions: string[]
      pollDistribution: Prisma.JsonValue | null
      userIdToPollResponsesMap: Prisma.JsonValue | null
      pollEndDate: Date
      mentions: string[]
      hashtags: string[]
      tags: string[]
      topicName: string | null
      backendPlatformUserId: string
      profileId: number
      mediaId: string | null
      threadId: string | null
      extra: Prisma.JsonValue | null
    }, ExtArgs["result"]["pollPost"]>
    composites: {
      searchMetadata: Prisma.$SearchMetadataPayload | null
      aiAnalysis: Prisma.$AIAnalysisPayload | null
    }
  }

  type PollPostGetPayload<S extends boolean | null | undefined | PollPostDefaultArgs> = $Result.GetResult<Prisma.$PollPostPayload, S>

  type PollPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PollPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PollPostCountAggregateInputType | true
    }

  export interface PollPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PollPost'], meta: { name: 'PollPost' } }
    /**
     * Find zero or one PollPost that matches the filter.
     * @param {PollPostFindUniqueArgs} args - Arguments to find a PollPost
     * @example
     * // Get one PollPost
     * const pollPost = await prisma.pollPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PollPostFindUniqueArgs>(args: SelectSubset<T, PollPostFindUniqueArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PollPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PollPostFindUniqueOrThrowArgs} args - Arguments to find a PollPost
     * @example
     * // Get one PollPost
     * const pollPost = await prisma.pollPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PollPostFindUniqueOrThrowArgs>(args: SelectSubset<T, PollPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PollPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollPostFindFirstArgs} args - Arguments to find a PollPost
     * @example
     * // Get one PollPost
     * const pollPost = await prisma.pollPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PollPostFindFirstArgs>(args?: SelectSubset<T, PollPostFindFirstArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PollPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollPostFindFirstOrThrowArgs} args - Arguments to find a PollPost
     * @example
     * // Get one PollPost
     * const pollPost = await prisma.pollPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PollPostFindFirstOrThrowArgs>(args?: SelectSubset<T, PollPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PollPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PollPosts
     * const pollPosts = await prisma.pollPost.findMany()
     * 
     * // Get first 10 PollPosts
     * const pollPosts = await prisma.pollPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pollPostWithIdOnly = await prisma.pollPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PollPostFindManyArgs>(args?: SelectSubset<T, PollPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PollPost.
     * @param {PollPostCreateArgs} args - Arguments to create a PollPost.
     * @example
     * // Create one PollPost
     * const PollPost = await prisma.pollPost.create({
     *   data: {
     *     // ... data to create a PollPost
     *   }
     * })
     * 
     */
    create<T extends PollPostCreateArgs>(args: SelectSubset<T, PollPostCreateArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PollPosts.
     * @param {PollPostCreateManyArgs} args - Arguments to create many PollPosts.
     * @example
     * // Create many PollPosts
     * const pollPost = await prisma.pollPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PollPostCreateManyArgs>(args?: SelectSubset<T, PollPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PollPost.
     * @param {PollPostDeleteArgs} args - Arguments to delete one PollPost.
     * @example
     * // Delete one PollPost
     * const PollPost = await prisma.pollPost.delete({
     *   where: {
     *     // ... filter to delete one PollPost
     *   }
     * })
     * 
     */
    delete<T extends PollPostDeleteArgs>(args: SelectSubset<T, PollPostDeleteArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PollPost.
     * @param {PollPostUpdateArgs} args - Arguments to update one PollPost.
     * @example
     * // Update one PollPost
     * const pollPost = await prisma.pollPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PollPostUpdateArgs>(args: SelectSubset<T, PollPostUpdateArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PollPosts.
     * @param {PollPostDeleteManyArgs} args - Arguments to filter PollPosts to delete.
     * @example
     * // Delete a few PollPosts
     * const { count } = await prisma.pollPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PollPostDeleteManyArgs>(args?: SelectSubset<T, PollPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PollPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PollPosts
     * const pollPost = await prisma.pollPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PollPostUpdateManyArgs>(args: SelectSubset<T, PollPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PollPost.
     * @param {PollPostUpsertArgs} args - Arguments to update or create a PollPost.
     * @example
     * // Update or create a PollPost
     * const pollPost = await prisma.pollPost.upsert({
     *   create: {
     *     // ... data to create a PollPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PollPost we want to update
     *   }
     * })
     */
    upsert<T extends PollPostUpsertArgs>(args: SelectSubset<T, PollPostUpsertArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more PollPosts that matches the filter.
     * @param {PollPostFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const pollPost = await prisma.pollPost.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: PollPostFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PollPost.
     * @param {PollPostAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const pollPost = await prisma.pollPost.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PollPostAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PollPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollPostCountArgs} args - Arguments to filter PollPosts to count.
     * @example
     * // Count the number of PollPosts
     * const count = await prisma.pollPost.count({
     *   where: {
     *     // ... the filter for the PollPosts we want to count
     *   }
     * })
    **/
    count<T extends PollPostCountArgs>(
      args?: Subset<T, PollPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PollPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PollPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PollPostAggregateArgs>(args: Subset<T, PollPostAggregateArgs>): Prisma.PrismaPromise<GetPollPostAggregateType<T>>

    /**
     * Group by PollPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PollPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PollPostGroupByArgs['orderBy'] }
        : { orderBy?: PollPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PollPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPollPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PollPost model
   */
  readonly fields: PollPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PollPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PollPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends PollPost$mediaArgs<ExtArgs> = {}>(args?: Subset<T, PollPost$mediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comments<T extends PollPost$commentsArgs<ExtArgs> = {}>(args?: Subset<T, PollPost$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    thread<T extends PollPost$threadArgs<ExtArgs> = {}>(args?: Subset<T, PollPost$threadArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PollPost model
   */ 
  interface PollPostFieldRefs {
    readonly id: FieldRef<"PollPost", 'String'>
    readonly createdAt: FieldRef<"PollPost", 'String'>
    readonly action: FieldRef<"PollPost", 'PostType'>
    readonly content: FieldRef<"PollPost", 'String'>
    readonly title: FieldRef<"PollPost", 'String'>
    readonly pollOptions: FieldRef<"PollPost", 'String[]'>
    readonly pollDistribution: FieldRef<"PollPost", 'Json'>
    readonly userIdToPollResponsesMap: FieldRef<"PollPost", 'Json'>
    readonly pollEndDate: FieldRef<"PollPost", 'DateTime'>
    readonly mentions: FieldRef<"PollPost", 'String[]'>
    readonly hashtags: FieldRef<"PollPost", 'String[]'>
    readonly tags: FieldRef<"PollPost", 'String[]'>
    readonly topicName: FieldRef<"PollPost", 'String'>
    readonly backendPlatformUserId: FieldRef<"PollPost", 'String'>
    readonly profileId: FieldRef<"PollPost", 'Int'>
    readonly mediaId: FieldRef<"PollPost", 'String'>
    readonly threadId: FieldRef<"PollPost", 'String'>
    readonly extra: FieldRef<"PollPost", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * PollPost findUnique
   */
  export type PollPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * Filter, which PollPost to fetch.
     */
    where: PollPostWhereUniqueInput
  }

  /**
   * PollPost findUniqueOrThrow
   */
  export type PollPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * Filter, which PollPost to fetch.
     */
    where: PollPostWhereUniqueInput
  }

  /**
   * PollPost findFirst
   */
  export type PollPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * Filter, which PollPost to fetch.
     */
    where?: PollPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollPosts to fetch.
     */
    orderBy?: PollPostOrderByWithRelationInput | PollPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PollPosts.
     */
    cursor?: PollPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PollPosts.
     */
    distinct?: PollPostScalarFieldEnum | PollPostScalarFieldEnum[]
  }

  /**
   * PollPost findFirstOrThrow
   */
  export type PollPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * Filter, which PollPost to fetch.
     */
    where?: PollPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollPosts to fetch.
     */
    orderBy?: PollPostOrderByWithRelationInput | PollPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PollPosts.
     */
    cursor?: PollPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PollPosts.
     */
    distinct?: PollPostScalarFieldEnum | PollPostScalarFieldEnum[]
  }

  /**
   * PollPost findMany
   */
  export type PollPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * Filter, which PollPosts to fetch.
     */
    where?: PollPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PollPosts to fetch.
     */
    orderBy?: PollPostOrderByWithRelationInput | PollPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PollPosts.
     */
    cursor?: PollPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PollPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PollPosts.
     */
    skip?: number
    distinct?: PollPostScalarFieldEnum | PollPostScalarFieldEnum[]
  }

  /**
   * PollPost create
   */
  export type PollPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * The data needed to create a PollPost.
     */
    data: XOR<PollPostCreateInput, PollPostUncheckedCreateInput>
  }

  /**
   * PollPost createMany
   */
  export type PollPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PollPosts.
     */
    data: PollPostCreateManyInput | PollPostCreateManyInput[]
  }

  /**
   * PollPost update
   */
  export type PollPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * The data needed to update a PollPost.
     */
    data: XOR<PollPostUpdateInput, PollPostUncheckedUpdateInput>
    /**
     * Choose, which PollPost to update.
     */
    where: PollPostWhereUniqueInput
  }

  /**
   * PollPost updateMany
   */
  export type PollPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PollPosts.
     */
    data: XOR<PollPostUpdateManyMutationInput, PollPostUncheckedUpdateManyInput>
    /**
     * Filter which PollPosts to update
     */
    where?: PollPostWhereInput
  }

  /**
   * PollPost upsert
   */
  export type PollPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * The filter to search for the PollPost to update in case it exists.
     */
    where: PollPostWhereUniqueInput
    /**
     * In case the PollPost found by the `where` argument doesn't exist, create a new PollPost with this data.
     */
    create: XOR<PollPostCreateInput, PollPostUncheckedCreateInput>
    /**
     * In case the PollPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PollPostUpdateInput, PollPostUncheckedUpdateInput>
  }

  /**
   * PollPost delete
   */
  export type PollPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    /**
     * Filter which PollPost to delete.
     */
    where: PollPostWhereUniqueInput
  }

  /**
   * PollPost deleteMany
   */
  export type PollPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PollPosts to delete
     */
    where?: PollPostWhereInput
  }

  /**
   * PollPost findRaw
   */
  export type PollPostFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PollPost aggregateRaw
   */
  export type PollPostAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PollPost.media
   */
  export type PollPost$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * PollPost.comments
   */
  export type PollPost$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * PollPost.thread
   */
  export type PollPost$threadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    where?: ThreadWhereInput
  }

  /**
   * PollPost without action
   */
  export type PollPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
  }


  /**
   * Model Space
   */

  export type AggregateSpace = {
    _count: SpaceCountAggregateOutputType | null
    _min: SpaceMinAggregateOutputType | null
    _max: SpaceMaxAggregateOutputType | null
  }

  export type SpaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.SpaceType | null
    createdAt: Date | null
    updatedAt: Date | null
    spaceType: string | null
    status: string | null
    visibility: string | null
    parentSpaceId: string | null
    isPrivate: boolean | null
    accessLevel: $Enums.AccessLevel | null
  }

  export type SpaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.SpaceType | null
    createdAt: Date | null
    updatedAt: Date | null
    spaceType: string | null
    status: string | null
    visibility: string | null
    parentSpaceId: string | null
    isPrivate: boolean | null
    accessLevel: $Enums.AccessLevel | null
  }

  export type SpaceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    createdAt: number
    updatedAt: number
    spaceType: number
    status: number
    visibility: number
    parentSpaceId: number
    isPrivate: number
    metadata: number
    settings: number
    accessLevel: number
    tags: number
    _all: number
  }


  export type SpaceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    spaceType?: true
    status?: true
    visibility?: true
    parentSpaceId?: true
    isPrivate?: true
    accessLevel?: true
  }

  export type SpaceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    spaceType?: true
    status?: true
    visibility?: true
    parentSpaceId?: true
    isPrivate?: true
    accessLevel?: true
  }

  export type SpaceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    spaceType?: true
    status?: true
    visibility?: true
    parentSpaceId?: true
    isPrivate?: true
    metadata?: true
    settings?: true
    accessLevel?: true
    tags?: true
    _all?: true
  }

  export type SpaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Space to aggregate.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Spaces
    **/
    _count?: true | SpaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpaceMaxAggregateInputType
  }

  export type GetSpaceAggregateType<T extends SpaceAggregateArgs> = {
        [P in keyof T & keyof AggregateSpace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpace[P]>
      : GetScalarType<T[P], AggregateSpace[P]>
  }




  export type SpaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceWhereInput
    orderBy?: SpaceOrderByWithAggregationInput | SpaceOrderByWithAggregationInput[]
    by: SpaceScalarFieldEnum[] | SpaceScalarFieldEnum
    having?: SpaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpaceCountAggregateInputType | true
    _min?: SpaceMinAggregateInputType
    _max?: SpaceMaxAggregateInputType
  }

  export type SpaceGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: $Enums.SpaceType
    createdAt: Date
    updatedAt: Date
    spaceType: string
    status: string
    visibility: string
    parentSpaceId: string | null
    isPrivate: boolean
    metadata: JsonValue | null
    settings: JsonValue | null
    accessLevel: $Enums.AccessLevel
    tags: string[]
    _count: SpaceCountAggregateOutputType | null
    _min: SpaceMinAggregateOutputType | null
    _max: SpaceMaxAggregateOutputType | null
  }

  type GetSpaceGroupByPayload<T extends SpaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpaceGroupByOutputType[P]>
            : GetScalarType<T[P], SpaceGroupByOutputType[P]>
        }
      >
    >


  export type SpaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    spaceType?: boolean
    status?: boolean
    visibility?: boolean
    parentSpaceId?: boolean
    isPrivate?: boolean
    metadata?: boolean
    settings?: boolean
    accessLevel?: boolean
    searchMetadata?: boolean | SearchMetadataDefaultArgs<ExtArgs>
    tags?: boolean
    members?: boolean | Space$membersArgs<ExtArgs>
    channels?: boolean | Space$channelsArgs<ExtArgs>
    posts?: boolean | Space$postsArgs<ExtArgs>
    files?: boolean | Space$filesArgs<ExtArgs>
    parentSpace?: boolean | Space$parentSpaceArgs<ExtArgs>
    childSpaces?: boolean | Space$childSpacesArgs<ExtArgs>
    _count?: boolean | SpaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["space"]>


  export type SpaceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    spaceType?: boolean
    status?: boolean
    visibility?: boolean
    parentSpaceId?: boolean
    isPrivate?: boolean
    metadata?: boolean
    settings?: boolean
    accessLevel?: boolean
    tags?: boolean
  }

  export type SpaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Space$membersArgs<ExtArgs>
    channels?: boolean | Space$channelsArgs<ExtArgs>
    posts?: boolean | Space$postsArgs<ExtArgs>
    files?: boolean | Space$filesArgs<ExtArgs>
    parentSpace?: boolean | Space$parentSpaceArgs<ExtArgs>
    childSpaces?: boolean | Space$childSpacesArgs<ExtArgs>
    _count?: boolean | SpaceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SpacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Space"
    objects: {
      members: Prisma.$SpaceMemberPayload<ExtArgs>[]
      channels: Prisma.$ChannelPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      parentSpace: Prisma.$SpacePayload<ExtArgs> | null
      childSpaces: Prisma.$SpacePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: $Enums.SpaceType
      createdAt: Date
      updatedAt: Date
      spaceType: string
      status: string
      visibility: string
      parentSpaceId: string | null
      isPrivate: boolean
      metadata: Prisma.JsonValue | null
      settings: Prisma.JsonValue | null
      accessLevel: $Enums.AccessLevel
      tags: string[]
    }, ExtArgs["result"]["space"]>
    composites: {
      searchMetadata: Prisma.$SearchMetadataPayload | null
    }
  }

  type SpaceGetPayload<S extends boolean | null | undefined | SpaceDefaultArgs> = $Result.GetResult<Prisma.$SpacePayload, S>

  type SpaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpaceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpaceCountAggregateInputType | true
    }

  export interface SpaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Space'], meta: { name: 'Space' } }
    /**
     * Find zero or one Space that matches the filter.
     * @param {SpaceFindUniqueArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpaceFindUniqueArgs>(args: SelectSubset<T, SpaceFindUniqueArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Space that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpaceFindUniqueOrThrowArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpaceFindUniqueOrThrowArgs>(args: SelectSubset<T, SpaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Space that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindFirstArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpaceFindFirstArgs>(args?: SelectSubset<T, SpaceFindFirstArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Space that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindFirstOrThrowArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpaceFindFirstOrThrowArgs>(args?: SelectSubset<T, SpaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Spaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spaces
     * const spaces = await prisma.space.findMany()
     * 
     * // Get first 10 Spaces
     * const spaces = await prisma.space.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spaceWithIdOnly = await prisma.space.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpaceFindManyArgs>(args?: SelectSubset<T, SpaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Space.
     * @param {SpaceCreateArgs} args - Arguments to create a Space.
     * @example
     * // Create one Space
     * const Space = await prisma.space.create({
     *   data: {
     *     // ... data to create a Space
     *   }
     * })
     * 
     */
    create<T extends SpaceCreateArgs>(args: SelectSubset<T, SpaceCreateArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Spaces.
     * @param {SpaceCreateManyArgs} args - Arguments to create many Spaces.
     * @example
     * // Create many Spaces
     * const space = await prisma.space.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpaceCreateManyArgs>(args?: SelectSubset<T, SpaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Space.
     * @param {SpaceDeleteArgs} args - Arguments to delete one Space.
     * @example
     * // Delete one Space
     * const Space = await prisma.space.delete({
     *   where: {
     *     // ... filter to delete one Space
     *   }
     * })
     * 
     */
    delete<T extends SpaceDeleteArgs>(args: SelectSubset<T, SpaceDeleteArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Space.
     * @param {SpaceUpdateArgs} args - Arguments to update one Space.
     * @example
     * // Update one Space
     * const space = await prisma.space.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpaceUpdateArgs>(args: SelectSubset<T, SpaceUpdateArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Spaces.
     * @param {SpaceDeleteManyArgs} args - Arguments to filter Spaces to delete.
     * @example
     * // Delete a few Spaces
     * const { count } = await prisma.space.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpaceDeleteManyArgs>(args?: SelectSubset<T, SpaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spaces
     * const space = await prisma.space.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpaceUpdateManyArgs>(args: SelectSubset<T, SpaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Space.
     * @param {SpaceUpsertArgs} args - Arguments to update or create a Space.
     * @example
     * // Update or create a Space
     * const space = await prisma.space.upsert({
     *   create: {
     *     // ... data to create a Space
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Space we want to update
     *   }
     * })
     */
    upsert<T extends SpaceUpsertArgs>(args: SelectSubset<T, SpaceUpsertArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Spaces that matches the filter.
     * @param {SpaceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const space = await prisma.space.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: SpaceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Space.
     * @param {SpaceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const space = await prisma.space.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SpaceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Spaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceCountArgs} args - Arguments to filter Spaces to count.
     * @example
     * // Count the number of Spaces
     * const count = await prisma.space.count({
     *   where: {
     *     // ... the filter for the Spaces we want to count
     *   }
     * })
    **/
    count<T extends SpaceCountArgs>(
      args?: Subset<T, SpaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Space.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpaceAggregateArgs>(args: Subset<T, SpaceAggregateArgs>): Prisma.PrismaPromise<GetSpaceAggregateType<T>>

    /**
     * Group by Space.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpaceGroupByArgs['orderBy'] }
        : { orderBy?: SpaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Space model
   */
  readonly fields: SpaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Space.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Space$membersArgs<ExtArgs> = {}>(args?: Subset<T, Space$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "findMany"> | Null>
    channels<T extends Space$channelsArgs<ExtArgs> = {}>(args?: Subset<T, Space$channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends Space$postsArgs<ExtArgs> = {}>(args?: Subset<T, Space$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    files<T extends Space$filesArgs<ExtArgs> = {}>(args?: Subset<T, Space$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany"> | Null>
    parentSpace<T extends Space$parentSpaceArgs<ExtArgs> = {}>(args?: Subset<T, Space$parentSpaceArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    childSpaces<T extends Space$childSpacesArgs<ExtArgs> = {}>(args?: Subset<T, Space$childSpacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Space model
   */ 
  interface SpaceFieldRefs {
    readonly id: FieldRef<"Space", 'String'>
    readonly name: FieldRef<"Space", 'String'>
    readonly description: FieldRef<"Space", 'String'>
    readonly type: FieldRef<"Space", 'SpaceType'>
    readonly createdAt: FieldRef<"Space", 'DateTime'>
    readonly updatedAt: FieldRef<"Space", 'DateTime'>
    readonly spaceType: FieldRef<"Space", 'String'>
    readonly status: FieldRef<"Space", 'String'>
    readonly visibility: FieldRef<"Space", 'String'>
    readonly parentSpaceId: FieldRef<"Space", 'String'>
    readonly isPrivate: FieldRef<"Space", 'Boolean'>
    readonly metadata: FieldRef<"Space", 'Json'>
    readonly settings: FieldRef<"Space", 'Json'>
    readonly accessLevel: FieldRef<"Space", 'AccessLevel'>
    readonly tags: FieldRef<"Space", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Space findUnique
   */
  export type SpaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space findUniqueOrThrow
   */
  export type SpaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space findFirst
   */
  export type SpaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spaces.
     */
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space findFirstOrThrow
   */
  export type SpaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Space to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spaces.
     */
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space findMany
   */
  export type SpaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter, which Spaces to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space create
   */
  export type SpaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Space.
     */
    data: XOR<SpaceCreateInput, SpaceUncheckedCreateInput>
  }

  /**
   * Space createMany
   */
  export type SpaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Spaces.
     */
    data: SpaceCreateManyInput | SpaceCreateManyInput[]
  }

  /**
   * Space update
   */
  export type SpaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Space.
     */
    data: XOR<SpaceUpdateInput, SpaceUncheckedUpdateInput>
    /**
     * Choose, which Space to update.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space updateMany
   */
  export type SpaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Spaces.
     */
    data: XOR<SpaceUpdateManyMutationInput, SpaceUncheckedUpdateManyInput>
    /**
     * Filter which Spaces to update
     */
    where?: SpaceWhereInput
  }

  /**
   * Space upsert
   */
  export type SpaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Space to update in case it exists.
     */
    where: SpaceWhereUniqueInput
    /**
     * In case the Space found by the `where` argument doesn't exist, create a new Space with this data.
     */
    create: XOR<SpaceCreateInput, SpaceUncheckedCreateInput>
    /**
     * In case the Space was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpaceUpdateInput, SpaceUncheckedUpdateInput>
  }

  /**
   * Space delete
   */
  export type SpaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    /**
     * Filter which Space to delete.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space deleteMany
   */
  export type SpaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Spaces to delete
     */
    where?: SpaceWhereInput
  }

  /**
   * Space findRaw
   */
  export type SpaceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Space aggregateRaw
   */
  export type SpaceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Space.members
   */
  export type Space$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    where?: SpaceMemberWhereInput
    orderBy?: SpaceMemberOrderByWithRelationInput | SpaceMemberOrderByWithRelationInput[]
    cursor?: SpaceMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpaceMemberScalarFieldEnum | SpaceMemberScalarFieldEnum[]
  }

  /**
   * Space.channels
   */
  export type Space$channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Space.posts
   */
  export type Space$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Space.files
   */
  export type Space$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Space.parentSpace
   */
  export type Space$parentSpaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    where?: SpaceWhereInput
  }

  /**
   * Space.childSpaces
   */
  export type Space$childSpacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    where?: SpaceWhereInput
    orderBy?: SpaceOrderByWithRelationInput | SpaceOrderByWithRelationInput[]
    cursor?: SpaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpaceScalarFieldEnum | SpaceScalarFieldEnum[]
  }

  /**
   * Space without action
   */
  export type SpaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
  }


  /**
   * Model Channel
   */

  export type AggregateChannel = {
    _count: ChannelCountAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  export type ChannelMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    spaceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    isPrivate: boolean | null
  }

  export type ChannelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    spaceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: string | null
    isPrivate: boolean | null
  }

  export type ChannelCountAggregateOutputType = {
    id: number
    name: number
    description: number
    spaceId: number
    createdAt: number
    updatedAt: number
    status: number
    pinnedPosts: number
    isPrivate: number
    metadata: number
    settings: number
    _all: number
  }


  export type ChannelMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    spaceId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    isPrivate?: true
  }

  export type ChannelMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    spaceId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    isPrivate?: true
  }

  export type ChannelCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    spaceId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    pinnedPosts?: true
    isPrivate?: true
    metadata?: true
    settings?: true
    _all?: true
  }

  export type ChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channel to aggregate.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Channels
    **/
    _count?: true | ChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMaxAggregateInputType
  }

  export type GetChannelAggregateType<T extends ChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannel[P]>
      : GetScalarType<T[P], AggregateChannel[P]>
  }




  export type ChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithAggregationInput | ChannelOrderByWithAggregationInput[]
    by: ChannelScalarFieldEnum[] | ChannelScalarFieldEnum
    having?: ChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCountAggregateInputType | true
    _min?: ChannelMinAggregateInputType
    _max?: ChannelMaxAggregateInputType
  }

  export type ChannelGroupByOutputType = {
    id: string
    name: string
    description: string | null
    spaceId: string
    createdAt: Date
    updatedAt: Date
    status: string
    pinnedPosts: string[]
    isPrivate: boolean
    metadata: JsonValue | null
    settings: JsonValue | null
    _count: ChannelCountAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  type GetChannelGroupByPayload<T extends ChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelGroupByOutputType[P]>
        }
      >
    >


  export type ChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    spaceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    pinnedPosts?: boolean
    isPrivate?: boolean
    metadata?: boolean
    settings?: boolean
    space?: boolean | SpaceDefaultArgs<ExtArgs>
    posts?: boolean | Channel$postsArgs<ExtArgs>
    files?: boolean | Channel$filesArgs<ExtArgs>
    members?: boolean | Channel$membersArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>


  export type ChannelSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    spaceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    pinnedPosts?: boolean
    isPrivate?: boolean
    metadata?: boolean
    settings?: boolean
  }

  export type ChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    space?: boolean | SpaceDefaultArgs<ExtArgs>
    posts?: boolean | Channel$postsArgs<ExtArgs>
    files?: boolean | Channel$filesArgs<ExtArgs>
    members?: boolean | Channel$membersArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Channel"
    objects: {
      space: Prisma.$SpacePayload<ExtArgs>
      posts: Prisma.$PostPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      members: Prisma.$ChannelMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      spaceId: string
      createdAt: Date
      updatedAt: Date
      status: string
      pinnedPosts: string[]
      isPrivate: boolean
      metadata: Prisma.JsonValue | null
      settings: Prisma.JsonValue | null
    }, ExtArgs["result"]["channel"]>
    composites: {}
  }

  type ChannelGetPayload<S extends boolean | null | undefined | ChannelDefaultArgs> = $Result.GetResult<Prisma.$ChannelPayload, S>

  type ChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelCountAggregateInputType | true
    }

  export interface ChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Channel'], meta: { name: 'Channel' } }
    /**
     * Find zero or one Channel that matches the filter.
     * @param {ChannelFindUniqueArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelFindUniqueArgs>(args: SelectSubset<T, ChannelFindUniqueArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Channel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelFindUniqueOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Channel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelFindFirstArgs>(args?: SelectSubset<T, ChannelFindFirstArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Channel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channels
     * const channels = await prisma.channel.findMany()
     * 
     * // Get first 10 Channels
     * const channels = await prisma.channel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelWithIdOnly = await prisma.channel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelFindManyArgs>(args?: SelectSubset<T, ChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Channel.
     * @param {ChannelCreateArgs} args - Arguments to create a Channel.
     * @example
     * // Create one Channel
     * const Channel = await prisma.channel.create({
     *   data: {
     *     // ... data to create a Channel
     *   }
     * })
     * 
     */
    create<T extends ChannelCreateArgs>(args: SelectSubset<T, ChannelCreateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Channels.
     * @param {ChannelCreateManyArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelCreateManyArgs>(args?: SelectSubset<T, ChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Channel.
     * @param {ChannelDeleteArgs} args - Arguments to delete one Channel.
     * @example
     * // Delete one Channel
     * const Channel = await prisma.channel.delete({
     *   where: {
     *     // ... filter to delete one Channel
     *   }
     * })
     * 
     */
    delete<T extends ChannelDeleteArgs>(args: SelectSubset<T, ChannelDeleteArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Channel.
     * @param {ChannelUpdateArgs} args - Arguments to update one Channel.
     * @example
     * // Update one Channel
     * const channel = await prisma.channel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelUpdateArgs>(args: SelectSubset<T, ChannelUpdateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Channels.
     * @param {ChannelDeleteManyArgs} args - Arguments to filter Channels to delete.
     * @example
     * // Delete a few Channels
     * const { count } = await prisma.channel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelDeleteManyArgs>(args?: SelectSubset<T, ChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelUpdateManyArgs>(args: SelectSubset<T, ChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Channel.
     * @param {ChannelUpsertArgs} args - Arguments to update or create a Channel.
     * @example
     * // Update or create a Channel
     * const channel = await prisma.channel.upsert({
     *   create: {
     *     // ... data to create a Channel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channel we want to update
     *   }
     * })
     */
    upsert<T extends ChannelUpsertArgs>(args: SelectSubset<T, ChannelUpsertArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Channels that matches the filter.
     * @param {ChannelFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const channel = await prisma.channel.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ChannelFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Channel.
     * @param {ChannelAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const channel = await prisma.channel.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ChannelAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCountArgs} args - Arguments to filter Channels to count.
     * @example
     * // Count the number of Channels
     * const count = await prisma.channel.count({
     *   where: {
     *     // ... the filter for the Channels we want to count
     *   }
     * })
    **/
    count<T extends ChannelCountArgs>(
      args?: Subset<T, ChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelAggregateArgs>(args: Subset<T, ChannelAggregateArgs>): Prisma.PrismaPromise<GetChannelAggregateType<T>>

    /**
     * Group by Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelGroupByArgs['orderBy'] }
        : { orderBy?: ChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Channel model
   */
  readonly fields: ChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Channel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    space<T extends SpaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpaceDefaultArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    posts<T extends Channel$postsArgs<ExtArgs> = {}>(args?: Subset<T, Channel$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    files<T extends Channel$filesArgs<ExtArgs> = {}>(args?: Subset<T, Channel$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany"> | Null>
    members<T extends Channel$membersArgs<ExtArgs> = {}>(args?: Subset<T, Channel$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Channel model
   */ 
  interface ChannelFieldRefs {
    readonly id: FieldRef<"Channel", 'String'>
    readonly name: FieldRef<"Channel", 'String'>
    readonly description: FieldRef<"Channel", 'String'>
    readonly spaceId: FieldRef<"Channel", 'String'>
    readonly createdAt: FieldRef<"Channel", 'DateTime'>
    readonly updatedAt: FieldRef<"Channel", 'DateTime'>
    readonly status: FieldRef<"Channel", 'String'>
    readonly pinnedPosts: FieldRef<"Channel", 'String[]'>
    readonly isPrivate: FieldRef<"Channel", 'Boolean'>
    readonly metadata: FieldRef<"Channel", 'Json'>
    readonly settings: FieldRef<"Channel", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Channel findUnique
   */
  export type ChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findUniqueOrThrow
   */
  export type ChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findFirst
   */
  export type ChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findFirstOrThrow
   */
  export type ChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findMany
   */
  export type ChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channels to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel create
   */
  export type ChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a Channel.
     */
    data: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
  }

  /**
   * Channel createMany
   */
  export type ChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Channels.
     */
    data: ChannelCreateManyInput | ChannelCreateManyInput[]
  }

  /**
   * Channel update
   */
  export type ChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a Channel.
     */
    data: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
    /**
     * Choose, which Channel to update.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel updateMany
   */
  export type ChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Channels.
     */
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyInput>
    /**
     * Filter which Channels to update
     */
    where?: ChannelWhereInput
  }

  /**
   * Channel upsert
   */
  export type ChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the Channel to update in case it exists.
     */
    where: ChannelWhereUniqueInput
    /**
     * In case the Channel found by the `where` argument doesn't exist, create a new Channel with this data.
     */
    create: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
    /**
     * In case the Channel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
  }

  /**
   * Channel delete
   */
  export type ChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter which Channel to delete.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel deleteMany
   */
  export type ChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channels to delete
     */
    where?: ChannelWhereInput
  }

  /**
   * Channel findRaw
   */
  export type ChannelFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Channel aggregateRaw
   */
  export type ChannelAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Channel.posts
   */
  export type Channel$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Channel.files
   */
  export type Channel$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Channel.members
   */
  export type Channel$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    where?: ChannelMemberWhereInput
    orderBy?: ChannelMemberOrderByWithRelationInput | ChannelMemberOrderByWithRelationInput[]
    cursor?: ChannelMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelMemberScalarFieldEnum | ChannelMemberScalarFieldEnum[]
  }

  /**
   * Channel without action
   */
  export type ChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
  }


  /**
   * Model Thread
   */

  export type AggregateThread = {
    _count: ThreadCountAggregateOutputType | null
    _min: ThreadMinAggregateOutputType | null
    _max: ThreadMaxAggregateOutputType | null
  }

  export type ThreadMinAggregateOutputType = {
    id: string | null
    parentPostId: string | null
    createdAt: string | null
    updatedAt: string | null
    status: string | null
    isLocked: boolean | null
  }

  export type ThreadMaxAggregateOutputType = {
    id: string | null
    parentPostId: string | null
    createdAt: string | null
    updatedAt: string | null
    status: string | null
    isLocked: boolean | null
  }

  export type ThreadCountAggregateOutputType = {
    id: number
    postIds: number
    parentPostId: number
    createdAt: number
    updatedAt: number
    metadata: number
    status: number
    isLocked: number
    _all: number
  }


  export type ThreadMinAggregateInputType = {
    id?: true
    parentPostId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    isLocked?: true
  }

  export type ThreadMaxAggregateInputType = {
    id?: true
    parentPostId?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    isLocked?: true
  }

  export type ThreadCountAggregateInputType = {
    id?: true
    postIds?: true
    parentPostId?: true
    createdAt?: true
    updatedAt?: true
    metadata?: true
    status?: true
    isLocked?: true
    _all?: true
  }

  export type ThreadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Thread to aggregate.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Threads
    **/
    _count?: true | ThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThreadMaxAggregateInputType
  }

  export type GetThreadAggregateType<T extends ThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThread[P]>
      : GetScalarType<T[P], AggregateThread[P]>
  }




  export type ThreadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreadWhereInput
    orderBy?: ThreadOrderByWithAggregationInput | ThreadOrderByWithAggregationInput[]
    by: ThreadScalarFieldEnum[] | ThreadScalarFieldEnum
    having?: ThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThreadCountAggregateInputType | true
    _min?: ThreadMinAggregateInputType
    _max?: ThreadMaxAggregateInputType
  }

  export type ThreadGroupByOutputType = {
    id: string
    postIds: string[]
    parentPostId: string
    createdAt: string
    updatedAt: string
    metadata: JsonValue | null
    status: string
    isLocked: boolean
    _count: ThreadCountAggregateOutputType | null
    _min: ThreadMinAggregateOutputType | null
    _max: ThreadMaxAggregateOutputType | null
  }

  type GetThreadGroupByPayload<T extends ThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadGroupByOutputType[P]>
        }
      >
    >


  export type ThreadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postIds?: boolean
    parentPostId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    status?: boolean
    isLocked?: boolean
    posts?: boolean | Thread$postsArgs<ExtArgs>
    pollPosts?: boolean | Thread$pollPostsArgs<ExtArgs>
    _count?: boolean | ThreadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["thread"]>


  export type ThreadSelectScalar = {
    id?: boolean
    postIds?: boolean
    parentPostId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    status?: boolean
    isLocked?: boolean
  }

  export type ThreadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Thread$postsArgs<ExtArgs>
    pollPosts?: boolean | Thread$pollPostsArgs<ExtArgs>
    _count?: boolean | ThreadCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ThreadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Thread"
    objects: {
      posts: Prisma.$PostPayload<ExtArgs>[]
      pollPosts: Prisma.$PollPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postIds: string[]
      parentPostId: string
      createdAt: string
      updatedAt: string
      metadata: Prisma.JsonValue | null
      status: string
      isLocked: boolean
    }, ExtArgs["result"]["thread"]>
    composites: {}
  }

  type ThreadGetPayload<S extends boolean | null | undefined | ThreadDefaultArgs> = $Result.GetResult<Prisma.$ThreadPayload, S>

  type ThreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ThreadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ThreadCountAggregateInputType | true
    }

  export interface ThreadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Thread'], meta: { name: 'Thread' } }
    /**
     * Find zero or one Thread that matches the filter.
     * @param {ThreadFindUniqueArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadFindUniqueArgs>(args: SelectSubset<T, ThreadFindUniqueArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Thread that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ThreadFindUniqueOrThrowArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadFindUniqueOrThrowArgs>(args: SelectSubset<T, ThreadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Thread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindFirstArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadFindFirstArgs>(args?: SelectSubset<T, ThreadFindFirstArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Thread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindFirstOrThrowArgs} args - Arguments to find a Thread
     * @example
     * // Get one Thread
     * const thread = await prisma.thread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadFindFirstOrThrowArgs>(args?: SelectSubset<T, ThreadFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Threads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Threads
     * const threads = await prisma.thread.findMany()
     * 
     * // Get first 10 Threads
     * const threads = await prisma.thread.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const threadWithIdOnly = await prisma.thread.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ThreadFindManyArgs>(args?: SelectSubset<T, ThreadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Thread.
     * @param {ThreadCreateArgs} args - Arguments to create a Thread.
     * @example
     * // Create one Thread
     * const Thread = await prisma.thread.create({
     *   data: {
     *     // ... data to create a Thread
     *   }
     * })
     * 
     */
    create<T extends ThreadCreateArgs>(args: SelectSubset<T, ThreadCreateArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Threads.
     * @param {ThreadCreateManyArgs} args - Arguments to create many Threads.
     * @example
     * // Create many Threads
     * const thread = await prisma.thread.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThreadCreateManyArgs>(args?: SelectSubset<T, ThreadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Thread.
     * @param {ThreadDeleteArgs} args - Arguments to delete one Thread.
     * @example
     * // Delete one Thread
     * const Thread = await prisma.thread.delete({
     *   where: {
     *     // ... filter to delete one Thread
     *   }
     * })
     * 
     */
    delete<T extends ThreadDeleteArgs>(args: SelectSubset<T, ThreadDeleteArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Thread.
     * @param {ThreadUpdateArgs} args - Arguments to update one Thread.
     * @example
     * // Update one Thread
     * const thread = await prisma.thread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThreadUpdateArgs>(args: SelectSubset<T, ThreadUpdateArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Threads.
     * @param {ThreadDeleteManyArgs} args - Arguments to filter Threads to delete.
     * @example
     * // Delete a few Threads
     * const { count } = await prisma.thread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThreadDeleteManyArgs>(args?: SelectSubset<T, ThreadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Threads
     * const thread = await prisma.thread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThreadUpdateManyArgs>(args: SelectSubset<T, ThreadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Thread.
     * @param {ThreadUpsertArgs} args - Arguments to update or create a Thread.
     * @example
     * // Update or create a Thread
     * const thread = await prisma.thread.upsert({
     *   create: {
     *     // ... data to create a Thread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Thread we want to update
     *   }
     * })
     */
    upsert<T extends ThreadUpsertArgs>(args: SelectSubset<T, ThreadUpsertArgs<ExtArgs>>): Prisma__ThreadClient<$Result.GetResult<Prisma.$ThreadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Threads that matches the filter.
     * @param {ThreadFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const thread = await prisma.thread.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ThreadFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Thread.
     * @param {ThreadAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const thread = await prisma.thread.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ThreadAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadCountArgs} args - Arguments to filter Threads to count.
     * @example
     * // Count the number of Threads
     * const count = await prisma.thread.count({
     *   where: {
     *     // ... the filter for the Threads we want to count
     *   }
     * })
    **/
    count<T extends ThreadCountArgs>(
      args?: Subset<T, ThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Thread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThreadAggregateArgs>(args: Subset<T, ThreadAggregateArgs>): Prisma.PrismaPromise<GetThreadAggregateType<T>>

    /**
     * Group by Thread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadGroupByArgs['orderBy'] }
        : { orderBy?: ThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Thread model
   */
  readonly fields: ThreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Thread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Thread$postsArgs<ExtArgs> = {}>(args?: Subset<T, Thread$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    pollPosts<T extends Thread$pollPostsArgs<ExtArgs> = {}>(args?: Subset<T, Thread$pollPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Thread model
   */ 
  interface ThreadFieldRefs {
    readonly id: FieldRef<"Thread", 'String'>
    readonly postIds: FieldRef<"Thread", 'String[]'>
    readonly parentPostId: FieldRef<"Thread", 'String'>
    readonly createdAt: FieldRef<"Thread", 'String'>
    readonly updatedAt: FieldRef<"Thread", 'String'>
    readonly metadata: FieldRef<"Thread", 'Json'>
    readonly status: FieldRef<"Thread", 'String'>
    readonly isLocked: FieldRef<"Thread", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Thread findUnique
   */
  export type ThreadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Thread to fetch.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread findUniqueOrThrow
   */
  export type ThreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Thread to fetch.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread findFirst
   */
  export type ThreadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Thread to fetch.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Threads.
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Threads.
     */
    distinct?: ThreadScalarFieldEnum | ThreadScalarFieldEnum[]
  }

  /**
   * Thread findFirstOrThrow
   */
  export type ThreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Thread to fetch.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Threads.
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Threads.
     */
    distinct?: ThreadScalarFieldEnum | ThreadScalarFieldEnum[]
  }

  /**
   * Thread findMany
   */
  export type ThreadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter, which Threads to fetch.
     */
    where?: ThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Threads to fetch.
     */
    orderBy?: ThreadOrderByWithRelationInput | ThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Threads.
     */
    cursor?: ThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Threads.
     */
    skip?: number
    distinct?: ThreadScalarFieldEnum | ThreadScalarFieldEnum[]
  }

  /**
   * Thread create
   */
  export type ThreadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * The data needed to create a Thread.
     */
    data: XOR<ThreadCreateInput, ThreadUncheckedCreateInput>
  }

  /**
   * Thread createMany
   */
  export type ThreadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Threads.
     */
    data: ThreadCreateManyInput | ThreadCreateManyInput[]
  }

  /**
   * Thread update
   */
  export type ThreadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * The data needed to update a Thread.
     */
    data: XOR<ThreadUpdateInput, ThreadUncheckedUpdateInput>
    /**
     * Choose, which Thread to update.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread updateMany
   */
  export type ThreadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Threads.
     */
    data: XOR<ThreadUpdateManyMutationInput, ThreadUncheckedUpdateManyInput>
    /**
     * Filter which Threads to update
     */
    where?: ThreadWhereInput
  }

  /**
   * Thread upsert
   */
  export type ThreadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * The filter to search for the Thread to update in case it exists.
     */
    where: ThreadWhereUniqueInput
    /**
     * In case the Thread found by the `where` argument doesn't exist, create a new Thread with this data.
     */
    create: XOR<ThreadCreateInput, ThreadUncheckedCreateInput>
    /**
     * In case the Thread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadUpdateInput, ThreadUncheckedUpdateInput>
  }

  /**
   * Thread delete
   */
  export type ThreadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
    /**
     * Filter which Thread to delete.
     */
    where: ThreadWhereUniqueInput
  }

  /**
   * Thread deleteMany
   */
  export type ThreadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Threads to delete
     */
    where?: ThreadWhereInput
  }

  /**
   * Thread findRaw
   */
  export type ThreadFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Thread aggregateRaw
   */
  export type ThreadAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Thread.posts
   */
  export type Thread$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Thread.pollPosts
   */
  export type Thread$pollPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    where?: PollPostWhereInput
    orderBy?: PollPostOrderByWithRelationInput | PollPostOrderByWithRelationInput[]
    cursor?: PollPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PollPostScalarFieldEnum | PollPostScalarFieldEnum[]
  }

  /**
   * Thread without action
   */
  export type ThreadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Thread
     */
    select?: ThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadInclude<ExtArgs> | null
  }


  /**
   * Model Note
   */

  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null
    _avg: NoteAvgAggregateOutputType | null
    _sum: NoteSumAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  export type NoteAvgAggregateOutputType = {
    profileId: number | null
  }

  export type NoteSumAggregateOutputType = {
    profileId: number | null
  }

  export type NoteMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: string | null
    authorId: string | null
    backendPlatformUserId: string | null
    profileId: number | null
    authorUserName: string | null
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType | null
    mediaId: string | null
    postId: string | null
    commentId: string | null
  }

  export type NoteMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: string | null
    authorId: string | null
    backendPlatformUserId: string | null
    profileId: number | null
    authorUserName: string | null
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType | null
    mediaId: string | null
    postId: string | null
    commentId: string | null
  }

  export type NoteCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    authorId: number
    backendPlatformUserId: number
    profileId: number
    authorUserName: number
    authorProfileImage: number
    authorAccountType: number
    mentions: number
    hashtags: number
    mediaId: number
    postId: number
    commentId: number
    _all: number
  }


  export type NoteAvgAggregateInputType = {
    profileId?: true
  }

  export type NoteSumAggregateInputType = {
    profileId?: true
  }

  export type NoteMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    authorId?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUserName?: true
    authorProfileImage?: true
    authorAccountType?: true
    mediaId?: true
    postId?: true
    commentId?: true
  }

  export type NoteMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    authorId?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUserName?: true
    authorProfileImage?: true
    authorAccountType?: true
    mediaId?: true
    postId?: true
    commentId?: true
  }

  export type NoteCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    authorId?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUserName?: true
    authorProfileImage?: true
    authorAccountType?: true
    mentions?: true
    hashtags?: true
    mediaId?: true
    postId?: true
    commentId?: true
    _all?: true
  }

  export type NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note to aggregate.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteMaxAggregateInputType
  }

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>
  }




  export type NoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithAggregationInput | NoteOrderByWithAggregationInput[]
    by: NoteScalarFieldEnum[] | NoteScalarFieldEnum
    having?: NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteCountAggregateInputType | true
    _avg?: NoteAvgAggregateInputType
    _sum?: NoteSumAggregateInputType
    _min?: NoteMinAggregateInputType
    _max?: NoteMaxAggregateInputType
  }

  export type NoteGroupByOutputType = {
    id: string
    content: string
    createdAt: string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType
    mentions: string[]
    hashtags: string[]
    mediaId: string | null
    postId: string
    commentId: string | null
    _count: NoteCountAggregateOutputType | null
    _avg: NoteAvgAggregateOutputType | null
    _sum: NoteSumAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  type GetNoteGroupByPayload<T extends NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteGroupByOutputType[P]>
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
        }
      >
    >


  export type NoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    authorId?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUserName?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    mentions?: boolean
    hashtags?: boolean
    mediaId?: boolean
    postId?: boolean
    commentId?: boolean
    searchMetadata?: boolean | SearchMetadataDefaultArgs<ExtArgs>
    aiAnalysis?: boolean | AIAnalysisDefaultArgs<ExtArgs>
    media?: boolean | Note$mediaArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    comment?: boolean | Note$commentArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>


  export type NoteSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    authorId?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUserName?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    mentions?: boolean
    hashtags?: boolean
    mediaId?: boolean
    postId?: boolean
    commentId?: boolean
  }

  export type NoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | Note$mediaArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    comment?: boolean | Note$commentArgs<ExtArgs>
  }

  export type $NotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Note"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs> | null
      post: Prisma.$PostPayload<ExtArgs>
      comment: Prisma.$CommentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: string
      authorId: string
      backendPlatformUserId: string
      profileId: number
      authorUserName: string
      authorProfileImage: string | null
      authorAccountType: $Enums.AccountType
      mentions: string[]
      hashtags: string[]
      mediaId: string | null
      postId: string
      commentId: string | null
    }, ExtArgs["result"]["note"]>
    composites: {
      searchMetadata: Prisma.$SearchMetadataPayload | null
      aiAnalysis: Prisma.$AIAnalysisPayload | null
    }
  }

  type NoteGetPayload<S extends boolean | null | undefined | NoteDefaultArgs> = $Result.GetResult<Prisma.$NotePayload, S>

  type NoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NoteCountAggregateInputType | true
    }

  export interface NoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Note'], meta: { name: 'Note' } }
    /**
     * Find zero or one Note that matches the filter.
     * @param {NoteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteFindUniqueArgs>(args: SelectSubset<T, NoteFindUniqueArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Note that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NoteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteFindFirstArgs>(args?: SelectSubset<T, NoteFindFirstArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteWithIdOnly = await prisma.note.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteFindManyArgs>(args?: SelectSubset<T, NoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Note.
     * @param {NoteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     * 
     */
    create<T extends NoteCreateArgs>(args: SelectSubset<T, NoteCreateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notes.
     * @param {NoteCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteCreateManyArgs>(args?: SelectSubset<T, NoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Note.
     * @param {NoteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     * 
     */
    delete<T extends NoteDeleteArgs>(args: SelectSubset<T, NoteDeleteArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Note.
     * @param {NoteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteUpdateArgs>(args: SelectSubset<T, NoteUpdateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notes.
     * @param {NoteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteDeleteManyArgs>(args?: SelectSubset<T, NoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteUpdateManyArgs>(args: SelectSubset<T, NoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Note.
     * @param {NoteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
     */
    upsert<T extends NoteUpsertArgs>(args: SelectSubset<T, NoteUpsertArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Notes that matches the filter.
     * @param {NoteFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const note = await prisma.note.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: NoteFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Note.
     * @param {NoteAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const note = await prisma.note.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: NoteAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NoteCountArgs>(
      args?: Subset<T, NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteAggregateArgs>(args: Subset<T, NoteAggregateArgs>): Prisma.PrismaPromise<GetNoteAggregateType<T>>

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteGroupByArgs['orderBy'] }
        : { orderBy?: NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Note model
   */
  readonly fields: NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends Note$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Note$mediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comment<T extends Note$commentArgs<ExtArgs> = {}>(args?: Subset<T, Note$commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Note model
   */ 
  interface NoteFieldRefs {
    readonly id: FieldRef<"Note", 'String'>
    readonly content: FieldRef<"Note", 'String'>
    readonly createdAt: FieldRef<"Note", 'String'>
    readonly authorId: FieldRef<"Note", 'String'>
    readonly backendPlatformUserId: FieldRef<"Note", 'String'>
    readonly profileId: FieldRef<"Note", 'Int'>
    readonly authorUserName: FieldRef<"Note", 'String'>
    readonly authorProfileImage: FieldRef<"Note", 'String'>
    readonly authorAccountType: FieldRef<"Note", 'AccountType'>
    readonly mentions: FieldRef<"Note", 'String[]'>
    readonly hashtags: FieldRef<"Note", 'String[]'>
    readonly mediaId: FieldRef<"Note", 'String'>
    readonly postId: FieldRef<"Note", 'String'>
    readonly commentId: FieldRef<"Note", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Note findUnique
   */
  export type NoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findUniqueOrThrow
   */
  export type NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findFirst
   */
  export type NoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findFirstOrThrow
   */
  export type NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note findMany
   */
  export type NoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Note create
   */
  export type NoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Note.
     */
    data: XOR<NoteCreateInput, NoteUncheckedCreateInput>
  }

  /**
   * Note createMany
   */
  export type NoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
  }

  /**
   * Note update
   */
  export type NoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Note.
     */
    data: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
    /**
     * Choose, which Note to update.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note updateMany
   */
  export type NoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
  }

  /**
   * Note upsert
   */
  export type NoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Note to update in case it exists.
     */
    where: NoteWhereUniqueInput
    /**
     * In case the Note found by the `where` argument doesn't exist, create a new Note with this data.
     */
    create: XOR<NoteCreateInput, NoteUncheckedCreateInput>
    /**
     * In case the Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
  }

  /**
   * Note delete
   */
  export type NoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter which Note to delete.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note deleteMany
   */
  export type NoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NoteWhereInput
  }

  /**
   * Note findRaw
   */
  export type NoteFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Note aggregateRaw
   */
  export type NoteAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Note.media
   */
  export type Note$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Note.comment
   */
  export type Note$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Note without action
   */
  export type NoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    profileId: number | null
    affinityScore: number | null
    qualityScore: number | null
  }

  export type CommentSumAggregateOutputType = {
    profileId: number | null
    affinityScore: number | null
    qualityScore: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    authorId: string | null
    content: string | null
    createdAt: string | null
    backendPlatformUserId: string | null
    profileId: number | null
    authorUsername: string | null
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType | null
    affinityScore: number | null
    qualityScore: number | null
    postId: string | null
    pollPostId: string | null
    mediaId: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    authorId: string | null
    content: string | null
    createdAt: string | null
    backendPlatformUserId: string | null
    profileId: number | null
    authorUsername: string | null
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType | null
    affinityScore: number | null
    qualityScore: number | null
    postId: string | null
    pollPostId: string | null
    mediaId: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    authorId: number
    content: number
    createdAt: number
    backendPlatformUserId: number
    profileId: number
    authorUsername: number
    authorProfileImage: number
    authorAccountType: number
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap: number
    userIdToReportsMap: number
    userIdToReactionMap: number
    mentions: number
    hashtags: number
    postId: number
    pollPostId: number
    extra: number
    mediaId: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    profileId?: true
    affinityScore?: true
    qualityScore?: true
  }

  export type CommentSumAggregateInputType = {
    profileId?: true
    affinityScore?: true
    qualityScore?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    createdAt?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    affinityScore?: true
    qualityScore?: true
    postId?: true
    pollPostId?: true
    mediaId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    createdAt?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    affinityScore?: true
    qualityScore?: true
    postId?: true
    pollPostId?: true
    mediaId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    createdAt?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    affinityScore?: true
    qualityScore?: true
    userIdToAffinityScoreMap?: true
    userIdToReportsMap?: true
    userIdToReactionMap?: true
    mentions?: true
    hashtags?: true
    postId?: true
    pollPostId?: true
    extra?: true
    mediaId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap: JsonValue | null
    userIdToReportsMap: JsonValue | null
    userIdToReactionMap: JsonValue | null
    mentions: string[]
    hashtags: string[]
    postId: string
    pollPostId: string | null
    extra: JsonValue | null
    mediaId: string | null
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUsername?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    affinityScore?: boolean
    qualityScore?: boolean
    userIdToAffinityScoreMap?: boolean
    userIdToReportsMap?: boolean
    userIdToReactionMap?: boolean
    mentions?: boolean
    hashtags?: boolean
    postId?: boolean
    pollPostId?: boolean
    extra?: boolean
    aiAnalysis?: boolean | AIAnalysisDefaultArgs<ExtArgs>
    mediaId?: boolean
    media?: boolean | Comment$mediaArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    notes?: boolean | Comment$notesArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    PollPost?: boolean | Comment$PollPostArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>


  export type CommentSelectScalar = {
    id?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUsername?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    affinityScore?: boolean
    qualityScore?: boolean
    userIdToAffinityScoreMap?: boolean
    userIdToReportsMap?: boolean
    userIdToReactionMap?: boolean
    mentions?: boolean
    hashtags?: boolean
    postId?: boolean
    pollPostId?: boolean
    extra?: boolean
    mediaId?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | Comment$mediaArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    notes?: boolean | Comment$notesArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    PollPost?: boolean | Comment$PollPostArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs> | null
      replies: Prisma.$CommentReplyPayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
      post: Prisma.$PostPayload<ExtArgs>
      PollPost: Prisma.$PollPostPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authorId: string
      content: string
      createdAt: string
      backendPlatformUserId: string
      profileId: number
      authorUsername: string
      authorProfileImage: string | null
      authorAccountType: $Enums.AccountType
      affinityScore: number
      qualityScore: number
      userIdToAffinityScoreMap: Prisma.JsonValue | null
      userIdToReportsMap: Prisma.JsonValue | null
      userIdToReactionMap: Prisma.JsonValue | null
      mentions: string[]
      hashtags: string[]
      postId: string
      pollPostId: string | null
      extra: Prisma.JsonValue | null
      mediaId: string | null
    }, ExtArgs["result"]["comment"]>
    composites: {
      aiAnalysis: Prisma.$AIAnalysisPayload | null
    }
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * @param {CommentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const comment = await prisma.comment.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: CommentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Comment.
     * @param {CommentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const comment = await prisma.comment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CommentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends Comment$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Comment$mediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findMany"> | Null>
    notes<T extends Comment$notesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany"> | Null>
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    PollPost<T extends Comment$PollPostArgs<ExtArgs> = {}>(args?: Subset<T, Comment$PollPostArgs<ExtArgs>>): Prisma__PollPostClient<$Result.GetResult<Prisma.$PollPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'String'>
    readonly backendPlatformUserId: FieldRef<"Comment", 'String'>
    readonly profileId: FieldRef<"Comment", 'Int'>
    readonly authorUsername: FieldRef<"Comment", 'String'>
    readonly authorProfileImage: FieldRef<"Comment", 'String'>
    readonly authorAccountType: FieldRef<"Comment", 'AccountType'>
    readonly affinityScore: FieldRef<"Comment", 'Int'>
    readonly qualityScore: FieldRef<"Comment", 'Int'>
    readonly userIdToAffinityScoreMap: FieldRef<"Comment", 'Json'>
    readonly userIdToReportsMap: FieldRef<"Comment", 'Json'>
    readonly userIdToReactionMap: FieldRef<"Comment", 'Json'>
    readonly mentions: FieldRef<"Comment", 'String[]'>
    readonly hashtags: FieldRef<"Comment", 'String[]'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly pollPostId: FieldRef<"Comment", 'String'>
    readonly extra: FieldRef<"Comment", 'Json'>
    readonly mediaId: FieldRef<"Comment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment findRaw
   */
  export type CommentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Comment aggregateRaw
   */
  export type CommentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Comment.media
   */
  export type Comment$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    where?: CommentReplyWhereInput
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    cursor?: CommentReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentReplyScalarFieldEnum | CommentReplyScalarFieldEnum[]
  }

  /**
   * Comment.notes
   */
  export type Comment$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Comment.PollPost
   */
  export type Comment$PollPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PollPost
     */
    select?: PollPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollPostInclude<ExtArgs> | null
    where?: PollPostWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model CommentReply
   */

  export type AggregateCommentReply = {
    _count: CommentReplyCountAggregateOutputType | null
    _avg: CommentReplyAvgAggregateOutputType | null
    _sum: CommentReplySumAggregateOutputType | null
    _min: CommentReplyMinAggregateOutputType | null
    _max: CommentReplyMaxAggregateOutputType | null
  }

  export type CommentReplyAvgAggregateOutputType = {
    profileId: number | null
    affinityScore: number | null
    qualityScore: number | null
  }

  export type CommentReplySumAggregateOutputType = {
    profileId: number | null
    affinityScore: number | null
    qualityScore: number | null
  }

  export type CommentReplyMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: string | null
    backendPlatformUserId: string | null
    profileId: number | null
    authorUsername: string | null
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType | null
    affinityScore: number | null
    qualityScore: number | null
    mediaid: string | null
    commentId: string | null
  }

  export type CommentReplyMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: string | null
    backendPlatformUserId: string | null
    profileId: number | null
    authorUsername: string | null
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType | null
    affinityScore: number | null
    qualityScore: number | null
    mediaid: string | null
    commentId: string | null
  }

  export type CommentReplyCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    backendPlatformUserId: number
    profileId: number
    authorUsername: number
    authorProfileImage: number
    authorAccountType: number
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap: number
    userIdToReportsMap: number
    userIdToReactionMap: number
    mentions: number
    hashtags: number
    mediaid: number
    commentId: number
    extra: number
    _all: number
  }


  export type CommentReplyAvgAggregateInputType = {
    profileId?: true
    affinityScore?: true
    qualityScore?: true
  }

  export type CommentReplySumAggregateInputType = {
    profileId?: true
    affinityScore?: true
    qualityScore?: true
  }

  export type CommentReplyMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    affinityScore?: true
    qualityScore?: true
    mediaid?: true
    commentId?: true
  }

  export type CommentReplyMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    affinityScore?: true
    qualityScore?: true
    mediaid?: true
    commentId?: true
  }

  export type CommentReplyCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    backendPlatformUserId?: true
    profileId?: true
    authorUsername?: true
    authorProfileImage?: true
    authorAccountType?: true
    affinityScore?: true
    qualityScore?: true
    userIdToAffinityScoreMap?: true
    userIdToReportsMap?: true
    userIdToReactionMap?: true
    mentions?: true
    hashtags?: true
    mediaid?: true
    commentId?: true
    extra?: true
    _all?: true
  }

  export type CommentReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentReply to aggregate.
     */
    where?: CommentReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReplies to fetch.
     */
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentReplies
    **/
    _count?: true | CommentReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentReplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentReplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentReplyMaxAggregateInputType
  }

  export type GetCommentReplyAggregateType<T extends CommentReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentReply[P]>
      : GetScalarType<T[P], AggregateCommentReply[P]>
  }




  export type CommentReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReplyWhereInput
    orderBy?: CommentReplyOrderByWithAggregationInput | CommentReplyOrderByWithAggregationInput[]
    by: CommentReplyScalarFieldEnum[] | CommentReplyScalarFieldEnum
    having?: CommentReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentReplyCountAggregateInputType | true
    _avg?: CommentReplyAvgAggregateInputType
    _sum?: CommentReplySumAggregateInputType
    _min?: CommentReplyMinAggregateInputType
    _max?: CommentReplyMaxAggregateInputType
  }

  export type CommentReplyGroupByOutputType = {
    id: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap: JsonValue | null
    userIdToReportsMap: JsonValue | null
    userIdToReactionMap: JsonValue | null
    mentions: string[]
    hashtags: string[]
    mediaid: string | null
    commentId: string
    extra: JsonValue | null
    _count: CommentReplyCountAggregateOutputType | null
    _avg: CommentReplyAvgAggregateOutputType | null
    _sum: CommentReplySumAggregateOutputType | null
    _min: CommentReplyMinAggregateOutputType | null
    _max: CommentReplyMaxAggregateOutputType | null
  }

  type GetCommentReplyGroupByPayload<T extends CommentReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentReplyGroupByOutputType[P]>
            : GetScalarType<T[P], CommentReplyGroupByOutputType[P]>
        }
      >
    >


  export type CommentReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUsername?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    affinityScore?: boolean
    qualityScore?: boolean
    userIdToAffinityScoreMap?: boolean
    userIdToReportsMap?: boolean
    userIdToReactionMap?: boolean
    mentions?: boolean
    hashtags?: boolean
    mediaid?: boolean
    commentId?: boolean
    extra?: boolean
    aiAnalysis?: boolean | AIAnalysisDefaultArgs<ExtArgs>
    media?: boolean | CommentReply$mediaArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentReply"]>


  export type CommentReplySelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    backendPlatformUserId?: boolean
    profileId?: boolean
    authorUsername?: boolean
    authorProfileImage?: boolean
    authorAccountType?: boolean
    affinityScore?: boolean
    qualityScore?: boolean
    userIdToAffinityScoreMap?: boolean
    userIdToReportsMap?: boolean
    userIdToReactionMap?: boolean
    mentions?: boolean
    hashtags?: boolean
    mediaid?: boolean
    commentId?: boolean
    extra?: boolean
  }

  export type CommentReplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | CommentReply$mediaArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }

  export type $CommentReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommentReply"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs> | null
      comment: Prisma.$CommentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: string
      backendPlatformUserId: string
      profileId: number
      authorUsername: string
      authorProfileImage: string | null
      authorAccountType: $Enums.AccountType
      affinityScore: number
      qualityScore: number
      userIdToAffinityScoreMap: Prisma.JsonValue | null
      userIdToReportsMap: Prisma.JsonValue | null
      userIdToReactionMap: Prisma.JsonValue | null
      mentions: string[]
      hashtags: string[]
      mediaid: string | null
      commentId: string
      extra: Prisma.JsonValue | null
    }, ExtArgs["result"]["commentReply"]>
    composites: {
      aiAnalysis: Prisma.$AIAnalysisPayload | null
    }
  }

  type CommentReplyGetPayload<S extends boolean | null | undefined | CommentReplyDefaultArgs> = $Result.GetResult<Prisma.$CommentReplyPayload, S>

  type CommentReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentReplyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentReplyCountAggregateInputType | true
    }

  export interface CommentReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentReply'], meta: { name: 'CommentReply' } }
    /**
     * Find zero or one CommentReply that matches the filter.
     * @param {CommentReplyFindUniqueArgs} args - Arguments to find a CommentReply
     * @example
     * // Get one CommentReply
     * const commentReply = await prisma.commentReply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentReplyFindUniqueArgs>(args: SelectSubset<T, CommentReplyFindUniqueArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommentReply that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentReplyFindUniqueOrThrowArgs} args - Arguments to find a CommentReply
     * @example
     * // Get one CommentReply
     * const commentReply = await prisma.commentReply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentReplyFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentReplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommentReply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyFindFirstArgs} args - Arguments to find a CommentReply
     * @example
     * // Get one CommentReply
     * const commentReply = await prisma.commentReply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentReplyFindFirstArgs>(args?: SelectSubset<T, CommentReplyFindFirstArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommentReply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyFindFirstOrThrowArgs} args - Arguments to find a CommentReply
     * @example
     * // Get one CommentReply
     * const commentReply = await prisma.commentReply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentReplyFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentReplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommentReplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentReplies
     * const commentReplies = await prisma.commentReply.findMany()
     * 
     * // Get first 10 CommentReplies
     * const commentReplies = await prisma.commentReply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentReplyWithIdOnly = await prisma.commentReply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentReplyFindManyArgs>(args?: SelectSubset<T, CommentReplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommentReply.
     * @param {CommentReplyCreateArgs} args - Arguments to create a CommentReply.
     * @example
     * // Create one CommentReply
     * const CommentReply = await prisma.commentReply.create({
     *   data: {
     *     // ... data to create a CommentReply
     *   }
     * })
     * 
     */
    create<T extends CommentReplyCreateArgs>(args: SelectSubset<T, CommentReplyCreateArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommentReplies.
     * @param {CommentReplyCreateManyArgs} args - Arguments to create many CommentReplies.
     * @example
     * // Create many CommentReplies
     * const commentReply = await prisma.commentReply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentReplyCreateManyArgs>(args?: SelectSubset<T, CommentReplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommentReply.
     * @param {CommentReplyDeleteArgs} args - Arguments to delete one CommentReply.
     * @example
     * // Delete one CommentReply
     * const CommentReply = await prisma.commentReply.delete({
     *   where: {
     *     // ... filter to delete one CommentReply
     *   }
     * })
     * 
     */
    delete<T extends CommentReplyDeleteArgs>(args: SelectSubset<T, CommentReplyDeleteArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommentReply.
     * @param {CommentReplyUpdateArgs} args - Arguments to update one CommentReply.
     * @example
     * // Update one CommentReply
     * const commentReply = await prisma.commentReply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentReplyUpdateArgs>(args: SelectSubset<T, CommentReplyUpdateArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommentReplies.
     * @param {CommentReplyDeleteManyArgs} args - Arguments to filter CommentReplies to delete.
     * @example
     * // Delete a few CommentReplies
     * const { count } = await prisma.commentReply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentReplyDeleteManyArgs>(args?: SelectSubset<T, CommentReplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentReplies
     * const commentReply = await prisma.commentReply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentReplyUpdateManyArgs>(args: SelectSubset<T, CommentReplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommentReply.
     * @param {CommentReplyUpsertArgs} args - Arguments to update or create a CommentReply.
     * @example
     * // Update or create a CommentReply
     * const commentReply = await prisma.commentReply.upsert({
     *   create: {
     *     // ... data to create a CommentReply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentReply we want to update
     *   }
     * })
     */
    upsert<T extends CommentReplyUpsertArgs>(args: SelectSubset<T, CommentReplyUpsertArgs<ExtArgs>>): Prisma__CommentReplyClient<$Result.GetResult<Prisma.$CommentReplyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more CommentReplies that matches the filter.
     * @param {CommentReplyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const commentReply = await prisma.commentReply.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: CommentReplyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CommentReply.
     * @param {CommentReplyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const commentReply = await prisma.commentReply.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CommentReplyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CommentReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyCountArgs} args - Arguments to filter CommentReplies to count.
     * @example
     * // Count the number of CommentReplies
     * const count = await prisma.commentReply.count({
     *   where: {
     *     // ... the filter for the CommentReplies we want to count
     *   }
     * })
    **/
    count<T extends CommentReplyCountArgs>(
      args?: Subset<T, CommentReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentReplyAggregateArgs>(args: Subset<T, CommentReplyAggregateArgs>): Prisma.PrismaPromise<GetCommentReplyAggregateType<T>>

    /**
     * Group by CommentReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentReplyGroupByArgs['orderBy'] }
        : { orderBy?: CommentReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommentReply model
   */
  readonly fields: CommentReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentReply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends CommentReply$mediaArgs<ExtArgs> = {}>(args?: Subset<T, CommentReply$mediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommentReply model
   */ 
  interface CommentReplyFieldRefs {
    readonly id: FieldRef<"CommentReply", 'String'>
    readonly content: FieldRef<"CommentReply", 'String'>
    readonly createdAt: FieldRef<"CommentReply", 'String'>
    readonly backendPlatformUserId: FieldRef<"CommentReply", 'String'>
    readonly profileId: FieldRef<"CommentReply", 'Int'>
    readonly authorUsername: FieldRef<"CommentReply", 'String'>
    readonly authorProfileImage: FieldRef<"CommentReply", 'String'>
    readonly authorAccountType: FieldRef<"CommentReply", 'AccountType'>
    readonly affinityScore: FieldRef<"CommentReply", 'Int'>
    readonly qualityScore: FieldRef<"CommentReply", 'Int'>
    readonly userIdToAffinityScoreMap: FieldRef<"CommentReply", 'Json'>
    readonly userIdToReportsMap: FieldRef<"CommentReply", 'Json'>
    readonly userIdToReactionMap: FieldRef<"CommentReply", 'Json'>
    readonly mentions: FieldRef<"CommentReply", 'String[]'>
    readonly hashtags: FieldRef<"CommentReply", 'String[]'>
    readonly mediaid: FieldRef<"CommentReply", 'String'>
    readonly commentId: FieldRef<"CommentReply", 'String'>
    readonly extra: FieldRef<"CommentReply", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * CommentReply findUnique
   */
  export type CommentReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which CommentReply to fetch.
     */
    where: CommentReplyWhereUniqueInput
  }

  /**
   * CommentReply findUniqueOrThrow
   */
  export type CommentReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which CommentReply to fetch.
     */
    where: CommentReplyWhereUniqueInput
  }

  /**
   * CommentReply findFirst
   */
  export type CommentReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which CommentReply to fetch.
     */
    where?: CommentReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReplies to fetch.
     */
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentReplies.
     */
    cursor?: CommentReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentReplies.
     */
    distinct?: CommentReplyScalarFieldEnum | CommentReplyScalarFieldEnum[]
  }

  /**
   * CommentReply findFirstOrThrow
   */
  export type CommentReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which CommentReply to fetch.
     */
    where?: CommentReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReplies to fetch.
     */
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentReplies.
     */
    cursor?: CommentReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentReplies.
     */
    distinct?: CommentReplyScalarFieldEnum | CommentReplyScalarFieldEnum[]
  }

  /**
   * CommentReply findMany
   */
  export type CommentReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter, which CommentReplies to fetch.
     */
    where?: CommentReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReplies to fetch.
     */
    orderBy?: CommentReplyOrderByWithRelationInput | CommentReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentReplies.
     */
    cursor?: CommentReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReplies.
     */
    skip?: number
    distinct?: CommentReplyScalarFieldEnum | CommentReplyScalarFieldEnum[]
  }

  /**
   * CommentReply create
   */
  export type CommentReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentReply.
     */
    data: XOR<CommentReplyCreateInput, CommentReplyUncheckedCreateInput>
  }

  /**
   * CommentReply createMany
   */
  export type CommentReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommentReplies.
     */
    data: CommentReplyCreateManyInput | CommentReplyCreateManyInput[]
  }

  /**
   * CommentReply update
   */
  export type CommentReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentReply.
     */
    data: XOR<CommentReplyUpdateInput, CommentReplyUncheckedUpdateInput>
    /**
     * Choose, which CommentReply to update.
     */
    where: CommentReplyWhereUniqueInput
  }

  /**
   * CommentReply updateMany
   */
  export type CommentReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommentReplies.
     */
    data: XOR<CommentReplyUpdateManyMutationInput, CommentReplyUncheckedUpdateManyInput>
    /**
     * Filter which CommentReplies to update
     */
    where?: CommentReplyWhereInput
  }

  /**
   * CommentReply upsert
   */
  export type CommentReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentReply to update in case it exists.
     */
    where: CommentReplyWhereUniqueInput
    /**
     * In case the CommentReply found by the `where` argument doesn't exist, create a new CommentReply with this data.
     */
    create: XOR<CommentReplyCreateInput, CommentReplyUncheckedCreateInput>
    /**
     * In case the CommentReply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentReplyUpdateInput, CommentReplyUncheckedUpdateInput>
  }

  /**
   * CommentReply delete
   */
  export type CommentReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
    /**
     * Filter which CommentReply to delete.
     */
    where: CommentReplyWhereUniqueInput
  }

  /**
   * CommentReply deleteMany
   */
  export type CommentReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentReplies to delete
     */
    where?: CommentReplyWhereInput
  }

  /**
   * CommentReply findRaw
   */
  export type CommentReplyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CommentReply aggregateRaw
   */
  export type CommentReplyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CommentReply.media
   */
  export type CommentReply$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * CommentReply without action
   */
  export type CommentReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReply
     */
    select?: CommentReplySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReplyInclude<ExtArgs> | null
  }


  /**
   * Model SpaceMember
   */

  export type AggregateSpaceMember = {
    _count: SpaceMemberCountAggregateOutputType | null
    _min: SpaceMemberMinAggregateOutputType | null
    _max: SpaceMemberMaxAggregateOutputType | null
  }

  export type SpaceMemberMinAggregateOutputType = {
    id: string | null
    spaceId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    status: string | null
  }

  export type SpaceMemberMaxAggregateOutputType = {
    id: string | null
    spaceId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    status: string | null
  }

  export type SpaceMemberCountAggregateOutputType = {
    id: number
    spaceId: number
    userId: number
    role: number
    joinedAt: number
    status: number
    permissions: number
    _all: number
  }


  export type SpaceMemberMinAggregateInputType = {
    id?: true
    spaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    status?: true
  }

  export type SpaceMemberMaxAggregateInputType = {
    id?: true
    spaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    status?: true
  }

  export type SpaceMemberCountAggregateInputType = {
    id?: true
    spaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    status?: true
    permissions?: true
    _all?: true
  }

  export type SpaceMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpaceMember to aggregate.
     */
    where?: SpaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceMembers to fetch.
     */
    orderBy?: SpaceMemberOrderByWithRelationInput | SpaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpaceMembers
    **/
    _count?: true | SpaceMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpaceMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpaceMemberMaxAggregateInputType
  }

  export type GetSpaceMemberAggregateType<T extends SpaceMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateSpaceMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpaceMember[P]>
      : GetScalarType<T[P], AggregateSpaceMember[P]>
  }




  export type SpaceMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpaceMemberWhereInput
    orderBy?: SpaceMemberOrderByWithAggregationInput | SpaceMemberOrderByWithAggregationInput[]
    by: SpaceMemberScalarFieldEnum[] | SpaceMemberScalarFieldEnum
    having?: SpaceMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpaceMemberCountAggregateInputType | true
    _min?: SpaceMemberMinAggregateInputType
    _max?: SpaceMemberMaxAggregateInputType
  }

  export type SpaceMemberGroupByOutputType = {
    id: string
    spaceId: string
    userId: string
    role: string
    joinedAt: Date
    status: string
    permissions: string[]
    _count: SpaceMemberCountAggregateOutputType | null
    _min: SpaceMemberMinAggregateOutputType | null
    _max: SpaceMemberMaxAggregateOutputType | null
  }

  type GetSpaceMemberGroupByPayload<T extends SpaceMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpaceMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpaceMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpaceMemberGroupByOutputType[P]>
            : GetScalarType<T[P], SpaceMemberGroupByOutputType[P]>
        }
      >
    >


  export type SpaceMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    status?: boolean
    permissions?: boolean
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spaceMember"]>


  export type SpaceMemberSelectScalar = {
    id?: boolean
    spaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    status?: boolean
    permissions?: boolean
  }

  export type SpaceMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    space?: boolean | SpaceDefaultArgs<ExtArgs>
  }

  export type $SpaceMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpaceMember"
    objects: {
      space: Prisma.$SpacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      spaceId: string
      userId: string
      role: string
      joinedAt: Date
      status: string
      permissions: string[]
    }, ExtArgs["result"]["spaceMember"]>
    composites: {}
  }

  type SpaceMemberGetPayload<S extends boolean | null | undefined | SpaceMemberDefaultArgs> = $Result.GetResult<Prisma.$SpaceMemberPayload, S>

  type SpaceMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpaceMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpaceMemberCountAggregateInputType | true
    }

  export interface SpaceMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpaceMember'], meta: { name: 'SpaceMember' } }
    /**
     * Find zero or one SpaceMember that matches the filter.
     * @param {SpaceMemberFindUniqueArgs} args - Arguments to find a SpaceMember
     * @example
     * // Get one SpaceMember
     * const spaceMember = await prisma.spaceMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpaceMemberFindUniqueArgs>(args: SelectSubset<T, SpaceMemberFindUniqueArgs<ExtArgs>>): Prisma__SpaceMemberClient<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SpaceMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpaceMemberFindUniqueOrThrowArgs} args - Arguments to find a SpaceMember
     * @example
     * // Get one SpaceMember
     * const spaceMember = await prisma.spaceMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpaceMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, SpaceMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpaceMemberClient<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SpaceMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceMemberFindFirstArgs} args - Arguments to find a SpaceMember
     * @example
     * // Get one SpaceMember
     * const spaceMember = await prisma.spaceMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpaceMemberFindFirstArgs>(args?: SelectSubset<T, SpaceMemberFindFirstArgs<ExtArgs>>): Prisma__SpaceMemberClient<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SpaceMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceMemberFindFirstOrThrowArgs} args - Arguments to find a SpaceMember
     * @example
     * // Get one SpaceMember
     * const spaceMember = await prisma.spaceMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpaceMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, SpaceMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpaceMemberClient<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpaceMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpaceMembers
     * const spaceMembers = await prisma.spaceMember.findMany()
     * 
     * // Get first 10 SpaceMembers
     * const spaceMembers = await prisma.spaceMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spaceMemberWithIdOnly = await prisma.spaceMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpaceMemberFindManyArgs>(args?: SelectSubset<T, SpaceMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SpaceMember.
     * @param {SpaceMemberCreateArgs} args - Arguments to create a SpaceMember.
     * @example
     * // Create one SpaceMember
     * const SpaceMember = await prisma.spaceMember.create({
     *   data: {
     *     // ... data to create a SpaceMember
     *   }
     * })
     * 
     */
    create<T extends SpaceMemberCreateArgs>(args: SelectSubset<T, SpaceMemberCreateArgs<ExtArgs>>): Prisma__SpaceMemberClient<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpaceMembers.
     * @param {SpaceMemberCreateManyArgs} args - Arguments to create many SpaceMembers.
     * @example
     * // Create many SpaceMembers
     * const spaceMember = await prisma.spaceMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpaceMemberCreateManyArgs>(args?: SelectSubset<T, SpaceMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpaceMember.
     * @param {SpaceMemberDeleteArgs} args - Arguments to delete one SpaceMember.
     * @example
     * // Delete one SpaceMember
     * const SpaceMember = await prisma.spaceMember.delete({
     *   where: {
     *     // ... filter to delete one SpaceMember
     *   }
     * })
     * 
     */
    delete<T extends SpaceMemberDeleteArgs>(args: SelectSubset<T, SpaceMemberDeleteArgs<ExtArgs>>): Prisma__SpaceMemberClient<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SpaceMember.
     * @param {SpaceMemberUpdateArgs} args - Arguments to update one SpaceMember.
     * @example
     * // Update one SpaceMember
     * const spaceMember = await prisma.spaceMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpaceMemberUpdateArgs>(args: SelectSubset<T, SpaceMemberUpdateArgs<ExtArgs>>): Prisma__SpaceMemberClient<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpaceMembers.
     * @param {SpaceMemberDeleteManyArgs} args - Arguments to filter SpaceMembers to delete.
     * @example
     * // Delete a few SpaceMembers
     * const { count } = await prisma.spaceMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpaceMemberDeleteManyArgs>(args?: SelectSubset<T, SpaceMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpaceMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpaceMembers
     * const spaceMember = await prisma.spaceMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpaceMemberUpdateManyArgs>(args: SelectSubset<T, SpaceMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpaceMember.
     * @param {SpaceMemberUpsertArgs} args - Arguments to update or create a SpaceMember.
     * @example
     * // Update or create a SpaceMember
     * const spaceMember = await prisma.spaceMember.upsert({
     *   create: {
     *     // ... data to create a SpaceMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpaceMember we want to update
     *   }
     * })
     */
    upsert<T extends SpaceMemberUpsertArgs>(args: SelectSubset<T, SpaceMemberUpsertArgs<ExtArgs>>): Prisma__SpaceMemberClient<$Result.GetResult<Prisma.$SpaceMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more SpaceMembers that matches the filter.
     * @param {SpaceMemberFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const spaceMember = await prisma.spaceMember.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: SpaceMemberFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SpaceMember.
     * @param {SpaceMemberAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const spaceMember = await prisma.spaceMember.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SpaceMemberAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SpaceMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceMemberCountArgs} args - Arguments to filter SpaceMembers to count.
     * @example
     * // Count the number of SpaceMembers
     * const count = await prisma.spaceMember.count({
     *   where: {
     *     // ... the filter for the SpaceMembers we want to count
     *   }
     * })
    **/
    count<T extends SpaceMemberCountArgs>(
      args?: Subset<T, SpaceMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpaceMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpaceMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpaceMemberAggregateArgs>(args: Subset<T, SpaceMemberAggregateArgs>): Prisma.PrismaPromise<GetSpaceMemberAggregateType<T>>

    /**
     * Group by SpaceMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpaceMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpaceMemberGroupByArgs['orderBy'] }
        : { orderBy?: SpaceMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpaceMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpaceMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpaceMember model
   */
  readonly fields: SpaceMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpaceMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpaceMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    space<T extends SpaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpaceDefaultArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpaceMember model
   */ 
  interface SpaceMemberFieldRefs {
    readonly id: FieldRef<"SpaceMember", 'String'>
    readonly spaceId: FieldRef<"SpaceMember", 'String'>
    readonly userId: FieldRef<"SpaceMember", 'String'>
    readonly role: FieldRef<"SpaceMember", 'String'>
    readonly joinedAt: FieldRef<"SpaceMember", 'DateTime'>
    readonly status: FieldRef<"SpaceMember", 'String'>
    readonly permissions: FieldRef<"SpaceMember", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * SpaceMember findUnique
   */
  export type SpaceMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which SpaceMember to fetch.
     */
    where: SpaceMemberWhereUniqueInput
  }

  /**
   * SpaceMember findUniqueOrThrow
   */
  export type SpaceMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which SpaceMember to fetch.
     */
    where: SpaceMemberWhereUniqueInput
  }

  /**
   * SpaceMember findFirst
   */
  export type SpaceMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which SpaceMember to fetch.
     */
    where?: SpaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceMembers to fetch.
     */
    orderBy?: SpaceMemberOrderByWithRelationInput | SpaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpaceMembers.
     */
    cursor?: SpaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpaceMembers.
     */
    distinct?: SpaceMemberScalarFieldEnum | SpaceMemberScalarFieldEnum[]
  }

  /**
   * SpaceMember findFirstOrThrow
   */
  export type SpaceMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which SpaceMember to fetch.
     */
    where?: SpaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceMembers to fetch.
     */
    orderBy?: SpaceMemberOrderByWithRelationInput | SpaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpaceMembers.
     */
    cursor?: SpaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpaceMembers.
     */
    distinct?: SpaceMemberScalarFieldEnum | SpaceMemberScalarFieldEnum[]
  }

  /**
   * SpaceMember findMany
   */
  export type SpaceMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which SpaceMembers to fetch.
     */
    where?: SpaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpaceMembers to fetch.
     */
    orderBy?: SpaceMemberOrderByWithRelationInput | SpaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpaceMembers.
     */
    cursor?: SpaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpaceMembers.
     */
    skip?: number
    distinct?: SpaceMemberScalarFieldEnum | SpaceMemberScalarFieldEnum[]
  }

  /**
   * SpaceMember create
   */
  export type SpaceMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a SpaceMember.
     */
    data: XOR<SpaceMemberCreateInput, SpaceMemberUncheckedCreateInput>
  }

  /**
   * SpaceMember createMany
   */
  export type SpaceMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpaceMembers.
     */
    data: SpaceMemberCreateManyInput | SpaceMemberCreateManyInput[]
  }

  /**
   * SpaceMember update
   */
  export type SpaceMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a SpaceMember.
     */
    data: XOR<SpaceMemberUpdateInput, SpaceMemberUncheckedUpdateInput>
    /**
     * Choose, which SpaceMember to update.
     */
    where: SpaceMemberWhereUniqueInput
  }

  /**
   * SpaceMember updateMany
   */
  export type SpaceMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpaceMembers.
     */
    data: XOR<SpaceMemberUpdateManyMutationInput, SpaceMemberUncheckedUpdateManyInput>
    /**
     * Filter which SpaceMembers to update
     */
    where?: SpaceMemberWhereInput
  }

  /**
   * SpaceMember upsert
   */
  export type SpaceMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the SpaceMember to update in case it exists.
     */
    where: SpaceMemberWhereUniqueInput
    /**
     * In case the SpaceMember found by the `where` argument doesn't exist, create a new SpaceMember with this data.
     */
    create: XOR<SpaceMemberCreateInput, SpaceMemberUncheckedCreateInput>
    /**
     * In case the SpaceMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpaceMemberUpdateInput, SpaceMemberUncheckedUpdateInput>
  }

  /**
   * SpaceMember delete
   */
  export type SpaceMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
    /**
     * Filter which SpaceMember to delete.
     */
    where: SpaceMemberWhereUniqueInput
  }

  /**
   * SpaceMember deleteMany
   */
  export type SpaceMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpaceMembers to delete
     */
    where?: SpaceMemberWhereInput
  }

  /**
   * SpaceMember findRaw
   */
  export type SpaceMemberFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SpaceMember aggregateRaw
   */
  export type SpaceMemberAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SpaceMember without action
   */
  export type SpaceMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpaceMember
     */
    select?: SpaceMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceMemberInclude<ExtArgs> | null
  }


  /**
   * Model ChannelMember
   */

  export type AggregateChannelMember = {
    _count: ChannelMemberCountAggregateOutputType | null
    _min: ChannelMemberMinAggregateOutputType | null
    _max: ChannelMemberMaxAggregateOutputType | null
  }

  export type ChannelMemberMinAggregateOutputType = {
    id: string | null
    channelId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    lastRead: Date | null
  }

  export type ChannelMemberMaxAggregateOutputType = {
    id: string | null
    channelId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    lastRead: Date | null
  }

  export type ChannelMemberCountAggregateOutputType = {
    id: number
    channelId: number
    userId: number
    role: number
    joinedAt: number
    lastRead: number
    _all: number
  }


  export type ChannelMemberMinAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
    role?: true
    joinedAt?: true
    lastRead?: true
  }

  export type ChannelMemberMaxAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
    role?: true
    joinedAt?: true
    lastRead?: true
  }

  export type ChannelMemberCountAggregateInputType = {
    id?: true
    channelId?: true
    userId?: true
    role?: true
    joinedAt?: true
    lastRead?: true
    _all?: true
  }

  export type ChannelMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelMember to aggregate.
     */
    where?: ChannelMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelMembers to fetch.
     */
    orderBy?: ChannelMemberOrderByWithRelationInput | ChannelMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChannelMembers
    **/
    _count?: true | ChannelMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMemberMaxAggregateInputType
  }

  export type GetChannelMemberAggregateType<T extends ChannelMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateChannelMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannelMember[P]>
      : GetScalarType<T[P], AggregateChannelMember[P]>
  }




  export type ChannelMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelMemberWhereInput
    orderBy?: ChannelMemberOrderByWithAggregationInput | ChannelMemberOrderByWithAggregationInput[]
    by: ChannelMemberScalarFieldEnum[] | ChannelMemberScalarFieldEnum
    having?: ChannelMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelMemberCountAggregateInputType | true
    _min?: ChannelMemberMinAggregateInputType
    _max?: ChannelMemberMaxAggregateInputType
  }

  export type ChannelMemberGroupByOutputType = {
    id: string
    channelId: string
    userId: string
    role: string
    joinedAt: Date
    lastRead: Date | null
    _count: ChannelMemberCountAggregateOutputType | null
    _min: ChannelMemberMinAggregateOutputType | null
    _max: ChannelMemberMaxAggregateOutputType | null
  }

  type GetChannelMemberGroupByPayload<T extends ChannelMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelMemberGroupByOutputType[P]>
        }
      >
    >


  export type ChannelMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    lastRead?: boolean
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelMember"]>


  export type ChannelMemberSelectScalar = {
    id?: boolean
    channelId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    lastRead?: boolean
  }

  export type ChannelMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefaultArgs<ExtArgs>
  }

  export type $ChannelMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChannelMember"
    objects: {
      channel: Prisma.$ChannelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      channelId: string
      userId: string
      role: string
      joinedAt: Date
      lastRead: Date | null
    }, ExtArgs["result"]["channelMember"]>
    composites: {}
  }

  type ChannelMemberGetPayload<S extends boolean | null | undefined | ChannelMemberDefaultArgs> = $Result.GetResult<Prisma.$ChannelMemberPayload, S>

  type ChannelMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelMemberCountAggregateInputType | true
    }

  export interface ChannelMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelMember'], meta: { name: 'ChannelMember' } }
    /**
     * Find zero or one ChannelMember that matches the filter.
     * @param {ChannelMemberFindUniqueArgs} args - Arguments to find a ChannelMember
     * @example
     * // Get one ChannelMember
     * const channelMember = await prisma.channelMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelMemberFindUniqueArgs>(args: SelectSubset<T, ChannelMemberFindUniqueArgs<ExtArgs>>): Prisma__ChannelMemberClient<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChannelMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelMemberFindUniqueOrThrowArgs} args - Arguments to find a ChannelMember
     * @example
     * // Get one ChannelMember
     * const channelMember = await prisma.channelMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelMemberClient<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChannelMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMemberFindFirstArgs} args - Arguments to find a ChannelMember
     * @example
     * // Get one ChannelMember
     * const channelMember = await prisma.channelMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelMemberFindFirstArgs>(args?: SelectSubset<T, ChannelMemberFindFirstArgs<ExtArgs>>): Prisma__ChannelMemberClient<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChannelMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMemberFindFirstOrThrowArgs} args - Arguments to find a ChannelMember
     * @example
     * // Get one ChannelMember
     * const channelMember = await prisma.channelMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelMemberClient<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChannelMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelMembers
     * const channelMembers = await prisma.channelMember.findMany()
     * 
     * // Get first 10 ChannelMembers
     * const channelMembers = await prisma.channelMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelMemberWithIdOnly = await prisma.channelMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelMemberFindManyArgs>(args?: SelectSubset<T, ChannelMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChannelMember.
     * @param {ChannelMemberCreateArgs} args - Arguments to create a ChannelMember.
     * @example
     * // Create one ChannelMember
     * const ChannelMember = await prisma.channelMember.create({
     *   data: {
     *     // ... data to create a ChannelMember
     *   }
     * })
     * 
     */
    create<T extends ChannelMemberCreateArgs>(args: SelectSubset<T, ChannelMemberCreateArgs<ExtArgs>>): Prisma__ChannelMemberClient<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChannelMembers.
     * @param {ChannelMemberCreateManyArgs} args - Arguments to create many ChannelMembers.
     * @example
     * // Create many ChannelMembers
     * const channelMember = await prisma.channelMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelMemberCreateManyArgs>(args?: SelectSubset<T, ChannelMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChannelMember.
     * @param {ChannelMemberDeleteArgs} args - Arguments to delete one ChannelMember.
     * @example
     * // Delete one ChannelMember
     * const ChannelMember = await prisma.channelMember.delete({
     *   where: {
     *     // ... filter to delete one ChannelMember
     *   }
     * })
     * 
     */
    delete<T extends ChannelMemberDeleteArgs>(args: SelectSubset<T, ChannelMemberDeleteArgs<ExtArgs>>): Prisma__ChannelMemberClient<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChannelMember.
     * @param {ChannelMemberUpdateArgs} args - Arguments to update one ChannelMember.
     * @example
     * // Update one ChannelMember
     * const channelMember = await prisma.channelMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelMemberUpdateArgs>(args: SelectSubset<T, ChannelMemberUpdateArgs<ExtArgs>>): Prisma__ChannelMemberClient<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChannelMembers.
     * @param {ChannelMemberDeleteManyArgs} args - Arguments to filter ChannelMembers to delete.
     * @example
     * // Delete a few ChannelMembers
     * const { count } = await prisma.channelMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelMemberDeleteManyArgs>(args?: SelectSubset<T, ChannelMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelMembers
     * const channelMember = await prisma.channelMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelMemberUpdateManyArgs>(args: SelectSubset<T, ChannelMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChannelMember.
     * @param {ChannelMemberUpsertArgs} args - Arguments to update or create a ChannelMember.
     * @example
     * // Update or create a ChannelMember
     * const channelMember = await prisma.channelMember.upsert({
     *   create: {
     *     // ... data to create a ChannelMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelMember we want to update
     *   }
     * })
     */
    upsert<T extends ChannelMemberUpsertArgs>(args: SelectSubset<T, ChannelMemberUpsertArgs<ExtArgs>>): Prisma__ChannelMemberClient<$Result.GetResult<Prisma.$ChannelMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more ChannelMembers that matches the filter.
     * @param {ChannelMemberFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const channelMember = await prisma.channelMember.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ChannelMemberFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ChannelMember.
     * @param {ChannelMemberAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const channelMember = await prisma.channelMember.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ChannelMemberAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ChannelMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMemberCountArgs} args - Arguments to filter ChannelMembers to count.
     * @example
     * // Count the number of ChannelMembers
     * const count = await prisma.channelMember.count({
     *   where: {
     *     // ... the filter for the ChannelMembers we want to count
     *   }
     * })
    **/
    count<T extends ChannelMemberCountArgs>(
      args?: Subset<T, ChannelMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChannelMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelMemberAggregateArgs>(args: Subset<T, ChannelMemberAggregateArgs>): Prisma.PrismaPromise<GetChannelMemberAggregateType<T>>

    /**
     * Group by ChannelMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelMemberGroupByArgs['orderBy'] }
        : { orderBy?: ChannelMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChannelMember model
   */
  readonly fields: ChannelMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChannelMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel<T extends ChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefaultArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChannelMember model
   */ 
  interface ChannelMemberFieldRefs {
    readonly id: FieldRef<"ChannelMember", 'String'>
    readonly channelId: FieldRef<"ChannelMember", 'String'>
    readonly userId: FieldRef<"ChannelMember", 'String'>
    readonly role: FieldRef<"ChannelMember", 'String'>
    readonly joinedAt: FieldRef<"ChannelMember", 'DateTime'>
    readonly lastRead: FieldRef<"ChannelMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChannelMember findUnique
   */
  export type ChannelMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMember to fetch.
     */
    where: ChannelMemberWhereUniqueInput
  }

  /**
   * ChannelMember findUniqueOrThrow
   */
  export type ChannelMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMember to fetch.
     */
    where: ChannelMemberWhereUniqueInput
  }

  /**
   * ChannelMember findFirst
   */
  export type ChannelMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMember to fetch.
     */
    where?: ChannelMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelMembers to fetch.
     */
    orderBy?: ChannelMemberOrderByWithRelationInput | ChannelMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelMembers.
     */
    cursor?: ChannelMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelMembers.
     */
    distinct?: ChannelMemberScalarFieldEnum | ChannelMemberScalarFieldEnum[]
  }

  /**
   * ChannelMember findFirstOrThrow
   */
  export type ChannelMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMember to fetch.
     */
    where?: ChannelMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelMembers to fetch.
     */
    orderBy?: ChannelMemberOrderByWithRelationInput | ChannelMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelMembers.
     */
    cursor?: ChannelMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelMembers.
     */
    distinct?: ChannelMemberScalarFieldEnum | ChannelMemberScalarFieldEnum[]
  }

  /**
   * ChannelMember findMany
   */
  export type ChannelMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChannelMembers to fetch.
     */
    where?: ChannelMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelMembers to fetch.
     */
    orderBy?: ChannelMemberOrderByWithRelationInput | ChannelMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChannelMembers.
     */
    cursor?: ChannelMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChannelMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelMembers.
     */
    skip?: number
    distinct?: ChannelMemberScalarFieldEnum | ChannelMemberScalarFieldEnum[]
  }

  /**
   * ChannelMember create
   */
  export type ChannelMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ChannelMember.
     */
    data: XOR<ChannelMemberCreateInput, ChannelMemberUncheckedCreateInput>
  }

  /**
   * ChannelMember createMany
   */
  export type ChannelMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelMembers.
     */
    data: ChannelMemberCreateManyInput | ChannelMemberCreateManyInput[]
  }

  /**
   * ChannelMember update
   */
  export type ChannelMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ChannelMember.
     */
    data: XOR<ChannelMemberUpdateInput, ChannelMemberUncheckedUpdateInput>
    /**
     * Choose, which ChannelMember to update.
     */
    where: ChannelMemberWhereUniqueInput
  }

  /**
   * ChannelMember updateMany
   */
  export type ChannelMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelMembers.
     */
    data: XOR<ChannelMemberUpdateManyMutationInput, ChannelMemberUncheckedUpdateManyInput>
    /**
     * Filter which ChannelMembers to update
     */
    where?: ChannelMemberWhereInput
  }

  /**
   * ChannelMember upsert
   */
  export type ChannelMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ChannelMember to update in case it exists.
     */
    where: ChannelMemberWhereUniqueInput
    /**
     * In case the ChannelMember found by the `where` argument doesn't exist, create a new ChannelMember with this data.
     */
    create: XOR<ChannelMemberCreateInput, ChannelMemberUncheckedCreateInput>
    /**
     * In case the ChannelMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelMemberUpdateInput, ChannelMemberUncheckedUpdateInput>
  }

  /**
   * ChannelMember delete
   */
  export type ChannelMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
    /**
     * Filter which ChannelMember to delete.
     */
    where: ChannelMemberWhereUniqueInput
  }

  /**
   * ChannelMember deleteMany
   */
  export type ChannelMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelMembers to delete
     */
    where?: ChannelMemberWhereInput
  }

  /**
   * ChannelMember findRaw
   */
  export type ChannelMemberFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ChannelMember aggregateRaw
   */
  export type ChannelMemberAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ChannelMember without action
   */
  export type ChannelMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelMember
     */
    select?: ChannelMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelMemberInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
  }

  export type FileSumAggregateOutputType = {
    size: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.MediaType | null
    url: string | null
    uploadedBy: string | null
    uploadedAt: Date | null
    size: number | null
    status: string | null
    preview: string | null
    thumbnail: string | null
    spaceId: string | null
    channelId: string | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.MediaType | null
    url: string | null
    uploadedBy: string | null
    uploadedAt: Date | null
    size: number | null
    status: string | null
    preview: string | null
    thumbnail: string | null
    spaceId: string | null
    channelId: string | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    name: number
    type: number
    url: number
    uploadedBy: number
    uploadedAt: number
    size: number
    status: number
    preview: number
    thumbnail: number
    spaceId: number
    channelId: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true
  }

  export type FileSumAggregateInputType = {
    size?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    uploadedBy?: true
    uploadedAt?: true
    size?: true
    status?: true
    preview?: true
    thumbnail?: true
    spaceId?: true
    channelId?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    uploadedBy?: true
    uploadedAt?: true
    size?: true
    status?: true
    preview?: true
    thumbnail?: true
    spaceId?: true
    channelId?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    uploadedBy?: true
    uploadedAt?: true
    size?: true
    status?: true
    preview?: true
    thumbnail?: true
    spaceId?: true
    channelId?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    name: string
    type: $Enums.MediaType
    url: string
    uploadedBy: string
    uploadedAt: Date
    size: number
    status: string
    preview: string | null
    thumbnail: string | null
    spaceId: string | null
    channelId: string | null
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    metadata?: boolean | FileMetadataDefaultArgs<ExtArgs>
    uploadedBy?: boolean
    uploadedAt?: boolean
    size?: boolean
    status?: boolean
    preview?: boolean
    thumbnail?: boolean
    searchMetadata?: boolean | SearchMetadataDefaultArgs<ExtArgs>
    aiAnalysis?: boolean | AIAnalysisDefaultArgs<ExtArgs>
    spaceId?: boolean
    channelId?: boolean
    posts?: boolean | File$postsArgs<ExtArgs>
    Space?: boolean | File$SpaceArgs<ExtArgs>
    Channel?: boolean | File$ChannelArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>


  export type FileSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    size?: boolean
    status?: boolean
    preview?: boolean
    thumbnail?: boolean
    spaceId?: boolean
    channelId?: boolean
  }

  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | File$postsArgs<ExtArgs>
    Space?: boolean | File$SpaceArgs<ExtArgs>
    Channel?: boolean | File$ChannelArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      posts: Prisma.$FileToPostPayload<ExtArgs>[]
      Space: Prisma.$SpacePayload<ExtArgs> | null
      Channel: Prisma.$ChannelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.MediaType
      url: string
      uploadedBy: string
      uploadedAt: Date
      size: number
      status: string
      preview: string | null
      thumbnail: string | null
      spaceId: string | null
      channelId: string | null
    }, ExtArgs["result"]["file"]>
    composites: {
      metadata: Prisma.$FileMetadataPayload
      searchMetadata: Prisma.$SearchMetadataPayload | null
      aiAnalysis: Prisma.$AIAnalysisPayload | null
    }
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Files that matches the filter.
     * @param {FileFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const file = await prisma.file.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: FileFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a File.
     * @param {FileAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const file = await prisma.file.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FileAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends File$postsArgs<ExtArgs> = {}>(args?: Subset<T, File$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileToPostPayload<ExtArgs>, T, "findMany"> | Null>
    Space<T extends File$SpaceArgs<ExtArgs> = {}>(args?: Subset<T, File$SpaceArgs<ExtArgs>>): Prisma__SpaceClient<$Result.GetResult<Prisma.$SpacePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Channel<T extends File$ChannelArgs<ExtArgs> = {}>(args?: Subset<T, File$ChannelArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */ 
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly name: FieldRef<"File", 'String'>
    readonly type: FieldRef<"File", 'MediaType'>
    readonly url: FieldRef<"File", 'String'>
    readonly uploadedBy: FieldRef<"File", 'String'>
    readonly uploadedAt: FieldRef<"File", 'DateTime'>
    readonly size: FieldRef<"File", 'Int'>
    readonly status: FieldRef<"File", 'String'>
    readonly preview: FieldRef<"File", 'String'>
    readonly thumbnail: FieldRef<"File", 'String'>
    readonly spaceId: FieldRef<"File", 'String'>
    readonly channelId: FieldRef<"File", 'String'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
  }

  /**
   * File findRaw
   */
  export type FileFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * File aggregateRaw
   */
  export type FileAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * File.posts
   */
  export type File$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileToPost
     */
    select?: FileToPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileToPostInclude<ExtArgs> | null
    where?: FileToPostWhereInput
    orderBy?: FileToPostOrderByWithRelationInput | FileToPostOrderByWithRelationInput[]
    cursor?: FileToPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileToPostScalarFieldEnum | FileToPostScalarFieldEnum[]
  }

  /**
   * File.Space
   */
  export type File$SpaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpaceInclude<ExtArgs> | null
    where?: SpaceWhereInput
  }

  /**
   * File.Channel
   */
  export type File$ChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model FileToPost
   */

  export type AggregateFileToPost = {
    _count: FileToPostCountAggregateOutputType | null
    _min: FileToPostMinAggregateOutputType | null
    _max: FileToPostMaxAggregateOutputType | null
  }

  export type FileToPostMinAggregateOutputType = {
    id: string | null
    fileId: string | null
    postId: string | null
    createdAt: Date | null
  }

  export type FileToPostMaxAggregateOutputType = {
    id: string | null
    fileId: string | null
    postId: string | null
    createdAt: Date | null
  }

  export type FileToPostCountAggregateOutputType = {
    id: number
    fileId: number
    postId: number
    createdAt: number
    _all: number
  }


  export type FileToPostMinAggregateInputType = {
    id?: true
    fileId?: true
    postId?: true
    createdAt?: true
  }

  export type FileToPostMaxAggregateInputType = {
    id?: true
    fileId?: true
    postId?: true
    createdAt?: true
  }

  export type FileToPostCountAggregateInputType = {
    id?: true
    fileId?: true
    postId?: true
    createdAt?: true
    _all?: true
  }

  export type FileToPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileToPost to aggregate.
     */
    where?: FileToPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileToPosts to fetch.
     */
    orderBy?: FileToPostOrderByWithRelationInput | FileToPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileToPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileToPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileToPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileToPosts
    **/
    _count?: true | FileToPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileToPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileToPostMaxAggregateInputType
  }

  export type GetFileToPostAggregateType<T extends FileToPostAggregateArgs> = {
        [P in keyof T & keyof AggregateFileToPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileToPost[P]>
      : GetScalarType<T[P], AggregateFileToPost[P]>
  }




  export type FileToPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileToPostWhereInput
    orderBy?: FileToPostOrderByWithAggregationInput | FileToPostOrderByWithAggregationInput[]
    by: FileToPostScalarFieldEnum[] | FileToPostScalarFieldEnum
    having?: FileToPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileToPostCountAggregateInputType | true
    _min?: FileToPostMinAggregateInputType
    _max?: FileToPostMaxAggregateInputType
  }

  export type FileToPostGroupByOutputType = {
    id: string
    fileId: string
    postId: string
    createdAt: Date
    _count: FileToPostCountAggregateOutputType | null
    _min: FileToPostMinAggregateOutputType | null
    _max: FileToPostMaxAggregateOutputType | null
  }

  type GetFileToPostGroupByPayload<T extends FileToPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileToPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileToPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileToPostGroupByOutputType[P]>
            : GetScalarType<T[P], FileToPostGroupByOutputType[P]>
        }
      >
    >


  export type FileToPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileId?: boolean
    postId?: boolean
    createdAt?: boolean
    file?: boolean | FileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileToPost"]>


  export type FileToPostSelectScalar = {
    id?: boolean
    fileId?: boolean
    postId?: boolean
    createdAt?: boolean
  }

  export type FileToPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | FileDefaultArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $FileToPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileToPost"
    objects: {
      file: Prisma.$FilePayload<ExtArgs>
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fileId: string
      postId: string
      createdAt: Date
    }, ExtArgs["result"]["fileToPost"]>
    composites: {}
  }

  type FileToPostGetPayload<S extends boolean | null | undefined | FileToPostDefaultArgs> = $Result.GetResult<Prisma.$FileToPostPayload, S>

  type FileToPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FileToPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FileToPostCountAggregateInputType | true
    }

  export interface FileToPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileToPost'], meta: { name: 'FileToPost' } }
    /**
     * Find zero or one FileToPost that matches the filter.
     * @param {FileToPostFindUniqueArgs} args - Arguments to find a FileToPost
     * @example
     * // Get one FileToPost
     * const fileToPost = await prisma.fileToPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileToPostFindUniqueArgs>(args: SelectSubset<T, FileToPostFindUniqueArgs<ExtArgs>>): Prisma__FileToPostClient<$Result.GetResult<Prisma.$FileToPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FileToPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FileToPostFindUniqueOrThrowArgs} args - Arguments to find a FileToPost
     * @example
     * // Get one FileToPost
     * const fileToPost = await prisma.fileToPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileToPostFindUniqueOrThrowArgs>(args: SelectSubset<T, FileToPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileToPostClient<$Result.GetResult<Prisma.$FileToPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FileToPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileToPostFindFirstArgs} args - Arguments to find a FileToPost
     * @example
     * // Get one FileToPost
     * const fileToPost = await prisma.fileToPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileToPostFindFirstArgs>(args?: SelectSubset<T, FileToPostFindFirstArgs<ExtArgs>>): Prisma__FileToPostClient<$Result.GetResult<Prisma.$FileToPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FileToPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileToPostFindFirstOrThrowArgs} args - Arguments to find a FileToPost
     * @example
     * // Get one FileToPost
     * const fileToPost = await prisma.fileToPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileToPostFindFirstOrThrowArgs>(args?: SelectSubset<T, FileToPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileToPostClient<$Result.GetResult<Prisma.$FileToPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FileToPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileToPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileToPosts
     * const fileToPosts = await prisma.fileToPost.findMany()
     * 
     * // Get first 10 FileToPosts
     * const fileToPosts = await prisma.fileToPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileToPostWithIdOnly = await prisma.fileToPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileToPostFindManyArgs>(args?: SelectSubset<T, FileToPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileToPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FileToPost.
     * @param {FileToPostCreateArgs} args - Arguments to create a FileToPost.
     * @example
     * // Create one FileToPost
     * const FileToPost = await prisma.fileToPost.create({
     *   data: {
     *     // ... data to create a FileToPost
     *   }
     * })
     * 
     */
    create<T extends FileToPostCreateArgs>(args: SelectSubset<T, FileToPostCreateArgs<ExtArgs>>): Prisma__FileToPostClient<$Result.GetResult<Prisma.$FileToPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FileToPosts.
     * @param {FileToPostCreateManyArgs} args - Arguments to create many FileToPosts.
     * @example
     * // Create many FileToPosts
     * const fileToPost = await prisma.fileToPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileToPostCreateManyArgs>(args?: SelectSubset<T, FileToPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FileToPost.
     * @param {FileToPostDeleteArgs} args - Arguments to delete one FileToPost.
     * @example
     * // Delete one FileToPost
     * const FileToPost = await prisma.fileToPost.delete({
     *   where: {
     *     // ... filter to delete one FileToPost
     *   }
     * })
     * 
     */
    delete<T extends FileToPostDeleteArgs>(args: SelectSubset<T, FileToPostDeleteArgs<ExtArgs>>): Prisma__FileToPostClient<$Result.GetResult<Prisma.$FileToPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FileToPost.
     * @param {FileToPostUpdateArgs} args - Arguments to update one FileToPost.
     * @example
     * // Update one FileToPost
     * const fileToPost = await prisma.fileToPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileToPostUpdateArgs>(args: SelectSubset<T, FileToPostUpdateArgs<ExtArgs>>): Prisma__FileToPostClient<$Result.GetResult<Prisma.$FileToPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FileToPosts.
     * @param {FileToPostDeleteManyArgs} args - Arguments to filter FileToPosts to delete.
     * @example
     * // Delete a few FileToPosts
     * const { count } = await prisma.fileToPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileToPostDeleteManyArgs>(args?: SelectSubset<T, FileToPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileToPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileToPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileToPosts
     * const fileToPost = await prisma.fileToPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileToPostUpdateManyArgs>(args: SelectSubset<T, FileToPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FileToPost.
     * @param {FileToPostUpsertArgs} args - Arguments to update or create a FileToPost.
     * @example
     * // Update or create a FileToPost
     * const fileToPost = await prisma.fileToPost.upsert({
     *   create: {
     *     // ... data to create a FileToPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileToPost we want to update
     *   }
     * })
     */
    upsert<T extends FileToPostUpsertArgs>(args: SelectSubset<T, FileToPostUpsertArgs<ExtArgs>>): Prisma__FileToPostClient<$Result.GetResult<Prisma.$FileToPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more FileToPosts that matches the filter.
     * @param {FileToPostFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const fileToPost = await prisma.fileToPost.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: FileToPostFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FileToPost.
     * @param {FileToPostAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const fileToPost = await prisma.fileToPost.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FileToPostAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of FileToPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileToPostCountArgs} args - Arguments to filter FileToPosts to count.
     * @example
     * // Count the number of FileToPosts
     * const count = await prisma.fileToPost.count({
     *   where: {
     *     // ... the filter for the FileToPosts we want to count
     *   }
     * })
    **/
    count<T extends FileToPostCountArgs>(
      args?: Subset<T, FileToPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileToPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileToPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileToPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileToPostAggregateArgs>(args: Subset<T, FileToPostAggregateArgs>): Prisma.PrismaPromise<GetFileToPostAggregateType<T>>

    /**
     * Group by FileToPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileToPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileToPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileToPostGroupByArgs['orderBy'] }
        : { orderBy?: FileToPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileToPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileToPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileToPost model
   */
  readonly fields: FileToPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileToPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileToPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    file<T extends FileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FileDefaultArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileToPost model
   */ 
  interface FileToPostFieldRefs {
    readonly id: FieldRef<"FileToPost", 'String'>
    readonly fileId: FieldRef<"FileToPost", 'String'>
    readonly postId: FieldRef<"FileToPost", 'String'>
    readonly createdAt: FieldRef<"FileToPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileToPost findUnique
   */
  export type FileToPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileToPost
     */
    select?: FileToPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileToPostInclude<ExtArgs> | null
    /**
     * Filter, which FileToPost to fetch.
     */
    where: FileToPostWhereUniqueInput
  }

  /**
   * FileToPost findUniqueOrThrow
   */
  export type FileToPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileToPost
     */
    select?: FileToPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileToPostInclude<ExtArgs> | null
    /**
     * Filter, which FileToPost to fetch.
     */
    where: FileToPostWhereUniqueInput
  }

  /**
   * FileToPost findFirst
   */
  export type FileToPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileToPost
     */
    select?: FileToPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileToPostInclude<ExtArgs> | null
    /**
     * Filter, which FileToPost to fetch.
     */
    where?: FileToPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileToPosts to fetch.
     */
    orderBy?: FileToPostOrderByWithRelationInput | FileToPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileToPosts.
     */
    cursor?: FileToPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileToPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileToPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileToPosts.
     */
    distinct?: FileToPostScalarFieldEnum | FileToPostScalarFieldEnum[]
  }

  /**
   * FileToPost findFirstOrThrow
   */
  export type FileToPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileToPost
     */
    select?: FileToPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileToPostInclude<ExtArgs> | null
    /**
     * Filter, which FileToPost to fetch.
     */
    where?: FileToPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileToPosts to fetch.
     */
    orderBy?: FileToPostOrderByWithRelationInput | FileToPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileToPosts.
     */
    cursor?: FileToPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileToPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileToPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileToPosts.
     */
    distinct?: FileToPostScalarFieldEnum | FileToPostScalarFieldEnum[]
  }

  /**
   * FileToPost findMany
   */
  export type FileToPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileToPost
     */
    select?: FileToPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileToPostInclude<ExtArgs> | null
    /**
     * Filter, which FileToPosts to fetch.
     */
    where?: FileToPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileToPosts to fetch.
     */
    orderBy?: FileToPostOrderByWithRelationInput | FileToPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileToPosts.
     */
    cursor?: FileToPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileToPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileToPosts.
     */
    skip?: number
    distinct?: FileToPostScalarFieldEnum | FileToPostScalarFieldEnum[]
  }

  /**
   * FileToPost create
   */
  export type FileToPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileToPost
     */
    select?: FileToPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileToPostInclude<ExtArgs> | null
    /**
     * The data needed to create a FileToPost.
     */
    data: XOR<FileToPostCreateInput, FileToPostUncheckedCreateInput>
  }

  /**
   * FileToPost createMany
   */
  export type FileToPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileToPosts.
     */
    data: FileToPostCreateManyInput | FileToPostCreateManyInput[]
  }

  /**
   * FileToPost update
   */
  export type FileToPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileToPost
     */
    select?: FileToPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileToPostInclude<ExtArgs> | null
    /**
     * The data needed to update a FileToPost.
     */
    data: XOR<FileToPostUpdateInput, FileToPostUncheckedUpdateInput>
    /**
     * Choose, which FileToPost to update.
     */
    where: FileToPostWhereUniqueInput
  }

  /**
   * FileToPost updateMany
   */
  export type FileToPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileToPosts.
     */
    data: XOR<FileToPostUpdateManyMutationInput, FileToPostUncheckedUpdateManyInput>
    /**
     * Filter which FileToPosts to update
     */
    where?: FileToPostWhereInput
  }

  /**
   * FileToPost upsert
   */
  export type FileToPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileToPost
     */
    select?: FileToPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileToPostInclude<ExtArgs> | null
    /**
     * The filter to search for the FileToPost to update in case it exists.
     */
    where: FileToPostWhereUniqueInput
    /**
     * In case the FileToPost found by the `where` argument doesn't exist, create a new FileToPost with this data.
     */
    create: XOR<FileToPostCreateInput, FileToPostUncheckedCreateInput>
    /**
     * In case the FileToPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileToPostUpdateInput, FileToPostUncheckedUpdateInput>
  }

  /**
   * FileToPost delete
   */
  export type FileToPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileToPost
     */
    select?: FileToPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileToPostInclude<ExtArgs> | null
    /**
     * Filter which FileToPost to delete.
     */
    where: FileToPostWhereUniqueInput
  }

  /**
   * FileToPost deleteMany
   */
  export type FileToPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileToPosts to delete
     */
    where?: FileToPostWhereInput
  }

  /**
   * FileToPost findRaw
   */
  export type FileToPostFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FileToPost aggregateRaw
   */
  export type FileToPostAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FileToPost without action
   */
  export type FileToPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileToPost
     */
    select?: FileToPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileToPostInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const MediaScalarFieldEnum: {
    id: 'id',
    mediaType: 'mediaType',
    status: 'status',
    fileContent: 'fileContent',
    fileName: 'fileName',
    transcription: 'transcription',
    extractedText: 'extractedText',
    createdAt: 'createdAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    parentSpaceId: 'parentSpaceId',
    title: 'title',
    content: 'content',
    description: 'description',
    status: 'status',
    workflowStatus: 'workflowStatus',
    assignedTo: 'assignedTo',
    contentFormat: 'contentFormat',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    publishedAt: 'publishedAt',
    postType: 'postType',
    category: 'category',
    threadParticipantType: 'threadParticipantType',
    backendPlatformUserId: 'backendPlatformUserId',
    profileId: 'profileId',
    authorUsername: 'authorUsername',
    authorProfileImage: 'authorProfileImage',
    authorAccountType: 'authorAccountType',
    tags: 'tags',
    mentions: 'mentions',
    hashtags: 'hashtags',
    topicName: 'topicName',
    mediaId: 'mediaId',
    backgroundImageUrl: 'backgroundImageUrl',
    affinityScore: 'affinityScore',
    qualityScore: 'qualityScore',
    viewCount: 'viewCount',
    userIdToAffinityScoreMap: 'userIdToAffinityScoreMap',
    userIdToReportsMap: 'userIdToReportsMap',
    userIdToReactionMap: 'userIdToReactionMap',
    readingTime: 'readingTime',
    aiGeneratedQuestionResponse: 'aiGeneratedQuestionResponse',
    threadId: 'threadId',
    spaceId: 'spaceId',
    channelId: 'channelId',
    extra: 'extra',
    visibility: 'visibility',
    isPinned: 'isPinned',
    isArchived: 'isArchived',
    workflow: 'workflow',
    version: 'version'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const PollPostScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    action: 'action',
    content: 'content',
    title: 'title',
    pollOptions: 'pollOptions',
    pollDistribution: 'pollDistribution',
    userIdToPollResponsesMap: 'userIdToPollResponsesMap',
    pollEndDate: 'pollEndDate',
    mentions: 'mentions',
    hashtags: 'hashtags',
    tags: 'tags',
    topicName: 'topicName',
    backendPlatformUserId: 'backendPlatformUserId',
    profileId: 'profileId',
    mediaId: 'mediaId',
    threadId: 'threadId',
    extra: 'extra'
  };

  export type PollPostScalarFieldEnum = (typeof PollPostScalarFieldEnum)[keyof typeof PollPostScalarFieldEnum]


  export const SpaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    spaceType: 'spaceType',
    status: 'status',
    visibility: 'visibility',
    parentSpaceId: 'parentSpaceId',
    isPrivate: 'isPrivate',
    metadata: 'metadata',
    settings: 'settings',
    accessLevel: 'accessLevel',
    tags: 'tags'
  };

  export type SpaceScalarFieldEnum = (typeof SpaceScalarFieldEnum)[keyof typeof SpaceScalarFieldEnum]


  export const ChannelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    spaceId: 'spaceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    pinnedPosts: 'pinnedPosts',
    isPrivate: 'isPrivate',
    metadata: 'metadata',
    settings: 'settings'
  };

  export type ChannelScalarFieldEnum = (typeof ChannelScalarFieldEnum)[keyof typeof ChannelScalarFieldEnum]


  export const ThreadScalarFieldEnum: {
    id: 'id',
    postIds: 'postIds',
    parentPostId: 'parentPostId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    metadata: 'metadata',
    status: 'status',
    isLocked: 'isLocked'
  };

  export type ThreadScalarFieldEnum = (typeof ThreadScalarFieldEnum)[keyof typeof ThreadScalarFieldEnum]


  export const NoteScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    authorId: 'authorId',
    backendPlatformUserId: 'backendPlatformUserId',
    profileId: 'profileId',
    authorUserName: 'authorUserName',
    authorProfileImage: 'authorProfileImage',
    authorAccountType: 'authorAccountType',
    mentions: 'mentions',
    hashtags: 'hashtags',
    mediaId: 'mediaId',
    postId: 'postId',
    commentId: 'commentId'
  };

  export type NoteScalarFieldEnum = (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    content: 'content',
    createdAt: 'createdAt',
    backendPlatformUserId: 'backendPlatformUserId',
    profileId: 'profileId',
    authorUsername: 'authorUsername',
    authorProfileImage: 'authorProfileImage',
    authorAccountType: 'authorAccountType',
    affinityScore: 'affinityScore',
    qualityScore: 'qualityScore',
    userIdToAffinityScoreMap: 'userIdToAffinityScoreMap',
    userIdToReportsMap: 'userIdToReportsMap',
    userIdToReactionMap: 'userIdToReactionMap',
    mentions: 'mentions',
    hashtags: 'hashtags',
    postId: 'postId',
    pollPostId: 'pollPostId',
    extra: 'extra',
    mediaId: 'mediaId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const CommentReplyScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    backendPlatformUserId: 'backendPlatformUserId',
    profileId: 'profileId',
    authorUsername: 'authorUsername',
    authorProfileImage: 'authorProfileImage',
    authorAccountType: 'authorAccountType',
    affinityScore: 'affinityScore',
    qualityScore: 'qualityScore',
    userIdToAffinityScoreMap: 'userIdToAffinityScoreMap',
    userIdToReportsMap: 'userIdToReportsMap',
    userIdToReactionMap: 'userIdToReactionMap',
    mentions: 'mentions',
    hashtags: 'hashtags',
    mediaid: 'mediaid',
    commentId: 'commentId',
    extra: 'extra'
  };

  export type CommentReplyScalarFieldEnum = (typeof CommentReplyScalarFieldEnum)[keyof typeof CommentReplyScalarFieldEnum]


  export const SpaceMemberScalarFieldEnum: {
    id: 'id',
    spaceId: 'spaceId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt',
    status: 'status',
    permissions: 'permissions'
  };

  export type SpaceMemberScalarFieldEnum = (typeof SpaceMemberScalarFieldEnum)[keyof typeof SpaceMemberScalarFieldEnum]


  export const ChannelMemberScalarFieldEnum: {
    id: 'id',
    channelId: 'channelId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt',
    lastRead: 'lastRead'
  };

  export type ChannelMemberScalarFieldEnum = (typeof ChannelMemberScalarFieldEnum)[keyof typeof ChannelMemberScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    url: 'url',
    uploadedBy: 'uploadedBy',
    uploadedAt: 'uploadedAt',
    size: 'size',
    status: 'status',
    preview: 'preview',
    thumbnail: 'thumbnail',
    spaceId: 'spaceId',
    channelId: 'channelId'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const FileToPostScalarFieldEnum: {
    id: 'id',
    fileId: 'fileId',
    postId: 'postId',
    createdAt: 'createdAt'
  };

  export type FileToPostScalarFieldEnum = (typeof FileToPostScalarFieldEnum)[keyof typeof FileToPostScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PostType'
   */
  export type EnumPostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostType'>
    


  /**
   * Reference to a field of type 'PostType[]'
   */
  export type ListEnumPostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostType[]'>
    


  /**
   * Reference to a field of type 'Category'
   */
  export type EnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category'>
    


  /**
   * Reference to a field of type 'Category[]'
   */
  export type ListEnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category[]'>
    


  /**
   * Reference to a field of type 'ThreadParticipantType'
   */
  export type EnumThreadParticipantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ThreadParticipantType'>
    


  /**
   * Reference to a field of type 'ThreadParticipantType[]'
   */
  export type ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ThreadParticipantType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SpaceType'
   */
  export type EnumSpaceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SpaceType'>
    


  /**
   * Reference to a field of type 'SpaceType[]'
   */
  export type ListEnumSpaceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SpaceType[]'>
    


  /**
   * Reference to a field of type 'AccessLevel'
   */
  export type EnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel'>
    


  /**
   * Reference to a field of type 'AccessLevel[]'
   */
  export type ListEnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    mediaType?: StringFilter<"Media"> | string
    status?: StringFilter<"Media"> | string
    fileContent?: StringNullableFilter<"Media"> | string | null
    fileName?: StringFilter<"Media"> | string
    transcription?: StringNullableFilter<"Media"> | string | null
    extractedText?: StringNullableFilter<"Media"> | string | null
    createdAt?: DateTimeFilter<"Media"> | Date | string
    CommentReply?: CommentReplyListRelationFilter
    Post?: PostListRelationFilter
    Comment?: CommentListRelationFilter
    PollPost?: PollPostListRelationFilter
    Note?: NoteListRelationFilter
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    mediaType?: SortOrder
    status?: SortOrder
    fileContent?: SortOrder
    fileName?: SortOrder
    transcription?: SortOrder
    extractedText?: SortOrder
    createdAt?: SortOrder
    CommentReply?: CommentReplyOrderByRelationAggregateInput
    Post?: PostOrderByRelationAggregateInput
    Comment?: CommentOrderByRelationAggregateInput
    PollPost?: PollPostOrderByRelationAggregateInput
    Note?: NoteOrderByRelationAggregateInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    mediaType?: StringFilter<"Media"> | string
    status?: StringFilter<"Media"> | string
    fileContent?: StringNullableFilter<"Media"> | string | null
    fileName?: StringFilter<"Media"> | string
    transcription?: StringNullableFilter<"Media"> | string | null
    extractedText?: StringNullableFilter<"Media"> | string | null
    createdAt?: DateTimeFilter<"Media"> | Date | string
    CommentReply?: CommentReplyListRelationFilter
    Post?: PostListRelationFilter
    Comment?: CommentListRelationFilter
    PollPost?: PollPostListRelationFilter
    Note?: NoteListRelationFilter
  }, "id">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    mediaType?: SortOrder
    status?: SortOrder
    fileContent?: SortOrder
    fileName?: SortOrder
    transcription?: SortOrder
    extractedText?: SortOrder
    createdAt?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    mediaType?: StringWithAggregatesFilter<"Media"> | string
    status?: StringWithAggregatesFilter<"Media"> | string
    fileContent?: StringNullableWithAggregatesFilter<"Media"> | string | null
    fileName?: StringWithAggregatesFilter<"Media"> | string
    transcription?: StringNullableWithAggregatesFilter<"Media"> | string | null
    extractedText?: StringNullableWithAggregatesFilter<"Media"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    authorId?: StringFilter<"Post"> | string
    parentSpaceId?: StringNullableFilter<"Post"> | string | null
    title?: StringNullableFilter<"Post"> | string | null
    content?: StringFilter<"Post"> | string
    description?: StringNullableFilter<"Post"> | string | null
    status?: StringFilter<"Post"> | string
    workflowStatus?: StringNullableFilter<"Post"> | string | null
    assignedTo?: StringNullableFilter<"Post"> | string | null
    contentFormat?: StringFilter<"Post"> | string
    createdAt?: StringFilter<"Post"> | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    postType?: EnumPostTypeFilter<"Post"> | $Enums.PostType
    category?: EnumCategoryNullableFilter<"Post"> | $Enums.Category | null
    threadParticipantType?: EnumThreadParticipantTypeNullableFilter<"Post"> | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFilter<"Post"> | string
    profileId?: IntFilter<"Post"> | number
    authorUsername?: StringFilter<"Post"> | string
    authorProfileImage?: StringNullableFilter<"Post"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Post"> | $Enums.AccountType
    tags?: StringNullableListFilter<"Post">
    mentions?: StringNullableListFilter<"Post">
    hashtags?: StringNullableListFilter<"Post">
    topicName?: StringNullableFilter<"Post"> | string | null
    mediaId?: StringNullableFilter<"Post"> | string | null
    backgroundImageUrl?: StringNullableFilter<"Post"> | string | null
    affinityScore?: IntFilter<"Post"> | number
    qualityScore?: IntFilter<"Post"> | number
    viewCount?: IntFilter<"Post"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"Post">
    userIdToReportsMap?: JsonNullableFilter<"Post">
    userIdToReactionMap?: JsonNullableFilter<"Post">
    insights?: XOR<ContentInsightsNullableCompositeFilter, ContentInsightsObjectEqualityInput> | null
    readingTime?: StringNullableFilter<"Post"> | string | null
    aiGeneratedQuestionResponse?: StringNullableFilter<"Post"> | string | null
    aiAnalysis?: XOR<AIAnalysisNullableCompositeFilter, AIAnalysisObjectEqualityInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCompositeFilter, SearchMetadataObjectEqualityInput> | null
    threadId?: StringNullableFilter<"Post"> | string | null
    spaceId?: StringNullableFilter<"Post"> | string | null
    channelId?: StringNullableFilter<"Post"> | string | null
    extra?: JsonNullableFilter<"Post">
    visibility?: StringFilter<"Post"> | string
    isPinned?: BoolFilter<"Post"> | boolean
    isArchived?: BoolFilter<"Post"> | boolean
    workflow?: JsonNullableFilter<"Post">
    version?: IntFilter<"Post"> | number
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    files?: FileToPostListRelationFilter
    comments?: CommentListRelationFilter
    notes?: NoteListRelationFilter
    thread?: XOR<ThreadNullableRelationFilter, ThreadWhereInput> | null
    space?: XOR<SpaceNullableRelationFilter, SpaceWhereInput> | null
    channel?: XOR<ChannelNullableRelationFilter, ChannelWhereInput> | null
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    parentSpaceId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    description?: SortOrder
    status?: SortOrder
    workflowStatus?: SortOrder
    assignedTo?: SortOrder
    contentFormat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    postType?: SortOrder
    category?: SortOrder
    threadParticipantType?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    tags?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    topicName?: SortOrder
    mediaId?: SortOrder
    backgroundImageUrl?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    userIdToAffinityScoreMap?: SortOrder
    userIdToReportsMap?: SortOrder
    userIdToReactionMap?: SortOrder
    insights?: ContentInsightsOrderByInput
    readingTime?: SortOrder
    aiGeneratedQuestionResponse?: SortOrder
    aiAnalysis?: AIAnalysisOrderByInput
    searchMetadata?: SearchMetadataOrderByInput
    threadId?: SortOrder
    spaceId?: SortOrder
    channelId?: SortOrder
    extra?: SortOrder
    visibility?: SortOrder
    isPinned?: SortOrder
    isArchived?: SortOrder
    workflow?: SortOrder
    version?: SortOrder
    media?: MediaOrderByWithRelationInput
    files?: FileToPostOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    thread?: ThreadOrderByWithRelationInput
    space?: SpaceOrderByWithRelationInput
    channel?: ChannelOrderByWithRelationInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    authorId?: StringFilter<"Post"> | string
    parentSpaceId?: StringNullableFilter<"Post"> | string | null
    title?: StringNullableFilter<"Post"> | string | null
    content?: StringFilter<"Post"> | string
    description?: StringNullableFilter<"Post"> | string | null
    status?: StringFilter<"Post"> | string
    workflowStatus?: StringNullableFilter<"Post"> | string | null
    assignedTo?: StringNullableFilter<"Post"> | string | null
    contentFormat?: StringFilter<"Post"> | string
    createdAt?: StringFilter<"Post"> | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    postType?: EnumPostTypeFilter<"Post"> | $Enums.PostType
    category?: EnumCategoryNullableFilter<"Post"> | $Enums.Category | null
    threadParticipantType?: EnumThreadParticipantTypeNullableFilter<"Post"> | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFilter<"Post"> | string
    profileId?: IntFilter<"Post"> | number
    authorUsername?: StringFilter<"Post"> | string
    authorProfileImage?: StringNullableFilter<"Post"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Post"> | $Enums.AccountType
    tags?: StringNullableListFilter<"Post">
    mentions?: StringNullableListFilter<"Post">
    hashtags?: StringNullableListFilter<"Post">
    topicName?: StringNullableFilter<"Post"> | string | null
    mediaId?: StringNullableFilter<"Post"> | string | null
    backgroundImageUrl?: StringNullableFilter<"Post"> | string | null
    affinityScore?: IntFilter<"Post"> | number
    qualityScore?: IntFilter<"Post"> | number
    viewCount?: IntFilter<"Post"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"Post">
    userIdToReportsMap?: JsonNullableFilter<"Post">
    userIdToReactionMap?: JsonNullableFilter<"Post">
    insights?: XOR<ContentInsightsNullableCompositeFilter, ContentInsightsObjectEqualityInput> | null
    readingTime?: StringNullableFilter<"Post"> | string | null
    aiGeneratedQuestionResponse?: StringNullableFilter<"Post"> | string | null
    aiAnalysis?: XOR<AIAnalysisNullableCompositeFilter, AIAnalysisObjectEqualityInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCompositeFilter, SearchMetadataObjectEqualityInput> | null
    threadId?: StringNullableFilter<"Post"> | string | null
    spaceId?: StringNullableFilter<"Post"> | string | null
    channelId?: StringNullableFilter<"Post"> | string | null
    extra?: JsonNullableFilter<"Post">
    visibility?: StringFilter<"Post"> | string
    isPinned?: BoolFilter<"Post"> | boolean
    isArchived?: BoolFilter<"Post"> | boolean
    workflow?: JsonNullableFilter<"Post">
    version?: IntFilter<"Post"> | number
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    files?: FileToPostListRelationFilter
    comments?: CommentListRelationFilter
    notes?: NoteListRelationFilter
    thread?: XOR<ThreadNullableRelationFilter, ThreadWhereInput> | null
    space?: XOR<SpaceNullableRelationFilter, SpaceWhereInput> | null
    channel?: XOR<ChannelNullableRelationFilter, ChannelWhereInput> | null
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    parentSpaceId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    description?: SortOrder
    status?: SortOrder
    workflowStatus?: SortOrder
    assignedTo?: SortOrder
    contentFormat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    postType?: SortOrder
    category?: SortOrder
    threadParticipantType?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    tags?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    topicName?: SortOrder
    mediaId?: SortOrder
    backgroundImageUrl?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    userIdToAffinityScoreMap?: SortOrder
    userIdToReportsMap?: SortOrder
    userIdToReactionMap?: SortOrder
    readingTime?: SortOrder
    aiGeneratedQuestionResponse?: SortOrder
    threadId?: SortOrder
    spaceId?: SortOrder
    channelId?: SortOrder
    extra?: SortOrder
    visibility?: SortOrder
    isPinned?: SortOrder
    isArchived?: SortOrder
    workflow?: SortOrder
    version?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    authorId?: StringWithAggregatesFilter<"Post"> | string
    parentSpaceId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    title?: StringNullableWithAggregatesFilter<"Post"> | string | null
    content?: StringWithAggregatesFilter<"Post"> | string
    description?: StringNullableWithAggregatesFilter<"Post"> | string | null
    status?: StringWithAggregatesFilter<"Post"> | string
    workflowStatus?: StringNullableWithAggregatesFilter<"Post"> | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"Post"> | string | null
    contentFormat?: StringWithAggregatesFilter<"Post"> | string
    createdAt?: StringWithAggregatesFilter<"Post"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Post"> | Date | string | null
    postType?: EnumPostTypeWithAggregatesFilter<"Post"> | $Enums.PostType
    category?: EnumCategoryNullableWithAggregatesFilter<"Post"> | $Enums.Category | null
    threadParticipantType?: EnumThreadParticipantTypeNullableWithAggregatesFilter<"Post"> | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringWithAggregatesFilter<"Post"> | string
    profileId?: IntWithAggregatesFilter<"Post"> | number
    authorUsername?: StringWithAggregatesFilter<"Post"> | string
    authorProfileImage?: StringNullableWithAggregatesFilter<"Post"> | string | null
    authorAccountType?: EnumAccountTypeWithAggregatesFilter<"Post"> | $Enums.AccountType
    tags?: StringNullableListFilter<"Post">
    mentions?: StringNullableListFilter<"Post">
    hashtags?: StringNullableListFilter<"Post">
    topicName?: StringNullableWithAggregatesFilter<"Post"> | string | null
    mediaId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    backgroundImageUrl?: StringNullableWithAggregatesFilter<"Post"> | string | null
    affinityScore?: IntWithAggregatesFilter<"Post"> | number
    qualityScore?: IntWithAggregatesFilter<"Post"> | number
    viewCount?: IntWithAggregatesFilter<"Post"> | number
    userIdToAffinityScoreMap?: JsonNullableWithAggregatesFilter<"Post">
    userIdToReportsMap?: JsonNullableWithAggregatesFilter<"Post">
    userIdToReactionMap?: JsonNullableWithAggregatesFilter<"Post">
    readingTime?: StringNullableWithAggregatesFilter<"Post"> | string | null
    aiGeneratedQuestionResponse?: StringNullableWithAggregatesFilter<"Post"> | string | null
    threadId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    spaceId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    channelId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    extra?: JsonNullableWithAggregatesFilter<"Post">
    visibility?: StringWithAggregatesFilter<"Post"> | string
    isPinned?: BoolWithAggregatesFilter<"Post"> | boolean
    isArchived?: BoolWithAggregatesFilter<"Post"> | boolean
    workflow?: JsonNullableWithAggregatesFilter<"Post">
    version?: IntWithAggregatesFilter<"Post"> | number
  }

  export type PollPostWhereInput = {
    AND?: PollPostWhereInput | PollPostWhereInput[]
    OR?: PollPostWhereInput[]
    NOT?: PollPostWhereInput | PollPostWhereInput[]
    id?: StringFilter<"PollPost"> | string
    createdAt?: StringFilter<"PollPost"> | string
    action?: EnumPostTypeFilter<"PollPost"> | $Enums.PostType
    content?: StringFilter<"PollPost"> | string
    title?: StringNullableFilter<"PollPost"> | string | null
    pollOptions?: StringNullableListFilter<"PollPost">
    pollDistribution?: JsonNullableFilter<"PollPost">
    userIdToPollResponsesMap?: JsonNullableFilter<"PollPost">
    pollEndDate?: DateTimeFilter<"PollPost"> | Date | string
    mentions?: StringNullableListFilter<"PollPost">
    hashtags?: StringNullableListFilter<"PollPost">
    tags?: StringNullableListFilter<"PollPost">
    topicName?: StringNullableFilter<"PollPost"> | string | null
    backendPlatformUserId?: StringFilter<"PollPost"> | string
    profileId?: IntFilter<"PollPost"> | number
    mediaId?: StringNullableFilter<"PollPost"> | string | null
    threadId?: StringNullableFilter<"PollPost"> | string | null
    extra?: JsonNullableFilter<"PollPost">
    searchMetadata?: XOR<SearchMetadataNullableCompositeFilter, SearchMetadataObjectEqualityInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCompositeFilter, AIAnalysisObjectEqualityInput> | null
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    comments?: CommentListRelationFilter
    thread?: XOR<ThreadNullableRelationFilter, ThreadWhereInput> | null
  }

  export type PollPostOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    content?: SortOrder
    title?: SortOrder
    pollOptions?: SortOrder
    pollDistribution?: SortOrder
    userIdToPollResponsesMap?: SortOrder
    pollEndDate?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    tags?: SortOrder
    topicName?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    mediaId?: SortOrder
    threadId?: SortOrder
    extra?: SortOrder
    searchMetadata?: SearchMetadataOrderByInput
    aiAnalysis?: AIAnalysisOrderByInput
    media?: MediaOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    thread?: ThreadOrderByWithRelationInput
  }

  export type PollPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PollPostWhereInput | PollPostWhereInput[]
    OR?: PollPostWhereInput[]
    NOT?: PollPostWhereInput | PollPostWhereInput[]
    createdAt?: StringFilter<"PollPost"> | string
    action?: EnumPostTypeFilter<"PollPost"> | $Enums.PostType
    content?: StringFilter<"PollPost"> | string
    title?: StringNullableFilter<"PollPost"> | string | null
    pollOptions?: StringNullableListFilter<"PollPost">
    pollDistribution?: JsonNullableFilter<"PollPost">
    userIdToPollResponsesMap?: JsonNullableFilter<"PollPost">
    pollEndDate?: DateTimeFilter<"PollPost"> | Date | string
    mentions?: StringNullableListFilter<"PollPost">
    hashtags?: StringNullableListFilter<"PollPost">
    tags?: StringNullableListFilter<"PollPost">
    topicName?: StringNullableFilter<"PollPost"> | string | null
    backendPlatformUserId?: StringFilter<"PollPost"> | string
    profileId?: IntFilter<"PollPost"> | number
    mediaId?: StringNullableFilter<"PollPost"> | string | null
    threadId?: StringNullableFilter<"PollPost"> | string | null
    extra?: JsonNullableFilter<"PollPost">
    searchMetadata?: XOR<SearchMetadataNullableCompositeFilter, SearchMetadataObjectEqualityInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCompositeFilter, AIAnalysisObjectEqualityInput> | null
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    comments?: CommentListRelationFilter
    thread?: XOR<ThreadNullableRelationFilter, ThreadWhereInput> | null
  }, "id">

  export type PollPostOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    content?: SortOrder
    title?: SortOrder
    pollOptions?: SortOrder
    pollDistribution?: SortOrder
    userIdToPollResponsesMap?: SortOrder
    pollEndDate?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    tags?: SortOrder
    topicName?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    mediaId?: SortOrder
    threadId?: SortOrder
    extra?: SortOrder
    _count?: PollPostCountOrderByAggregateInput
    _avg?: PollPostAvgOrderByAggregateInput
    _max?: PollPostMaxOrderByAggregateInput
    _min?: PollPostMinOrderByAggregateInput
    _sum?: PollPostSumOrderByAggregateInput
  }

  export type PollPostScalarWhereWithAggregatesInput = {
    AND?: PollPostScalarWhereWithAggregatesInput | PollPostScalarWhereWithAggregatesInput[]
    OR?: PollPostScalarWhereWithAggregatesInput[]
    NOT?: PollPostScalarWhereWithAggregatesInput | PollPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PollPost"> | string
    createdAt?: StringWithAggregatesFilter<"PollPost"> | string
    action?: EnumPostTypeWithAggregatesFilter<"PollPost"> | $Enums.PostType
    content?: StringWithAggregatesFilter<"PollPost"> | string
    title?: StringNullableWithAggregatesFilter<"PollPost"> | string | null
    pollOptions?: StringNullableListFilter<"PollPost">
    pollDistribution?: JsonNullableWithAggregatesFilter<"PollPost">
    userIdToPollResponsesMap?: JsonNullableWithAggregatesFilter<"PollPost">
    pollEndDate?: DateTimeWithAggregatesFilter<"PollPost"> | Date | string
    mentions?: StringNullableListFilter<"PollPost">
    hashtags?: StringNullableListFilter<"PollPost">
    tags?: StringNullableListFilter<"PollPost">
    topicName?: StringNullableWithAggregatesFilter<"PollPost"> | string | null
    backendPlatformUserId?: StringWithAggregatesFilter<"PollPost"> | string
    profileId?: IntWithAggregatesFilter<"PollPost"> | number
    mediaId?: StringNullableWithAggregatesFilter<"PollPost"> | string | null
    threadId?: StringNullableWithAggregatesFilter<"PollPost"> | string | null
    extra?: JsonNullableWithAggregatesFilter<"PollPost">
  }

  export type SpaceWhereInput = {
    AND?: SpaceWhereInput | SpaceWhereInput[]
    OR?: SpaceWhereInput[]
    NOT?: SpaceWhereInput | SpaceWhereInput[]
    id?: StringFilter<"Space"> | string
    name?: StringFilter<"Space"> | string
    description?: StringNullableFilter<"Space"> | string | null
    type?: EnumSpaceTypeFilter<"Space"> | $Enums.SpaceType
    createdAt?: DateTimeFilter<"Space"> | Date | string
    updatedAt?: DateTimeFilter<"Space"> | Date | string
    spaceType?: StringFilter<"Space"> | string
    status?: StringFilter<"Space"> | string
    visibility?: StringFilter<"Space"> | string
    parentSpaceId?: StringNullableFilter<"Space"> | string | null
    isPrivate?: BoolFilter<"Space"> | boolean
    metadata?: JsonNullableFilter<"Space">
    settings?: JsonNullableFilter<"Space">
    accessLevel?: EnumAccessLevelFilter<"Space"> | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCompositeFilter, SearchMetadataObjectEqualityInput> | null
    tags?: StringNullableListFilter<"Space">
    members?: SpaceMemberListRelationFilter
    channels?: ChannelListRelationFilter
    posts?: PostListRelationFilter
    files?: FileListRelationFilter
    parentSpace?: XOR<SpaceNullableRelationFilter, SpaceWhereInput> | null
    childSpaces?: SpaceListRelationFilter
  }

  export type SpaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    spaceType?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    parentSpaceId?: SortOrder
    isPrivate?: SortOrder
    metadata?: SortOrder
    settings?: SortOrder
    accessLevel?: SortOrder
    searchMetadata?: SearchMetadataOrderByInput
    tags?: SortOrder
    members?: SpaceMemberOrderByRelationAggregateInput
    channels?: ChannelOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    parentSpace?: SpaceOrderByWithRelationInput
    childSpaces?: SpaceOrderByRelationAggregateInput
  }

  export type SpaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpaceWhereInput | SpaceWhereInput[]
    OR?: SpaceWhereInput[]
    NOT?: SpaceWhereInput | SpaceWhereInput[]
    name?: StringFilter<"Space"> | string
    description?: StringNullableFilter<"Space"> | string | null
    type?: EnumSpaceTypeFilter<"Space"> | $Enums.SpaceType
    createdAt?: DateTimeFilter<"Space"> | Date | string
    updatedAt?: DateTimeFilter<"Space"> | Date | string
    spaceType?: StringFilter<"Space"> | string
    status?: StringFilter<"Space"> | string
    visibility?: StringFilter<"Space"> | string
    parentSpaceId?: StringNullableFilter<"Space"> | string | null
    isPrivate?: BoolFilter<"Space"> | boolean
    metadata?: JsonNullableFilter<"Space">
    settings?: JsonNullableFilter<"Space">
    accessLevel?: EnumAccessLevelFilter<"Space"> | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCompositeFilter, SearchMetadataObjectEqualityInput> | null
    tags?: StringNullableListFilter<"Space">
    members?: SpaceMemberListRelationFilter
    channels?: ChannelListRelationFilter
    posts?: PostListRelationFilter
    files?: FileListRelationFilter
    parentSpace?: XOR<SpaceNullableRelationFilter, SpaceWhereInput> | null
    childSpaces?: SpaceListRelationFilter
  }, "id">

  export type SpaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    spaceType?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    parentSpaceId?: SortOrder
    isPrivate?: SortOrder
    metadata?: SortOrder
    settings?: SortOrder
    accessLevel?: SortOrder
    tags?: SortOrder
    _count?: SpaceCountOrderByAggregateInput
    _max?: SpaceMaxOrderByAggregateInput
    _min?: SpaceMinOrderByAggregateInput
  }

  export type SpaceScalarWhereWithAggregatesInput = {
    AND?: SpaceScalarWhereWithAggregatesInput | SpaceScalarWhereWithAggregatesInput[]
    OR?: SpaceScalarWhereWithAggregatesInput[]
    NOT?: SpaceScalarWhereWithAggregatesInput | SpaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Space"> | string
    name?: StringWithAggregatesFilter<"Space"> | string
    description?: StringNullableWithAggregatesFilter<"Space"> | string | null
    type?: EnumSpaceTypeWithAggregatesFilter<"Space"> | $Enums.SpaceType
    createdAt?: DateTimeWithAggregatesFilter<"Space"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Space"> | Date | string
    spaceType?: StringWithAggregatesFilter<"Space"> | string
    status?: StringWithAggregatesFilter<"Space"> | string
    visibility?: StringWithAggregatesFilter<"Space"> | string
    parentSpaceId?: StringNullableWithAggregatesFilter<"Space"> | string | null
    isPrivate?: BoolWithAggregatesFilter<"Space"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Space">
    settings?: JsonNullableWithAggregatesFilter<"Space">
    accessLevel?: EnumAccessLevelWithAggregatesFilter<"Space"> | $Enums.AccessLevel
    tags?: StringNullableListFilter<"Space">
  }

  export type ChannelWhereInput = {
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    id?: StringFilter<"Channel"> | string
    name?: StringFilter<"Channel"> | string
    description?: StringNullableFilter<"Channel"> | string | null
    spaceId?: StringFilter<"Channel"> | string
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
    status?: StringFilter<"Channel"> | string
    pinnedPosts?: StringNullableListFilter<"Channel">
    isPrivate?: BoolFilter<"Channel"> | boolean
    metadata?: JsonNullableFilter<"Channel">
    settings?: JsonNullableFilter<"Channel">
    space?: XOR<SpaceRelationFilter, SpaceWhereInput>
    posts?: PostListRelationFilter
    files?: FileListRelationFilter
    members?: ChannelMemberListRelationFilter
  }

  export type ChannelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    spaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    pinnedPosts?: SortOrder
    isPrivate?: SortOrder
    metadata?: SortOrder
    settings?: SortOrder
    space?: SpaceOrderByWithRelationInput
    posts?: PostOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    members?: ChannelMemberOrderByRelationAggregateInput
  }

  export type ChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    name?: StringFilter<"Channel"> | string
    description?: StringNullableFilter<"Channel"> | string | null
    spaceId?: StringFilter<"Channel"> | string
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
    status?: StringFilter<"Channel"> | string
    pinnedPosts?: StringNullableListFilter<"Channel">
    isPrivate?: BoolFilter<"Channel"> | boolean
    metadata?: JsonNullableFilter<"Channel">
    settings?: JsonNullableFilter<"Channel">
    space?: XOR<SpaceRelationFilter, SpaceWhereInput>
    posts?: PostListRelationFilter
    files?: FileListRelationFilter
    members?: ChannelMemberListRelationFilter
  }, "id">

  export type ChannelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    spaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    pinnedPosts?: SortOrder
    isPrivate?: SortOrder
    metadata?: SortOrder
    settings?: SortOrder
    _count?: ChannelCountOrderByAggregateInput
    _max?: ChannelMaxOrderByAggregateInput
    _min?: ChannelMinOrderByAggregateInput
  }

  export type ChannelScalarWhereWithAggregatesInput = {
    AND?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    OR?: ChannelScalarWhereWithAggregatesInput[]
    NOT?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Channel"> | string
    name?: StringWithAggregatesFilter<"Channel"> | string
    description?: StringNullableWithAggregatesFilter<"Channel"> | string | null
    spaceId?: StringWithAggregatesFilter<"Channel"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Channel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Channel"> | Date | string
    status?: StringWithAggregatesFilter<"Channel"> | string
    pinnedPosts?: StringNullableListFilter<"Channel">
    isPrivate?: BoolWithAggregatesFilter<"Channel"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Channel">
    settings?: JsonNullableWithAggregatesFilter<"Channel">
  }

  export type ThreadWhereInput = {
    AND?: ThreadWhereInput | ThreadWhereInput[]
    OR?: ThreadWhereInput[]
    NOT?: ThreadWhereInput | ThreadWhereInput[]
    id?: StringFilter<"Thread"> | string
    postIds?: StringNullableListFilter<"Thread">
    parentPostId?: StringFilter<"Thread"> | string
    createdAt?: StringFilter<"Thread"> | string
    updatedAt?: StringFilter<"Thread"> | string
    metadata?: JsonNullableFilter<"Thread">
    status?: StringFilter<"Thread"> | string
    isLocked?: BoolFilter<"Thread"> | boolean
    posts?: PostListRelationFilter
    pollPosts?: PollPostListRelationFilter
  }

  export type ThreadOrderByWithRelationInput = {
    id?: SortOrder
    postIds?: SortOrder
    parentPostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
    status?: SortOrder
    isLocked?: SortOrder
    posts?: PostOrderByRelationAggregateInput
    pollPosts?: PollPostOrderByRelationAggregateInput
  }

  export type ThreadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ThreadWhereInput | ThreadWhereInput[]
    OR?: ThreadWhereInput[]
    NOT?: ThreadWhereInput | ThreadWhereInput[]
    postIds?: StringNullableListFilter<"Thread">
    parentPostId?: StringFilter<"Thread"> | string
    createdAt?: StringFilter<"Thread"> | string
    updatedAt?: StringFilter<"Thread"> | string
    metadata?: JsonNullableFilter<"Thread">
    status?: StringFilter<"Thread"> | string
    isLocked?: BoolFilter<"Thread"> | boolean
    posts?: PostListRelationFilter
    pollPosts?: PollPostListRelationFilter
  }, "id">

  export type ThreadOrderByWithAggregationInput = {
    id?: SortOrder
    postIds?: SortOrder
    parentPostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
    status?: SortOrder
    isLocked?: SortOrder
    _count?: ThreadCountOrderByAggregateInput
    _max?: ThreadMaxOrderByAggregateInput
    _min?: ThreadMinOrderByAggregateInput
  }

  export type ThreadScalarWhereWithAggregatesInput = {
    AND?: ThreadScalarWhereWithAggregatesInput | ThreadScalarWhereWithAggregatesInput[]
    OR?: ThreadScalarWhereWithAggregatesInput[]
    NOT?: ThreadScalarWhereWithAggregatesInput | ThreadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Thread"> | string
    postIds?: StringNullableListFilter<"Thread">
    parentPostId?: StringWithAggregatesFilter<"Thread"> | string
    createdAt?: StringWithAggregatesFilter<"Thread"> | string
    updatedAt?: StringWithAggregatesFilter<"Thread"> | string
    metadata?: JsonNullableWithAggregatesFilter<"Thread">
    status?: StringWithAggregatesFilter<"Thread"> | string
    isLocked?: BoolWithAggregatesFilter<"Thread"> | boolean
  }

  export type NoteWhereInput = {
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    id?: StringFilter<"Note"> | string
    content?: StringFilter<"Note"> | string
    createdAt?: StringFilter<"Note"> | string
    authorId?: StringFilter<"Note"> | string
    backendPlatformUserId?: StringFilter<"Note"> | string
    profileId?: IntFilter<"Note"> | number
    authorUserName?: StringFilter<"Note"> | string
    authorProfileImage?: StringNullableFilter<"Note"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Note"> | $Enums.AccountType
    mentions?: StringNullableListFilter<"Note">
    hashtags?: StringNullableListFilter<"Note">
    mediaId?: StringNullableFilter<"Note"> | string | null
    postId?: StringFilter<"Note"> | string
    commentId?: StringNullableFilter<"Note"> | string | null
    searchMetadata?: XOR<SearchMetadataNullableCompositeFilter, SearchMetadataObjectEqualityInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCompositeFilter, AIAnalysisObjectEqualityInput> | null
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    post?: XOR<PostRelationFilter, PostWhereInput>
    comment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
  }

  export type NoteOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    authorId?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUserName?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    mediaId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    searchMetadata?: SearchMetadataOrderByInput
    aiAnalysis?: AIAnalysisOrderByInput
    media?: MediaOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
  }

  export type NoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    content?: StringFilter<"Note"> | string
    createdAt?: StringFilter<"Note"> | string
    authorId?: StringFilter<"Note"> | string
    backendPlatformUserId?: StringFilter<"Note"> | string
    profileId?: IntFilter<"Note"> | number
    authorUserName?: StringFilter<"Note"> | string
    authorProfileImage?: StringNullableFilter<"Note"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Note"> | $Enums.AccountType
    mentions?: StringNullableListFilter<"Note">
    hashtags?: StringNullableListFilter<"Note">
    mediaId?: StringNullableFilter<"Note"> | string | null
    postId?: StringFilter<"Note"> | string
    commentId?: StringNullableFilter<"Note"> | string | null
    searchMetadata?: XOR<SearchMetadataNullableCompositeFilter, SearchMetadataObjectEqualityInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCompositeFilter, AIAnalysisObjectEqualityInput> | null
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    post?: XOR<PostRelationFilter, PostWhereInput>
    comment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
  }, "id">

  export type NoteOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    authorId?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUserName?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    mediaId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    _count?: NoteCountOrderByAggregateInput
    _avg?: NoteAvgOrderByAggregateInput
    _max?: NoteMaxOrderByAggregateInput
    _min?: NoteMinOrderByAggregateInput
    _sum?: NoteSumOrderByAggregateInput
  }

  export type NoteScalarWhereWithAggregatesInput = {
    AND?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    OR?: NoteScalarWhereWithAggregatesInput[]
    NOT?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Note"> | string
    content?: StringWithAggregatesFilter<"Note"> | string
    createdAt?: StringWithAggregatesFilter<"Note"> | string
    authorId?: StringWithAggregatesFilter<"Note"> | string
    backendPlatformUserId?: StringWithAggregatesFilter<"Note"> | string
    profileId?: IntWithAggregatesFilter<"Note"> | number
    authorUserName?: StringWithAggregatesFilter<"Note"> | string
    authorProfileImage?: StringNullableWithAggregatesFilter<"Note"> | string | null
    authorAccountType?: EnumAccountTypeWithAggregatesFilter<"Note"> | $Enums.AccountType
    mentions?: StringNullableListFilter<"Note">
    hashtags?: StringNullableListFilter<"Note">
    mediaId?: StringNullableWithAggregatesFilter<"Note"> | string | null
    postId?: StringWithAggregatesFilter<"Note"> | string
    commentId?: StringNullableWithAggregatesFilter<"Note"> | string | null
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: StringFilter<"Comment"> | string
    backendPlatformUserId?: StringFilter<"Comment"> | string
    profileId?: IntFilter<"Comment"> | number
    authorUsername?: StringFilter<"Comment"> | string
    authorProfileImage?: StringNullableFilter<"Comment"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Comment"> | $Enums.AccountType
    affinityScore?: IntFilter<"Comment"> | number
    qualityScore?: IntFilter<"Comment"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"Comment">
    userIdToReportsMap?: JsonNullableFilter<"Comment">
    userIdToReactionMap?: JsonNullableFilter<"Comment">
    mentions?: StringNullableListFilter<"Comment">
    hashtags?: StringNullableListFilter<"Comment">
    postId?: StringFilter<"Comment"> | string
    pollPostId?: StringNullableFilter<"Comment"> | string | null
    extra?: JsonNullableFilter<"Comment">
    aiAnalysis?: XOR<AIAnalysisNullableCompositeFilter, AIAnalysisObjectEqualityInput> | null
    mediaId?: StringNullableFilter<"Comment"> | string | null
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    replies?: CommentReplyListRelationFilter
    notes?: NoteListRelationFilter
    post?: XOR<PostRelationFilter, PostWhereInput>
    PollPost?: XOR<PollPostNullableRelationFilter, PollPostWhereInput> | null
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    userIdToAffinityScoreMap?: SortOrder
    userIdToReportsMap?: SortOrder
    userIdToReactionMap?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    postId?: SortOrder
    pollPostId?: SortOrder
    extra?: SortOrder
    aiAnalysis?: AIAnalysisOrderByInput
    mediaId?: SortOrder
    media?: MediaOrderByWithRelationInput
    replies?: CommentReplyOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    post?: PostOrderByWithRelationInput
    PollPost?: PollPostOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: StringFilter<"Comment"> | string
    backendPlatformUserId?: StringFilter<"Comment"> | string
    profileId?: IntFilter<"Comment"> | number
    authorUsername?: StringFilter<"Comment"> | string
    authorProfileImage?: StringNullableFilter<"Comment"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Comment"> | $Enums.AccountType
    affinityScore?: IntFilter<"Comment"> | number
    qualityScore?: IntFilter<"Comment"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"Comment">
    userIdToReportsMap?: JsonNullableFilter<"Comment">
    userIdToReactionMap?: JsonNullableFilter<"Comment">
    mentions?: StringNullableListFilter<"Comment">
    hashtags?: StringNullableListFilter<"Comment">
    postId?: StringFilter<"Comment"> | string
    pollPostId?: StringNullableFilter<"Comment"> | string | null
    extra?: JsonNullableFilter<"Comment">
    aiAnalysis?: XOR<AIAnalysisNullableCompositeFilter, AIAnalysisObjectEqualityInput> | null
    mediaId?: StringNullableFilter<"Comment"> | string | null
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    replies?: CommentReplyListRelationFilter
    notes?: NoteListRelationFilter
    post?: XOR<PostRelationFilter, PostWhereInput>
    PollPost?: XOR<PollPostNullableRelationFilter, PollPostWhereInput> | null
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    userIdToAffinityScoreMap?: SortOrder
    userIdToReportsMap?: SortOrder
    userIdToReactionMap?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    postId?: SortOrder
    pollPostId?: SortOrder
    extra?: SortOrder
    mediaId?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: StringWithAggregatesFilter<"Comment"> | string
    backendPlatformUserId?: StringWithAggregatesFilter<"Comment"> | string
    profileId?: IntWithAggregatesFilter<"Comment"> | number
    authorUsername?: StringWithAggregatesFilter<"Comment"> | string
    authorProfileImage?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    authorAccountType?: EnumAccountTypeWithAggregatesFilter<"Comment"> | $Enums.AccountType
    affinityScore?: IntWithAggregatesFilter<"Comment"> | number
    qualityScore?: IntWithAggregatesFilter<"Comment"> | number
    userIdToAffinityScoreMap?: JsonNullableWithAggregatesFilter<"Comment">
    userIdToReportsMap?: JsonNullableWithAggregatesFilter<"Comment">
    userIdToReactionMap?: JsonNullableWithAggregatesFilter<"Comment">
    mentions?: StringNullableListFilter<"Comment">
    hashtags?: StringNullableListFilter<"Comment">
    postId?: StringWithAggregatesFilter<"Comment"> | string
    pollPostId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    extra?: JsonNullableWithAggregatesFilter<"Comment">
    mediaId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
  }

  export type CommentReplyWhereInput = {
    AND?: CommentReplyWhereInput | CommentReplyWhereInput[]
    OR?: CommentReplyWhereInput[]
    NOT?: CommentReplyWhereInput | CommentReplyWhereInput[]
    id?: StringFilter<"CommentReply"> | string
    content?: StringFilter<"CommentReply"> | string
    createdAt?: StringFilter<"CommentReply"> | string
    backendPlatformUserId?: StringFilter<"CommentReply"> | string
    profileId?: IntFilter<"CommentReply"> | number
    authorUsername?: StringFilter<"CommentReply"> | string
    authorProfileImage?: StringNullableFilter<"CommentReply"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"CommentReply"> | $Enums.AccountType
    affinityScore?: IntFilter<"CommentReply"> | number
    qualityScore?: IntFilter<"CommentReply"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"CommentReply">
    userIdToReportsMap?: JsonNullableFilter<"CommentReply">
    userIdToReactionMap?: JsonNullableFilter<"CommentReply">
    mentions?: StringNullableListFilter<"CommentReply">
    hashtags?: StringNullableListFilter<"CommentReply">
    mediaid?: StringNullableFilter<"CommentReply"> | string | null
    commentId?: StringFilter<"CommentReply"> | string
    extra?: JsonNullableFilter<"CommentReply">
    aiAnalysis?: XOR<AIAnalysisNullableCompositeFilter, AIAnalysisObjectEqualityInput> | null
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    comment?: XOR<CommentRelationFilter, CommentWhereInput>
  }

  export type CommentReplyOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    userIdToAffinityScoreMap?: SortOrder
    userIdToReportsMap?: SortOrder
    userIdToReactionMap?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    mediaid?: SortOrder
    commentId?: SortOrder
    extra?: SortOrder
    aiAnalysis?: AIAnalysisOrderByInput
    media?: MediaOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
  }

  export type CommentReplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentReplyWhereInput | CommentReplyWhereInput[]
    OR?: CommentReplyWhereInput[]
    NOT?: CommentReplyWhereInput | CommentReplyWhereInput[]
    content?: StringFilter<"CommentReply"> | string
    createdAt?: StringFilter<"CommentReply"> | string
    backendPlatformUserId?: StringFilter<"CommentReply"> | string
    profileId?: IntFilter<"CommentReply"> | number
    authorUsername?: StringFilter<"CommentReply"> | string
    authorProfileImage?: StringNullableFilter<"CommentReply"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"CommentReply"> | $Enums.AccountType
    affinityScore?: IntFilter<"CommentReply"> | number
    qualityScore?: IntFilter<"CommentReply"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"CommentReply">
    userIdToReportsMap?: JsonNullableFilter<"CommentReply">
    userIdToReactionMap?: JsonNullableFilter<"CommentReply">
    mentions?: StringNullableListFilter<"CommentReply">
    hashtags?: StringNullableListFilter<"CommentReply">
    mediaid?: StringNullableFilter<"CommentReply"> | string | null
    commentId?: StringFilter<"CommentReply"> | string
    extra?: JsonNullableFilter<"CommentReply">
    aiAnalysis?: XOR<AIAnalysisNullableCompositeFilter, AIAnalysisObjectEqualityInput> | null
    media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    comment?: XOR<CommentRelationFilter, CommentWhereInput>
  }, "id">

  export type CommentReplyOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    userIdToAffinityScoreMap?: SortOrder
    userIdToReportsMap?: SortOrder
    userIdToReactionMap?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    mediaid?: SortOrder
    commentId?: SortOrder
    extra?: SortOrder
    _count?: CommentReplyCountOrderByAggregateInput
    _avg?: CommentReplyAvgOrderByAggregateInput
    _max?: CommentReplyMaxOrderByAggregateInput
    _min?: CommentReplyMinOrderByAggregateInput
    _sum?: CommentReplySumOrderByAggregateInput
  }

  export type CommentReplyScalarWhereWithAggregatesInput = {
    AND?: CommentReplyScalarWhereWithAggregatesInput | CommentReplyScalarWhereWithAggregatesInput[]
    OR?: CommentReplyScalarWhereWithAggregatesInput[]
    NOT?: CommentReplyScalarWhereWithAggregatesInput | CommentReplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommentReply"> | string
    content?: StringWithAggregatesFilter<"CommentReply"> | string
    createdAt?: StringWithAggregatesFilter<"CommentReply"> | string
    backendPlatformUserId?: StringWithAggregatesFilter<"CommentReply"> | string
    profileId?: IntWithAggregatesFilter<"CommentReply"> | number
    authorUsername?: StringWithAggregatesFilter<"CommentReply"> | string
    authorProfileImage?: StringNullableWithAggregatesFilter<"CommentReply"> | string | null
    authorAccountType?: EnumAccountTypeWithAggregatesFilter<"CommentReply"> | $Enums.AccountType
    affinityScore?: IntWithAggregatesFilter<"CommentReply"> | number
    qualityScore?: IntWithAggregatesFilter<"CommentReply"> | number
    userIdToAffinityScoreMap?: JsonNullableWithAggregatesFilter<"CommentReply">
    userIdToReportsMap?: JsonNullableWithAggregatesFilter<"CommentReply">
    userIdToReactionMap?: JsonNullableWithAggregatesFilter<"CommentReply">
    mentions?: StringNullableListFilter<"CommentReply">
    hashtags?: StringNullableListFilter<"CommentReply">
    mediaid?: StringNullableWithAggregatesFilter<"CommentReply"> | string | null
    commentId?: StringWithAggregatesFilter<"CommentReply"> | string
    extra?: JsonNullableWithAggregatesFilter<"CommentReply">
  }

  export type SpaceMemberWhereInput = {
    AND?: SpaceMemberWhereInput | SpaceMemberWhereInput[]
    OR?: SpaceMemberWhereInput[]
    NOT?: SpaceMemberWhereInput | SpaceMemberWhereInput[]
    id?: StringFilter<"SpaceMember"> | string
    spaceId?: StringFilter<"SpaceMember"> | string
    userId?: StringFilter<"SpaceMember"> | string
    role?: StringFilter<"SpaceMember"> | string
    joinedAt?: DateTimeFilter<"SpaceMember"> | Date | string
    status?: StringFilter<"SpaceMember"> | string
    permissions?: StringNullableListFilter<"SpaceMember">
    space?: XOR<SpaceRelationFilter, SpaceWhereInput>
  }

  export type SpaceMemberOrderByWithRelationInput = {
    id?: SortOrder
    spaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    permissions?: SortOrder
    space?: SpaceOrderByWithRelationInput
  }

  export type SpaceMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    spaceId_userId?: SpaceMemberSpaceIdUserIdCompoundUniqueInput
    AND?: SpaceMemberWhereInput | SpaceMemberWhereInput[]
    OR?: SpaceMemberWhereInput[]
    NOT?: SpaceMemberWhereInput | SpaceMemberWhereInput[]
    spaceId?: StringFilter<"SpaceMember"> | string
    userId?: StringFilter<"SpaceMember"> | string
    role?: StringFilter<"SpaceMember"> | string
    joinedAt?: DateTimeFilter<"SpaceMember"> | Date | string
    status?: StringFilter<"SpaceMember"> | string
    permissions?: StringNullableListFilter<"SpaceMember">
    space?: XOR<SpaceRelationFilter, SpaceWhereInput>
  }, "id" | "spaceId_userId">

  export type SpaceMemberOrderByWithAggregationInput = {
    id?: SortOrder
    spaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    permissions?: SortOrder
    _count?: SpaceMemberCountOrderByAggregateInput
    _max?: SpaceMemberMaxOrderByAggregateInput
    _min?: SpaceMemberMinOrderByAggregateInput
  }

  export type SpaceMemberScalarWhereWithAggregatesInput = {
    AND?: SpaceMemberScalarWhereWithAggregatesInput | SpaceMemberScalarWhereWithAggregatesInput[]
    OR?: SpaceMemberScalarWhereWithAggregatesInput[]
    NOT?: SpaceMemberScalarWhereWithAggregatesInput | SpaceMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpaceMember"> | string
    spaceId?: StringWithAggregatesFilter<"SpaceMember"> | string
    userId?: StringWithAggregatesFilter<"SpaceMember"> | string
    role?: StringWithAggregatesFilter<"SpaceMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"SpaceMember"> | Date | string
    status?: StringWithAggregatesFilter<"SpaceMember"> | string
    permissions?: StringNullableListFilter<"SpaceMember">
  }

  export type ChannelMemberWhereInput = {
    AND?: ChannelMemberWhereInput | ChannelMemberWhereInput[]
    OR?: ChannelMemberWhereInput[]
    NOT?: ChannelMemberWhereInput | ChannelMemberWhereInput[]
    id?: StringFilter<"ChannelMember"> | string
    channelId?: StringFilter<"ChannelMember"> | string
    userId?: StringFilter<"ChannelMember"> | string
    role?: StringFilter<"ChannelMember"> | string
    joinedAt?: DateTimeFilter<"ChannelMember"> | Date | string
    lastRead?: DateTimeNullableFilter<"ChannelMember"> | Date | string | null
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
  }

  export type ChannelMemberOrderByWithRelationInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    lastRead?: SortOrder
    channel?: ChannelOrderByWithRelationInput
  }

  export type ChannelMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    channelId_userId?: ChannelMemberChannelIdUserIdCompoundUniqueInput
    AND?: ChannelMemberWhereInput | ChannelMemberWhereInput[]
    OR?: ChannelMemberWhereInput[]
    NOT?: ChannelMemberWhereInput | ChannelMemberWhereInput[]
    channelId?: StringFilter<"ChannelMember"> | string
    userId?: StringFilter<"ChannelMember"> | string
    role?: StringFilter<"ChannelMember"> | string
    joinedAt?: DateTimeFilter<"ChannelMember"> | Date | string
    lastRead?: DateTimeNullableFilter<"ChannelMember"> | Date | string | null
    channel?: XOR<ChannelRelationFilter, ChannelWhereInput>
  }, "id" | "channelId_userId">

  export type ChannelMemberOrderByWithAggregationInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    lastRead?: SortOrder
    _count?: ChannelMemberCountOrderByAggregateInput
    _max?: ChannelMemberMaxOrderByAggregateInput
    _min?: ChannelMemberMinOrderByAggregateInput
  }

  export type ChannelMemberScalarWhereWithAggregatesInput = {
    AND?: ChannelMemberScalarWhereWithAggregatesInput | ChannelMemberScalarWhereWithAggregatesInput[]
    OR?: ChannelMemberScalarWhereWithAggregatesInput[]
    NOT?: ChannelMemberScalarWhereWithAggregatesInput | ChannelMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChannelMember"> | string
    channelId?: StringWithAggregatesFilter<"ChannelMember"> | string
    userId?: StringWithAggregatesFilter<"ChannelMember"> | string
    role?: StringWithAggregatesFilter<"ChannelMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"ChannelMember"> | Date | string
    lastRead?: DateTimeNullableWithAggregatesFilter<"ChannelMember"> | Date | string | null
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: StringFilter<"File"> | string
    name?: StringFilter<"File"> | string
    type?: EnumMediaTypeFilter<"File"> | $Enums.MediaType
    url?: StringFilter<"File"> | string
    metadata?: XOR<FileMetadataCompositeFilter, FileMetadataObjectEqualityInput>
    uploadedBy?: StringFilter<"File"> | string
    uploadedAt?: DateTimeFilter<"File"> | Date | string
    size?: IntFilter<"File"> | number
    status?: StringFilter<"File"> | string
    preview?: StringNullableFilter<"File"> | string | null
    thumbnail?: StringNullableFilter<"File"> | string | null
    searchMetadata?: XOR<SearchMetadataNullableCompositeFilter, SearchMetadataObjectEqualityInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCompositeFilter, AIAnalysisObjectEqualityInput> | null
    spaceId?: StringNullableFilter<"File"> | string | null
    channelId?: StringNullableFilter<"File"> | string | null
    posts?: FileToPostListRelationFilter
    Space?: XOR<SpaceNullableRelationFilter, SpaceWhereInput> | null
    Channel?: XOR<ChannelNullableRelationFilter, ChannelWhereInput> | null
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    metadata?: FileMetadataOrderByInput
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    size?: SortOrder
    status?: SortOrder
    preview?: SortOrder
    thumbnail?: SortOrder
    searchMetadata?: SearchMetadataOrderByInput
    aiAnalysis?: AIAnalysisOrderByInput
    spaceId?: SortOrder
    channelId?: SortOrder
    posts?: FileToPostOrderByRelationAggregateInput
    Space?: SpaceOrderByWithRelationInput
    Channel?: ChannelOrderByWithRelationInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    name?: StringFilter<"File"> | string
    type?: EnumMediaTypeFilter<"File"> | $Enums.MediaType
    url?: StringFilter<"File"> | string
    metadata?: XOR<FileMetadataCompositeFilter, FileMetadataObjectEqualityInput>
    uploadedBy?: StringFilter<"File"> | string
    uploadedAt?: DateTimeFilter<"File"> | Date | string
    size?: IntFilter<"File"> | number
    status?: StringFilter<"File"> | string
    preview?: StringNullableFilter<"File"> | string | null
    thumbnail?: StringNullableFilter<"File"> | string | null
    searchMetadata?: XOR<SearchMetadataNullableCompositeFilter, SearchMetadataObjectEqualityInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCompositeFilter, AIAnalysisObjectEqualityInput> | null
    spaceId?: StringNullableFilter<"File"> | string | null
    channelId?: StringNullableFilter<"File"> | string | null
    posts?: FileToPostListRelationFilter
    Space?: XOR<SpaceNullableRelationFilter, SpaceWhereInput> | null
    Channel?: XOR<ChannelNullableRelationFilter, ChannelWhereInput> | null
  }, "id">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    size?: SortOrder
    status?: SortOrder
    preview?: SortOrder
    thumbnail?: SortOrder
    spaceId?: SortOrder
    channelId?: SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"File"> | string
    name?: StringWithAggregatesFilter<"File"> | string
    type?: EnumMediaTypeWithAggregatesFilter<"File"> | $Enums.MediaType
    url?: StringWithAggregatesFilter<"File"> | string
    uploadedBy?: StringWithAggregatesFilter<"File"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    size?: IntWithAggregatesFilter<"File"> | number
    status?: StringWithAggregatesFilter<"File"> | string
    preview?: StringNullableWithAggregatesFilter<"File"> | string | null
    thumbnail?: StringNullableWithAggregatesFilter<"File"> | string | null
    spaceId?: StringNullableWithAggregatesFilter<"File"> | string | null
    channelId?: StringNullableWithAggregatesFilter<"File"> | string | null
  }

  export type FileToPostWhereInput = {
    AND?: FileToPostWhereInput | FileToPostWhereInput[]
    OR?: FileToPostWhereInput[]
    NOT?: FileToPostWhereInput | FileToPostWhereInput[]
    id?: StringFilter<"FileToPost"> | string
    fileId?: StringFilter<"FileToPost"> | string
    postId?: StringFilter<"FileToPost"> | string
    createdAt?: DateTimeFilter<"FileToPost"> | Date | string
    file?: XOR<FileRelationFilter, FileWhereInput>
    post?: XOR<PostRelationFilter, PostWhereInput>
  }

  export type FileToPostOrderByWithRelationInput = {
    id?: SortOrder
    fileId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    file?: FileOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
  }

  export type FileToPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fileId_postId?: FileToPostFileIdPostIdCompoundUniqueInput
    AND?: FileToPostWhereInput | FileToPostWhereInput[]
    OR?: FileToPostWhereInput[]
    NOT?: FileToPostWhereInput | FileToPostWhereInput[]
    fileId?: StringFilter<"FileToPost"> | string
    postId?: StringFilter<"FileToPost"> | string
    createdAt?: DateTimeFilter<"FileToPost"> | Date | string
    file?: XOR<FileRelationFilter, FileWhereInput>
    post?: XOR<PostRelationFilter, PostWhereInput>
  }, "id" | "fileId_postId">

  export type FileToPostOrderByWithAggregationInput = {
    id?: SortOrder
    fileId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    _count?: FileToPostCountOrderByAggregateInput
    _max?: FileToPostMaxOrderByAggregateInput
    _min?: FileToPostMinOrderByAggregateInput
  }

  export type FileToPostScalarWhereWithAggregatesInput = {
    AND?: FileToPostScalarWhereWithAggregatesInput | FileToPostScalarWhereWithAggregatesInput[]
    OR?: FileToPostScalarWhereWithAggregatesInput[]
    NOT?: FileToPostScalarWhereWithAggregatesInput | FileToPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FileToPost"> | string
    fileId?: StringWithAggregatesFilter<"FileToPost"> | string
    postId?: StringWithAggregatesFilter<"FileToPost"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FileToPost"> | Date | string
  }

  export type MediaCreateInput = {
    id?: string
    mediaType: string
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    CommentReply?: CommentReplyCreateNestedManyWithoutMediaInput
    Post?: PostCreateNestedManyWithoutMediaInput
    Comment?: CommentCreateNestedManyWithoutMediaInput
    PollPost?: PollPostCreateNestedManyWithoutMediaInput
    Note?: NoteCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    mediaType: string
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    CommentReply?: CommentReplyUncheckedCreateNestedManyWithoutMediaInput
    Post?: PostUncheckedCreateNestedManyWithoutMediaInput
    Comment?: CommentUncheckedCreateNestedManyWithoutMediaInput
    PollPost?: PollPostUncheckedCreateNestedManyWithoutMediaInput
    Note?: NoteUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaUpdateInput = {
    mediaType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CommentReply?: CommentReplyUpdateManyWithoutMediaNestedInput
    Post?: PostUpdateManyWithoutMediaNestedInput
    Comment?: CommentUpdateManyWithoutMediaNestedInput
    PollPost?: PollPostUpdateManyWithoutMediaNestedInput
    Note?: NoteUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    mediaType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CommentReply?: CommentReplyUncheckedUpdateManyWithoutMediaNestedInput
    Post?: PostUncheckedUpdateManyWithoutMediaNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutMediaNestedInput
    PollPost?: PollPostUncheckedUpdateManyWithoutMediaNestedInput
    Note?: NoteUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaCreateManyInput = {
    id?: string
    mediaType: string
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
  }

  export type MediaUpdateManyMutationInput = {
    mediaType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    mediaType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
    media?: MediaCreateNestedOneWithoutPostInput
    files?: FileToPostCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
    files?: FileToPostUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostNestedInput
    files?: FileToPostUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
    files?: FileToPostUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
  }

  export type PostUpdateManyMutationInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type PostUncheckedUpdateManyInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type PollPostCreateInput = {
    id?: string
    createdAt: string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | null
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    extra?: InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaCreateNestedOneWithoutPollPostInput
    comments?: CommentCreateNestedManyWithoutPollPostInput
    thread?: ThreadCreateNestedOneWithoutPollPostsInput
  }

  export type PollPostUncheckedCreateInput = {
    id?: string
    createdAt: string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | null
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    mediaId?: string | null
    threadId?: string | null
    extra?: InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    comments?: CommentUncheckedCreateNestedManyWithoutPollPostInput
  }

  export type PollPostUpdateInput = {
    createdAt?: StringFieldUpdateOperationsInput | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | InputJsonValue | null
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    extra?: InputJsonValue | InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaUpdateOneWithoutPollPostNestedInput
    comments?: CommentUpdateManyWithoutPollPostNestedInput
    thread?: ThreadUpdateOneWithoutPollPostsNestedInput
  }

  export type PollPostUncheckedUpdateInput = {
    createdAt?: StringFieldUpdateOperationsInput | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | InputJsonValue | null
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    comments?: CommentUncheckedUpdateManyWithoutPollPostNestedInput
  }

  export type PollPostCreateManyInput = {
    id?: string
    createdAt: string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | null
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    mediaId?: string | null
    threadId?: string | null
    extra?: InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type PollPostUpdateManyMutationInput = {
    createdAt?: StringFieldUpdateOperationsInput | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | InputJsonValue | null
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    extra?: InputJsonValue | InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type PollPostUncheckedUpdateManyInput = {
    createdAt?: StringFieldUpdateOperationsInput | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | InputJsonValue | null
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type SpaceCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: string
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberCreateNestedManyWithoutSpaceInput
    channels?: ChannelCreateNestedManyWithoutSpaceInput
    posts?: PostCreateNestedManyWithoutSpaceInput
    files?: FileCreateNestedManyWithoutSpaceInput
    parentSpace?: SpaceCreateNestedOneWithoutChildSpacesInput
    childSpaces?: SpaceCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: string
    parentSpaceId?: string | null
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberUncheckedCreateNestedManyWithoutSpaceInput
    channels?: ChannelUncheckedCreateNestedManyWithoutSpaceInput
    posts?: PostUncheckedCreateNestedManyWithoutSpaceInput
    files?: FileUncheckedCreateNestedManyWithoutSpaceInput
    childSpaces?: SpaceUncheckedCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUpdateManyWithoutSpaceNestedInput
    posts?: PostUpdateManyWithoutSpaceNestedInput
    files?: FileUpdateManyWithoutSpaceNestedInput
    parentSpace?: SpaceUpdateOneWithoutChildSpacesNestedInput
    childSpaces?: SpaceUpdateManyWithoutParentSpaceNestedInput
  }

  export type SpaceUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUncheckedUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutSpaceNestedInput
    posts?: PostUncheckedUpdateManyWithoutSpaceNestedInput
    files?: FileUncheckedUpdateManyWithoutSpaceNestedInput
    childSpaces?: SpaceUncheckedUpdateManyWithoutParentSpaceNestedInput
  }

  export type SpaceCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: string
    parentSpaceId?: string | null
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceCreatetagsInput | string[]
  }

  export type SpaceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
  }

  export type SpaceUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
  }

  export type ChannelCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    space: SpaceCreateNestedOneWithoutChannelsInput
    posts?: PostCreateNestedManyWithoutChannelInput
    files?: FileCreateNestedManyWithoutChannelInput
    members?: ChannelMemberCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    spaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    posts?: PostUncheckedCreateNestedManyWithoutChannelInput
    files?: FileUncheckedCreateNestedManyWithoutChannelInput
    members?: ChannelMemberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    space?: SpaceUpdateOneRequiredWithoutChannelsNestedInput
    posts?: PostUpdateManyWithoutChannelNestedInput
    files?: FileUpdateManyWithoutChannelNestedInput
    members?: ChannelMemberUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    posts?: PostUncheckedUpdateManyWithoutChannelNestedInput
    files?: FileUncheckedUpdateManyWithoutChannelNestedInput
    members?: ChannelMemberUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    spaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
  }

  export type ChannelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
  }

  export type ChannelUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
  }

  export type ThreadCreateInput = {
    id?: string
    postIds?: ThreadCreatepostIdsInput | string[]
    parentPostId: string
    createdAt: string
    updatedAt: string
    metadata?: InputJsonValue | null
    status?: string
    isLocked?: boolean
    posts?: PostCreateNestedManyWithoutThreadInput
    pollPosts?: PollPostCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateInput = {
    id?: string
    postIds?: ThreadCreatepostIdsInput | string[]
    parentPostId: string
    createdAt: string
    updatedAt: string
    metadata?: InputJsonValue | null
    status?: string
    isLocked?: boolean
    posts?: PostUncheckedCreateNestedManyWithoutThreadInput
    pollPosts?: PollPostUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadUpdateInput = {
    postIds?: ThreadUpdatepostIdsInput | string[]
    parentPostId?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUpdateManyWithoutThreadNestedInput
    pollPosts?: PollPostUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateInput = {
    postIds?: ThreadUpdatepostIdsInput | string[]
    parentPostId?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUncheckedUpdateManyWithoutThreadNestedInput
    pollPosts?: PollPostUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type ThreadCreateManyInput = {
    id?: string
    postIds?: ThreadCreatepostIdsInput | string[]
    parentPostId: string
    createdAt: string
    updatedAt: string
    metadata?: InputJsonValue | null
    status?: string
    isLocked?: boolean
  }

  export type ThreadUpdateManyMutationInput = {
    postIds?: ThreadUpdatepostIdsInput | string[]
    parentPostId?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ThreadUncheckedUpdateManyInput = {
    postIds?: ThreadUpdatepostIdsInput | string[]
    parentPostId?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NoteCreateInput = {
    id?: string
    content: string
    createdAt: string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaCreateNestedOneWithoutNoteInput
    post: PostCreateNestedOneWithoutNotesInput
    comment?: CommentCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateInput = {
    id?: string
    content: string
    createdAt: string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    commentId?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type NoteUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaUpdateOneWithoutNoteNestedInput
    post?: PostUpdateOneRequiredWithoutNotesNestedInput
    comment?: CommentUpdateOneWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type NoteCreateManyInput = {
    id?: string
    content: string
    createdAt: string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    commentId?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type NoteUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type NoteUncheckedUpdateManyInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type CommentCreateInput = {
    id?: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaCreateNestedOneWithoutCommentInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    notes?: NoteCreateNestedManyWithoutCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    PollPost?: PollPostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    postId: string
    pollPostId?: string | null
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    mediaId?: string | null
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
    notes?: NoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaUpdateOneWithoutCommentNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    notes?: NoteUpdateManyWithoutCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    PollPost?: PollPostUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    postId?: StringFieldUpdateOperationsInput | string
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    postId: string
    pollPostId?: string | null
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    mediaId?: string | null
  }

  export type CommentUpdateManyMutationInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type CommentUncheckedUpdateManyInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    postId?: StringFieldUpdateOperationsInput | string
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentReplyCreateInput = {
    id?: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaCreateNestedOneWithoutCommentReplyInput
    comment: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentReplyUncheckedCreateInput = {
    id?: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    mediaid?: string | null
    commentId: string
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type CommentReplyUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaUpdateOneWithoutCommentReplyNestedInput
    comment?: CommentUpdateOneRequiredWithoutRepliesNestedInput
  }

  export type CommentReplyUncheckedUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    mediaid?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: StringFieldUpdateOperationsInput | string
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type CommentReplyCreateManyInput = {
    id?: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    mediaid?: string | null
    commentId: string
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type CommentReplyUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type CommentReplyUncheckedUpdateManyInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    mediaid?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: StringFieldUpdateOperationsInput | string
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type SpaceMemberCreateInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    status?: string
    permissions?: SpaceMemberCreatepermissionsInput | string[]
    space: SpaceCreateNestedOneWithoutMembersInput
  }

  export type SpaceMemberUncheckedCreateInput = {
    id?: string
    spaceId: string
    userId: string
    role: string
    joinedAt?: Date | string
    status?: string
    permissions?: SpaceMemberCreatepermissionsInput | string[]
  }

  export type SpaceMemberUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    permissions?: SpaceMemberUpdatepermissionsInput | string[]
    space?: SpaceUpdateOneRequiredWithoutMembersNestedInput
  }

  export type SpaceMemberUncheckedUpdateInput = {
    spaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    permissions?: SpaceMemberUpdatepermissionsInput | string[]
  }

  export type SpaceMemberCreateManyInput = {
    id?: string
    spaceId: string
    userId: string
    role: string
    joinedAt?: Date | string
    status?: string
    permissions?: SpaceMemberCreatepermissionsInput | string[]
  }

  export type SpaceMemberUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    permissions?: SpaceMemberUpdatepermissionsInput | string[]
  }

  export type SpaceMemberUncheckedUpdateManyInput = {
    spaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    permissions?: SpaceMemberUpdatepermissionsInput | string[]
  }

  export type ChannelMemberCreateInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    lastRead?: Date | string | null
    channel: ChannelCreateNestedOneWithoutMembersInput
  }

  export type ChannelMemberUncheckedCreateInput = {
    id?: string
    channelId: string
    userId: string
    role: string
    joinedAt?: Date | string
    lastRead?: Date | string | null
  }

  export type ChannelMemberUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: ChannelUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ChannelMemberUncheckedUpdateInput = {
    channelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelMemberCreateManyInput = {
    id?: string
    channelId: string
    userId: string
    role: string
    joinedAt?: Date | string
    lastRead?: Date | string | null
  }

  export type ChannelMemberUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelMemberUncheckedUpdateManyInput = {
    channelId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileCreateInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: XOR<FileMetadataCreateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    posts?: FileToPostCreateNestedManyWithoutFileInput
    Space?: SpaceCreateNestedOneWithoutFilesInput
    Channel?: ChannelCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: XOR<FileMetadataCreateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    spaceId?: string | null
    channelId?: string | null
    posts?: FileToPostUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: XOR<FileMetadataUpdateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    posts?: FileToPostUpdateManyWithoutFileNestedInput
    Space?: SpaceUpdateOneWithoutFilesNestedInput
    Channel?: ChannelUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: XOR<FileMetadataUpdateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: FileToPostUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileCreateManyInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: XOR<FileMetadataCreateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    spaceId?: string | null
    channelId?: string | null
  }

  export type FileUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: XOR<FileMetadataUpdateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type FileUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: XOR<FileMetadataUpdateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileToPostCreateInput = {
    id?: string
    createdAt?: Date | string
    file: FileCreateNestedOneWithoutPostsInput
    post: PostCreateNestedOneWithoutFilesInput
  }

  export type FileToPostUncheckedCreateInput = {
    id?: string
    fileId: string
    postId: string
    createdAt?: Date | string
  }

  export type FileToPostUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileUpdateOneRequiredWithoutPostsNestedInput
    post?: PostUpdateOneRequiredWithoutFilesNestedInput
  }

  export type FileToPostUncheckedUpdateInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileToPostCreateManyInput = {
    id?: string
    fileId: string
    postId: string
    createdAt?: Date | string
  }

  export type FileToPostUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileToPostUncheckedUpdateManyInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CommentReplyListRelationFilter = {
    every?: CommentReplyWhereInput
    some?: CommentReplyWhereInput
    none?: CommentReplyWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type PollPostListRelationFilter = {
    every?: PollPostWhereInput
    some?: PollPostWhereInput
    none?: PollPostWhereInput
  }

  export type NoteListRelationFilter = {
    every?: NoteWhereInput
    some?: NoteWhereInput
    none?: NoteWhereInput
  }

  export type CommentReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PollPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    mediaType?: SortOrder
    status?: SortOrder
    fileContent?: SortOrder
    fileName?: SortOrder
    transcription?: SortOrder
    extractedText?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    mediaType?: SortOrder
    status?: SortOrder
    fileContent?: SortOrder
    fileName?: SortOrder
    transcription?: SortOrder
    extractedText?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    mediaType?: SortOrder
    status?: SortOrder
    fileContent?: SortOrder
    fileName?: SortOrder
    transcription?: SortOrder
    extractedText?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type EnumPostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeFilter<$PrismaModel> | $Enums.PostType
  }

  export type EnumCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableFilter<$PrismaModel> | $Enums.Category | null
    isSet?: boolean
  }

  export type EnumThreadParticipantTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreadParticipantType | EnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ThreadParticipantType[] | ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ThreadParticipantType[] | ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumThreadParticipantTypeNullableFilter<$PrismaModel> | $Enums.ThreadParticipantType | null
    isSet?: boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type ContentInsightsNullableCompositeFilter = {
    equals?: ContentInsightsObjectEqualityInput | null
    is?: ContentInsightsWhereInput | null
    isNot?: ContentInsightsWhereInput | null
    isSet?: boolean
  }

  export type ContentInsightsObjectEqualityInput = {
    sentenceCount: number
    wordCount: number
    language: string
    languageConfidence: number
    entities?: EntitiesObjectEqualityInput[]
    sentiment: SentimentObjectEqualityInput
    topics?: string[]
    keywords?: string[]
    summary?: string | null
    readability?: number | null
  }

  export type AIAnalysisNullableCompositeFilter = {
    equals?: AIAnalysisObjectEqualityInput | null
    is?: AIAnalysisWhereInput | null
    isNot?: AIAnalysisWhereInput | null
    isSet?: boolean
  }

  export type AIAnalysisObjectEqualityInput = {
    summary?: string | null
    keyPoints?: string[]
    sentiment: SentimentAnalysisObjectEqualityInput
    entities?: NamedEntityObjectEqualityInput[]
    topics?: TopicAnalysisObjectEqualityInput[]
    keywords?: KeywordObjectEqualityInput[]
    readabilityScore: ReadabilityMetricsObjectEqualityInput
    qualityMetrics: ContentQualityObjectEqualityInput
    toxicity: ToxicityAnalysisObjectEqualityInput
    originality: OriginalityScoreObjectEqualityInput
    language: LanguageAnalysisObjectEqualityInput
    translation: TranslationInfoObjectEqualityInput
    grammarCheck: GrammarAnalysisObjectEqualityInput
    styleAnalysis: StyleMetricsObjectEqualityInput
    intentions?: IntentAnalysisObjectEqualityInput[]
    emotions: EmotionAnalysisObjectEqualityInput
    bias: BiasAnalysisObjectEqualityInput
    subjectivity: number
    imageAnalysis?: ImageAnalysisObjectEqualityInput[]
    videoAnalysis?: VideoAnalysisObjectEqualityInput[]
    audioAnalysis?: AudioAnalysisObjectEqualityInput[]
    marketInsights: MarketAnalysisObjectEqualityInput
    competitiveInfo: CompetitiveAnalysisObjectEqualityInput
    actionItems?: ActionItemObjectEqualityInput[]
    processingTime: number
    confidenceScore: number
    modelVersions: ModelMetadataObjectEqualityInput
    timestamp: Date | string
    processingCost: number
  }

  export type SearchMetadataNullableCompositeFilter = {
    equals?: SearchMetadataObjectEqualityInput | null
    is?: SearchMetadataWhereInput | null
    isNot?: SearchMetadataWhereInput | null
    isSet?: boolean
  }

  export type SearchMetadataObjectEqualityInput = {
    title: string
    description?: string | null
    keywords?: string[]
    contentType: string
    language: string
    fileSize?: number | null
    wordCount?: number | null
    pageCount?: number | null
    duration?: number | null
    transcription?: string | null
    extractedText?: string | null
    lastIndexed: Date | string
    searchScore: number
    aiTags?: string[]
    classifications?: string[]
    visibility: $Enums.AccessLevel
    readingLevel?: string | null
    locationData?: InputJsonValue | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type MediaNullableRelationFilter = {
    is?: MediaWhereInput | null
    isNot?: MediaWhereInput | null
  }

  export type FileToPostListRelationFilter = {
    every?: FileToPostWhereInput
    some?: FileToPostWhereInput
    none?: FileToPostWhereInput
  }

  export type ThreadNullableRelationFilter = {
    is?: ThreadWhereInput | null
    isNot?: ThreadWhereInput | null
  }

  export type SpaceNullableRelationFilter = {
    is?: SpaceWhereInput | null
    isNot?: SpaceWhereInput | null
  }

  export type ChannelNullableRelationFilter = {
    is?: ChannelWhereInput | null
    isNot?: ChannelWhereInput | null
  }

  export type ContentInsightsOrderByInput = {
    sentenceCount?: SortOrder
    wordCount?: SortOrder
    language?: SortOrder
    languageConfidence?: SortOrder
    entities?: EntitiesOrderByCompositeAggregateInput
    sentiment?: SentimentOrderByInput
    topics?: SortOrder
    keywords?: SortOrder
    summary?: SortOrder
    readability?: SortOrder
  }

  export type AIAnalysisOrderByInput = {
    summary?: SortOrder
    keyPoints?: SortOrder
    sentiment?: SentimentAnalysisOrderByInput
    entities?: NamedEntityOrderByCompositeAggregateInput
    topics?: TopicAnalysisOrderByCompositeAggregateInput
    keywords?: KeywordOrderByCompositeAggregateInput
    readabilityScore?: ReadabilityMetricsOrderByInput
    qualityMetrics?: ContentQualityOrderByInput
    toxicity?: ToxicityAnalysisOrderByInput
    originality?: OriginalityScoreOrderByInput
    language?: LanguageAnalysisOrderByInput
    translation?: TranslationInfoOrderByInput
    grammarCheck?: GrammarAnalysisOrderByInput
    styleAnalysis?: StyleMetricsOrderByInput
    intentions?: IntentAnalysisOrderByCompositeAggregateInput
    emotions?: EmotionAnalysisOrderByInput
    bias?: BiasAnalysisOrderByInput
    subjectivity?: SortOrder
    imageAnalysis?: ImageAnalysisOrderByCompositeAggregateInput
    videoAnalysis?: VideoAnalysisOrderByCompositeAggregateInput
    audioAnalysis?: AudioAnalysisOrderByCompositeAggregateInput
    marketInsights?: MarketAnalysisOrderByInput
    competitiveInfo?: CompetitiveAnalysisOrderByInput
    actionItems?: ActionItemOrderByCompositeAggregateInput
    processingTime?: SortOrder
    confidenceScore?: SortOrder
    modelVersions?: ModelMetadataOrderByInput
    timestamp?: SortOrder
    processingCost?: SortOrder
  }

  export type SearchMetadataOrderByInput = {
    title?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    contentType?: SortOrder
    language?: SortOrder
    fileSize?: SortOrder
    wordCount?: SortOrder
    pageCount?: SortOrder
    duration?: SortOrder
    transcription?: SortOrder
    extractedText?: SortOrder
    lastIndexed?: SortOrder
    searchScore?: SortOrder
    aiTags?: SortOrder
    classifications?: SortOrder
    visibility?: SortOrder
    readingLevel?: SortOrder
    locationData?: SortOrder
  }

  export type FileToPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    parentSpaceId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    description?: SortOrder
    status?: SortOrder
    workflowStatus?: SortOrder
    assignedTo?: SortOrder
    contentFormat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    postType?: SortOrder
    category?: SortOrder
    threadParticipantType?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    tags?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    topicName?: SortOrder
    mediaId?: SortOrder
    backgroundImageUrl?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    userIdToAffinityScoreMap?: SortOrder
    userIdToReportsMap?: SortOrder
    userIdToReactionMap?: SortOrder
    readingTime?: SortOrder
    aiGeneratedQuestionResponse?: SortOrder
    threadId?: SortOrder
    spaceId?: SortOrder
    channelId?: SortOrder
    extra?: SortOrder
    visibility?: SortOrder
    isPinned?: SortOrder
    isArchived?: SortOrder
    workflow?: SortOrder
    version?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    profileId?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    version?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    parentSpaceId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    description?: SortOrder
    status?: SortOrder
    workflowStatus?: SortOrder
    assignedTo?: SortOrder
    contentFormat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    postType?: SortOrder
    category?: SortOrder
    threadParticipantType?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    topicName?: SortOrder
    mediaId?: SortOrder
    backgroundImageUrl?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    readingTime?: SortOrder
    aiGeneratedQuestionResponse?: SortOrder
    threadId?: SortOrder
    spaceId?: SortOrder
    channelId?: SortOrder
    visibility?: SortOrder
    isPinned?: SortOrder
    isArchived?: SortOrder
    version?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    parentSpaceId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    description?: SortOrder
    status?: SortOrder
    workflowStatus?: SortOrder
    assignedTo?: SortOrder
    contentFormat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    postType?: SortOrder
    category?: SortOrder
    threadParticipantType?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    topicName?: SortOrder
    mediaId?: SortOrder
    backgroundImageUrl?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    readingTime?: SortOrder
    aiGeneratedQuestionResponse?: SortOrder
    threadId?: SortOrder
    spaceId?: SortOrder
    channelId?: SortOrder
    visibility?: SortOrder
    isPinned?: SortOrder
    isArchived?: SortOrder
    version?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    profileId?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    viewCount?: SortOrder
    version?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumPostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeWithAggregatesFilter<$PrismaModel> | $Enums.PostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostTypeFilter<$PrismaModel>
    _max?: NestedEnumPostTypeFilter<$PrismaModel>
  }

  export type EnumCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.Category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumCategoryNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumThreadParticipantTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreadParticipantType | EnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ThreadParticipantType[] | ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ThreadParticipantType[] | ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumThreadParticipantTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ThreadParticipantType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumThreadParticipantTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumThreadParticipantTypeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PollPostCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    content?: SortOrder
    title?: SortOrder
    pollOptions?: SortOrder
    pollDistribution?: SortOrder
    userIdToPollResponsesMap?: SortOrder
    pollEndDate?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    tags?: SortOrder
    topicName?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    mediaId?: SortOrder
    threadId?: SortOrder
    extra?: SortOrder
  }

  export type PollPostAvgOrderByAggregateInput = {
    profileId?: SortOrder
  }

  export type PollPostMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    content?: SortOrder
    title?: SortOrder
    pollEndDate?: SortOrder
    topicName?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    mediaId?: SortOrder
    threadId?: SortOrder
  }

  export type PollPostMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    content?: SortOrder
    title?: SortOrder
    pollEndDate?: SortOrder
    topicName?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    mediaId?: SortOrder
    threadId?: SortOrder
  }

  export type PollPostSumOrderByAggregateInput = {
    profileId?: SortOrder
  }

  export type EnumSpaceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SpaceType | EnumSpaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SpaceType[] | ListEnumSpaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpaceType[] | ListEnumSpaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpaceTypeFilter<$PrismaModel> | $Enums.SpaceType
  }

  export type EnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }

  export type SpaceMemberListRelationFilter = {
    every?: SpaceMemberWhereInput
    some?: SpaceMemberWhereInput
    none?: SpaceMemberWhereInput
  }

  export type ChannelListRelationFilter = {
    every?: ChannelWhereInput
    some?: ChannelWhereInput
    none?: ChannelWhereInput
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type SpaceListRelationFilter = {
    every?: SpaceWhereInput
    some?: SpaceWhereInput
    none?: SpaceWhereInput
  }

  export type SpaceMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    spaceType?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    parentSpaceId?: SortOrder
    isPrivate?: SortOrder
    metadata?: SortOrder
    settings?: SortOrder
    accessLevel?: SortOrder
    tags?: SortOrder
  }

  export type SpaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    spaceType?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    parentSpaceId?: SortOrder
    isPrivate?: SortOrder
    accessLevel?: SortOrder
  }

  export type SpaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    spaceType?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    parentSpaceId?: SortOrder
    isPrivate?: SortOrder
    accessLevel?: SortOrder
  }

  export type EnumSpaceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SpaceType | EnumSpaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SpaceType[] | ListEnumSpaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpaceType[] | ListEnumSpaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpaceTypeWithAggregatesFilter<$PrismaModel> | $Enums.SpaceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpaceTypeFilter<$PrismaModel>
    _max?: NestedEnumSpaceTypeFilter<$PrismaModel>
  }

  export type EnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }

  export type SpaceRelationFilter = {
    is?: SpaceWhereInput
    isNot?: SpaceWhereInput
  }

  export type ChannelMemberListRelationFilter = {
    every?: ChannelMemberWhereInput
    some?: ChannelMemberWhereInput
    none?: ChannelMemberWhereInput
  }

  export type ChannelMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    spaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    pinnedPosts?: SortOrder
    isPrivate?: SortOrder
    metadata?: SortOrder
    settings?: SortOrder
  }

  export type ChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    spaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    isPrivate?: SortOrder
  }

  export type ChannelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    spaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    isPrivate?: SortOrder
  }

  export type ThreadCountOrderByAggregateInput = {
    id?: SortOrder
    postIds?: SortOrder
    parentPostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
    status?: SortOrder
    isLocked?: SortOrder
  }

  export type ThreadMaxOrderByAggregateInput = {
    id?: SortOrder
    parentPostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    isLocked?: SortOrder
  }

  export type ThreadMinOrderByAggregateInput = {
    id?: SortOrder
    parentPostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    isLocked?: SortOrder
  }

  export type PostRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type CommentNullableRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type NoteCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    authorId?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUserName?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    mediaId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
  }

  export type NoteAvgOrderByAggregateInput = {
    profileId?: SortOrder
  }

  export type NoteMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    authorId?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUserName?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    mediaId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
  }

  export type NoteMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    authorId?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUserName?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    mediaId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
  }

  export type NoteSumOrderByAggregateInput = {
    profileId?: SortOrder
  }

  export type PollPostNullableRelationFilter = {
    is?: PollPostWhereInput | null
    isNot?: PollPostWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    userIdToAffinityScoreMap?: SortOrder
    userIdToReportsMap?: SortOrder
    userIdToReactionMap?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    postId?: SortOrder
    pollPostId?: SortOrder
    extra?: SortOrder
    mediaId?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    profileId?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    postId?: SortOrder
    pollPostId?: SortOrder
    mediaId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    postId?: SortOrder
    pollPostId?: SortOrder
    mediaId?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    profileId?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
  }

  export type CommentRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type CommentReplyCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    userIdToAffinityScoreMap?: SortOrder
    userIdToReportsMap?: SortOrder
    userIdToReactionMap?: SortOrder
    mentions?: SortOrder
    hashtags?: SortOrder
    mediaid?: SortOrder
    commentId?: SortOrder
    extra?: SortOrder
  }

  export type CommentReplyAvgOrderByAggregateInput = {
    profileId?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
  }

  export type CommentReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    mediaid?: SortOrder
    commentId?: SortOrder
  }

  export type CommentReplyMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    backendPlatformUserId?: SortOrder
    profileId?: SortOrder
    authorUsername?: SortOrder
    authorProfileImage?: SortOrder
    authorAccountType?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
    mediaid?: SortOrder
    commentId?: SortOrder
  }

  export type CommentReplySumOrderByAggregateInput = {
    profileId?: SortOrder
    affinityScore?: SortOrder
    qualityScore?: SortOrder
  }

  export type SpaceMemberSpaceIdUserIdCompoundUniqueInput = {
    spaceId: string
    userId: string
  }

  export type SpaceMemberCountOrderByAggregateInput = {
    id?: SortOrder
    spaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    permissions?: SortOrder
  }

  export type SpaceMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    spaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
  }

  export type SpaceMemberMinOrderByAggregateInput = {
    id?: SortOrder
    spaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
  }

  export type ChannelRelationFilter = {
    is?: ChannelWhereInput
    isNot?: ChannelWhereInput
  }

  export type ChannelMemberChannelIdUserIdCompoundUniqueInput = {
    channelId: string
    userId: string
  }

  export type ChannelMemberCountOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    lastRead?: SortOrder
  }

  export type ChannelMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    lastRead?: SortOrder
  }

  export type ChannelMemberMinOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    lastRead?: SortOrder
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type FileMetadataCompositeFilter = {
    equals?: FileMetadataObjectEqualityInput
    is?: FileMetadataWhereInput
    isNot?: FileMetadataWhereInput
  }

  export type FileMetadataObjectEqualityInput = {
    fileName: string
    fileSize: number
    mimeType: string
    extension: string
    hash: string
    dimensions?: DimensionsObjectEqualityInput | null
    duration?: number | null
    encoding?: string | null
    compression?: string | null
    processingStatus: string
    version: number
    createdBy: string
    modifiedBy: string
    parentFolder?: string | null
    path: string
    checksum: string
  }

  export type FileMetadataOrderByInput = {
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    extension?: SortOrder
    hash?: SortOrder
    dimensions?: DimensionsOrderByInput
    duration?: SortOrder
    encoding?: SortOrder
    compression?: SortOrder
    processingStatus?: SortOrder
    version?: SortOrder
    createdBy?: SortOrder
    modifiedBy?: SortOrder
    parentFolder?: SortOrder
    path?: SortOrder
    checksum?: SortOrder
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    size?: SortOrder
    status?: SortOrder
    preview?: SortOrder
    thumbnail?: SortOrder
    spaceId?: SortOrder
    channelId?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    size?: SortOrder
    status?: SortOrder
    preview?: SortOrder
    thumbnail?: SortOrder
    spaceId?: SortOrder
    channelId?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    size?: SortOrder
    status?: SortOrder
    preview?: SortOrder
    thumbnail?: SortOrder
    spaceId?: SortOrder
    channelId?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type FileRelationFilter = {
    is?: FileWhereInput
    isNot?: FileWhereInput
  }

  export type FileToPostFileIdPostIdCompoundUniqueInput = {
    fileId: string
    postId: string
  }

  export type FileToPostCountOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
  }

  export type FileToPostMaxOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
  }

  export type FileToPostMinOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentReplyCreateNestedManyWithoutMediaInput = {
    create?: XOR<CommentReplyCreateWithoutMediaInput, CommentReplyUncheckedCreateWithoutMediaInput> | CommentReplyCreateWithoutMediaInput[] | CommentReplyUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutMediaInput | CommentReplyCreateOrConnectWithoutMediaInput[]
    createMany?: CommentReplyCreateManyMediaInputEnvelope
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutMediaInput = {
    create?: XOR<PostCreateWithoutMediaInput, PostUncheckedCreateWithoutMediaInput> | PostCreateWithoutMediaInput[] | PostUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: PostCreateOrConnectWithoutMediaInput | PostCreateOrConnectWithoutMediaInput[]
    createMany?: PostCreateManyMediaInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutMediaInput = {
    create?: XOR<CommentCreateWithoutMediaInput, CommentUncheckedCreateWithoutMediaInput> | CommentCreateWithoutMediaInput[] | CommentUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutMediaInput | CommentCreateOrConnectWithoutMediaInput[]
    createMany?: CommentCreateManyMediaInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PollPostCreateNestedManyWithoutMediaInput = {
    create?: XOR<PollPostCreateWithoutMediaInput, PollPostUncheckedCreateWithoutMediaInput> | PollPostCreateWithoutMediaInput[] | PollPostUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: PollPostCreateOrConnectWithoutMediaInput | PollPostCreateOrConnectWithoutMediaInput[]
    createMany?: PollPostCreateManyMediaInputEnvelope
    connect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutMediaInput = {
    create?: XOR<NoteCreateWithoutMediaInput, NoteUncheckedCreateWithoutMediaInput> | NoteCreateWithoutMediaInput[] | NoteUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutMediaInput | NoteCreateOrConnectWithoutMediaInput[]
    createMany?: NoteCreateManyMediaInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type CommentReplyUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<CommentReplyCreateWithoutMediaInput, CommentReplyUncheckedCreateWithoutMediaInput> | CommentReplyCreateWithoutMediaInput[] | CommentReplyUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutMediaInput | CommentReplyCreateOrConnectWithoutMediaInput[]
    createMany?: CommentReplyCreateManyMediaInputEnvelope
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<PostCreateWithoutMediaInput, PostUncheckedCreateWithoutMediaInput> | PostCreateWithoutMediaInput[] | PostUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: PostCreateOrConnectWithoutMediaInput | PostCreateOrConnectWithoutMediaInput[]
    createMany?: PostCreateManyMediaInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<CommentCreateWithoutMediaInput, CommentUncheckedCreateWithoutMediaInput> | CommentCreateWithoutMediaInput[] | CommentUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutMediaInput | CommentCreateOrConnectWithoutMediaInput[]
    createMany?: CommentCreateManyMediaInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PollPostUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<PollPostCreateWithoutMediaInput, PollPostUncheckedCreateWithoutMediaInput> | PollPostCreateWithoutMediaInput[] | PollPostUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: PollPostCreateOrConnectWithoutMediaInput | PollPostCreateOrConnectWithoutMediaInput[]
    createMany?: PollPostCreateManyMediaInputEnvelope
    connect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<NoteCreateWithoutMediaInput, NoteUncheckedCreateWithoutMediaInput> | NoteCreateWithoutMediaInput[] | NoteUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutMediaInput | NoteCreateOrConnectWithoutMediaInput[]
    createMany?: NoteCreateManyMediaInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CommentReplyUpdateManyWithoutMediaNestedInput = {
    create?: XOR<CommentReplyCreateWithoutMediaInput, CommentReplyUncheckedCreateWithoutMediaInput> | CommentReplyCreateWithoutMediaInput[] | CommentReplyUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutMediaInput | CommentReplyCreateOrConnectWithoutMediaInput[]
    upsert?: CommentReplyUpsertWithWhereUniqueWithoutMediaInput | CommentReplyUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: CommentReplyCreateManyMediaInputEnvelope
    set?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    disconnect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    delete?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    update?: CommentReplyUpdateWithWhereUniqueWithoutMediaInput | CommentReplyUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: CommentReplyUpdateManyWithWhereWithoutMediaInput | CommentReplyUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
  }

  export type PostUpdateManyWithoutMediaNestedInput = {
    create?: XOR<PostCreateWithoutMediaInput, PostUncheckedCreateWithoutMediaInput> | PostCreateWithoutMediaInput[] | PostUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: PostCreateOrConnectWithoutMediaInput | PostCreateOrConnectWithoutMediaInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutMediaInput | PostUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: PostCreateManyMediaInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutMediaInput | PostUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: PostUpdateManyWithWhereWithoutMediaInput | PostUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutMediaNestedInput = {
    create?: XOR<CommentCreateWithoutMediaInput, CommentUncheckedCreateWithoutMediaInput> | CommentCreateWithoutMediaInput[] | CommentUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutMediaInput | CommentCreateOrConnectWithoutMediaInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutMediaInput | CommentUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: CommentCreateManyMediaInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutMediaInput | CommentUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutMediaInput | CommentUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PollPostUpdateManyWithoutMediaNestedInput = {
    create?: XOR<PollPostCreateWithoutMediaInput, PollPostUncheckedCreateWithoutMediaInput> | PollPostCreateWithoutMediaInput[] | PollPostUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: PollPostCreateOrConnectWithoutMediaInput | PollPostCreateOrConnectWithoutMediaInput[]
    upsert?: PollPostUpsertWithWhereUniqueWithoutMediaInput | PollPostUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: PollPostCreateManyMediaInputEnvelope
    set?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    disconnect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    delete?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    connect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    update?: PollPostUpdateWithWhereUniqueWithoutMediaInput | PollPostUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: PollPostUpdateManyWithWhereWithoutMediaInput | PollPostUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: PollPostScalarWhereInput | PollPostScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutMediaNestedInput = {
    create?: XOR<NoteCreateWithoutMediaInput, NoteUncheckedCreateWithoutMediaInput> | NoteCreateWithoutMediaInput[] | NoteUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutMediaInput | NoteCreateOrConnectWithoutMediaInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutMediaInput | NoteUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: NoteCreateManyMediaInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutMediaInput | NoteUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutMediaInput | NoteUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type CommentReplyUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<CommentReplyCreateWithoutMediaInput, CommentReplyUncheckedCreateWithoutMediaInput> | CommentReplyCreateWithoutMediaInput[] | CommentReplyUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutMediaInput | CommentReplyCreateOrConnectWithoutMediaInput[]
    upsert?: CommentReplyUpsertWithWhereUniqueWithoutMediaInput | CommentReplyUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: CommentReplyCreateManyMediaInputEnvelope
    set?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    disconnect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    delete?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    update?: CommentReplyUpdateWithWhereUniqueWithoutMediaInput | CommentReplyUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: CommentReplyUpdateManyWithWhereWithoutMediaInput | CommentReplyUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<PostCreateWithoutMediaInput, PostUncheckedCreateWithoutMediaInput> | PostCreateWithoutMediaInput[] | PostUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: PostCreateOrConnectWithoutMediaInput | PostCreateOrConnectWithoutMediaInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutMediaInput | PostUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: PostCreateManyMediaInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutMediaInput | PostUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: PostUpdateManyWithWhereWithoutMediaInput | PostUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<CommentCreateWithoutMediaInput, CommentUncheckedCreateWithoutMediaInput> | CommentCreateWithoutMediaInput[] | CommentUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutMediaInput | CommentCreateOrConnectWithoutMediaInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutMediaInput | CommentUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: CommentCreateManyMediaInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutMediaInput | CommentUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutMediaInput | CommentUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PollPostUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<PollPostCreateWithoutMediaInput, PollPostUncheckedCreateWithoutMediaInput> | PollPostCreateWithoutMediaInput[] | PollPostUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: PollPostCreateOrConnectWithoutMediaInput | PollPostCreateOrConnectWithoutMediaInput[]
    upsert?: PollPostUpsertWithWhereUniqueWithoutMediaInput | PollPostUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: PollPostCreateManyMediaInputEnvelope
    set?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    disconnect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    delete?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    connect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    update?: PollPostUpdateWithWhereUniqueWithoutMediaInput | PollPostUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: PollPostUpdateManyWithWhereWithoutMediaInput | PollPostUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: PollPostScalarWhereInput | PollPostScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<NoteCreateWithoutMediaInput, NoteUncheckedCreateWithoutMediaInput> | NoteCreateWithoutMediaInput[] | NoteUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutMediaInput | NoteCreateOrConnectWithoutMediaInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutMediaInput | NoteUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: NoteCreateManyMediaInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutMediaInput | NoteUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutMediaInput | NoteUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type PostCreatetagsInput = {
    set: string[]
  }

  export type PostCreatementionsInput = {
    set: string[]
  }

  export type PostCreatehashtagsInput = {
    set: string[]
  }

  export type ContentInsightsNullableCreateEnvelopeInput = {
    set?: ContentInsightsCreateInput | null
  }

  export type ContentInsightsCreateInput = {
    sentenceCount: number
    wordCount: number
    language: string
    languageConfidence: number
    entities?: EntitiesCreateInput | EntitiesCreateInput[]
    sentiment: SentimentCreateInput
    topics?: ContentInsightsCreatetopicsInput | string[]
    keywords?: ContentInsightsCreatekeywordsInput | string[]
    summary?: string | null
    readability?: number | null
  }

  export type AIAnalysisNullableCreateEnvelopeInput = {
    set?: AIAnalysisCreateInput | null
  }

  export type AIAnalysisCreateInput = {
    summary?: string | null
    keyPoints?: AIAnalysisCreatekeyPointsInput | string[]
    sentiment: SentimentAnalysisCreateInput
    entities?: NamedEntityCreateInput | NamedEntityCreateInput[]
    topics?: TopicAnalysisCreateInput | TopicAnalysisCreateInput[]
    keywords?: KeywordCreateInput | KeywordCreateInput[]
    readabilityScore: ReadabilityMetricsCreateInput
    qualityMetrics: ContentQualityCreateInput
    toxicity: ToxicityAnalysisCreateInput
    originality: OriginalityScoreCreateInput
    language: LanguageAnalysisCreateInput
    translation: TranslationInfoCreateInput
    grammarCheck: GrammarAnalysisCreateInput
    styleAnalysis: StyleMetricsCreateInput
    intentions?: IntentAnalysisCreateInput | IntentAnalysisCreateInput[]
    emotions: EmotionAnalysisCreateInput
    bias: BiasAnalysisCreateInput
    subjectivity: number
    imageAnalysis?: ImageAnalysisCreateInput | ImageAnalysisCreateInput[]
    videoAnalysis?: VideoAnalysisCreateInput | VideoAnalysisCreateInput[]
    audioAnalysis?: AudioAnalysisCreateInput | AudioAnalysisCreateInput[]
    marketInsights: MarketAnalysisCreateInput
    competitiveInfo: CompetitiveAnalysisCreateInput
    actionItems?: ActionItemCreateInput | ActionItemCreateInput[]
    processingTime: number
    confidenceScore: number
    modelVersions: ModelMetadataCreateInput
    timestamp: Date | string
    processingCost: number
  }

  export type SearchMetadataNullableCreateEnvelopeInput = {
    set?: SearchMetadataCreateInput | null
  }

  export type SearchMetadataCreateInput = {
    title: string
    description?: string | null
    keywords?: SearchMetadataCreatekeywordsInput | string[]
    contentType: string
    language: string
    fileSize?: number | null
    wordCount?: number | null
    pageCount?: number | null
    duration?: number | null
    transcription?: string | null
    extractedText?: string | null
    lastIndexed: Date | string
    searchScore: number
    aiTags?: SearchMetadataCreateaiTagsInput | string[]
    classifications?: SearchMetadataCreateclassificationsInput | string[]
    visibility: $Enums.AccessLevel
    readingLevel?: string | null
    locationData?: InputJsonValue | null
  }

  export type MediaCreateNestedOneWithoutPostInput = {
    create?: XOR<MediaCreateWithoutPostInput, MediaUncheckedCreateWithoutPostInput>
    connectOrCreate?: MediaCreateOrConnectWithoutPostInput
    connect?: MediaWhereUniqueInput
  }

  export type FileToPostCreateNestedManyWithoutPostInput = {
    create?: XOR<FileToPostCreateWithoutPostInput, FileToPostUncheckedCreateWithoutPostInput> | FileToPostCreateWithoutPostInput[] | FileToPostUncheckedCreateWithoutPostInput[]
    connectOrCreate?: FileToPostCreateOrConnectWithoutPostInput | FileToPostCreateOrConnectWithoutPostInput[]
    createMany?: FileToPostCreateManyPostInputEnvelope
    connect?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutPostInput = {
    create?: XOR<NoteCreateWithoutPostInput, NoteUncheckedCreateWithoutPostInput> | NoteCreateWithoutPostInput[] | NoteUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutPostInput | NoteCreateOrConnectWithoutPostInput[]
    createMany?: NoteCreateManyPostInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type ThreadCreateNestedOneWithoutPostsInput = {
    create?: XOR<ThreadCreateWithoutPostsInput, ThreadUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutPostsInput
    connect?: ThreadWhereUniqueInput
  }

  export type SpaceCreateNestedOneWithoutPostsInput = {
    create?: XOR<SpaceCreateWithoutPostsInput, SpaceUncheckedCreateWithoutPostsInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutPostsInput
    connect?: SpaceWhereUniqueInput
  }

  export type ChannelCreateNestedOneWithoutPostsInput = {
    create?: XOR<ChannelCreateWithoutPostsInput, ChannelUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutPostsInput
    connect?: ChannelWhereUniqueInput
  }

  export type FileToPostUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<FileToPostCreateWithoutPostInput, FileToPostUncheckedCreateWithoutPostInput> | FileToPostCreateWithoutPostInput[] | FileToPostUncheckedCreateWithoutPostInput[]
    connectOrCreate?: FileToPostCreateOrConnectWithoutPostInput | FileToPostCreateOrConnectWithoutPostInput[]
    createMany?: FileToPostCreateManyPostInputEnvelope
    connect?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<NoteCreateWithoutPostInput, NoteUncheckedCreateWithoutPostInput> | NoteCreateWithoutPostInput[] | NoteUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutPostInput | NoteCreateOrConnectWithoutPostInput[]
    createMany?: NoteCreateManyPostInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type EnumPostTypeFieldUpdateOperationsInput = {
    set?: $Enums.PostType
  }

  export type NullableEnumCategoryFieldUpdateOperationsInput = {
    set?: $Enums.Category | null
    unset?: boolean
  }

  export type NullableEnumThreadParticipantTypeFieldUpdateOperationsInput = {
    set?: $Enums.ThreadParticipantType | null
    unset?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type PostUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PostUpdatementionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PostUpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContentInsightsNullableUpdateEnvelopeInput = {
    set?: ContentInsightsCreateInput | null
    upsert?: ContentInsightsUpsertInput
    unset?: boolean
  }

  export type AIAnalysisNullableUpdateEnvelopeInput = {
    set?: AIAnalysisCreateInput | null
    upsert?: AIAnalysisUpsertInput
    unset?: boolean
  }

  export type SearchMetadataNullableUpdateEnvelopeInput = {
    set?: SearchMetadataCreateInput | null
    upsert?: SearchMetadataUpsertInput
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MediaUpdateOneWithoutPostNestedInput = {
    create?: XOR<MediaCreateWithoutPostInput, MediaUncheckedCreateWithoutPostInput>
    connectOrCreate?: MediaCreateOrConnectWithoutPostInput
    upsert?: MediaUpsertWithoutPostInput
    disconnect?: boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutPostInput, MediaUpdateWithoutPostInput>, MediaUncheckedUpdateWithoutPostInput>
  }

  export type FileToPostUpdateManyWithoutPostNestedInput = {
    create?: XOR<FileToPostCreateWithoutPostInput, FileToPostUncheckedCreateWithoutPostInput> | FileToPostCreateWithoutPostInput[] | FileToPostUncheckedCreateWithoutPostInput[]
    connectOrCreate?: FileToPostCreateOrConnectWithoutPostInput | FileToPostCreateOrConnectWithoutPostInput[]
    upsert?: FileToPostUpsertWithWhereUniqueWithoutPostInput | FileToPostUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: FileToPostCreateManyPostInputEnvelope
    set?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
    disconnect?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
    delete?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
    connect?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
    update?: FileToPostUpdateWithWhereUniqueWithoutPostInput | FileToPostUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: FileToPostUpdateManyWithWhereWithoutPostInput | FileToPostUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: FileToPostScalarWhereInput | FileToPostScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutPostNestedInput = {
    create?: XOR<NoteCreateWithoutPostInput, NoteUncheckedCreateWithoutPostInput> | NoteCreateWithoutPostInput[] | NoteUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutPostInput | NoteCreateOrConnectWithoutPostInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutPostInput | NoteUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: NoteCreateManyPostInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutPostInput | NoteUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutPostInput | NoteUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type ThreadUpdateOneWithoutPostsNestedInput = {
    create?: XOR<ThreadCreateWithoutPostsInput, ThreadUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutPostsInput
    upsert?: ThreadUpsertWithoutPostsInput
    disconnect?: boolean
    delete?: ThreadWhereInput | boolean
    connect?: ThreadWhereUniqueInput
    update?: XOR<XOR<ThreadUpdateToOneWithWhereWithoutPostsInput, ThreadUpdateWithoutPostsInput>, ThreadUncheckedUpdateWithoutPostsInput>
  }

  export type SpaceUpdateOneWithoutPostsNestedInput = {
    create?: XOR<SpaceCreateWithoutPostsInput, SpaceUncheckedCreateWithoutPostsInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutPostsInput
    upsert?: SpaceUpsertWithoutPostsInput
    disconnect?: boolean
    delete?: SpaceWhereInput | boolean
    connect?: SpaceWhereUniqueInput
    update?: XOR<XOR<SpaceUpdateToOneWithWhereWithoutPostsInput, SpaceUpdateWithoutPostsInput>, SpaceUncheckedUpdateWithoutPostsInput>
  }

  export type ChannelUpdateOneWithoutPostsNestedInput = {
    create?: XOR<ChannelCreateWithoutPostsInput, ChannelUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutPostsInput
    upsert?: ChannelUpsertWithoutPostsInput
    disconnect?: boolean
    delete?: ChannelWhereInput | boolean
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutPostsInput, ChannelUpdateWithoutPostsInput>, ChannelUncheckedUpdateWithoutPostsInput>
  }

  export type FileToPostUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<FileToPostCreateWithoutPostInput, FileToPostUncheckedCreateWithoutPostInput> | FileToPostCreateWithoutPostInput[] | FileToPostUncheckedCreateWithoutPostInput[]
    connectOrCreate?: FileToPostCreateOrConnectWithoutPostInput | FileToPostCreateOrConnectWithoutPostInput[]
    upsert?: FileToPostUpsertWithWhereUniqueWithoutPostInput | FileToPostUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: FileToPostCreateManyPostInputEnvelope
    set?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
    disconnect?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
    delete?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
    connect?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
    update?: FileToPostUpdateWithWhereUniqueWithoutPostInput | FileToPostUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: FileToPostUpdateManyWithWhereWithoutPostInput | FileToPostUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: FileToPostScalarWhereInput | FileToPostScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<NoteCreateWithoutPostInput, NoteUncheckedCreateWithoutPostInput> | NoteCreateWithoutPostInput[] | NoteUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutPostInput | NoteCreateOrConnectWithoutPostInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutPostInput | NoteUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: NoteCreateManyPostInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutPostInput | NoteUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutPostInput | NoteUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type PollPostCreatepollOptionsInput = {
    set: string[]
  }

  export type PollPostCreatementionsInput = {
    set: string[]
  }

  export type PollPostCreatehashtagsInput = {
    set: string[]
  }

  export type PollPostCreatetagsInput = {
    set: string[]
  }

  export type MediaCreateNestedOneWithoutPollPostInput = {
    create?: XOR<MediaCreateWithoutPollPostInput, MediaUncheckedCreateWithoutPollPostInput>
    connectOrCreate?: MediaCreateOrConnectWithoutPollPostInput
    connect?: MediaWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutPollPostInput = {
    create?: XOR<CommentCreateWithoutPollPostInput, CommentUncheckedCreateWithoutPollPostInput> | CommentCreateWithoutPollPostInput[] | CommentUncheckedCreateWithoutPollPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPollPostInput | CommentCreateOrConnectWithoutPollPostInput[]
    createMany?: CommentCreateManyPollPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ThreadCreateNestedOneWithoutPollPostsInput = {
    create?: XOR<ThreadCreateWithoutPollPostsInput, ThreadUncheckedCreateWithoutPollPostsInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutPollPostsInput
    connect?: ThreadWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutPollPostInput = {
    create?: XOR<CommentCreateWithoutPollPostInput, CommentUncheckedCreateWithoutPollPostInput> | CommentCreateWithoutPollPostInput[] | CommentUncheckedCreateWithoutPollPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPollPostInput | CommentCreateOrConnectWithoutPollPostInput[]
    createMany?: CommentCreateManyPollPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PollPostUpdatepollOptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PollPostUpdatementionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PollPostUpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PollPostUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MediaUpdateOneWithoutPollPostNestedInput = {
    create?: XOR<MediaCreateWithoutPollPostInput, MediaUncheckedCreateWithoutPollPostInput>
    connectOrCreate?: MediaCreateOrConnectWithoutPollPostInput
    upsert?: MediaUpsertWithoutPollPostInput
    disconnect?: boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutPollPostInput, MediaUpdateWithoutPollPostInput>, MediaUncheckedUpdateWithoutPollPostInput>
  }

  export type CommentUpdateManyWithoutPollPostNestedInput = {
    create?: XOR<CommentCreateWithoutPollPostInput, CommentUncheckedCreateWithoutPollPostInput> | CommentCreateWithoutPollPostInput[] | CommentUncheckedCreateWithoutPollPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPollPostInput | CommentCreateOrConnectWithoutPollPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPollPostInput | CommentUpsertWithWhereUniqueWithoutPollPostInput[]
    createMany?: CommentCreateManyPollPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPollPostInput | CommentUpdateWithWhereUniqueWithoutPollPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPollPostInput | CommentUpdateManyWithWhereWithoutPollPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ThreadUpdateOneWithoutPollPostsNestedInput = {
    create?: XOR<ThreadCreateWithoutPollPostsInput, ThreadUncheckedCreateWithoutPollPostsInput>
    connectOrCreate?: ThreadCreateOrConnectWithoutPollPostsInput
    upsert?: ThreadUpsertWithoutPollPostsInput
    disconnect?: boolean
    delete?: ThreadWhereInput | boolean
    connect?: ThreadWhereUniqueInput
    update?: XOR<XOR<ThreadUpdateToOneWithWhereWithoutPollPostsInput, ThreadUpdateWithoutPollPostsInput>, ThreadUncheckedUpdateWithoutPollPostsInput>
  }

  export type CommentUncheckedUpdateManyWithoutPollPostNestedInput = {
    create?: XOR<CommentCreateWithoutPollPostInput, CommentUncheckedCreateWithoutPollPostInput> | CommentCreateWithoutPollPostInput[] | CommentUncheckedCreateWithoutPollPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPollPostInput | CommentCreateOrConnectWithoutPollPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPollPostInput | CommentUpsertWithWhereUniqueWithoutPollPostInput[]
    createMany?: CommentCreateManyPollPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPollPostInput | CommentUpdateWithWhereUniqueWithoutPollPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPollPostInput | CommentUpdateManyWithWhereWithoutPollPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type SpaceCreatetagsInput = {
    set: string[]
  }

  export type SpaceMemberCreateNestedManyWithoutSpaceInput = {
    create?: XOR<SpaceMemberCreateWithoutSpaceInput, SpaceMemberUncheckedCreateWithoutSpaceInput> | SpaceMemberCreateWithoutSpaceInput[] | SpaceMemberUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: SpaceMemberCreateOrConnectWithoutSpaceInput | SpaceMemberCreateOrConnectWithoutSpaceInput[]
    createMany?: SpaceMemberCreateManySpaceInputEnvelope
    connect?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
  }

  export type ChannelCreateNestedManyWithoutSpaceInput = {
    create?: XOR<ChannelCreateWithoutSpaceInput, ChannelUncheckedCreateWithoutSpaceInput> | ChannelCreateWithoutSpaceInput[] | ChannelUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutSpaceInput | ChannelCreateOrConnectWithoutSpaceInput[]
    createMany?: ChannelCreateManySpaceInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutSpaceInput = {
    create?: XOR<PostCreateWithoutSpaceInput, PostUncheckedCreateWithoutSpaceInput> | PostCreateWithoutSpaceInput[] | PostUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: PostCreateOrConnectWithoutSpaceInput | PostCreateOrConnectWithoutSpaceInput[]
    createMany?: PostCreateManySpaceInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutSpaceInput = {
    create?: XOR<FileCreateWithoutSpaceInput, FileUncheckedCreateWithoutSpaceInput> | FileCreateWithoutSpaceInput[] | FileUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: FileCreateOrConnectWithoutSpaceInput | FileCreateOrConnectWithoutSpaceInput[]
    createMany?: FileCreateManySpaceInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type SpaceCreateNestedOneWithoutChildSpacesInput = {
    create?: XOR<SpaceCreateWithoutChildSpacesInput, SpaceUncheckedCreateWithoutChildSpacesInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutChildSpacesInput
    connect?: SpaceWhereUniqueInput
  }

  export type SpaceCreateNestedManyWithoutParentSpaceInput = {
    create?: XOR<SpaceCreateWithoutParentSpaceInput, SpaceUncheckedCreateWithoutParentSpaceInput> | SpaceCreateWithoutParentSpaceInput[] | SpaceUncheckedCreateWithoutParentSpaceInput[]
    connectOrCreate?: SpaceCreateOrConnectWithoutParentSpaceInput | SpaceCreateOrConnectWithoutParentSpaceInput[]
    createMany?: SpaceCreateManyParentSpaceInputEnvelope
    connect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
  }

  export type SpaceMemberUncheckedCreateNestedManyWithoutSpaceInput = {
    create?: XOR<SpaceMemberCreateWithoutSpaceInput, SpaceMemberUncheckedCreateWithoutSpaceInput> | SpaceMemberCreateWithoutSpaceInput[] | SpaceMemberUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: SpaceMemberCreateOrConnectWithoutSpaceInput | SpaceMemberCreateOrConnectWithoutSpaceInput[]
    createMany?: SpaceMemberCreateManySpaceInputEnvelope
    connect?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
  }

  export type ChannelUncheckedCreateNestedManyWithoutSpaceInput = {
    create?: XOR<ChannelCreateWithoutSpaceInput, ChannelUncheckedCreateWithoutSpaceInput> | ChannelCreateWithoutSpaceInput[] | ChannelUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutSpaceInput | ChannelCreateOrConnectWithoutSpaceInput[]
    createMany?: ChannelCreateManySpaceInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutSpaceInput = {
    create?: XOR<PostCreateWithoutSpaceInput, PostUncheckedCreateWithoutSpaceInput> | PostCreateWithoutSpaceInput[] | PostUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: PostCreateOrConnectWithoutSpaceInput | PostCreateOrConnectWithoutSpaceInput[]
    createMany?: PostCreateManySpaceInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutSpaceInput = {
    create?: XOR<FileCreateWithoutSpaceInput, FileUncheckedCreateWithoutSpaceInput> | FileCreateWithoutSpaceInput[] | FileUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: FileCreateOrConnectWithoutSpaceInput | FileCreateOrConnectWithoutSpaceInput[]
    createMany?: FileCreateManySpaceInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type SpaceUncheckedCreateNestedManyWithoutParentSpaceInput = {
    create?: XOR<SpaceCreateWithoutParentSpaceInput, SpaceUncheckedCreateWithoutParentSpaceInput> | SpaceCreateWithoutParentSpaceInput[] | SpaceUncheckedCreateWithoutParentSpaceInput[]
    connectOrCreate?: SpaceCreateOrConnectWithoutParentSpaceInput | SpaceCreateOrConnectWithoutParentSpaceInput[]
    createMany?: SpaceCreateManyParentSpaceInputEnvelope
    connect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
  }

  export type EnumSpaceTypeFieldUpdateOperationsInput = {
    set?: $Enums.SpaceType
  }

  export type EnumAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.AccessLevel
  }

  export type SpaceUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SpaceMemberUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<SpaceMemberCreateWithoutSpaceInput, SpaceMemberUncheckedCreateWithoutSpaceInput> | SpaceMemberCreateWithoutSpaceInput[] | SpaceMemberUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: SpaceMemberCreateOrConnectWithoutSpaceInput | SpaceMemberCreateOrConnectWithoutSpaceInput[]
    upsert?: SpaceMemberUpsertWithWhereUniqueWithoutSpaceInput | SpaceMemberUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: SpaceMemberCreateManySpaceInputEnvelope
    set?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
    disconnect?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
    delete?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
    connect?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
    update?: SpaceMemberUpdateWithWhereUniqueWithoutSpaceInput | SpaceMemberUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: SpaceMemberUpdateManyWithWhereWithoutSpaceInput | SpaceMemberUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: SpaceMemberScalarWhereInput | SpaceMemberScalarWhereInput[]
  }

  export type ChannelUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<ChannelCreateWithoutSpaceInput, ChannelUncheckedCreateWithoutSpaceInput> | ChannelCreateWithoutSpaceInput[] | ChannelUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutSpaceInput | ChannelCreateOrConnectWithoutSpaceInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutSpaceInput | ChannelUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: ChannelCreateManySpaceInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutSpaceInput | ChannelUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutSpaceInput | ChannelUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type PostUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<PostCreateWithoutSpaceInput, PostUncheckedCreateWithoutSpaceInput> | PostCreateWithoutSpaceInput[] | PostUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: PostCreateOrConnectWithoutSpaceInput | PostCreateOrConnectWithoutSpaceInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutSpaceInput | PostUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: PostCreateManySpaceInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutSpaceInput | PostUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: PostUpdateManyWithWhereWithoutSpaceInput | PostUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type FileUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<FileCreateWithoutSpaceInput, FileUncheckedCreateWithoutSpaceInput> | FileCreateWithoutSpaceInput[] | FileUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: FileCreateOrConnectWithoutSpaceInput | FileCreateOrConnectWithoutSpaceInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutSpaceInput | FileUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: FileCreateManySpaceInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutSpaceInput | FileUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: FileUpdateManyWithWhereWithoutSpaceInput | FileUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type SpaceUpdateOneWithoutChildSpacesNestedInput = {
    create?: XOR<SpaceCreateWithoutChildSpacesInput, SpaceUncheckedCreateWithoutChildSpacesInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutChildSpacesInput
    upsert?: SpaceUpsertWithoutChildSpacesInput
    disconnect?: boolean
    delete?: SpaceWhereInput | boolean
    connect?: SpaceWhereUniqueInput
    update?: XOR<XOR<SpaceUpdateToOneWithWhereWithoutChildSpacesInput, SpaceUpdateWithoutChildSpacesInput>, SpaceUncheckedUpdateWithoutChildSpacesInput>
  }

  export type SpaceUpdateManyWithoutParentSpaceNestedInput = {
    create?: XOR<SpaceCreateWithoutParentSpaceInput, SpaceUncheckedCreateWithoutParentSpaceInput> | SpaceCreateWithoutParentSpaceInput[] | SpaceUncheckedCreateWithoutParentSpaceInput[]
    connectOrCreate?: SpaceCreateOrConnectWithoutParentSpaceInput | SpaceCreateOrConnectWithoutParentSpaceInput[]
    upsert?: SpaceUpsertWithWhereUniqueWithoutParentSpaceInput | SpaceUpsertWithWhereUniqueWithoutParentSpaceInput[]
    createMany?: SpaceCreateManyParentSpaceInputEnvelope
    set?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    disconnect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    delete?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    connect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    update?: SpaceUpdateWithWhereUniqueWithoutParentSpaceInput | SpaceUpdateWithWhereUniqueWithoutParentSpaceInput[]
    updateMany?: SpaceUpdateManyWithWhereWithoutParentSpaceInput | SpaceUpdateManyWithWhereWithoutParentSpaceInput[]
    deleteMany?: SpaceScalarWhereInput | SpaceScalarWhereInput[]
  }

  export type SpaceMemberUncheckedUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<SpaceMemberCreateWithoutSpaceInput, SpaceMemberUncheckedCreateWithoutSpaceInput> | SpaceMemberCreateWithoutSpaceInput[] | SpaceMemberUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: SpaceMemberCreateOrConnectWithoutSpaceInput | SpaceMemberCreateOrConnectWithoutSpaceInput[]
    upsert?: SpaceMemberUpsertWithWhereUniqueWithoutSpaceInput | SpaceMemberUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: SpaceMemberCreateManySpaceInputEnvelope
    set?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
    disconnect?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
    delete?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
    connect?: SpaceMemberWhereUniqueInput | SpaceMemberWhereUniqueInput[]
    update?: SpaceMemberUpdateWithWhereUniqueWithoutSpaceInput | SpaceMemberUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: SpaceMemberUpdateManyWithWhereWithoutSpaceInput | SpaceMemberUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: SpaceMemberScalarWhereInput | SpaceMemberScalarWhereInput[]
  }

  export type ChannelUncheckedUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<ChannelCreateWithoutSpaceInput, ChannelUncheckedCreateWithoutSpaceInput> | ChannelCreateWithoutSpaceInput[] | ChannelUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutSpaceInput | ChannelCreateOrConnectWithoutSpaceInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutSpaceInput | ChannelUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: ChannelCreateManySpaceInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutSpaceInput | ChannelUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutSpaceInput | ChannelUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<PostCreateWithoutSpaceInput, PostUncheckedCreateWithoutSpaceInput> | PostCreateWithoutSpaceInput[] | PostUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: PostCreateOrConnectWithoutSpaceInput | PostCreateOrConnectWithoutSpaceInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutSpaceInput | PostUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: PostCreateManySpaceInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutSpaceInput | PostUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: PostUpdateManyWithWhereWithoutSpaceInput | PostUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutSpaceNestedInput = {
    create?: XOR<FileCreateWithoutSpaceInput, FileUncheckedCreateWithoutSpaceInput> | FileCreateWithoutSpaceInput[] | FileUncheckedCreateWithoutSpaceInput[]
    connectOrCreate?: FileCreateOrConnectWithoutSpaceInput | FileCreateOrConnectWithoutSpaceInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutSpaceInput | FileUpsertWithWhereUniqueWithoutSpaceInput[]
    createMany?: FileCreateManySpaceInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutSpaceInput | FileUpdateWithWhereUniqueWithoutSpaceInput[]
    updateMany?: FileUpdateManyWithWhereWithoutSpaceInput | FileUpdateManyWithWhereWithoutSpaceInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type SpaceUncheckedUpdateManyWithoutParentSpaceNestedInput = {
    create?: XOR<SpaceCreateWithoutParentSpaceInput, SpaceUncheckedCreateWithoutParentSpaceInput> | SpaceCreateWithoutParentSpaceInput[] | SpaceUncheckedCreateWithoutParentSpaceInput[]
    connectOrCreate?: SpaceCreateOrConnectWithoutParentSpaceInput | SpaceCreateOrConnectWithoutParentSpaceInput[]
    upsert?: SpaceUpsertWithWhereUniqueWithoutParentSpaceInput | SpaceUpsertWithWhereUniqueWithoutParentSpaceInput[]
    createMany?: SpaceCreateManyParentSpaceInputEnvelope
    set?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    disconnect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    delete?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    connect?: SpaceWhereUniqueInput | SpaceWhereUniqueInput[]
    update?: SpaceUpdateWithWhereUniqueWithoutParentSpaceInput | SpaceUpdateWithWhereUniqueWithoutParentSpaceInput[]
    updateMany?: SpaceUpdateManyWithWhereWithoutParentSpaceInput | SpaceUpdateManyWithWhereWithoutParentSpaceInput[]
    deleteMany?: SpaceScalarWhereInput | SpaceScalarWhereInput[]
  }

  export type ChannelCreatepinnedPostsInput = {
    set: string[]
  }

  export type SpaceCreateNestedOneWithoutChannelsInput = {
    create?: XOR<SpaceCreateWithoutChannelsInput, SpaceUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutChannelsInput
    connect?: SpaceWhereUniqueInput
  }

  export type PostCreateNestedManyWithoutChannelInput = {
    create?: XOR<PostCreateWithoutChannelInput, PostUncheckedCreateWithoutChannelInput> | PostCreateWithoutChannelInput[] | PostUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: PostCreateOrConnectWithoutChannelInput | PostCreateOrConnectWithoutChannelInput[]
    createMany?: PostCreateManyChannelInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutChannelInput = {
    create?: XOR<FileCreateWithoutChannelInput, FileUncheckedCreateWithoutChannelInput> | FileCreateWithoutChannelInput[] | FileUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: FileCreateOrConnectWithoutChannelInput | FileCreateOrConnectWithoutChannelInput[]
    createMany?: FileCreateManyChannelInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ChannelMemberCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelMemberCreateWithoutChannelInput, ChannelMemberUncheckedCreateWithoutChannelInput> | ChannelMemberCreateWithoutChannelInput[] | ChannelMemberUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelMemberCreateOrConnectWithoutChannelInput | ChannelMemberCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelMemberCreateManyChannelInputEnvelope
    connect?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<PostCreateWithoutChannelInput, PostUncheckedCreateWithoutChannelInput> | PostCreateWithoutChannelInput[] | PostUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: PostCreateOrConnectWithoutChannelInput | PostCreateOrConnectWithoutChannelInput[]
    createMany?: PostCreateManyChannelInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<FileCreateWithoutChannelInput, FileUncheckedCreateWithoutChannelInput> | FileCreateWithoutChannelInput[] | FileUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: FileCreateOrConnectWithoutChannelInput | FileCreateOrConnectWithoutChannelInput[]
    createMany?: FileCreateManyChannelInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ChannelMemberUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelMemberCreateWithoutChannelInput, ChannelMemberUncheckedCreateWithoutChannelInput> | ChannelMemberCreateWithoutChannelInput[] | ChannelMemberUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelMemberCreateOrConnectWithoutChannelInput | ChannelMemberCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelMemberCreateManyChannelInputEnvelope
    connect?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
  }

  export type ChannelUpdatepinnedPostsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SpaceUpdateOneRequiredWithoutChannelsNestedInput = {
    create?: XOR<SpaceCreateWithoutChannelsInput, SpaceUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutChannelsInput
    upsert?: SpaceUpsertWithoutChannelsInput
    connect?: SpaceWhereUniqueInput
    update?: XOR<XOR<SpaceUpdateToOneWithWhereWithoutChannelsInput, SpaceUpdateWithoutChannelsInput>, SpaceUncheckedUpdateWithoutChannelsInput>
  }

  export type PostUpdateManyWithoutChannelNestedInput = {
    create?: XOR<PostCreateWithoutChannelInput, PostUncheckedCreateWithoutChannelInput> | PostCreateWithoutChannelInput[] | PostUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: PostCreateOrConnectWithoutChannelInput | PostCreateOrConnectWithoutChannelInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutChannelInput | PostUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: PostCreateManyChannelInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutChannelInput | PostUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: PostUpdateManyWithWhereWithoutChannelInput | PostUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type FileUpdateManyWithoutChannelNestedInput = {
    create?: XOR<FileCreateWithoutChannelInput, FileUncheckedCreateWithoutChannelInput> | FileCreateWithoutChannelInput[] | FileUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: FileCreateOrConnectWithoutChannelInput | FileCreateOrConnectWithoutChannelInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutChannelInput | FileUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: FileCreateManyChannelInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutChannelInput | FileUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: FileUpdateManyWithWhereWithoutChannelInput | FileUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ChannelMemberUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelMemberCreateWithoutChannelInput, ChannelMemberUncheckedCreateWithoutChannelInput> | ChannelMemberCreateWithoutChannelInput[] | ChannelMemberUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelMemberCreateOrConnectWithoutChannelInput | ChannelMemberCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelMemberUpsertWithWhereUniqueWithoutChannelInput | ChannelMemberUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelMemberCreateManyChannelInputEnvelope
    set?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
    disconnect?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
    delete?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
    connect?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
    update?: ChannelMemberUpdateWithWhereUniqueWithoutChannelInput | ChannelMemberUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelMemberUpdateManyWithWhereWithoutChannelInput | ChannelMemberUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelMemberScalarWhereInput | ChannelMemberScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<PostCreateWithoutChannelInput, PostUncheckedCreateWithoutChannelInput> | PostCreateWithoutChannelInput[] | PostUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: PostCreateOrConnectWithoutChannelInput | PostCreateOrConnectWithoutChannelInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutChannelInput | PostUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: PostCreateManyChannelInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutChannelInput | PostUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: PostUpdateManyWithWhereWithoutChannelInput | PostUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<FileCreateWithoutChannelInput, FileUncheckedCreateWithoutChannelInput> | FileCreateWithoutChannelInput[] | FileUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: FileCreateOrConnectWithoutChannelInput | FileCreateOrConnectWithoutChannelInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutChannelInput | FileUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: FileCreateManyChannelInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutChannelInput | FileUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: FileUpdateManyWithWhereWithoutChannelInput | FileUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ChannelMemberUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelMemberCreateWithoutChannelInput, ChannelMemberUncheckedCreateWithoutChannelInput> | ChannelMemberCreateWithoutChannelInput[] | ChannelMemberUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelMemberCreateOrConnectWithoutChannelInput | ChannelMemberCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelMemberUpsertWithWhereUniqueWithoutChannelInput | ChannelMemberUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelMemberCreateManyChannelInputEnvelope
    set?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
    disconnect?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
    delete?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
    connect?: ChannelMemberWhereUniqueInput | ChannelMemberWhereUniqueInput[]
    update?: ChannelMemberUpdateWithWhereUniqueWithoutChannelInput | ChannelMemberUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelMemberUpdateManyWithWhereWithoutChannelInput | ChannelMemberUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelMemberScalarWhereInput | ChannelMemberScalarWhereInput[]
  }

  export type ThreadCreatepostIdsInput = {
    set: string[]
  }

  export type PostCreateNestedManyWithoutThreadInput = {
    create?: XOR<PostCreateWithoutThreadInput, PostUncheckedCreateWithoutThreadInput> | PostCreateWithoutThreadInput[] | PostUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: PostCreateOrConnectWithoutThreadInput | PostCreateOrConnectWithoutThreadInput[]
    createMany?: PostCreateManyThreadInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PollPostCreateNestedManyWithoutThreadInput = {
    create?: XOR<PollPostCreateWithoutThreadInput, PollPostUncheckedCreateWithoutThreadInput> | PollPostCreateWithoutThreadInput[] | PollPostUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: PollPostCreateOrConnectWithoutThreadInput | PollPostCreateOrConnectWithoutThreadInput[]
    createMany?: PollPostCreateManyThreadInputEnvelope
    connect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<PostCreateWithoutThreadInput, PostUncheckedCreateWithoutThreadInput> | PostCreateWithoutThreadInput[] | PostUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: PostCreateOrConnectWithoutThreadInput | PostCreateOrConnectWithoutThreadInput[]
    createMany?: PostCreateManyThreadInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PollPostUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<PollPostCreateWithoutThreadInput, PollPostUncheckedCreateWithoutThreadInput> | PollPostCreateWithoutThreadInput[] | PollPostUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: PollPostCreateOrConnectWithoutThreadInput | PollPostCreateOrConnectWithoutThreadInput[]
    createMany?: PollPostCreateManyThreadInputEnvelope
    connect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
  }

  export type ThreadUpdatepostIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PostUpdateManyWithoutThreadNestedInput = {
    create?: XOR<PostCreateWithoutThreadInput, PostUncheckedCreateWithoutThreadInput> | PostCreateWithoutThreadInput[] | PostUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: PostCreateOrConnectWithoutThreadInput | PostCreateOrConnectWithoutThreadInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutThreadInput | PostUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: PostCreateManyThreadInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutThreadInput | PostUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: PostUpdateManyWithWhereWithoutThreadInput | PostUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PollPostUpdateManyWithoutThreadNestedInput = {
    create?: XOR<PollPostCreateWithoutThreadInput, PollPostUncheckedCreateWithoutThreadInput> | PollPostCreateWithoutThreadInput[] | PollPostUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: PollPostCreateOrConnectWithoutThreadInput | PollPostCreateOrConnectWithoutThreadInput[]
    upsert?: PollPostUpsertWithWhereUniqueWithoutThreadInput | PollPostUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: PollPostCreateManyThreadInputEnvelope
    set?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    disconnect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    delete?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    connect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    update?: PollPostUpdateWithWhereUniqueWithoutThreadInput | PollPostUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: PollPostUpdateManyWithWhereWithoutThreadInput | PollPostUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: PollPostScalarWhereInput | PollPostScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<PostCreateWithoutThreadInput, PostUncheckedCreateWithoutThreadInput> | PostCreateWithoutThreadInput[] | PostUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: PostCreateOrConnectWithoutThreadInput | PostCreateOrConnectWithoutThreadInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutThreadInput | PostUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: PostCreateManyThreadInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutThreadInput | PostUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: PostUpdateManyWithWhereWithoutThreadInput | PostUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PollPostUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<PollPostCreateWithoutThreadInput, PollPostUncheckedCreateWithoutThreadInput> | PollPostCreateWithoutThreadInput[] | PollPostUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: PollPostCreateOrConnectWithoutThreadInput | PollPostCreateOrConnectWithoutThreadInput[]
    upsert?: PollPostUpsertWithWhereUniqueWithoutThreadInput | PollPostUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: PollPostCreateManyThreadInputEnvelope
    set?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    disconnect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    delete?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    connect?: PollPostWhereUniqueInput | PollPostWhereUniqueInput[]
    update?: PollPostUpdateWithWhereUniqueWithoutThreadInput | PollPostUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: PollPostUpdateManyWithWhereWithoutThreadInput | PollPostUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: PollPostScalarWhereInput | PollPostScalarWhereInput[]
  }

  export type NoteCreatementionsInput = {
    set: string[]
  }

  export type NoteCreatehashtagsInput = {
    set: string[]
  }

  export type MediaCreateNestedOneWithoutNoteInput = {
    create?: XOR<MediaCreateWithoutNoteInput, MediaUncheckedCreateWithoutNoteInput>
    connectOrCreate?: MediaCreateOrConnectWithoutNoteInput
    connect?: MediaWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutNotesInput = {
    create?: XOR<PostCreateWithoutNotesInput, PostUncheckedCreateWithoutNotesInput>
    connectOrCreate?: PostCreateOrConnectWithoutNotesInput
    connect?: PostWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutNotesInput = {
    create?: XOR<CommentCreateWithoutNotesInput, CommentUncheckedCreateWithoutNotesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutNotesInput
    connect?: CommentWhereUniqueInput
  }

  export type NoteUpdatementionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NoteUpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MediaUpdateOneWithoutNoteNestedInput = {
    create?: XOR<MediaCreateWithoutNoteInput, MediaUncheckedCreateWithoutNoteInput>
    connectOrCreate?: MediaCreateOrConnectWithoutNoteInput
    upsert?: MediaUpsertWithoutNoteInput
    disconnect?: boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutNoteInput, MediaUpdateWithoutNoteInput>, MediaUncheckedUpdateWithoutNoteInput>
  }

  export type PostUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<PostCreateWithoutNotesInput, PostUncheckedCreateWithoutNotesInput>
    connectOrCreate?: PostCreateOrConnectWithoutNotesInput
    upsert?: PostUpsertWithoutNotesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutNotesInput, PostUpdateWithoutNotesInput>, PostUncheckedUpdateWithoutNotesInput>
  }

  export type CommentUpdateOneWithoutNotesNestedInput = {
    create?: XOR<CommentCreateWithoutNotesInput, CommentUncheckedCreateWithoutNotesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutNotesInput
    upsert?: CommentUpsertWithoutNotesInput
    disconnect?: boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutNotesInput, CommentUpdateWithoutNotesInput>, CommentUncheckedUpdateWithoutNotesInput>
  }

  export type CommentCreatementionsInput = {
    set: string[]
  }

  export type CommentCreatehashtagsInput = {
    set: string[]
  }

  export type MediaCreateNestedOneWithoutCommentInput = {
    create?: XOR<MediaCreateWithoutCommentInput, MediaUncheckedCreateWithoutCommentInput>
    connectOrCreate?: MediaCreateOrConnectWithoutCommentInput
    connect?: MediaWhereUniqueInput
  }

  export type CommentReplyCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput> | CommentReplyCreateWithoutCommentInput[] | CommentReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutCommentInput | CommentReplyCreateOrConnectWithoutCommentInput[]
    createMany?: CommentReplyCreateManyCommentInputEnvelope
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutCommentInput = {
    create?: XOR<NoteCreateWithoutCommentInput, NoteUncheckedCreateWithoutCommentInput> | NoteCreateWithoutCommentInput[] | NoteUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutCommentInput | NoteCreateOrConnectWithoutCommentInput[]
    createMany?: NoteCreateManyCommentInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type PollPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PollPostCreateWithoutCommentsInput, PollPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PollPostCreateOrConnectWithoutCommentsInput
    connect?: PollPostWhereUniqueInput
  }

  export type CommentReplyUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput> | CommentReplyCreateWithoutCommentInput[] | CommentReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutCommentInput | CommentReplyCreateOrConnectWithoutCommentInput[]
    createMany?: CommentReplyCreateManyCommentInputEnvelope
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<NoteCreateWithoutCommentInput, NoteUncheckedCreateWithoutCommentInput> | NoteCreateWithoutCommentInput[] | NoteUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutCommentInput | NoteCreateOrConnectWithoutCommentInput[]
    createMany?: NoteCreateManyCommentInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type CommentUpdatementionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CommentUpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MediaUpdateOneWithoutCommentNestedInput = {
    create?: XOR<MediaCreateWithoutCommentInput, MediaUncheckedCreateWithoutCommentInput>
    connectOrCreate?: MediaCreateOrConnectWithoutCommentInput
    upsert?: MediaUpsertWithoutCommentInput
    disconnect?: boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutCommentInput, MediaUpdateWithoutCommentInput>, MediaUncheckedUpdateWithoutCommentInput>
  }

  export type CommentReplyUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput> | CommentReplyCreateWithoutCommentInput[] | CommentReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutCommentInput | CommentReplyCreateOrConnectWithoutCommentInput[]
    upsert?: CommentReplyUpsertWithWhereUniqueWithoutCommentInput | CommentReplyUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentReplyCreateManyCommentInputEnvelope
    set?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    disconnect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    delete?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    update?: CommentReplyUpdateWithWhereUniqueWithoutCommentInput | CommentReplyUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentReplyUpdateManyWithWhereWithoutCommentInput | CommentReplyUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutCommentNestedInput = {
    create?: XOR<NoteCreateWithoutCommentInput, NoteUncheckedCreateWithoutCommentInput> | NoteCreateWithoutCommentInput[] | NoteUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutCommentInput | NoteCreateOrConnectWithoutCommentInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutCommentInput | NoteUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: NoteCreateManyCommentInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutCommentInput | NoteUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutCommentInput | NoteUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PollPostUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<PollPostCreateWithoutCommentsInput, PollPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PollPostCreateOrConnectWithoutCommentsInput
    upsert?: PollPostUpsertWithoutCommentsInput
    disconnect?: boolean
    delete?: PollPostWhereInput | boolean
    connect?: PollPostWhereUniqueInput
    update?: XOR<XOR<PollPostUpdateToOneWithWhereWithoutCommentsInput, PollPostUpdateWithoutCommentsInput>, PollPostUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentReplyUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput> | CommentReplyCreateWithoutCommentInput[] | CommentReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReplyCreateOrConnectWithoutCommentInput | CommentReplyCreateOrConnectWithoutCommentInput[]
    upsert?: CommentReplyUpsertWithWhereUniqueWithoutCommentInput | CommentReplyUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentReplyCreateManyCommentInputEnvelope
    set?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    disconnect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    delete?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    connect?: CommentReplyWhereUniqueInput | CommentReplyWhereUniqueInput[]
    update?: CommentReplyUpdateWithWhereUniqueWithoutCommentInput | CommentReplyUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentReplyUpdateManyWithWhereWithoutCommentInput | CommentReplyUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<NoteCreateWithoutCommentInput, NoteUncheckedCreateWithoutCommentInput> | NoteCreateWithoutCommentInput[] | NoteUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutCommentInput | NoteCreateOrConnectWithoutCommentInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutCommentInput | NoteUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: NoteCreateManyCommentInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutCommentInput | NoteUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutCommentInput | NoteUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type CommentReplyCreatementionsInput = {
    set: string[]
  }

  export type CommentReplyCreatehashtagsInput = {
    set: string[]
  }

  export type MediaCreateNestedOneWithoutCommentReplyInput = {
    create?: XOR<MediaCreateWithoutCommentReplyInput, MediaUncheckedCreateWithoutCommentReplyInput>
    connectOrCreate?: MediaCreateOrConnectWithoutCommentReplyInput
    connect?: MediaWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentReplyUpdatementionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CommentReplyUpdatehashtagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MediaUpdateOneWithoutCommentReplyNestedInput = {
    create?: XOR<MediaCreateWithoutCommentReplyInput, MediaUncheckedCreateWithoutCommentReplyInput>
    connectOrCreate?: MediaCreateOrConnectWithoutCommentReplyInput
    upsert?: MediaUpsertWithoutCommentReplyInput
    disconnect?: boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutCommentReplyInput, MediaUpdateWithoutCommentReplyInput>, MediaUncheckedUpdateWithoutCommentReplyInput>
  }

  export type CommentUpdateOneRequiredWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type SpaceMemberCreatepermissionsInput = {
    set: string[]
  }

  export type SpaceCreateNestedOneWithoutMembersInput = {
    create?: XOR<SpaceCreateWithoutMembersInput, SpaceUncheckedCreateWithoutMembersInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutMembersInput
    connect?: SpaceWhereUniqueInput
  }

  export type SpaceMemberUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SpaceUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<SpaceCreateWithoutMembersInput, SpaceUncheckedCreateWithoutMembersInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutMembersInput
    upsert?: SpaceUpsertWithoutMembersInput
    connect?: SpaceWhereUniqueInput
    update?: XOR<XOR<SpaceUpdateToOneWithWhereWithoutMembersInput, SpaceUpdateWithoutMembersInput>, SpaceUncheckedUpdateWithoutMembersInput>
  }

  export type ChannelCreateNestedOneWithoutMembersInput = {
    create?: XOR<ChannelCreateWithoutMembersInput, ChannelUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutMembersInput
    connect?: ChannelWhereUniqueInput
  }

  export type ChannelUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ChannelCreateWithoutMembersInput, ChannelUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutMembersInput
    upsert?: ChannelUpsertWithoutMembersInput
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutMembersInput, ChannelUpdateWithoutMembersInput>, ChannelUncheckedUpdateWithoutMembersInput>
  }

  export type FileMetadataCreateEnvelopeInput = {
    set?: FileMetadataCreateInput
  }

  export type FileMetadataCreateInput = {
    fileName: string
    fileSize: number
    mimeType: string
    extension: string
    hash: string
    dimensions?: DimensionsCreateInput | null
    duration?: number | null
    encoding?: string | null
    compression?: string | null
    processingStatus: string
    version: number
    createdBy: string
    modifiedBy: string
    parentFolder?: string | null
    path: string
    checksum: string
  }

  export type FileToPostCreateNestedManyWithoutFileInput = {
    create?: XOR<FileToPostCreateWithoutFileInput, FileToPostUncheckedCreateWithoutFileInput> | FileToPostCreateWithoutFileInput[] | FileToPostUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FileToPostCreateOrConnectWithoutFileInput | FileToPostCreateOrConnectWithoutFileInput[]
    createMany?: FileToPostCreateManyFileInputEnvelope
    connect?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
  }

  export type SpaceCreateNestedOneWithoutFilesInput = {
    create?: XOR<SpaceCreateWithoutFilesInput, SpaceUncheckedCreateWithoutFilesInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutFilesInput
    connect?: SpaceWhereUniqueInput
  }

  export type ChannelCreateNestedOneWithoutFilesInput = {
    create?: XOR<ChannelCreateWithoutFilesInput, ChannelUncheckedCreateWithoutFilesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutFilesInput
    connect?: ChannelWhereUniqueInput
  }

  export type FileToPostUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<FileToPostCreateWithoutFileInput, FileToPostUncheckedCreateWithoutFileInput> | FileToPostCreateWithoutFileInput[] | FileToPostUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FileToPostCreateOrConnectWithoutFileInput | FileToPostCreateOrConnectWithoutFileInput[]
    createMany?: FileToPostCreateManyFileInputEnvelope
    connect?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type FileMetadataUpdateEnvelopeInput = {
    set?: FileMetadataCreateInput
    update?: FileMetadataUpdateInput
  }

  export type FileToPostUpdateManyWithoutFileNestedInput = {
    create?: XOR<FileToPostCreateWithoutFileInput, FileToPostUncheckedCreateWithoutFileInput> | FileToPostCreateWithoutFileInput[] | FileToPostUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FileToPostCreateOrConnectWithoutFileInput | FileToPostCreateOrConnectWithoutFileInput[]
    upsert?: FileToPostUpsertWithWhereUniqueWithoutFileInput | FileToPostUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: FileToPostCreateManyFileInputEnvelope
    set?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
    disconnect?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
    delete?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
    connect?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
    update?: FileToPostUpdateWithWhereUniqueWithoutFileInput | FileToPostUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: FileToPostUpdateManyWithWhereWithoutFileInput | FileToPostUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: FileToPostScalarWhereInput | FileToPostScalarWhereInput[]
  }

  export type SpaceUpdateOneWithoutFilesNestedInput = {
    create?: XOR<SpaceCreateWithoutFilesInput, SpaceUncheckedCreateWithoutFilesInput>
    connectOrCreate?: SpaceCreateOrConnectWithoutFilesInput
    upsert?: SpaceUpsertWithoutFilesInput
    disconnect?: boolean
    delete?: SpaceWhereInput | boolean
    connect?: SpaceWhereUniqueInput
    update?: XOR<XOR<SpaceUpdateToOneWithWhereWithoutFilesInput, SpaceUpdateWithoutFilesInput>, SpaceUncheckedUpdateWithoutFilesInput>
  }

  export type ChannelUpdateOneWithoutFilesNestedInput = {
    create?: XOR<ChannelCreateWithoutFilesInput, ChannelUncheckedCreateWithoutFilesInput>
    connectOrCreate?: ChannelCreateOrConnectWithoutFilesInput
    upsert?: ChannelUpsertWithoutFilesInput
    disconnect?: boolean
    delete?: ChannelWhereInput | boolean
    connect?: ChannelWhereUniqueInput
    update?: XOR<XOR<ChannelUpdateToOneWithWhereWithoutFilesInput, ChannelUpdateWithoutFilesInput>, ChannelUncheckedUpdateWithoutFilesInput>
  }

  export type FileToPostUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<FileToPostCreateWithoutFileInput, FileToPostUncheckedCreateWithoutFileInput> | FileToPostCreateWithoutFileInput[] | FileToPostUncheckedCreateWithoutFileInput[]
    connectOrCreate?: FileToPostCreateOrConnectWithoutFileInput | FileToPostCreateOrConnectWithoutFileInput[]
    upsert?: FileToPostUpsertWithWhereUniqueWithoutFileInput | FileToPostUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: FileToPostCreateManyFileInputEnvelope
    set?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
    disconnect?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
    delete?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
    connect?: FileToPostWhereUniqueInput | FileToPostWhereUniqueInput[]
    update?: FileToPostUpdateWithWhereUniqueWithoutFileInput | FileToPostUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: FileToPostUpdateManyWithWhereWithoutFileInput | FileToPostUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: FileToPostScalarWhereInput | FileToPostScalarWhereInput[]
  }

  export type FileCreateNestedOneWithoutPostsInput = {
    create?: XOR<FileCreateWithoutPostsInput, FileUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FileCreateOrConnectWithoutPostsInput
    connect?: FileWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutFilesInput = {
    create?: XOR<PostCreateWithoutFilesInput, PostUncheckedCreateWithoutFilesInput>
    connectOrCreate?: PostCreateOrConnectWithoutFilesInput
    connect?: PostWhereUniqueInput
  }

  export type FileUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<FileCreateWithoutPostsInput, FileUncheckedCreateWithoutPostsInput>
    connectOrCreate?: FileCreateOrConnectWithoutPostsInput
    upsert?: FileUpsertWithoutPostsInput
    connect?: FileWhereUniqueInput
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutPostsInput, FileUpdateWithoutPostsInput>, FileUncheckedUpdateWithoutPostsInput>
  }

  export type PostUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<PostCreateWithoutFilesInput, PostUncheckedCreateWithoutFilesInput>
    connectOrCreate?: PostCreateOrConnectWithoutFilesInput
    upsert?: PostUpsertWithoutFilesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutFilesInput, PostUpdateWithoutFilesInput>, PostUncheckedUpdateWithoutFilesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedEnumPostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeFilter<$PrismaModel> | $Enums.PostType
  }

  export type NestedEnumCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableFilter<$PrismaModel> | $Enums.Category | null
    isSet?: boolean
  }

  export type NestedEnumThreadParticipantTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreadParticipantType | EnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ThreadParticipantType[] | ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ThreadParticipantType[] | ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumThreadParticipantTypeNullableFilter<$PrismaModel> | $Enums.ThreadParticipantType | null
    isSet?: boolean
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type ContentInsightsWhereInput = {
    AND?: ContentInsightsWhereInput | ContentInsightsWhereInput[]
    OR?: ContentInsightsWhereInput[]
    NOT?: ContentInsightsWhereInput | ContentInsightsWhereInput[]
    sentenceCount?: IntFilter<"ContentInsights"> | number
    wordCount?: IntFilter<"ContentInsights"> | number
    language?: StringFilter<"ContentInsights"> | string
    languageConfidence?: FloatFilter<"ContentInsights"> | number
    entities?: EntitiesCompositeListFilter | EntitiesObjectEqualityInput[]
    sentiment?: XOR<SentimentCompositeFilter, SentimentObjectEqualityInput>
    topics?: StringNullableListFilter<"ContentInsights">
    keywords?: StringNullableListFilter<"ContentInsights">
    summary?: StringNullableFilter<"ContentInsights"> | string | null
    readability?: FloatNullableFilter<"ContentInsights"> | number | null
  }

  export type EntitiesObjectEqualityInput = {
    text: string
    label: string
    confidence?: number | null
    startPos?: number | null
    endPos?: number | null
    metadata?: InputJsonValue | null
  }

  export type SentimentObjectEqualityInput = {
    negative: number
    neutral: number
    positive: number
    compound: number
    confidence?: number | null
  }

  export type AIAnalysisWhereInput = {
    AND?: AIAnalysisWhereInput | AIAnalysisWhereInput[]
    OR?: AIAnalysisWhereInput[]
    NOT?: AIAnalysisWhereInput | AIAnalysisWhereInput[]
    summary?: StringNullableFilter<"AIAnalysis"> | string | null
    keyPoints?: StringNullableListFilter<"AIAnalysis">
    sentiment?: XOR<SentimentAnalysisCompositeFilter, SentimentAnalysisObjectEqualityInput>
    entities?: NamedEntityCompositeListFilter | NamedEntityObjectEqualityInput[]
    topics?: TopicAnalysisCompositeListFilter | TopicAnalysisObjectEqualityInput[]
    keywords?: KeywordCompositeListFilter | KeywordObjectEqualityInput[]
    readabilityScore?: XOR<ReadabilityMetricsCompositeFilter, ReadabilityMetricsObjectEqualityInput>
    qualityMetrics?: XOR<ContentQualityCompositeFilter, ContentQualityObjectEqualityInput>
    toxicity?: XOR<ToxicityAnalysisCompositeFilter, ToxicityAnalysisObjectEqualityInput>
    originality?: XOR<OriginalityScoreCompositeFilter, OriginalityScoreObjectEqualityInput>
    language?: XOR<LanguageAnalysisCompositeFilter, LanguageAnalysisObjectEqualityInput>
    translation?: XOR<TranslationInfoCompositeFilter, TranslationInfoObjectEqualityInput>
    grammarCheck?: XOR<GrammarAnalysisCompositeFilter, GrammarAnalysisObjectEqualityInput>
    styleAnalysis?: XOR<StyleMetricsCompositeFilter, StyleMetricsObjectEqualityInput>
    intentions?: IntentAnalysisCompositeListFilter | IntentAnalysisObjectEqualityInput[]
    emotions?: XOR<EmotionAnalysisCompositeFilter, EmotionAnalysisObjectEqualityInput>
    bias?: XOR<BiasAnalysisCompositeFilter, BiasAnalysisObjectEqualityInput>
    subjectivity?: FloatFilter<"AIAnalysis"> | number
    imageAnalysis?: ImageAnalysisCompositeListFilter | ImageAnalysisObjectEqualityInput[]
    videoAnalysis?: VideoAnalysisCompositeListFilter | VideoAnalysisObjectEqualityInput[]
    audioAnalysis?: AudioAnalysisCompositeListFilter | AudioAnalysisObjectEqualityInput[]
    marketInsights?: XOR<MarketAnalysisCompositeFilter, MarketAnalysisObjectEqualityInput>
    competitiveInfo?: XOR<CompetitiveAnalysisCompositeFilter, CompetitiveAnalysisObjectEqualityInput>
    actionItems?: ActionItemCompositeListFilter | ActionItemObjectEqualityInput[]
    processingTime?: IntFilter<"AIAnalysis"> | number
    confidenceScore?: FloatFilter<"AIAnalysis"> | number
    modelVersions?: XOR<ModelMetadataCompositeFilter, ModelMetadataObjectEqualityInput>
    timestamp?: DateTimeFilter<"AIAnalysis"> | Date | string
    processingCost?: FloatFilter<"AIAnalysis"> | number
  }

  export type SentimentAnalysisObjectEqualityInput = {
    overall: number
    compound: number
    positive: number
    negative: number
    neutral: number
    segments?: SentimentSegmentObjectEqualityInput[]
    confidence: number
  }

  export type NamedEntityObjectEqualityInput = {
    text: string
    type: string
    confidence: number
    startIndex: number
    endIndex: number
    metadata?: InputJsonValue | null
    wikification: WikiDataObjectEqualityInput
  }

  export type TopicAnalysisObjectEqualityInput = {
    topic: string
    confidence: number
    subtopics?: string[]
    relevance: number
    hierarchy?: string[]
    context: TopicContextObjectEqualityInput
  }

  export type KeywordObjectEqualityInput = {
    text: string
    score: number
    frequency: number
    type: string
    related?: string[]
    importance: KeywordMetricsObjectEqualityInput
  }

  export type ReadabilityMetricsObjectEqualityInput = {
    fleschKincaid: number
    gunningFog: number
    smog: number
    ari: number
    colemanLiau: number
    readingTime: number
    grade: string
    complexity: ComplexityMetricsObjectEqualityInput
  }

  export type ContentQualityObjectEqualityInput = {
    clarity: number
    coherence: number
    engagement: number
    expertise: number
    factualAccuracy: number
    sources?: SourceValidationObjectEqualityInput[]
    structure: StructureAnalysisObjectEqualityInput
    formatting: FormattingAnalysisObjectEqualityInput
  }

  export type ToxicityAnalysisObjectEqualityInput = {
    overall: number
    categories: ToxicityCategoriesObjectEqualityInput
    threats?: ThreatDetectionObjectEqualityInput[]
    moderation: ModerationDecisionObjectEqualityInput
    severity: ToxicitySeverityObjectEqualityInput
  }

  export type OriginalityScoreObjectEqualityInput = {
    overall: number
    uniqueness: number
    similarities?: SimilarityMatchObjectEqualityInput[]
    plagiarism: PlagiarismMetricsObjectEqualityInput
  }

  export type LanguageAnalysisObjectEqualityInput = {
    detected: string
    confidence: number
    alternatives?: LanguageAlternativeObjectEqualityInput[]
    dialects?: string[]
    scripts?: string[]
    languageFamily: string
  }

  export type TranslationInfoObjectEqualityInput = {
    sourceLanguage: string
    targetLanguage: string
    quality: number
    confidence: number
    provider: string
  }

  export type GrammarAnalysisObjectEqualityInput = {
    errors?: GrammarErrorObjectEqualityInput[]
    style?: StyleSuggestionObjectEqualityInput[]
    overall: number
    fluency: number
  }

  export type StyleMetricsObjectEqualityInput = {
    formality: number
    tone: string
    vocabulary: VocabularyMetricsObjectEqualityInput
    voice: string
  }

  export type IntentAnalysisObjectEqualityInput = {
    primary: string
    confidence: number
    secondary?: string[]
    context: string
  }

  export type EmotionAnalysisObjectEqualityInput = {
    primary: string
    secondary?: string[]
    intensity: number
    confidence: number
    spectrum: EmotionSpectrumObjectEqualityInput
  }

  export type BiasAnalysisObjectEqualityInput = {
    overall: number
    types?: BiasTypeObjectEqualityInput[]
    context: string
    severity: number
  }

  export type ImageAnalysisObjectEqualityInput = {
    objects?: DetectedObjectObjectEqualityInput[]
    faces?: FaceAnalysisObjectEqualityInput[]
    text?: string | null
    labels?: LabelObjectEqualityInput[]
    colors: ColorAnalysisObjectEqualityInput
    nsfw: NSFWAnalysisObjectEqualityInput
    quality: ImageQualityObjectEqualityInput
    composition: ImageCompositionObjectEqualityInput
  }

  export type VideoAnalysisObjectEqualityInput = {
    scenes?: SceneObjectEqualityInput[]
    transcript?: string | null
    keyFrames?: KeyFrameObjectEqualityInput[]
    actions?: ActionObjectEqualityInput[]
    captions?: CaptionObjectEqualityInput[]
    motion: MotionAnalysisObjectEqualityInput
  }

  export type AudioAnalysisObjectEqualityInput = {
    transcript?: string | null
    speakers?: SpeakerObjectEqualityInput[]
    sentiment: SentimentAnalysisObjectEqualityInput
    noise: NoiseAnalysisObjectEqualityInput
    music: MusicAnalysisObjectEqualityInput
    clarity: number
  }

  export type MarketAnalysisObjectEqualityInput = {
    trends?: TrendObjectEqualityInput[]
    sentiment: number
    competition?: string[]
    opportunities?: string[]
  }

  export type CompetitiveAnalysisObjectEqualityInput = {
    positioning: number
    advantages?: string[]
    threats?: string[]
    recommendations?: string[]
  }

  export type ActionItemObjectEqualityInput = {
    description: string
    priority: number
    category: string
    deadline?: Date | string | null
  }

  export type ModelMetadataObjectEqualityInput = {
    modelId: string
    version: string
    provider: string
    timestamp: Date | string
    parameters: InputJsonValue
    performance: ModelPerformanceObjectEqualityInput
  }

  export type SearchMetadataWhereInput = {
    AND?: SearchMetadataWhereInput | SearchMetadataWhereInput[]
    OR?: SearchMetadataWhereInput[]
    NOT?: SearchMetadataWhereInput | SearchMetadataWhereInput[]
    title?: StringFilter<"SearchMetadata"> | string
    description?: StringNullableFilter<"SearchMetadata"> | string | null
    keywords?: StringNullableListFilter<"SearchMetadata">
    contentType?: StringFilter<"SearchMetadata"> | string
    language?: StringFilter<"SearchMetadata"> | string
    fileSize?: IntNullableFilter<"SearchMetadata"> | number | null
    wordCount?: IntNullableFilter<"SearchMetadata"> | number | null
    pageCount?: IntNullableFilter<"SearchMetadata"> | number | null
    duration?: IntNullableFilter<"SearchMetadata"> | number | null
    transcription?: StringNullableFilter<"SearchMetadata"> | string | null
    extractedText?: StringNullableFilter<"SearchMetadata"> | string | null
    lastIndexed?: DateTimeFilter<"SearchMetadata"> | Date | string
    searchScore?: FloatFilter<"SearchMetadata"> | number
    aiTags?: StringNullableListFilter<"SearchMetadata">
    classifications?: StringNullableListFilter<"SearchMetadata">
    visibility?: EnumAccessLevelFilter<"SearchMetadata"> | $Enums.AccessLevel
    readingLevel?: StringNullableFilter<"SearchMetadata"> | string | null
    locationData?: JsonNullableFilter<"SearchMetadata">
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EntitiesOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type SentimentOrderByInput = {
    negative?: SortOrder
    neutral?: SortOrder
    positive?: SortOrder
    compound?: SortOrder
    confidence?: SortOrder
  }

  export type SentimentAnalysisOrderByInput = {
    overall?: SortOrder
    compound?: SortOrder
    positive?: SortOrder
    negative?: SortOrder
    neutral?: SortOrder
    segments?: SentimentSegmentOrderByCompositeAggregateInput
    confidence?: SortOrder
  }

  export type NamedEntityOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type TopicAnalysisOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type KeywordOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ReadabilityMetricsOrderByInput = {
    fleschKincaid?: SortOrder
    gunningFog?: SortOrder
    smog?: SortOrder
    ari?: SortOrder
    colemanLiau?: SortOrder
    readingTime?: SortOrder
    grade?: SortOrder
    complexity?: ComplexityMetricsOrderByInput
  }

  export type ContentQualityOrderByInput = {
    clarity?: SortOrder
    coherence?: SortOrder
    engagement?: SortOrder
    expertise?: SortOrder
    factualAccuracy?: SortOrder
    sources?: SourceValidationOrderByCompositeAggregateInput
    structure?: StructureAnalysisOrderByInput
    formatting?: FormattingAnalysisOrderByInput
  }

  export type ToxicityAnalysisOrderByInput = {
    overall?: SortOrder
    categories?: ToxicityCategoriesOrderByInput
    threats?: ThreatDetectionOrderByCompositeAggregateInput
    moderation?: ModerationDecisionOrderByInput
    severity?: ToxicitySeverityOrderByInput
  }

  export type OriginalityScoreOrderByInput = {
    overall?: SortOrder
    uniqueness?: SortOrder
    similarities?: SimilarityMatchOrderByCompositeAggregateInput
    plagiarism?: PlagiarismMetricsOrderByInput
  }

  export type LanguageAnalysisOrderByInput = {
    detected?: SortOrder
    confidence?: SortOrder
    alternatives?: LanguageAlternativeOrderByCompositeAggregateInput
    dialects?: SortOrder
    scripts?: SortOrder
    languageFamily?: SortOrder
  }

  export type TranslationInfoOrderByInput = {
    sourceLanguage?: SortOrder
    targetLanguage?: SortOrder
    quality?: SortOrder
    confidence?: SortOrder
    provider?: SortOrder
  }

  export type GrammarAnalysisOrderByInput = {
    errors?: GrammarErrorOrderByCompositeAggregateInput
    style?: StyleSuggestionOrderByCompositeAggregateInput
    overall?: SortOrder
    fluency?: SortOrder
  }

  export type StyleMetricsOrderByInput = {
    formality?: SortOrder
    tone?: SortOrder
    vocabulary?: VocabularyMetricsOrderByInput
    voice?: SortOrder
  }

  export type IntentAnalysisOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type EmotionAnalysisOrderByInput = {
    primary?: SortOrder
    secondary?: SortOrder
    intensity?: SortOrder
    confidence?: SortOrder
    spectrum?: EmotionSpectrumOrderByInput
  }

  export type BiasAnalysisOrderByInput = {
    overall?: SortOrder
    types?: BiasTypeOrderByCompositeAggregateInput
    context?: SortOrder
    severity?: SortOrder
  }

  export type ImageAnalysisOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type VideoAnalysisOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type AudioAnalysisOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type MarketAnalysisOrderByInput = {
    trends?: TrendOrderByCompositeAggregateInput
    sentiment?: SortOrder
    competition?: SortOrder
    opportunities?: SortOrder
  }

  export type CompetitiveAnalysisOrderByInput = {
    positioning?: SortOrder
    advantages?: SortOrder
    threats?: SortOrder
    recommendations?: SortOrder
  }

  export type ActionItemOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ModelMetadataOrderByInput = {
    modelId?: SortOrder
    version?: SortOrder
    provider?: SortOrder
    timestamp?: SortOrder
    parameters?: SortOrder
    performance?: ModelPerformanceOrderByInput
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumPostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostType | EnumPostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostType[] | ListEnumPostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPostTypeWithAggregatesFilter<$PrismaModel> | $Enums.PostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostTypeFilter<$PrismaModel>
    _max?: NestedEnumPostTypeFilter<$PrismaModel>
  }

  export type NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.Category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumCategoryNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumThreadParticipantTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ThreadParticipantType | EnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ThreadParticipantType[] | ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ThreadParticipantType[] | ListEnumThreadParticipantTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumThreadParticipantTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ThreadParticipantType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumThreadParticipantTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumThreadParticipantTypeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumSpaceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SpaceType | EnumSpaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SpaceType[] | ListEnumSpaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpaceType[] | ListEnumSpaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpaceTypeFilter<$PrismaModel> | $Enums.SpaceType
  }

  export type NestedEnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }

  export type NestedEnumSpaceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SpaceType | EnumSpaceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SpaceType[] | ListEnumSpaceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SpaceType[] | ListEnumSpaceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSpaceTypeWithAggregatesFilter<$PrismaModel> | $Enums.SpaceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSpaceTypeFilter<$PrismaModel>
    _max?: NestedEnumSpaceTypeFilter<$PrismaModel>
  }

  export type NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type FileMetadataWhereInput = {
    AND?: FileMetadataWhereInput | FileMetadataWhereInput[]
    OR?: FileMetadataWhereInput[]
    NOT?: FileMetadataWhereInput | FileMetadataWhereInput[]
    fileName?: StringFilter<"FileMetadata"> | string
    fileSize?: IntFilter<"FileMetadata"> | number
    mimeType?: StringFilter<"FileMetadata"> | string
    extension?: StringFilter<"FileMetadata"> | string
    hash?: StringFilter<"FileMetadata"> | string
    dimensions?: XOR<DimensionsNullableCompositeFilter, DimensionsObjectEqualityInput> | null
    duration?: IntNullableFilter<"FileMetadata"> | number | null
    encoding?: StringNullableFilter<"FileMetadata"> | string | null
    compression?: StringNullableFilter<"FileMetadata"> | string | null
    processingStatus?: StringFilter<"FileMetadata"> | string
    version?: IntFilter<"FileMetadata"> | number
    createdBy?: StringFilter<"FileMetadata"> | string
    modifiedBy?: StringFilter<"FileMetadata"> | string
    parentFolder?: StringNullableFilter<"FileMetadata"> | string | null
    path?: StringFilter<"FileMetadata"> | string
    checksum?: StringFilter<"FileMetadata"> | string
  }

  export type DimensionsObjectEqualityInput = {
    width: number
    height: number
    depth?: number | null
    aspectRatio?: number | null
    resolution?: string | null
  }

  export type DimensionsOrderByInput = {
    width?: SortOrder
    height?: SortOrder
    depth?: SortOrder
    aspectRatio?: SortOrder
    resolution?: SortOrder
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type CommentReplyCreateWithoutMediaInput = {
    id?: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    comment: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentReplyUncheckedCreateWithoutMediaInput = {
    id?: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    commentId: string
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type CommentReplyCreateOrConnectWithoutMediaInput = {
    where: CommentReplyWhereUniqueInput
    create: XOR<CommentReplyCreateWithoutMediaInput, CommentReplyUncheckedCreateWithoutMediaInput>
  }

  export type CommentReplyCreateManyMediaInputEnvelope = {
    data: CommentReplyCreateManyMediaInput | CommentReplyCreateManyMediaInput[]
  }

  export type PostCreateWithoutMediaInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
    files?: FileToPostCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutMediaInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
    files?: FileToPostUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutMediaInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutMediaInput, PostUncheckedCreateWithoutMediaInput>
  }

  export type PostCreateManyMediaInputEnvelope = {
    data: PostCreateManyMediaInput | PostCreateManyMediaInput[]
  }

  export type CommentCreateWithoutMediaInput = {
    id?: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    notes?: NoteCreateNestedManyWithoutCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    PollPost?: PollPostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutMediaInput = {
    id?: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    postId: string
    pollPostId?: string | null
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
    notes?: NoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutMediaInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutMediaInput, CommentUncheckedCreateWithoutMediaInput>
  }

  export type CommentCreateManyMediaInputEnvelope = {
    data: CommentCreateManyMediaInput | CommentCreateManyMediaInput[]
  }

  export type PollPostCreateWithoutMediaInput = {
    id?: string
    createdAt: string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | null
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    extra?: InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    comments?: CommentCreateNestedManyWithoutPollPostInput
    thread?: ThreadCreateNestedOneWithoutPollPostsInput
  }

  export type PollPostUncheckedCreateWithoutMediaInput = {
    id?: string
    createdAt: string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | null
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    threadId?: string | null
    extra?: InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    comments?: CommentUncheckedCreateNestedManyWithoutPollPostInput
  }

  export type PollPostCreateOrConnectWithoutMediaInput = {
    where: PollPostWhereUniqueInput
    create: XOR<PollPostCreateWithoutMediaInput, PollPostUncheckedCreateWithoutMediaInput>
  }

  export type PollPostCreateManyMediaInputEnvelope = {
    data: PollPostCreateManyMediaInput | PollPostCreateManyMediaInput[]
  }

  export type NoteCreateWithoutMediaInput = {
    id?: string
    content: string
    createdAt: string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    post: PostCreateNestedOneWithoutNotesInput
    comment?: CommentCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutMediaInput = {
    id?: string
    content: string
    createdAt: string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    postId: string
    commentId?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type NoteCreateOrConnectWithoutMediaInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutMediaInput, NoteUncheckedCreateWithoutMediaInput>
  }

  export type NoteCreateManyMediaInputEnvelope = {
    data: NoteCreateManyMediaInput | NoteCreateManyMediaInput[]
  }

  export type CommentReplyUpsertWithWhereUniqueWithoutMediaInput = {
    where: CommentReplyWhereUniqueInput
    update: XOR<CommentReplyUpdateWithoutMediaInput, CommentReplyUncheckedUpdateWithoutMediaInput>
    create: XOR<CommentReplyCreateWithoutMediaInput, CommentReplyUncheckedCreateWithoutMediaInput>
  }

  export type CommentReplyUpdateWithWhereUniqueWithoutMediaInput = {
    where: CommentReplyWhereUniqueInput
    data: XOR<CommentReplyUpdateWithoutMediaInput, CommentReplyUncheckedUpdateWithoutMediaInput>
  }

  export type CommentReplyUpdateManyWithWhereWithoutMediaInput = {
    where: CommentReplyScalarWhereInput
    data: XOR<CommentReplyUpdateManyMutationInput, CommentReplyUncheckedUpdateManyWithoutMediaInput>
  }

  export type CommentReplyScalarWhereInput = {
    AND?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
    OR?: CommentReplyScalarWhereInput[]
    NOT?: CommentReplyScalarWhereInput | CommentReplyScalarWhereInput[]
    id?: StringFilter<"CommentReply"> | string
    content?: StringFilter<"CommentReply"> | string
    createdAt?: StringFilter<"CommentReply"> | string
    backendPlatformUserId?: StringFilter<"CommentReply"> | string
    profileId?: IntFilter<"CommentReply"> | number
    authorUsername?: StringFilter<"CommentReply"> | string
    authorProfileImage?: StringNullableFilter<"CommentReply"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"CommentReply"> | $Enums.AccountType
    affinityScore?: IntFilter<"CommentReply"> | number
    qualityScore?: IntFilter<"CommentReply"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"CommentReply">
    userIdToReportsMap?: JsonNullableFilter<"CommentReply">
    userIdToReactionMap?: JsonNullableFilter<"CommentReply">
    mentions?: StringNullableListFilter<"CommentReply">
    hashtags?: StringNullableListFilter<"CommentReply">
    mediaid?: StringNullableFilter<"CommentReply"> | string | null
    commentId?: StringFilter<"CommentReply"> | string
    extra?: JsonNullableFilter<"CommentReply">
  }

  export type PostUpsertWithWhereUniqueWithoutMediaInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutMediaInput, PostUncheckedUpdateWithoutMediaInput>
    create: XOR<PostCreateWithoutMediaInput, PostUncheckedCreateWithoutMediaInput>
  }

  export type PostUpdateWithWhereUniqueWithoutMediaInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutMediaInput, PostUncheckedUpdateWithoutMediaInput>
  }

  export type PostUpdateManyWithWhereWithoutMediaInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutMediaInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    authorId?: StringFilter<"Post"> | string
    parentSpaceId?: StringNullableFilter<"Post"> | string | null
    title?: StringNullableFilter<"Post"> | string | null
    content?: StringFilter<"Post"> | string
    description?: StringNullableFilter<"Post"> | string | null
    status?: StringFilter<"Post"> | string
    workflowStatus?: StringNullableFilter<"Post"> | string | null
    assignedTo?: StringNullableFilter<"Post"> | string | null
    contentFormat?: StringFilter<"Post"> | string
    createdAt?: StringFilter<"Post"> | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    postType?: EnumPostTypeFilter<"Post"> | $Enums.PostType
    category?: EnumCategoryNullableFilter<"Post"> | $Enums.Category | null
    threadParticipantType?: EnumThreadParticipantTypeNullableFilter<"Post"> | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFilter<"Post"> | string
    profileId?: IntFilter<"Post"> | number
    authorUsername?: StringFilter<"Post"> | string
    authorProfileImage?: StringNullableFilter<"Post"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Post"> | $Enums.AccountType
    tags?: StringNullableListFilter<"Post">
    mentions?: StringNullableListFilter<"Post">
    hashtags?: StringNullableListFilter<"Post">
    topicName?: StringNullableFilter<"Post"> | string | null
    mediaId?: StringNullableFilter<"Post"> | string | null
    backgroundImageUrl?: StringNullableFilter<"Post"> | string | null
    affinityScore?: IntFilter<"Post"> | number
    qualityScore?: IntFilter<"Post"> | number
    viewCount?: IntFilter<"Post"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"Post">
    userIdToReportsMap?: JsonNullableFilter<"Post">
    userIdToReactionMap?: JsonNullableFilter<"Post">
    readingTime?: StringNullableFilter<"Post"> | string | null
    aiGeneratedQuestionResponse?: StringNullableFilter<"Post"> | string | null
    threadId?: StringNullableFilter<"Post"> | string | null
    spaceId?: StringNullableFilter<"Post"> | string | null
    channelId?: StringNullableFilter<"Post"> | string | null
    extra?: JsonNullableFilter<"Post">
    visibility?: StringFilter<"Post"> | string
    isPinned?: BoolFilter<"Post"> | boolean
    isArchived?: BoolFilter<"Post"> | boolean
    workflow?: JsonNullableFilter<"Post">
    version?: IntFilter<"Post"> | number
  }

  export type CommentUpsertWithWhereUniqueWithoutMediaInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutMediaInput, CommentUncheckedUpdateWithoutMediaInput>
    create: XOR<CommentCreateWithoutMediaInput, CommentUncheckedCreateWithoutMediaInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutMediaInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutMediaInput, CommentUncheckedUpdateWithoutMediaInput>
  }

  export type CommentUpdateManyWithWhereWithoutMediaInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutMediaInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: StringFilter<"Comment"> | string
    backendPlatformUserId?: StringFilter<"Comment"> | string
    profileId?: IntFilter<"Comment"> | number
    authorUsername?: StringFilter<"Comment"> | string
    authorProfileImage?: StringNullableFilter<"Comment"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Comment"> | $Enums.AccountType
    affinityScore?: IntFilter<"Comment"> | number
    qualityScore?: IntFilter<"Comment"> | number
    userIdToAffinityScoreMap?: JsonNullableFilter<"Comment">
    userIdToReportsMap?: JsonNullableFilter<"Comment">
    userIdToReactionMap?: JsonNullableFilter<"Comment">
    mentions?: StringNullableListFilter<"Comment">
    hashtags?: StringNullableListFilter<"Comment">
    postId?: StringFilter<"Comment"> | string
    pollPostId?: StringNullableFilter<"Comment"> | string | null
    extra?: JsonNullableFilter<"Comment">
    mediaId?: StringNullableFilter<"Comment"> | string | null
  }

  export type PollPostUpsertWithWhereUniqueWithoutMediaInput = {
    where: PollPostWhereUniqueInput
    update: XOR<PollPostUpdateWithoutMediaInput, PollPostUncheckedUpdateWithoutMediaInput>
    create: XOR<PollPostCreateWithoutMediaInput, PollPostUncheckedCreateWithoutMediaInput>
  }

  export type PollPostUpdateWithWhereUniqueWithoutMediaInput = {
    where: PollPostWhereUniqueInput
    data: XOR<PollPostUpdateWithoutMediaInput, PollPostUncheckedUpdateWithoutMediaInput>
  }

  export type PollPostUpdateManyWithWhereWithoutMediaInput = {
    where: PollPostScalarWhereInput
    data: XOR<PollPostUpdateManyMutationInput, PollPostUncheckedUpdateManyWithoutMediaInput>
  }

  export type PollPostScalarWhereInput = {
    AND?: PollPostScalarWhereInput | PollPostScalarWhereInput[]
    OR?: PollPostScalarWhereInput[]
    NOT?: PollPostScalarWhereInput | PollPostScalarWhereInput[]
    id?: StringFilter<"PollPost"> | string
    createdAt?: StringFilter<"PollPost"> | string
    action?: EnumPostTypeFilter<"PollPost"> | $Enums.PostType
    content?: StringFilter<"PollPost"> | string
    title?: StringNullableFilter<"PollPost"> | string | null
    pollOptions?: StringNullableListFilter<"PollPost">
    pollDistribution?: JsonNullableFilter<"PollPost">
    userIdToPollResponsesMap?: JsonNullableFilter<"PollPost">
    pollEndDate?: DateTimeFilter<"PollPost"> | Date | string
    mentions?: StringNullableListFilter<"PollPost">
    hashtags?: StringNullableListFilter<"PollPost">
    tags?: StringNullableListFilter<"PollPost">
    topicName?: StringNullableFilter<"PollPost"> | string | null
    backendPlatformUserId?: StringFilter<"PollPost"> | string
    profileId?: IntFilter<"PollPost"> | number
    mediaId?: StringNullableFilter<"PollPost"> | string | null
    threadId?: StringNullableFilter<"PollPost"> | string | null
    extra?: JsonNullableFilter<"PollPost">
  }

  export type NoteUpsertWithWhereUniqueWithoutMediaInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutMediaInput, NoteUncheckedUpdateWithoutMediaInput>
    create: XOR<NoteCreateWithoutMediaInput, NoteUncheckedCreateWithoutMediaInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutMediaInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutMediaInput, NoteUncheckedUpdateWithoutMediaInput>
  }

  export type NoteUpdateManyWithWhereWithoutMediaInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutMediaInput>
  }

  export type NoteScalarWhereInput = {
    AND?: NoteScalarWhereInput | NoteScalarWhereInput[]
    OR?: NoteScalarWhereInput[]
    NOT?: NoteScalarWhereInput | NoteScalarWhereInput[]
    id?: StringFilter<"Note"> | string
    content?: StringFilter<"Note"> | string
    createdAt?: StringFilter<"Note"> | string
    authorId?: StringFilter<"Note"> | string
    backendPlatformUserId?: StringFilter<"Note"> | string
    profileId?: IntFilter<"Note"> | number
    authorUserName?: StringFilter<"Note"> | string
    authorProfileImage?: StringNullableFilter<"Note"> | string | null
    authorAccountType?: EnumAccountTypeFilter<"Note"> | $Enums.AccountType
    mentions?: StringNullableListFilter<"Note">
    hashtags?: StringNullableListFilter<"Note">
    mediaId?: StringNullableFilter<"Note"> | string | null
    postId?: StringFilter<"Note"> | string
    commentId?: StringNullableFilter<"Note"> | string | null
  }

  export type EntitiesCreateInput = {
    text: string
    label: string
    confidence?: number | null
    startPos?: number | null
    endPos?: number | null
    metadata?: InputJsonValue | null
  }

  export type SentimentCreateInput = {
    negative: number
    neutral: number
    positive: number
    compound: number
    confidence?: number | null
  }

  export type ContentInsightsCreatetopicsInput = {
    set: string[]
  }

  export type ContentInsightsCreatekeywordsInput = {
    set: string[]
  }

  export type AIAnalysisCreatekeyPointsInput = {
    set: string[]
  }

  export type SentimentAnalysisCreateInput = {
    overall: number
    compound: number
    positive: number
    negative: number
    neutral: number
    segments?: SentimentSegmentCreateInput | SentimentSegmentCreateInput[]
    confidence: number
  }

  export type NamedEntityCreateInput = {
    text: string
    type: string
    confidence: number
    startIndex: number
    endIndex: number
    metadata?: InputJsonValue | null
    wikification: WikiDataCreateInput
  }

  export type TopicAnalysisCreateInput = {
    topic: string
    confidence: number
    subtopics?: TopicAnalysisCreatesubtopicsInput | string[]
    relevance: number
    hierarchy?: TopicAnalysisCreatehierarchyInput | string[]
    context: TopicContextCreateInput
  }

  export type KeywordCreateInput = {
    text: string
    score: number
    frequency: number
    type: string
    related?: KeywordCreaterelatedInput | string[]
    importance: KeywordMetricsCreateInput
  }

  export type ReadabilityMetricsCreateInput = {
    fleschKincaid: number
    gunningFog: number
    smog: number
    ari: number
    colemanLiau: number
    readingTime: number
    grade: string
    complexity: ComplexityMetricsCreateInput
  }

  export type ContentQualityCreateInput = {
    clarity: number
    coherence: number
    engagement: number
    expertise: number
    factualAccuracy: number
    sources?: SourceValidationCreateInput | SourceValidationCreateInput[]
    structure: StructureAnalysisCreateInput
    formatting: FormattingAnalysisCreateInput
  }

  export type ToxicityAnalysisCreateInput = {
    overall: number
    categories: ToxicityCategoriesCreateInput
    threats?: ThreatDetectionCreateInput | ThreatDetectionCreateInput[]
    moderation: ModerationDecisionCreateInput
    severity: ToxicitySeverityCreateInput
  }

  export type OriginalityScoreCreateInput = {
    overall: number
    uniqueness: number
    similarities?: SimilarityMatchCreateInput | SimilarityMatchCreateInput[]
    plagiarism: PlagiarismMetricsCreateInput
  }

  export type LanguageAnalysisCreateInput = {
    detected: string
    confidence: number
    alternatives?: LanguageAlternativeCreateInput | LanguageAlternativeCreateInput[]
    dialects?: LanguageAnalysisCreatedialectsInput | string[]
    scripts?: LanguageAnalysisCreatescriptsInput | string[]
    languageFamily: string
  }

  export type TranslationInfoCreateInput = {
    sourceLanguage: string
    targetLanguage: string
    quality: number
    confidence: number
    provider: string
  }

  export type GrammarAnalysisCreateInput = {
    errors?: GrammarErrorCreateInput | GrammarErrorCreateInput[]
    style?: StyleSuggestionCreateInput | StyleSuggestionCreateInput[]
    overall: number
    fluency: number
  }

  export type StyleMetricsCreateInput = {
    formality: number
    tone: string
    vocabulary: VocabularyMetricsCreateInput
    voice: string
  }

  export type IntentAnalysisCreateInput = {
    primary: string
    confidence: number
    secondary?: IntentAnalysisCreatesecondaryInput | string[]
    context: string
  }

  export type EmotionAnalysisCreateInput = {
    primary: string
    secondary?: EmotionAnalysisCreatesecondaryInput | string[]
    intensity: number
    confidence: number
    spectrum: EmotionSpectrumCreateInput
  }

  export type BiasAnalysisCreateInput = {
    overall: number
    types?: BiasTypeCreateInput | BiasTypeCreateInput[]
    context: string
    severity: number
  }

  export type ImageAnalysisCreateInput = {
    objects?: DetectedObjectCreateInput | DetectedObjectCreateInput[]
    faces?: FaceAnalysisCreateInput | FaceAnalysisCreateInput[]
    text?: string | null
    labels?: LabelCreateInput | LabelCreateInput[]
    colors: ColorAnalysisCreateInput
    nsfw: NSFWAnalysisCreateInput
    quality: ImageQualityCreateInput
    composition: ImageCompositionCreateInput
  }

  export type VideoAnalysisCreateInput = {
    scenes?: SceneCreateInput | SceneCreateInput[]
    transcript?: string | null
    keyFrames?: KeyFrameCreateInput | KeyFrameCreateInput[]
    actions?: ActionCreateInput | ActionCreateInput[]
    captions?: CaptionCreateInput | CaptionCreateInput[]
    motion: MotionAnalysisCreateInput
  }

  export type AudioAnalysisCreateInput = {
    transcript?: string | null
    speakers?: SpeakerCreateInput | SpeakerCreateInput[]
    sentiment: SentimentAnalysisCreateInput
    noise: NoiseAnalysisCreateInput
    music: MusicAnalysisCreateInput
    clarity: number
  }

  export type MarketAnalysisCreateInput = {
    trends?: TrendCreateInput | TrendCreateInput[]
    sentiment: number
    competition?: MarketAnalysisCreatecompetitionInput | string[]
    opportunities?: MarketAnalysisCreateopportunitiesInput | string[]
  }

  export type CompetitiveAnalysisCreateInput = {
    positioning: number
    advantages?: CompetitiveAnalysisCreateadvantagesInput | string[]
    threats?: CompetitiveAnalysisCreatethreatsInput | string[]
    recommendations?: CompetitiveAnalysisCreaterecommendationsInput | string[]
  }

  export type ActionItemCreateInput = {
    description: string
    priority: number
    category: string
    deadline?: Date | string | null
  }

  export type ModelMetadataCreateInput = {
    modelId: string
    version: string
    provider: string
    timestamp: Date | string
    parameters: InputJsonValue
    performance: ModelPerformanceCreateInput
  }

  export type SearchMetadataCreatekeywordsInput = {
    set: string[]
  }

  export type SearchMetadataCreateaiTagsInput = {
    set: string[]
  }

  export type SearchMetadataCreateclassificationsInput = {
    set: string[]
  }

  export type MediaCreateWithoutPostInput = {
    id?: string
    mediaType: string
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    CommentReply?: CommentReplyCreateNestedManyWithoutMediaInput
    Comment?: CommentCreateNestedManyWithoutMediaInput
    PollPost?: PollPostCreateNestedManyWithoutMediaInput
    Note?: NoteCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutPostInput = {
    id?: string
    mediaType: string
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    CommentReply?: CommentReplyUncheckedCreateNestedManyWithoutMediaInput
    Comment?: CommentUncheckedCreateNestedManyWithoutMediaInput
    PollPost?: PollPostUncheckedCreateNestedManyWithoutMediaInput
    Note?: NoteUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutPostInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutPostInput, MediaUncheckedCreateWithoutPostInput>
  }

  export type FileToPostCreateWithoutPostInput = {
    id?: string
    createdAt?: Date | string
    file: FileCreateNestedOneWithoutPostsInput
  }

  export type FileToPostUncheckedCreateWithoutPostInput = {
    id?: string
    fileId: string
    createdAt?: Date | string
  }

  export type FileToPostCreateOrConnectWithoutPostInput = {
    where: FileToPostWhereUniqueInput
    create: XOR<FileToPostCreateWithoutPostInput, FileToPostUncheckedCreateWithoutPostInput>
  }

  export type FileToPostCreateManyPostInputEnvelope = {
    data: FileToPostCreateManyPostInput | FileToPostCreateManyPostInput[]
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaCreateNestedOneWithoutCommentInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    notes?: NoteCreateNestedManyWithoutCommentInput
    PollPost?: PollPostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    pollPostId?: string | null
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    mediaId?: string | null
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
    notes?: NoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
  }

  export type NoteCreateWithoutPostInput = {
    id?: string
    content: string
    createdAt: string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaCreateNestedOneWithoutNoteInput
    comment?: CommentCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutPostInput = {
    id?: string
    content: string
    createdAt: string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    mediaId?: string | null
    commentId?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type NoteCreateOrConnectWithoutPostInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutPostInput, NoteUncheckedCreateWithoutPostInput>
  }

  export type NoteCreateManyPostInputEnvelope = {
    data: NoteCreateManyPostInput | NoteCreateManyPostInput[]
  }

  export type ThreadCreateWithoutPostsInput = {
    id?: string
    postIds?: ThreadCreatepostIdsInput | string[]
    parentPostId: string
    createdAt: string
    updatedAt: string
    metadata?: InputJsonValue | null
    status?: string
    isLocked?: boolean
    pollPosts?: PollPostCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateWithoutPostsInput = {
    id?: string
    postIds?: ThreadCreatepostIdsInput | string[]
    parentPostId: string
    createdAt: string
    updatedAt: string
    metadata?: InputJsonValue | null
    status?: string
    isLocked?: boolean
    pollPosts?: PollPostUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadCreateOrConnectWithoutPostsInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutPostsInput, ThreadUncheckedCreateWithoutPostsInput>
  }

  export type SpaceCreateWithoutPostsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: string
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberCreateNestedManyWithoutSpaceInput
    channels?: ChannelCreateNestedManyWithoutSpaceInput
    files?: FileCreateNestedManyWithoutSpaceInput
    parentSpace?: SpaceCreateNestedOneWithoutChildSpacesInput
    childSpaces?: SpaceCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: string
    parentSpaceId?: string | null
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberUncheckedCreateNestedManyWithoutSpaceInput
    channels?: ChannelUncheckedCreateNestedManyWithoutSpaceInput
    files?: FileUncheckedCreateNestedManyWithoutSpaceInput
    childSpaces?: SpaceUncheckedCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceCreateOrConnectWithoutPostsInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutPostsInput, SpaceUncheckedCreateWithoutPostsInput>
  }

  export type ChannelCreateWithoutPostsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    space: SpaceCreateNestedOneWithoutChannelsInput
    files?: FileCreateNestedManyWithoutChannelInput
    members?: ChannelMemberCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    description?: string | null
    spaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    files?: FileUncheckedCreateNestedManyWithoutChannelInput
    members?: ChannelMemberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutPostsInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutPostsInput, ChannelUncheckedCreateWithoutPostsInput>
  }

  export type ContentInsightsUpsertInput = {
    set: ContentInsightsCreateInput | null
    update: ContentInsightsUpdateInput
  }

  export type AIAnalysisUpsertInput = {
    set: AIAnalysisCreateInput | null
    update: AIAnalysisUpdateInput
  }

  export type SearchMetadataUpsertInput = {
    set: SearchMetadataCreateInput | null
    update: SearchMetadataUpdateInput
  }

  export type MediaUpsertWithoutPostInput = {
    update: XOR<MediaUpdateWithoutPostInput, MediaUncheckedUpdateWithoutPostInput>
    create: XOR<MediaCreateWithoutPostInput, MediaUncheckedCreateWithoutPostInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutPostInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutPostInput, MediaUncheckedUpdateWithoutPostInput>
  }

  export type MediaUpdateWithoutPostInput = {
    mediaType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CommentReply?: CommentReplyUpdateManyWithoutMediaNestedInput
    Comment?: CommentUpdateManyWithoutMediaNestedInput
    PollPost?: PollPostUpdateManyWithoutMediaNestedInput
    Note?: NoteUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutPostInput = {
    mediaType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CommentReply?: CommentReplyUncheckedUpdateManyWithoutMediaNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutMediaNestedInput
    PollPost?: PollPostUncheckedUpdateManyWithoutMediaNestedInput
    Note?: NoteUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type FileToPostUpsertWithWhereUniqueWithoutPostInput = {
    where: FileToPostWhereUniqueInput
    update: XOR<FileToPostUpdateWithoutPostInput, FileToPostUncheckedUpdateWithoutPostInput>
    create: XOR<FileToPostCreateWithoutPostInput, FileToPostUncheckedCreateWithoutPostInput>
  }

  export type FileToPostUpdateWithWhereUniqueWithoutPostInput = {
    where: FileToPostWhereUniqueInput
    data: XOR<FileToPostUpdateWithoutPostInput, FileToPostUncheckedUpdateWithoutPostInput>
  }

  export type FileToPostUpdateManyWithWhereWithoutPostInput = {
    where: FileToPostScalarWhereInput
    data: XOR<FileToPostUpdateManyMutationInput, FileToPostUncheckedUpdateManyWithoutPostInput>
  }

  export type FileToPostScalarWhereInput = {
    AND?: FileToPostScalarWhereInput | FileToPostScalarWhereInput[]
    OR?: FileToPostScalarWhereInput[]
    NOT?: FileToPostScalarWhereInput | FileToPostScalarWhereInput[]
    id?: StringFilter<"FileToPost"> | string
    fileId?: StringFilter<"FileToPost"> | string
    postId?: StringFilter<"FileToPost"> | string
    createdAt?: DateTimeFilter<"FileToPost"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type NoteUpsertWithWhereUniqueWithoutPostInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutPostInput, NoteUncheckedUpdateWithoutPostInput>
    create: XOR<NoteCreateWithoutPostInput, NoteUncheckedCreateWithoutPostInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutPostInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutPostInput, NoteUncheckedUpdateWithoutPostInput>
  }

  export type NoteUpdateManyWithWhereWithoutPostInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutPostInput>
  }

  export type ThreadUpsertWithoutPostsInput = {
    update: XOR<ThreadUpdateWithoutPostsInput, ThreadUncheckedUpdateWithoutPostsInput>
    create: XOR<ThreadCreateWithoutPostsInput, ThreadUncheckedCreateWithoutPostsInput>
    where?: ThreadWhereInput
  }

  export type ThreadUpdateToOneWithWhereWithoutPostsInput = {
    where?: ThreadWhereInput
    data: XOR<ThreadUpdateWithoutPostsInput, ThreadUncheckedUpdateWithoutPostsInput>
  }

  export type ThreadUpdateWithoutPostsInput = {
    postIds?: ThreadUpdatepostIdsInput | string[]
    parentPostId?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    pollPosts?: PollPostUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateWithoutPostsInput = {
    postIds?: ThreadUpdatepostIdsInput | string[]
    parentPostId?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    pollPosts?: PollPostUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type SpaceUpsertWithoutPostsInput = {
    update: XOR<SpaceUpdateWithoutPostsInput, SpaceUncheckedUpdateWithoutPostsInput>
    create: XOR<SpaceCreateWithoutPostsInput, SpaceUncheckedCreateWithoutPostsInput>
    where?: SpaceWhereInput
  }

  export type SpaceUpdateToOneWithWhereWithoutPostsInput = {
    where?: SpaceWhereInput
    data: XOR<SpaceUpdateWithoutPostsInput, SpaceUncheckedUpdateWithoutPostsInput>
  }

  export type SpaceUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUpdateManyWithoutSpaceNestedInput
    files?: FileUpdateManyWithoutSpaceNestedInput
    parentSpace?: SpaceUpdateOneWithoutChildSpacesNestedInput
    childSpaces?: SpaceUpdateManyWithoutParentSpaceNestedInput
  }

  export type SpaceUncheckedUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUncheckedUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutSpaceNestedInput
    files?: FileUncheckedUpdateManyWithoutSpaceNestedInput
    childSpaces?: SpaceUncheckedUpdateManyWithoutParentSpaceNestedInput
  }

  export type ChannelUpsertWithoutPostsInput = {
    update: XOR<ChannelUpdateWithoutPostsInput, ChannelUncheckedUpdateWithoutPostsInput>
    create: XOR<ChannelCreateWithoutPostsInput, ChannelUncheckedCreateWithoutPostsInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutPostsInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutPostsInput, ChannelUncheckedUpdateWithoutPostsInput>
  }

  export type ChannelUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    space?: SpaceUpdateOneRequiredWithoutChannelsNestedInput
    files?: FileUpdateManyWithoutChannelNestedInput
    members?: ChannelMemberUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    files?: FileUncheckedUpdateManyWithoutChannelNestedInput
    members?: ChannelMemberUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type MediaCreateWithoutPollPostInput = {
    id?: string
    mediaType: string
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    CommentReply?: CommentReplyCreateNestedManyWithoutMediaInput
    Post?: PostCreateNestedManyWithoutMediaInput
    Comment?: CommentCreateNestedManyWithoutMediaInput
    Note?: NoteCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutPollPostInput = {
    id?: string
    mediaType: string
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    CommentReply?: CommentReplyUncheckedCreateNestedManyWithoutMediaInput
    Post?: PostUncheckedCreateNestedManyWithoutMediaInput
    Comment?: CommentUncheckedCreateNestedManyWithoutMediaInput
    Note?: NoteUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutPollPostInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutPollPostInput, MediaUncheckedCreateWithoutPollPostInput>
  }

  export type CommentCreateWithoutPollPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaCreateNestedOneWithoutCommentInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    notes?: NoteCreateNestedManyWithoutCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutPollPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    postId: string
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    mediaId?: string | null
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
    notes?: NoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutPollPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPollPostInput, CommentUncheckedCreateWithoutPollPostInput>
  }

  export type CommentCreateManyPollPostInputEnvelope = {
    data: CommentCreateManyPollPostInput | CommentCreateManyPollPostInput[]
  }

  export type ThreadCreateWithoutPollPostsInput = {
    id?: string
    postIds?: ThreadCreatepostIdsInput | string[]
    parentPostId: string
    createdAt: string
    updatedAt: string
    metadata?: InputJsonValue | null
    status?: string
    isLocked?: boolean
    posts?: PostCreateNestedManyWithoutThreadInput
  }

  export type ThreadUncheckedCreateWithoutPollPostsInput = {
    id?: string
    postIds?: ThreadCreatepostIdsInput | string[]
    parentPostId: string
    createdAt: string
    updatedAt: string
    metadata?: InputJsonValue | null
    status?: string
    isLocked?: boolean
    posts?: PostUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadCreateOrConnectWithoutPollPostsInput = {
    where: ThreadWhereUniqueInput
    create: XOR<ThreadCreateWithoutPollPostsInput, ThreadUncheckedCreateWithoutPollPostsInput>
  }

  export type MediaUpsertWithoutPollPostInput = {
    update: XOR<MediaUpdateWithoutPollPostInput, MediaUncheckedUpdateWithoutPollPostInput>
    create: XOR<MediaCreateWithoutPollPostInput, MediaUncheckedCreateWithoutPollPostInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutPollPostInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutPollPostInput, MediaUncheckedUpdateWithoutPollPostInput>
  }

  export type MediaUpdateWithoutPollPostInput = {
    mediaType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CommentReply?: CommentReplyUpdateManyWithoutMediaNestedInput
    Post?: PostUpdateManyWithoutMediaNestedInput
    Comment?: CommentUpdateManyWithoutMediaNestedInput
    Note?: NoteUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutPollPostInput = {
    mediaType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CommentReply?: CommentReplyUncheckedUpdateManyWithoutMediaNestedInput
    Post?: PostUncheckedUpdateManyWithoutMediaNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutMediaNestedInput
    Note?: NoteUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutPollPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPollPostInput, CommentUncheckedUpdateWithoutPollPostInput>
    create: XOR<CommentCreateWithoutPollPostInput, CommentUncheckedCreateWithoutPollPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPollPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPollPostInput, CommentUncheckedUpdateWithoutPollPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPollPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPollPostInput>
  }

  export type ThreadUpsertWithoutPollPostsInput = {
    update: XOR<ThreadUpdateWithoutPollPostsInput, ThreadUncheckedUpdateWithoutPollPostsInput>
    create: XOR<ThreadCreateWithoutPollPostsInput, ThreadUncheckedCreateWithoutPollPostsInput>
    where?: ThreadWhereInput
  }

  export type ThreadUpdateToOneWithWhereWithoutPollPostsInput = {
    where?: ThreadWhereInput
    data: XOR<ThreadUpdateWithoutPollPostsInput, ThreadUncheckedUpdateWithoutPollPostsInput>
  }

  export type ThreadUpdateWithoutPollPostsInput = {
    postIds?: ThreadUpdatepostIdsInput | string[]
    parentPostId?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUpdateManyWithoutThreadNestedInput
  }

  export type ThreadUncheckedUpdateWithoutPollPostsInput = {
    postIds?: ThreadUpdatepostIdsInput | string[]
    parentPostId?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type SpaceMemberCreateWithoutSpaceInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    status?: string
    permissions?: SpaceMemberCreatepermissionsInput | string[]
  }

  export type SpaceMemberUncheckedCreateWithoutSpaceInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    status?: string
    permissions?: SpaceMemberCreatepermissionsInput | string[]
  }

  export type SpaceMemberCreateOrConnectWithoutSpaceInput = {
    where: SpaceMemberWhereUniqueInput
    create: XOR<SpaceMemberCreateWithoutSpaceInput, SpaceMemberUncheckedCreateWithoutSpaceInput>
  }

  export type SpaceMemberCreateManySpaceInputEnvelope = {
    data: SpaceMemberCreateManySpaceInput | SpaceMemberCreateManySpaceInput[]
  }

  export type ChannelCreateWithoutSpaceInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    posts?: PostCreateNestedManyWithoutChannelInput
    files?: FileCreateNestedManyWithoutChannelInput
    members?: ChannelMemberCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutSpaceInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    posts?: PostUncheckedCreateNestedManyWithoutChannelInput
    files?: FileUncheckedCreateNestedManyWithoutChannelInput
    members?: ChannelMemberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutSpaceInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutSpaceInput, ChannelUncheckedCreateWithoutSpaceInput>
  }

  export type ChannelCreateManySpaceInputEnvelope = {
    data: ChannelCreateManySpaceInput | ChannelCreateManySpaceInput[]
  }

  export type PostCreateWithoutSpaceInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
    media?: MediaCreateNestedOneWithoutPostInput
    files?: FileToPostCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutSpaceInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: string | null
    channelId?: string | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
    files?: FileToPostUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutSpaceInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutSpaceInput, PostUncheckedCreateWithoutSpaceInput>
  }

  export type PostCreateManySpaceInputEnvelope = {
    data: PostCreateManySpaceInput | PostCreateManySpaceInput[]
  }

  export type FileCreateWithoutSpaceInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: XOR<FileMetadataCreateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    posts?: FileToPostCreateNestedManyWithoutFileInput
    Channel?: ChannelCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutSpaceInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: XOR<FileMetadataCreateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    channelId?: string | null
    posts?: FileToPostUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileCreateOrConnectWithoutSpaceInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutSpaceInput, FileUncheckedCreateWithoutSpaceInput>
  }

  export type FileCreateManySpaceInputEnvelope = {
    data: FileCreateManySpaceInput | FileCreateManySpaceInput[]
  }

  export type SpaceCreateWithoutChildSpacesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: string
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberCreateNestedManyWithoutSpaceInput
    channels?: ChannelCreateNestedManyWithoutSpaceInput
    posts?: PostCreateNestedManyWithoutSpaceInput
    files?: FileCreateNestedManyWithoutSpaceInput
    parentSpace?: SpaceCreateNestedOneWithoutChildSpacesInput
  }

  export type SpaceUncheckedCreateWithoutChildSpacesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: string
    parentSpaceId?: string | null
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberUncheckedCreateNestedManyWithoutSpaceInput
    channels?: ChannelUncheckedCreateNestedManyWithoutSpaceInput
    posts?: PostUncheckedCreateNestedManyWithoutSpaceInput
    files?: FileUncheckedCreateNestedManyWithoutSpaceInput
  }

  export type SpaceCreateOrConnectWithoutChildSpacesInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutChildSpacesInput, SpaceUncheckedCreateWithoutChildSpacesInput>
  }

  export type SpaceCreateWithoutParentSpaceInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: string
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberCreateNestedManyWithoutSpaceInput
    channels?: ChannelCreateNestedManyWithoutSpaceInput
    posts?: PostCreateNestedManyWithoutSpaceInput
    files?: FileCreateNestedManyWithoutSpaceInput
    childSpaces?: SpaceCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceUncheckedCreateWithoutParentSpaceInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: string
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberUncheckedCreateNestedManyWithoutSpaceInput
    channels?: ChannelUncheckedCreateNestedManyWithoutSpaceInput
    posts?: PostUncheckedCreateNestedManyWithoutSpaceInput
    files?: FileUncheckedCreateNestedManyWithoutSpaceInput
    childSpaces?: SpaceUncheckedCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceCreateOrConnectWithoutParentSpaceInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutParentSpaceInput, SpaceUncheckedCreateWithoutParentSpaceInput>
  }

  export type SpaceCreateManyParentSpaceInputEnvelope = {
    data: SpaceCreateManyParentSpaceInput | SpaceCreateManyParentSpaceInput[]
  }

  export type SpaceMemberUpsertWithWhereUniqueWithoutSpaceInput = {
    where: SpaceMemberWhereUniqueInput
    update: XOR<SpaceMemberUpdateWithoutSpaceInput, SpaceMemberUncheckedUpdateWithoutSpaceInput>
    create: XOR<SpaceMemberCreateWithoutSpaceInput, SpaceMemberUncheckedCreateWithoutSpaceInput>
  }

  export type SpaceMemberUpdateWithWhereUniqueWithoutSpaceInput = {
    where: SpaceMemberWhereUniqueInput
    data: XOR<SpaceMemberUpdateWithoutSpaceInput, SpaceMemberUncheckedUpdateWithoutSpaceInput>
  }

  export type SpaceMemberUpdateManyWithWhereWithoutSpaceInput = {
    where: SpaceMemberScalarWhereInput
    data: XOR<SpaceMemberUpdateManyMutationInput, SpaceMemberUncheckedUpdateManyWithoutSpaceInput>
  }

  export type SpaceMemberScalarWhereInput = {
    AND?: SpaceMemberScalarWhereInput | SpaceMemberScalarWhereInput[]
    OR?: SpaceMemberScalarWhereInput[]
    NOT?: SpaceMemberScalarWhereInput | SpaceMemberScalarWhereInput[]
    id?: StringFilter<"SpaceMember"> | string
    spaceId?: StringFilter<"SpaceMember"> | string
    userId?: StringFilter<"SpaceMember"> | string
    role?: StringFilter<"SpaceMember"> | string
    joinedAt?: DateTimeFilter<"SpaceMember"> | Date | string
    status?: StringFilter<"SpaceMember"> | string
    permissions?: StringNullableListFilter<"SpaceMember">
  }

  export type ChannelUpsertWithWhereUniqueWithoutSpaceInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutSpaceInput, ChannelUncheckedUpdateWithoutSpaceInput>
    create: XOR<ChannelCreateWithoutSpaceInput, ChannelUncheckedCreateWithoutSpaceInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutSpaceInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutSpaceInput, ChannelUncheckedUpdateWithoutSpaceInput>
  }

  export type ChannelUpdateManyWithWhereWithoutSpaceInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutSpaceInput>
  }

  export type ChannelScalarWhereInput = {
    AND?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
    OR?: ChannelScalarWhereInput[]
    NOT?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
    id?: StringFilter<"Channel"> | string
    name?: StringFilter<"Channel"> | string
    description?: StringNullableFilter<"Channel"> | string | null
    spaceId?: StringFilter<"Channel"> | string
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
    status?: StringFilter<"Channel"> | string
    pinnedPosts?: StringNullableListFilter<"Channel">
    isPrivate?: BoolFilter<"Channel"> | boolean
    metadata?: JsonNullableFilter<"Channel">
    settings?: JsonNullableFilter<"Channel">
  }

  export type PostUpsertWithWhereUniqueWithoutSpaceInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutSpaceInput, PostUncheckedUpdateWithoutSpaceInput>
    create: XOR<PostCreateWithoutSpaceInput, PostUncheckedCreateWithoutSpaceInput>
  }

  export type PostUpdateWithWhereUniqueWithoutSpaceInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutSpaceInput, PostUncheckedUpdateWithoutSpaceInput>
  }

  export type PostUpdateManyWithWhereWithoutSpaceInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutSpaceInput>
  }

  export type FileUpsertWithWhereUniqueWithoutSpaceInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutSpaceInput, FileUncheckedUpdateWithoutSpaceInput>
    create: XOR<FileCreateWithoutSpaceInput, FileUncheckedCreateWithoutSpaceInput>
  }

  export type FileUpdateWithWhereUniqueWithoutSpaceInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutSpaceInput, FileUncheckedUpdateWithoutSpaceInput>
  }

  export type FileUpdateManyWithWhereWithoutSpaceInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutSpaceInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: StringFilter<"File"> | string
    name?: StringFilter<"File"> | string
    type?: EnumMediaTypeFilter<"File"> | $Enums.MediaType
    url?: StringFilter<"File"> | string
    uploadedBy?: StringFilter<"File"> | string
    uploadedAt?: DateTimeFilter<"File"> | Date | string
    size?: IntFilter<"File"> | number
    status?: StringFilter<"File"> | string
    preview?: StringNullableFilter<"File"> | string | null
    thumbnail?: StringNullableFilter<"File"> | string | null
    spaceId?: StringNullableFilter<"File"> | string | null
    channelId?: StringNullableFilter<"File"> | string | null
  }

  export type SpaceUpsertWithoutChildSpacesInput = {
    update: XOR<SpaceUpdateWithoutChildSpacesInput, SpaceUncheckedUpdateWithoutChildSpacesInput>
    create: XOR<SpaceCreateWithoutChildSpacesInput, SpaceUncheckedCreateWithoutChildSpacesInput>
    where?: SpaceWhereInput
  }

  export type SpaceUpdateToOneWithWhereWithoutChildSpacesInput = {
    where?: SpaceWhereInput
    data: XOR<SpaceUpdateWithoutChildSpacesInput, SpaceUncheckedUpdateWithoutChildSpacesInput>
  }

  export type SpaceUpdateWithoutChildSpacesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUpdateManyWithoutSpaceNestedInput
    posts?: PostUpdateManyWithoutSpaceNestedInput
    files?: FileUpdateManyWithoutSpaceNestedInput
    parentSpace?: SpaceUpdateOneWithoutChildSpacesNestedInput
  }

  export type SpaceUncheckedUpdateWithoutChildSpacesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUncheckedUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutSpaceNestedInput
    posts?: PostUncheckedUpdateManyWithoutSpaceNestedInput
    files?: FileUncheckedUpdateManyWithoutSpaceNestedInput
  }

  export type SpaceUpsertWithWhereUniqueWithoutParentSpaceInput = {
    where: SpaceWhereUniqueInput
    update: XOR<SpaceUpdateWithoutParentSpaceInput, SpaceUncheckedUpdateWithoutParentSpaceInput>
    create: XOR<SpaceCreateWithoutParentSpaceInput, SpaceUncheckedCreateWithoutParentSpaceInput>
  }

  export type SpaceUpdateWithWhereUniqueWithoutParentSpaceInput = {
    where: SpaceWhereUniqueInput
    data: XOR<SpaceUpdateWithoutParentSpaceInput, SpaceUncheckedUpdateWithoutParentSpaceInput>
  }

  export type SpaceUpdateManyWithWhereWithoutParentSpaceInput = {
    where: SpaceScalarWhereInput
    data: XOR<SpaceUpdateManyMutationInput, SpaceUncheckedUpdateManyWithoutParentSpaceInput>
  }

  export type SpaceScalarWhereInput = {
    AND?: SpaceScalarWhereInput | SpaceScalarWhereInput[]
    OR?: SpaceScalarWhereInput[]
    NOT?: SpaceScalarWhereInput | SpaceScalarWhereInput[]
    id?: StringFilter<"Space"> | string
    name?: StringFilter<"Space"> | string
    description?: StringNullableFilter<"Space"> | string | null
    type?: EnumSpaceTypeFilter<"Space"> | $Enums.SpaceType
    createdAt?: DateTimeFilter<"Space"> | Date | string
    updatedAt?: DateTimeFilter<"Space"> | Date | string
    spaceType?: StringFilter<"Space"> | string
    status?: StringFilter<"Space"> | string
    visibility?: StringFilter<"Space"> | string
    parentSpaceId?: StringNullableFilter<"Space"> | string | null
    isPrivate?: BoolFilter<"Space"> | boolean
    metadata?: JsonNullableFilter<"Space">
    settings?: JsonNullableFilter<"Space">
    accessLevel?: EnumAccessLevelFilter<"Space"> | $Enums.AccessLevel
    tags?: StringNullableListFilter<"Space">
  }

  export type SpaceCreateWithoutChannelsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: string
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberCreateNestedManyWithoutSpaceInput
    posts?: PostCreateNestedManyWithoutSpaceInput
    files?: FileCreateNestedManyWithoutSpaceInput
    parentSpace?: SpaceCreateNestedOneWithoutChildSpacesInput
    childSpaces?: SpaceCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceUncheckedCreateWithoutChannelsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: string
    parentSpaceId?: string | null
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberUncheckedCreateNestedManyWithoutSpaceInput
    posts?: PostUncheckedCreateNestedManyWithoutSpaceInput
    files?: FileUncheckedCreateNestedManyWithoutSpaceInput
    childSpaces?: SpaceUncheckedCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceCreateOrConnectWithoutChannelsInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutChannelsInput, SpaceUncheckedCreateWithoutChannelsInput>
  }

  export type PostCreateWithoutChannelInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
    media?: MediaCreateNestedOneWithoutPostInput
    files?: FileToPostCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutChannelInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: string | null
    spaceId?: string | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
    files?: FileToPostUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutChannelInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutChannelInput, PostUncheckedCreateWithoutChannelInput>
  }

  export type PostCreateManyChannelInputEnvelope = {
    data: PostCreateManyChannelInput | PostCreateManyChannelInput[]
  }

  export type FileCreateWithoutChannelInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: XOR<FileMetadataCreateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    posts?: FileToPostCreateNestedManyWithoutFileInput
    Space?: SpaceCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutChannelInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: XOR<FileMetadataCreateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    spaceId?: string | null
    posts?: FileToPostUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileCreateOrConnectWithoutChannelInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutChannelInput, FileUncheckedCreateWithoutChannelInput>
  }

  export type FileCreateManyChannelInputEnvelope = {
    data: FileCreateManyChannelInput | FileCreateManyChannelInput[]
  }

  export type ChannelMemberCreateWithoutChannelInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    lastRead?: Date | string | null
  }

  export type ChannelMemberUncheckedCreateWithoutChannelInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    lastRead?: Date | string | null
  }

  export type ChannelMemberCreateOrConnectWithoutChannelInput = {
    where: ChannelMemberWhereUniqueInput
    create: XOR<ChannelMemberCreateWithoutChannelInput, ChannelMemberUncheckedCreateWithoutChannelInput>
  }

  export type ChannelMemberCreateManyChannelInputEnvelope = {
    data: ChannelMemberCreateManyChannelInput | ChannelMemberCreateManyChannelInput[]
  }

  export type SpaceUpsertWithoutChannelsInput = {
    update: XOR<SpaceUpdateWithoutChannelsInput, SpaceUncheckedUpdateWithoutChannelsInput>
    create: XOR<SpaceCreateWithoutChannelsInput, SpaceUncheckedCreateWithoutChannelsInput>
    where?: SpaceWhereInput
  }

  export type SpaceUpdateToOneWithWhereWithoutChannelsInput = {
    where?: SpaceWhereInput
    data: XOR<SpaceUpdateWithoutChannelsInput, SpaceUncheckedUpdateWithoutChannelsInput>
  }

  export type SpaceUpdateWithoutChannelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUpdateManyWithoutSpaceNestedInput
    posts?: PostUpdateManyWithoutSpaceNestedInput
    files?: FileUpdateManyWithoutSpaceNestedInput
    parentSpace?: SpaceUpdateOneWithoutChildSpacesNestedInput
    childSpaces?: SpaceUpdateManyWithoutParentSpaceNestedInput
  }

  export type SpaceUncheckedUpdateWithoutChannelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUncheckedUpdateManyWithoutSpaceNestedInput
    posts?: PostUncheckedUpdateManyWithoutSpaceNestedInput
    files?: FileUncheckedUpdateManyWithoutSpaceNestedInput
    childSpaces?: SpaceUncheckedUpdateManyWithoutParentSpaceNestedInput
  }

  export type PostUpsertWithWhereUniqueWithoutChannelInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutChannelInput, PostUncheckedUpdateWithoutChannelInput>
    create: XOR<PostCreateWithoutChannelInput, PostUncheckedCreateWithoutChannelInput>
  }

  export type PostUpdateWithWhereUniqueWithoutChannelInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutChannelInput, PostUncheckedUpdateWithoutChannelInput>
  }

  export type PostUpdateManyWithWhereWithoutChannelInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutChannelInput>
  }

  export type FileUpsertWithWhereUniqueWithoutChannelInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutChannelInput, FileUncheckedUpdateWithoutChannelInput>
    create: XOR<FileCreateWithoutChannelInput, FileUncheckedCreateWithoutChannelInput>
  }

  export type FileUpdateWithWhereUniqueWithoutChannelInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutChannelInput, FileUncheckedUpdateWithoutChannelInput>
  }

  export type FileUpdateManyWithWhereWithoutChannelInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutChannelInput>
  }

  export type ChannelMemberUpsertWithWhereUniqueWithoutChannelInput = {
    where: ChannelMemberWhereUniqueInput
    update: XOR<ChannelMemberUpdateWithoutChannelInput, ChannelMemberUncheckedUpdateWithoutChannelInput>
    create: XOR<ChannelMemberCreateWithoutChannelInput, ChannelMemberUncheckedCreateWithoutChannelInput>
  }

  export type ChannelMemberUpdateWithWhereUniqueWithoutChannelInput = {
    where: ChannelMemberWhereUniqueInput
    data: XOR<ChannelMemberUpdateWithoutChannelInput, ChannelMemberUncheckedUpdateWithoutChannelInput>
  }

  export type ChannelMemberUpdateManyWithWhereWithoutChannelInput = {
    where: ChannelMemberScalarWhereInput
    data: XOR<ChannelMemberUpdateManyMutationInput, ChannelMemberUncheckedUpdateManyWithoutChannelInput>
  }

  export type ChannelMemberScalarWhereInput = {
    AND?: ChannelMemberScalarWhereInput | ChannelMemberScalarWhereInput[]
    OR?: ChannelMemberScalarWhereInput[]
    NOT?: ChannelMemberScalarWhereInput | ChannelMemberScalarWhereInput[]
    id?: StringFilter<"ChannelMember"> | string
    channelId?: StringFilter<"ChannelMember"> | string
    userId?: StringFilter<"ChannelMember"> | string
    role?: StringFilter<"ChannelMember"> | string
    joinedAt?: DateTimeFilter<"ChannelMember"> | Date | string
    lastRead?: DateTimeNullableFilter<"ChannelMember"> | Date | string | null
  }

  export type PostCreateWithoutThreadInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
    media?: MediaCreateNestedOneWithoutPostInput
    files?: FileToPostCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutThreadInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    spaceId?: string | null
    channelId?: string | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
    files?: FileToPostUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutThreadInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutThreadInput, PostUncheckedCreateWithoutThreadInput>
  }

  export type PostCreateManyThreadInputEnvelope = {
    data: PostCreateManyThreadInput | PostCreateManyThreadInput[]
  }

  export type PollPostCreateWithoutThreadInput = {
    id?: string
    createdAt: string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | null
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    extra?: InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaCreateNestedOneWithoutPollPostInput
    comments?: CommentCreateNestedManyWithoutPollPostInput
  }

  export type PollPostUncheckedCreateWithoutThreadInput = {
    id?: string
    createdAt: string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | null
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    mediaId?: string | null
    extra?: InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    comments?: CommentUncheckedCreateNestedManyWithoutPollPostInput
  }

  export type PollPostCreateOrConnectWithoutThreadInput = {
    where: PollPostWhereUniqueInput
    create: XOR<PollPostCreateWithoutThreadInput, PollPostUncheckedCreateWithoutThreadInput>
  }

  export type PollPostCreateManyThreadInputEnvelope = {
    data: PollPostCreateManyThreadInput | PollPostCreateManyThreadInput[]
  }

  export type PostUpsertWithWhereUniqueWithoutThreadInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutThreadInput, PostUncheckedUpdateWithoutThreadInput>
    create: XOR<PostCreateWithoutThreadInput, PostUncheckedCreateWithoutThreadInput>
  }

  export type PostUpdateWithWhereUniqueWithoutThreadInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutThreadInput, PostUncheckedUpdateWithoutThreadInput>
  }

  export type PostUpdateManyWithWhereWithoutThreadInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutThreadInput>
  }

  export type PollPostUpsertWithWhereUniqueWithoutThreadInput = {
    where: PollPostWhereUniqueInput
    update: XOR<PollPostUpdateWithoutThreadInput, PollPostUncheckedUpdateWithoutThreadInput>
    create: XOR<PollPostCreateWithoutThreadInput, PollPostUncheckedCreateWithoutThreadInput>
  }

  export type PollPostUpdateWithWhereUniqueWithoutThreadInput = {
    where: PollPostWhereUniqueInput
    data: XOR<PollPostUpdateWithoutThreadInput, PollPostUncheckedUpdateWithoutThreadInput>
  }

  export type PollPostUpdateManyWithWhereWithoutThreadInput = {
    where: PollPostScalarWhereInput
    data: XOR<PollPostUpdateManyMutationInput, PollPostUncheckedUpdateManyWithoutThreadInput>
  }

  export type MediaCreateWithoutNoteInput = {
    id?: string
    mediaType: string
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    CommentReply?: CommentReplyCreateNestedManyWithoutMediaInput
    Post?: PostCreateNestedManyWithoutMediaInput
    Comment?: CommentCreateNestedManyWithoutMediaInput
    PollPost?: PollPostCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutNoteInput = {
    id?: string
    mediaType: string
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    CommentReply?: CommentReplyUncheckedCreateNestedManyWithoutMediaInput
    Post?: PostUncheckedCreateNestedManyWithoutMediaInput
    Comment?: CommentUncheckedCreateNestedManyWithoutMediaInput
    PollPost?: PollPostUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutNoteInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutNoteInput, MediaUncheckedCreateWithoutNoteInput>
  }

  export type PostCreateWithoutNotesInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
    media?: MediaCreateNestedOneWithoutPostInput
    files?: FileToPostCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutNotesInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
    files?: FileToPostUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutNotesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutNotesInput, PostUncheckedCreateWithoutNotesInput>
  }

  export type CommentCreateWithoutNotesInput = {
    id?: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaCreateNestedOneWithoutCommentInput
    replies?: CommentReplyCreateNestedManyWithoutCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    PollPost?: PollPostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutNotesInput = {
    id?: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    postId: string
    pollPostId?: string | null
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    mediaId?: string | null
    replies?: CommentReplyUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutNotesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutNotesInput, CommentUncheckedCreateWithoutNotesInput>
  }

  export type MediaUpsertWithoutNoteInput = {
    update: XOR<MediaUpdateWithoutNoteInput, MediaUncheckedUpdateWithoutNoteInput>
    create: XOR<MediaCreateWithoutNoteInput, MediaUncheckedCreateWithoutNoteInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutNoteInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutNoteInput, MediaUncheckedUpdateWithoutNoteInput>
  }

  export type MediaUpdateWithoutNoteInput = {
    mediaType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CommentReply?: CommentReplyUpdateManyWithoutMediaNestedInput
    Post?: PostUpdateManyWithoutMediaNestedInput
    Comment?: CommentUpdateManyWithoutMediaNestedInput
    PollPost?: PollPostUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutNoteInput = {
    mediaType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CommentReply?: CommentReplyUncheckedUpdateManyWithoutMediaNestedInput
    Post?: PostUncheckedUpdateManyWithoutMediaNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutMediaNestedInput
    PollPost?: PollPostUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type PostUpsertWithoutNotesInput = {
    update: XOR<PostUpdateWithoutNotesInput, PostUncheckedUpdateWithoutNotesInput>
    create: XOR<PostCreateWithoutNotesInput, PostUncheckedCreateWithoutNotesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutNotesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutNotesInput, PostUncheckedUpdateWithoutNotesInput>
  }

  export type PostUpdateWithoutNotesInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostNestedInput
    files?: FileToPostUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutNotesInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
    files?: FileToPostUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CommentUpsertWithoutNotesInput = {
    update: XOR<CommentUpdateWithoutNotesInput, CommentUncheckedUpdateWithoutNotesInput>
    create: XOR<CommentCreateWithoutNotesInput, CommentUncheckedCreateWithoutNotesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutNotesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutNotesInput, CommentUncheckedUpdateWithoutNotesInput>
  }

  export type CommentUpdateWithoutNotesInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaUpdateOneWithoutCommentNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    PollPost?: PollPostUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutNotesInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    postId?: StringFieldUpdateOperationsInput | string
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type MediaCreateWithoutCommentInput = {
    id?: string
    mediaType: string
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    CommentReply?: CommentReplyCreateNestedManyWithoutMediaInput
    Post?: PostCreateNestedManyWithoutMediaInput
    PollPost?: PollPostCreateNestedManyWithoutMediaInput
    Note?: NoteCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutCommentInput = {
    id?: string
    mediaType: string
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    CommentReply?: CommentReplyUncheckedCreateNestedManyWithoutMediaInput
    Post?: PostUncheckedCreateNestedManyWithoutMediaInput
    PollPost?: PollPostUncheckedCreateNestedManyWithoutMediaInput
    Note?: NoteUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutCommentInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutCommentInput, MediaUncheckedCreateWithoutCommentInput>
  }

  export type CommentReplyCreateWithoutCommentInput = {
    id?: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaCreateNestedOneWithoutCommentReplyInput
  }

  export type CommentReplyUncheckedCreateWithoutCommentInput = {
    id?: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    mediaid?: string | null
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type CommentReplyCreateOrConnectWithoutCommentInput = {
    where: CommentReplyWhereUniqueInput
    create: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput>
  }

  export type CommentReplyCreateManyCommentInputEnvelope = {
    data: CommentReplyCreateManyCommentInput | CommentReplyCreateManyCommentInput[]
  }

  export type NoteCreateWithoutCommentInput = {
    id?: string
    content: string
    createdAt: string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaCreateNestedOneWithoutNoteInput
    post: PostCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutCommentInput = {
    id?: string
    content: string
    createdAt: string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type NoteCreateOrConnectWithoutCommentInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutCommentInput, NoteUncheckedCreateWithoutCommentInput>
  }

  export type NoteCreateManyCommentInputEnvelope = {
    data: NoteCreateManyCommentInput | NoteCreateManyCommentInput[]
  }

  export type PostCreateWithoutCommentsInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
    media?: MediaCreateNestedOneWithoutPostInput
    files?: FileToPostCreateNestedManyWithoutPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
    files?: FileToPostUncheckedCreateNestedManyWithoutPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type PollPostCreateWithoutCommentsInput = {
    id?: string
    createdAt: string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | null
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    extra?: InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaCreateNestedOneWithoutPollPostInput
    thread?: ThreadCreateNestedOneWithoutPollPostsInput
  }

  export type PollPostUncheckedCreateWithoutCommentsInput = {
    id?: string
    createdAt: string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | null
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    mediaId?: string | null
    threadId?: string | null
    extra?: InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type PollPostCreateOrConnectWithoutCommentsInput = {
    where: PollPostWhereUniqueInput
    create: XOR<PollPostCreateWithoutCommentsInput, PollPostUncheckedCreateWithoutCommentsInput>
  }

  export type MediaUpsertWithoutCommentInput = {
    update: XOR<MediaUpdateWithoutCommentInput, MediaUncheckedUpdateWithoutCommentInput>
    create: XOR<MediaCreateWithoutCommentInput, MediaUncheckedCreateWithoutCommentInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutCommentInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutCommentInput, MediaUncheckedUpdateWithoutCommentInput>
  }

  export type MediaUpdateWithoutCommentInput = {
    mediaType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CommentReply?: CommentReplyUpdateManyWithoutMediaNestedInput
    Post?: PostUpdateManyWithoutMediaNestedInput
    PollPost?: PollPostUpdateManyWithoutMediaNestedInput
    Note?: NoteUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutCommentInput = {
    mediaType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CommentReply?: CommentReplyUncheckedUpdateManyWithoutMediaNestedInput
    Post?: PostUncheckedUpdateManyWithoutMediaNestedInput
    PollPost?: PollPostUncheckedUpdateManyWithoutMediaNestedInput
    Note?: NoteUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type CommentReplyUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentReplyWhereUniqueInput
    update: XOR<CommentReplyUpdateWithoutCommentInput, CommentReplyUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentReplyCreateWithoutCommentInput, CommentReplyUncheckedCreateWithoutCommentInput>
  }

  export type CommentReplyUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentReplyWhereUniqueInput
    data: XOR<CommentReplyUpdateWithoutCommentInput, CommentReplyUncheckedUpdateWithoutCommentInput>
  }

  export type CommentReplyUpdateManyWithWhereWithoutCommentInput = {
    where: CommentReplyScalarWhereInput
    data: XOR<CommentReplyUpdateManyMutationInput, CommentReplyUncheckedUpdateManyWithoutCommentInput>
  }

  export type NoteUpsertWithWhereUniqueWithoutCommentInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutCommentInput, NoteUncheckedUpdateWithoutCommentInput>
    create: XOR<NoteCreateWithoutCommentInput, NoteUncheckedCreateWithoutCommentInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutCommentInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutCommentInput, NoteUncheckedUpdateWithoutCommentInput>
  }

  export type NoteUpdateManyWithWhereWithoutCommentInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutCommentInput>
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostNestedInput
    files?: FileToPostUpdateManyWithoutPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
    files?: FileToPostUncheckedUpdateManyWithoutPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PollPostUpsertWithoutCommentsInput = {
    update: XOR<PollPostUpdateWithoutCommentsInput, PollPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PollPostCreateWithoutCommentsInput, PollPostUncheckedCreateWithoutCommentsInput>
    where?: PollPostWhereInput
  }

  export type PollPostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PollPostWhereInput
    data: XOR<PollPostUpdateWithoutCommentsInput, PollPostUncheckedUpdateWithoutCommentsInput>
  }

  export type PollPostUpdateWithoutCommentsInput = {
    createdAt?: StringFieldUpdateOperationsInput | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | InputJsonValue | null
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    extra?: InputJsonValue | InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaUpdateOneWithoutPollPostNestedInput
    thread?: ThreadUpdateOneWithoutPollPostsNestedInput
  }

  export type PollPostUncheckedUpdateWithoutCommentsInput = {
    createdAt?: StringFieldUpdateOperationsInput | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | InputJsonValue | null
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type MediaCreateWithoutCommentReplyInput = {
    id?: string
    mediaType: string
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    Post?: PostCreateNestedManyWithoutMediaInput
    Comment?: CommentCreateNestedManyWithoutMediaInput
    PollPost?: PollPostCreateNestedManyWithoutMediaInput
    Note?: NoteCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutCommentReplyInput = {
    id?: string
    mediaType: string
    status: string
    fileContent?: string | null
    fileName: string
    transcription?: string | null
    extractedText?: string | null
    createdAt?: Date | string
    Post?: PostUncheckedCreateNestedManyWithoutMediaInput
    Comment?: CommentUncheckedCreateNestedManyWithoutMediaInput
    PollPost?: PollPostUncheckedCreateNestedManyWithoutMediaInput
    Note?: NoteUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutCommentReplyInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutCommentReplyInput, MediaUncheckedCreateWithoutCommentReplyInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaCreateNestedOneWithoutCommentInput
    notes?: NoteCreateNestedManyWithoutCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    PollPost?: PollPostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    postId: string
    pollPostId?: string | null
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    mediaId?: string | null
    notes?: NoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type MediaUpsertWithoutCommentReplyInput = {
    update: XOR<MediaUpdateWithoutCommentReplyInput, MediaUncheckedUpdateWithoutCommentReplyInput>
    create: XOR<MediaCreateWithoutCommentReplyInput, MediaUncheckedCreateWithoutCommentReplyInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutCommentReplyInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutCommentReplyInput, MediaUncheckedUpdateWithoutCommentReplyInput>
  }

  export type MediaUpdateWithoutCommentReplyInput = {
    mediaType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Post?: PostUpdateManyWithoutMediaNestedInput
    Comment?: CommentUpdateManyWithoutMediaNestedInput
    PollPost?: PollPostUpdateManyWithoutMediaNestedInput
    Note?: NoteUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutCommentReplyInput = {
    mediaType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fileContent?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Post?: PostUncheckedUpdateManyWithoutMediaNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutMediaNestedInput
    PollPost?: PollPostUncheckedUpdateManyWithoutMediaNestedInput
    Note?: NoteUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaUpdateOneWithoutCommentNestedInput
    notes?: NoteUpdateManyWithoutCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    PollPost?: PollPostUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    postId?: StringFieldUpdateOperationsInput | string
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type SpaceCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: string
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceCreatetagsInput | string[]
    channels?: ChannelCreateNestedManyWithoutSpaceInput
    posts?: PostCreateNestedManyWithoutSpaceInput
    files?: FileCreateNestedManyWithoutSpaceInput
    parentSpace?: SpaceCreateNestedOneWithoutChildSpacesInput
    childSpaces?: SpaceCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: string
    parentSpaceId?: string | null
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceCreatetagsInput | string[]
    channels?: ChannelUncheckedCreateNestedManyWithoutSpaceInput
    posts?: PostUncheckedCreateNestedManyWithoutSpaceInput
    files?: FileUncheckedCreateNestedManyWithoutSpaceInput
    childSpaces?: SpaceUncheckedCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceCreateOrConnectWithoutMembersInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutMembersInput, SpaceUncheckedCreateWithoutMembersInput>
  }

  export type SpaceUpsertWithoutMembersInput = {
    update: XOR<SpaceUpdateWithoutMembersInput, SpaceUncheckedUpdateWithoutMembersInput>
    create: XOR<SpaceCreateWithoutMembersInput, SpaceUncheckedCreateWithoutMembersInput>
    where?: SpaceWhereInput
  }

  export type SpaceUpdateToOneWithWhereWithoutMembersInput = {
    where?: SpaceWhereInput
    data: XOR<SpaceUpdateWithoutMembersInput, SpaceUncheckedUpdateWithoutMembersInput>
  }

  export type SpaceUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
    channels?: ChannelUpdateManyWithoutSpaceNestedInput
    posts?: PostUpdateManyWithoutSpaceNestedInput
    files?: FileUpdateManyWithoutSpaceNestedInput
    parentSpace?: SpaceUpdateOneWithoutChildSpacesNestedInput
    childSpaces?: SpaceUpdateManyWithoutParentSpaceNestedInput
  }

  export type SpaceUncheckedUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
    channels?: ChannelUncheckedUpdateManyWithoutSpaceNestedInput
    posts?: PostUncheckedUpdateManyWithoutSpaceNestedInput
    files?: FileUncheckedUpdateManyWithoutSpaceNestedInput
    childSpaces?: SpaceUncheckedUpdateManyWithoutParentSpaceNestedInput
  }

  export type ChannelCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    space: SpaceCreateNestedOneWithoutChannelsInput
    posts?: PostCreateNestedManyWithoutChannelInput
    files?: FileCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    spaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    posts?: PostUncheckedCreateNestedManyWithoutChannelInput
    files?: FileUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutMembersInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutMembersInput, ChannelUncheckedCreateWithoutMembersInput>
  }

  export type ChannelUpsertWithoutMembersInput = {
    update: XOR<ChannelUpdateWithoutMembersInput, ChannelUncheckedUpdateWithoutMembersInput>
    create: XOR<ChannelCreateWithoutMembersInput, ChannelUncheckedCreateWithoutMembersInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutMembersInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutMembersInput, ChannelUncheckedUpdateWithoutMembersInput>
  }

  export type ChannelUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    space?: SpaceUpdateOneRequiredWithoutChannelsNestedInput
    posts?: PostUpdateManyWithoutChannelNestedInput
    files?: FileUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    posts?: PostUncheckedUpdateManyWithoutChannelNestedInput
    files?: FileUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type DimensionsCreateInput = {
    width: number
    height: number
    depth?: number | null
    aspectRatio?: number | null
    resolution?: string | null
  }

  export type FileToPostCreateWithoutFileInput = {
    id?: string
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutFilesInput
  }

  export type FileToPostUncheckedCreateWithoutFileInput = {
    id?: string
    postId: string
    createdAt?: Date | string
  }

  export type FileToPostCreateOrConnectWithoutFileInput = {
    where: FileToPostWhereUniqueInput
    create: XOR<FileToPostCreateWithoutFileInput, FileToPostUncheckedCreateWithoutFileInput>
  }

  export type FileToPostCreateManyFileInputEnvelope = {
    data: FileToPostCreateManyFileInput | FileToPostCreateManyFileInput[]
  }

  export type SpaceCreateWithoutFilesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: string
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberCreateNestedManyWithoutSpaceInput
    channels?: ChannelCreateNestedManyWithoutSpaceInput
    posts?: PostCreateNestedManyWithoutSpaceInput
    parentSpace?: SpaceCreateNestedOneWithoutChildSpacesInput
    childSpaces?: SpaceCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: string
    parentSpaceId?: string | null
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceCreatetagsInput | string[]
    members?: SpaceMemberUncheckedCreateNestedManyWithoutSpaceInput
    channels?: ChannelUncheckedCreateNestedManyWithoutSpaceInput
    posts?: PostUncheckedCreateNestedManyWithoutSpaceInput
    childSpaces?: SpaceUncheckedCreateNestedManyWithoutParentSpaceInput
  }

  export type SpaceCreateOrConnectWithoutFilesInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutFilesInput, SpaceUncheckedCreateWithoutFilesInput>
  }

  export type ChannelCreateWithoutFilesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    space: SpaceCreateNestedOneWithoutChannelsInput
    posts?: PostCreateNestedManyWithoutChannelInput
    members?: ChannelMemberCreateNestedManyWithoutChannelInput
  }

  export type ChannelUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    description?: string | null
    spaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    posts?: PostUncheckedCreateNestedManyWithoutChannelInput
    members?: ChannelMemberUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutFilesInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutFilesInput, ChannelUncheckedCreateWithoutFilesInput>
  }

  export type FileMetadataUpdateInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    dimensions?: XOR<DimensionsNullableUpdateEnvelopeInput, DimensionsCreateInput> | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    encoding?: NullableStringFieldUpdateOperationsInput | string | null
    compression?: NullableStringFieldUpdateOperationsInput | string | null
    processingStatus?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    modifiedBy?: StringFieldUpdateOperationsInput | string
    parentFolder?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
  }

  export type FileToPostUpsertWithWhereUniqueWithoutFileInput = {
    where: FileToPostWhereUniqueInput
    update: XOR<FileToPostUpdateWithoutFileInput, FileToPostUncheckedUpdateWithoutFileInput>
    create: XOR<FileToPostCreateWithoutFileInput, FileToPostUncheckedCreateWithoutFileInput>
  }

  export type FileToPostUpdateWithWhereUniqueWithoutFileInput = {
    where: FileToPostWhereUniqueInput
    data: XOR<FileToPostUpdateWithoutFileInput, FileToPostUncheckedUpdateWithoutFileInput>
  }

  export type FileToPostUpdateManyWithWhereWithoutFileInput = {
    where: FileToPostScalarWhereInput
    data: XOR<FileToPostUpdateManyMutationInput, FileToPostUncheckedUpdateManyWithoutFileInput>
  }

  export type SpaceUpsertWithoutFilesInput = {
    update: XOR<SpaceUpdateWithoutFilesInput, SpaceUncheckedUpdateWithoutFilesInput>
    create: XOR<SpaceCreateWithoutFilesInput, SpaceUncheckedCreateWithoutFilesInput>
    where?: SpaceWhereInput
  }

  export type SpaceUpdateToOneWithWhereWithoutFilesInput = {
    where?: SpaceWhereInput
    data: XOR<SpaceUpdateWithoutFilesInput, SpaceUncheckedUpdateWithoutFilesInput>
  }

  export type SpaceUpdateWithoutFilesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUpdateManyWithoutSpaceNestedInput
    posts?: PostUpdateManyWithoutSpaceNestedInput
    parentSpace?: SpaceUpdateOneWithoutChildSpacesNestedInput
    childSpaces?: SpaceUpdateManyWithoutParentSpaceNestedInput
  }

  export type SpaceUncheckedUpdateWithoutFilesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUncheckedUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutSpaceNestedInput
    posts?: PostUncheckedUpdateManyWithoutSpaceNestedInput
    childSpaces?: SpaceUncheckedUpdateManyWithoutParentSpaceNestedInput
  }

  export type ChannelUpsertWithoutFilesInput = {
    update: XOR<ChannelUpdateWithoutFilesInput, ChannelUncheckedUpdateWithoutFilesInput>
    create: XOR<ChannelCreateWithoutFilesInput, ChannelUncheckedCreateWithoutFilesInput>
    where?: ChannelWhereInput
  }

  export type ChannelUpdateToOneWithWhereWithoutFilesInput = {
    where?: ChannelWhereInput
    data: XOR<ChannelUpdateWithoutFilesInput, ChannelUncheckedUpdateWithoutFilesInput>
  }

  export type ChannelUpdateWithoutFilesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    space?: SpaceUpdateOneRequiredWithoutChannelsNestedInput
    posts?: PostUpdateManyWithoutChannelNestedInput
    members?: ChannelMemberUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutFilesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    posts?: PostUncheckedUpdateManyWithoutChannelNestedInput
    members?: ChannelMemberUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type FileCreateWithoutPostsInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: XOR<FileMetadataCreateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    Space?: SpaceCreateNestedOneWithoutFilesInput
    Channel?: ChannelCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: XOR<FileMetadataCreateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    spaceId?: string | null
    channelId?: string | null
  }

  export type FileCreateOrConnectWithoutPostsInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutPostsInput, FileUncheckedCreateWithoutPostsInput>
  }

  export type PostCreateWithoutFilesInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
    media?: MediaCreateNestedOneWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    notes?: NoteCreateNestedManyWithoutPostInput
    thread?: ThreadCreateNestedOneWithoutPostsInput
    space?: SpaceCreateNestedOneWithoutPostsInput
    channel?: ChannelCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutFilesInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    notes?: NoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutFilesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutFilesInput, PostUncheckedCreateWithoutFilesInput>
  }

  export type FileUpsertWithoutPostsInput = {
    update: XOR<FileUpdateWithoutPostsInput, FileUncheckedUpdateWithoutPostsInput>
    create: XOR<FileCreateWithoutPostsInput, FileUncheckedCreateWithoutPostsInput>
    where?: FileWhereInput
  }

  export type FileUpdateToOneWithWhereWithoutPostsInput = {
    where?: FileWhereInput
    data: XOR<FileUpdateWithoutPostsInput, FileUncheckedUpdateWithoutPostsInput>
  }

  export type FileUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: XOR<FileMetadataUpdateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    Space?: SpaceUpdateOneWithoutFilesNestedInput
    Channel?: ChannelUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: XOR<FileMetadataUpdateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostUpsertWithoutFilesInput = {
    update: XOR<PostUpdateWithoutFilesInput, PostUncheckedUpdateWithoutFilesInput>
    create: XOR<PostCreateWithoutFilesInput, PostUncheckedCreateWithoutFilesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutFilesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutFilesInput, PostUncheckedUpdateWithoutFilesInput>
  }

  export type PostUpdateWithoutFilesInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutFilesInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EntitiesCompositeListFilter = {
    equals?: EntitiesObjectEqualityInput[]
    every?: EntitiesWhereInput
    some?: EntitiesWhereInput
    none?: EntitiesWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type SentimentCompositeFilter = {
    equals?: SentimentObjectEqualityInput
    is?: SentimentWhereInput
    isNot?: SentimentWhereInput
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type SentimentAnalysisCompositeFilter = {
    equals?: SentimentAnalysisObjectEqualityInput
    is?: SentimentAnalysisWhereInput
    isNot?: SentimentAnalysisWhereInput
  }

  export type NamedEntityCompositeListFilter = {
    equals?: NamedEntityObjectEqualityInput[]
    every?: NamedEntityWhereInput
    some?: NamedEntityWhereInput
    none?: NamedEntityWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type TopicAnalysisCompositeListFilter = {
    equals?: TopicAnalysisObjectEqualityInput[]
    every?: TopicAnalysisWhereInput
    some?: TopicAnalysisWhereInput
    none?: TopicAnalysisWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type KeywordCompositeListFilter = {
    equals?: KeywordObjectEqualityInput[]
    every?: KeywordWhereInput
    some?: KeywordWhereInput
    none?: KeywordWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ReadabilityMetricsCompositeFilter = {
    equals?: ReadabilityMetricsObjectEqualityInput
    is?: ReadabilityMetricsWhereInput
    isNot?: ReadabilityMetricsWhereInput
  }

  export type ContentQualityCompositeFilter = {
    equals?: ContentQualityObjectEqualityInput
    is?: ContentQualityWhereInput
    isNot?: ContentQualityWhereInput
  }

  export type ToxicityAnalysisCompositeFilter = {
    equals?: ToxicityAnalysisObjectEqualityInput
    is?: ToxicityAnalysisWhereInput
    isNot?: ToxicityAnalysisWhereInput
  }

  export type OriginalityScoreCompositeFilter = {
    equals?: OriginalityScoreObjectEqualityInput
    is?: OriginalityScoreWhereInput
    isNot?: OriginalityScoreWhereInput
  }

  export type LanguageAnalysisCompositeFilter = {
    equals?: LanguageAnalysisObjectEqualityInput
    is?: LanguageAnalysisWhereInput
    isNot?: LanguageAnalysisWhereInput
  }

  export type TranslationInfoCompositeFilter = {
    equals?: TranslationInfoObjectEqualityInput
    is?: TranslationInfoWhereInput
    isNot?: TranslationInfoWhereInput
  }

  export type GrammarAnalysisCompositeFilter = {
    equals?: GrammarAnalysisObjectEqualityInput
    is?: GrammarAnalysisWhereInput
    isNot?: GrammarAnalysisWhereInput
  }

  export type StyleMetricsCompositeFilter = {
    equals?: StyleMetricsObjectEqualityInput
    is?: StyleMetricsWhereInput
    isNot?: StyleMetricsWhereInput
  }

  export type IntentAnalysisCompositeListFilter = {
    equals?: IntentAnalysisObjectEqualityInput[]
    every?: IntentAnalysisWhereInput
    some?: IntentAnalysisWhereInput
    none?: IntentAnalysisWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type EmotionAnalysisCompositeFilter = {
    equals?: EmotionAnalysisObjectEqualityInput
    is?: EmotionAnalysisWhereInput
    isNot?: EmotionAnalysisWhereInput
  }

  export type BiasAnalysisCompositeFilter = {
    equals?: BiasAnalysisObjectEqualityInput
    is?: BiasAnalysisWhereInput
    isNot?: BiasAnalysisWhereInput
  }

  export type ImageAnalysisCompositeListFilter = {
    equals?: ImageAnalysisObjectEqualityInput[]
    every?: ImageAnalysisWhereInput
    some?: ImageAnalysisWhereInput
    none?: ImageAnalysisWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type VideoAnalysisCompositeListFilter = {
    equals?: VideoAnalysisObjectEqualityInput[]
    every?: VideoAnalysisWhereInput
    some?: VideoAnalysisWhereInput
    none?: VideoAnalysisWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type AudioAnalysisCompositeListFilter = {
    equals?: AudioAnalysisObjectEqualityInput[]
    every?: AudioAnalysisWhereInput
    some?: AudioAnalysisWhereInput
    none?: AudioAnalysisWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type MarketAnalysisCompositeFilter = {
    equals?: MarketAnalysisObjectEqualityInput
    is?: MarketAnalysisWhereInput
    isNot?: MarketAnalysisWhereInput
  }

  export type CompetitiveAnalysisCompositeFilter = {
    equals?: CompetitiveAnalysisObjectEqualityInput
    is?: CompetitiveAnalysisWhereInput
    isNot?: CompetitiveAnalysisWhereInput
  }

  export type ActionItemCompositeListFilter = {
    equals?: ActionItemObjectEqualityInput[]
    every?: ActionItemWhereInput
    some?: ActionItemWhereInput
    none?: ActionItemWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ModelMetadataCompositeFilter = {
    equals?: ModelMetadataObjectEqualityInput
    is?: ModelMetadataWhereInput
    isNot?: ModelMetadataWhereInput
  }

  export type SentimentSegmentObjectEqualityInput = {
    text: string
    sentiment: number
    startIndex: number
    endIndex: number
    aspects?: AspectSentimentObjectEqualityInput[]
  }

  export type WikiDataObjectEqualityInput = {
    entityId: string
    url: string
    confidence: number
    description?: string | null
  }

  export type TopicContextObjectEqualityInput = {
    domain: string
    category: string
    parentTopics?: string[]
    relatedTopics?: string[]
  }

  export type KeywordMetricsObjectEqualityInput = {
    tfIdf: number
    textRank: number
    prominence: number
    location?: KeywordLocationObjectEqualityInput[]
  }

  export type ComplexityMetricsObjectEqualityInput = {
    sentenceComplexity: number
    wordComplexity: number
    technicalLevel: string
    vocabularyDiversity: number
  }

  export type SourceValidationObjectEqualityInput = {
    url: string
    credibility: number
    type: string
    citations?: CitationObjectEqualityInput[]
  }

  export type StructureAnalysisObjectEqualityInput = {
    paragraphFlow: number
    transitionQuality: number
    logicalProgression: number
    sectioning: number
  }

  export type FormattingAnalysisObjectEqualityInput = {
    consistency: number
    readability: number
    visualHierarchy: number
    spacing: number
  }

  export type ToxicityCategoriesObjectEqualityInput = {
    hate: number
    harassment: number
    profanity: number
    violence: number
    sexual: number
    spam: number
    misleading: number
    bias: number
  }

  export type ThreatDetectionObjectEqualityInput = {
    type: string
    severity: number
    confidence: number
    context: string
  }

  export type ModerationDecisionObjectEqualityInput = {
    action: string
    confidence: number
    reason: string
    escalation: boolean
  }

  export type ToxicitySeverityObjectEqualityInput = {
    level: string
    score: number
    recommendation: string
  }

  export type SimilarityMatchObjectEqualityInput = {
    text: string
    source: string
    confidence: number
    context: string
  }

  export type PlagiarismMetricsObjectEqualityInput = {
    score: number
    matches: number
    sources?: string[]
    severity: string
  }

  export type LanguageAlternativeObjectEqualityInput = {
    language: string
    confidence: number
    probability: number
  }

  export type GrammarErrorObjectEqualityInput = {
    type: string
    suggestion: string
    context: string
    severity: number
  }

  export type StyleSuggestionObjectEqualityInput = {
    type: string
    suggestion: string
    reason: string
    importance: number
  }

  export type VocabularyMetricsObjectEqualityInput = {
    diversity: number
    sophistication: number
    jargon: number
    accessibility: number
  }

  export type EmotionSpectrumObjectEqualityInput = {
    joy: number
    sadness: number
    anger: number
    fear: number
    surprise: number
    disgust: number
  }

  export type BiasTypeObjectEqualityInput = {
    category: string
    score: number
    evidence?: string[]
  }

  export type DetectedObjectObjectEqualityInput = {
    label: string
    confidence: number
    boundingBox: BoundingBoxObjectEqualityInput
    attributes: InputJsonValue
  }

  export type FaceAnalysisObjectEqualityInput = {
    boundingBox: BoundingBoxObjectEqualityInput
    emotions: EmotionAnalysisObjectEqualityInput
    attributes: FaceAttributesObjectEqualityInput
    landmarks?: FaceLandmarkObjectEqualityInput[]
  }

  export type LabelObjectEqualityInput = {
    name: string
    confidence: number
    parents?: string[]
  }

  export type ColorAnalysisObjectEqualityInput = {
    dominant?: ColorObjectEqualityInput[]
    palette?: ColorObjectEqualityInput[]
    brightness: number
    contrast: number
  }

  export type NSFWAnalysisObjectEqualityInput = {
    score: number
    categories: NSFWCategoriesObjectEqualityInput
    confidence: number
  }

  export type ImageQualityObjectEqualityInput = {
    resolution: ResolutionObjectEqualityInput
    sharpness: number
    brightness: number
    noise: number
  }

  export type ImageCompositionObjectEqualityInput = {
    balance: number
    symmetry: number
    focus: number
    aesthetic: number
  }

  export type SceneObjectEqualityInput = {
    startTime: number
    endTime: number
    keyFrames?: KeyFrameObjectEqualityInput[]
    description: string
  }

  export type KeyFrameObjectEqualityInput = {
    timestamp: number
    image: ImageAnalysisObjectEqualityInput
    importance: number
  }

  export type ActionObjectEqualityInput = {
    type: string
    confidence: number
    startTime: number
    endTime: number
  }

  export type CaptionObjectEqualityInput = {
    text: string
    timestamp: number
    confidence: number
  }

  export type MotionAnalysisObjectEqualityInput = {
    activity: number
    stability: number
    tracking?: TrackingDataObjectEqualityInput[]
  }

  export type SpeakerObjectEqualityInput = {
    id: string
    segments?: TimeSegmentObjectEqualityInput[]
    confidence: number
    characteristics: SpeakerCharacteristicsObjectEqualityInput
  }

  export type NoiseAnalysisObjectEqualityInput = {
    level: number
    type?: string[]
    impact: number
  }

  export type MusicAnalysisObjectEqualityInput = {
    present: boolean
    genre?: string[]
    tempo: number
    mood?: string[]
  }

  export type TrendObjectEqualityInput = {
    name: string
    strength: number
    direction: string
    timeframe: string
  }

  export type ModelPerformanceObjectEqualityInput = {
    latency: number
    accuracy: number
    confidence: number
    resourceUsage: ResourceMetricsObjectEqualityInput
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type SentimentSegmentOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ComplexityMetricsOrderByInput = {
    sentenceComplexity?: SortOrder
    wordComplexity?: SortOrder
    technicalLevel?: SortOrder
    vocabularyDiversity?: SortOrder
  }

  export type SourceValidationOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type StructureAnalysisOrderByInput = {
    paragraphFlow?: SortOrder
    transitionQuality?: SortOrder
    logicalProgression?: SortOrder
    sectioning?: SortOrder
  }

  export type FormattingAnalysisOrderByInput = {
    consistency?: SortOrder
    readability?: SortOrder
    visualHierarchy?: SortOrder
    spacing?: SortOrder
  }

  export type ToxicityCategoriesOrderByInput = {
    hate?: SortOrder
    harassment?: SortOrder
    profanity?: SortOrder
    violence?: SortOrder
    sexual?: SortOrder
    spam?: SortOrder
    misleading?: SortOrder
    bias?: SortOrder
  }

  export type ThreatDetectionOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ModerationDecisionOrderByInput = {
    action?: SortOrder
    confidence?: SortOrder
    reason?: SortOrder
    escalation?: SortOrder
  }

  export type ToxicitySeverityOrderByInput = {
    level?: SortOrder
    score?: SortOrder
    recommendation?: SortOrder
  }

  export type SimilarityMatchOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type PlagiarismMetricsOrderByInput = {
    score?: SortOrder
    matches?: SortOrder
    sources?: SortOrder
    severity?: SortOrder
  }

  export type LanguageAlternativeOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type GrammarErrorOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type StyleSuggestionOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type VocabularyMetricsOrderByInput = {
    diversity?: SortOrder
    sophistication?: SortOrder
    jargon?: SortOrder
    accessibility?: SortOrder
  }

  export type EmotionSpectrumOrderByInput = {
    joy?: SortOrder
    sadness?: SortOrder
    anger?: SortOrder
    fear?: SortOrder
    surprise?: SortOrder
    disgust?: SortOrder
  }

  export type BiasTypeOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type TrendOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type ModelPerformanceOrderByInput = {
    latency?: SortOrder
    accuracy?: SortOrder
    confidence?: SortOrder
    resourceUsage?: ResourceMetricsOrderByInput
  }

  export type DimensionsNullableCompositeFilter = {
    equals?: DimensionsObjectEqualityInput | null
    is?: DimensionsWhereInput | null
    isNot?: DimensionsWhereInput | null
    isSet?: boolean
  }

  export type CommentReplyCreateManyMediaInput = {
    id?: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    commentId: string
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type PostCreateManyMediaInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: string | null
    spaceId?: string | null
    channelId?: string | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
  }

  export type CommentCreateManyMediaInput = {
    id?: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    postId: string
    pollPostId?: string | null
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type PollPostCreateManyMediaInput = {
    id?: string
    createdAt: string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | null
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    threadId?: string | null
    extra?: InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type NoteCreateManyMediaInput = {
    id?: string
    content: string
    createdAt: string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    postId: string
    commentId?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type CommentReplyUpdateWithoutMediaInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    comment?: CommentUpdateOneRequiredWithoutRepliesNestedInput
  }

  export type CommentReplyUncheckedUpdateWithoutMediaInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    commentId?: StringFieldUpdateOperationsInput | string
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type CommentReplyUncheckedUpdateManyWithoutMediaInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    commentId?: StringFieldUpdateOperationsInput | string
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type PostUpdateWithoutMediaInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
    files?: FileToPostUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutMediaInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
    files?: FileToPostUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutMediaInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUpdateWithoutMediaInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    notes?: NoteUpdateManyWithoutCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    PollPost?: PollPostUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutMediaInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    postId?: StringFieldUpdateOperationsInput | string
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutMediaInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    postId?: StringFieldUpdateOperationsInput | string
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type PollPostUpdateWithoutMediaInput = {
    createdAt?: StringFieldUpdateOperationsInput | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | InputJsonValue | null
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    extra?: InputJsonValue | InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    comments?: CommentUpdateManyWithoutPollPostNestedInput
    thread?: ThreadUpdateOneWithoutPollPostsNestedInput
  }

  export type PollPostUncheckedUpdateWithoutMediaInput = {
    createdAt?: StringFieldUpdateOperationsInput | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | InputJsonValue | null
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    comments?: CommentUncheckedUpdateManyWithoutPollPostNestedInput
  }

  export type PollPostUncheckedUpdateManyWithoutMediaInput = {
    createdAt?: StringFieldUpdateOperationsInput | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | InputJsonValue | null
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type NoteUpdateWithoutMediaInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    post?: PostUpdateOneRequiredWithoutNotesNestedInput
    comment?: CommentUpdateOneWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutMediaInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    postId?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type NoteUncheckedUpdateManyWithoutMediaInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    postId?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type SentimentSegmentCreateInput = {
    text: string
    sentiment: number
    startIndex: number
    endIndex: number
    aspects?: AspectSentimentCreateInput | AspectSentimentCreateInput[]
  }

  export type WikiDataCreateInput = {
    entityId: string
    url: string
    confidence: number
    description?: string | null
  }

  export type TopicAnalysisCreatesubtopicsInput = {
    set: string[]
  }

  export type TopicAnalysisCreatehierarchyInput = {
    set: string[]
  }

  export type TopicContextCreateInput = {
    domain: string
    category: string
    parentTopics?: TopicContextCreateparentTopicsInput | string[]
    relatedTopics?: TopicContextCreaterelatedTopicsInput | string[]
  }

  export type KeywordCreaterelatedInput = {
    set: string[]
  }

  export type KeywordMetricsCreateInput = {
    tfIdf: number
    textRank: number
    prominence: number
    location?: KeywordLocationCreateInput | KeywordLocationCreateInput[]
  }

  export type ComplexityMetricsCreateInput = {
    sentenceComplexity: number
    wordComplexity: number
    technicalLevel: string
    vocabularyDiversity: number
  }

  export type SourceValidationCreateInput = {
    url: string
    credibility: number
    type: string
    citations?: CitationCreateInput | CitationCreateInput[]
  }

  export type StructureAnalysisCreateInput = {
    paragraphFlow: number
    transitionQuality: number
    logicalProgression: number
    sectioning: number
  }

  export type FormattingAnalysisCreateInput = {
    consistency: number
    readability: number
    visualHierarchy: number
    spacing: number
  }

  export type ToxicityCategoriesCreateInput = {
    hate: number
    harassment: number
    profanity: number
    violence: number
    sexual: number
    spam: number
    misleading: number
    bias: number
  }

  export type ThreatDetectionCreateInput = {
    type: string
    severity: number
    confidence: number
    context: string
  }

  export type ModerationDecisionCreateInput = {
    action: string
    confidence: number
    reason: string
    escalation: boolean
  }

  export type ToxicitySeverityCreateInput = {
    level: string
    score: number
    recommendation: string
  }

  export type SimilarityMatchCreateInput = {
    text: string
    source: string
    confidence: number
    context: string
  }

  export type PlagiarismMetricsCreateInput = {
    score: number
    matches: number
    sources?: PlagiarismMetricsCreatesourcesInput | string[]
    severity: string
  }

  export type LanguageAlternativeCreateInput = {
    language: string
    confidence: number
    probability: number
  }

  export type LanguageAnalysisCreatedialectsInput = {
    set: string[]
  }

  export type LanguageAnalysisCreatescriptsInput = {
    set: string[]
  }

  export type GrammarErrorCreateInput = {
    type: string
    suggestion: string
    context: string
    severity: number
  }

  export type StyleSuggestionCreateInput = {
    type: string
    suggestion: string
    reason: string
    importance: number
  }

  export type VocabularyMetricsCreateInput = {
    diversity: number
    sophistication: number
    jargon: number
    accessibility: number
  }

  export type IntentAnalysisCreatesecondaryInput = {
    set: string[]
  }

  export type EmotionAnalysisCreatesecondaryInput = {
    set: string[]
  }

  export type EmotionSpectrumCreateInput = {
    joy: number
    sadness: number
    anger: number
    fear: number
    surprise: number
    disgust: number
  }

  export type BiasTypeCreateInput = {
    category: string
    score: number
    evidence?: BiasTypeCreateevidenceInput | string[]
  }

  export type DetectedObjectCreateInput = {
    label: string
    confidence: number
    boundingBox: BoundingBoxCreateInput
    attributes: InputJsonValue
  }

  export type FaceAnalysisCreateInput = {
    boundingBox: BoundingBoxCreateInput
    emotions: EmotionAnalysisCreateInput
    attributes: FaceAttributesCreateInput
    landmarks?: FaceLandmarkCreateInput | FaceLandmarkCreateInput[]
  }

  export type LabelCreateInput = {
    name: string
    confidence: number
    parents?: LabelCreateparentsInput | string[]
  }

  export type ColorAnalysisCreateInput = {
    dominant?: ColorCreateInput | ColorCreateInput[]
    palette?: ColorCreateInput | ColorCreateInput[]
    brightness: number
    contrast: number
  }

  export type NSFWAnalysisCreateInput = {
    score: number
    categories: NSFWCategoriesCreateInput
    confidence: number
  }

  export type ImageQualityCreateInput = {
    resolution: ResolutionCreateInput
    sharpness: number
    brightness: number
    noise: number
  }

  export type ImageCompositionCreateInput = {
    balance: number
    symmetry: number
    focus: number
    aesthetic: number
  }

  export type SceneCreateInput = {
    startTime: number
    endTime: number
    keyFrames?: KeyFrameCreateInput | KeyFrameCreateInput[]
    description: string
  }

  export type KeyFrameCreateInput = {
    timestamp: number
    image: ImageAnalysisCreateInput
    importance: number
  }

  export type ActionCreateInput = {
    type: string
    confidence: number
    startTime: number
    endTime: number
  }

  export type CaptionCreateInput = {
    text: string
    timestamp: number
    confidence: number
  }

  export type MotionAnalysisCreateInput = {
    activity: number
    stability: number
    tracking?: TrackingDataCreateInput | TrackingDataCreateInput[]
  }

  export type SpeakerCreateInput = {
    id: string
    segments?: TimeSegmentCreateInput | TimeSegmentCreateInput[]
    confidence: number
    characteristics: SpeakerCharacteristicsCreateInput
  }

  export type NoiseAnalysisCreateInput = {
    level: number
    type?: NoiseAnalysisCreatetypeInput | string[]
    impact: number
  }

  export type MusicAnalysisCreateInput = {
    present: boolean
    genre?: MusicAnalysisCreategenreInput | string[]
    tempo: number
    mood?: MusicAnalysisCreatemoodInput | string[]
  }

  export type TrendCreateInput = {
    name: string
    strength: number
    direction: string
    timeframe: string
  }

  export type MarketAnalysisCreatecompetitionInput = {
    set: string[]
  }

  export type MarketAnalysisCreateopportunitiesInput = {
    set: string[]
  }

  export type CompetitiveAnalysisCreateadvantagesInput = {
    set: string[]
  }

  export type CompetitiveAnalysisCreatethreatsInput = {
    set: string[]
  }

  export type CompetitiveAnalysisCreaterecommendationsInput = {
    set: string[]
  }

  export type ModelPerformanceCreateInput = {
    latency: number
    accuracy: number
    confidence: number
    resourceUsage: ResourceMetricsCreateInput
  }

  export type FileToPostCreateManyPostInput = {
    id?: string
    fileId: string
    createdAt?: Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    pollPostId?: string | null
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    mediaId?: string | null
  }

  export type NoteCreateManyPostInput = {
    id?: string
    content: string
    createdAt: string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    mediaId?: string | null
    commentId?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type ContentInsightsUpdateInput = {
    sentenceCount?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    languageConfidence?: FloatFieldUpdateOperationsInput | number
    entities?: XOR<EntitiesListUpdateEnvelopeInput, EntitiesCreateInput> | EntitiesCreateInput[]
    sentiment?: XOR<SentimentUpdateEnvelopeInput, SentimentCreateInput>
    topics?: ContentInsightsUpdatetopicsInput | string[]
    keywords?: ContentInsightsUpdatekeywordsInput | string[]
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    readability?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AIAnalysisUpdateInput = {
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keyPoints?: AIAnalysisUpdatekeyPointsInput | string[]
    sentiment?: XOR<SentimentAnalysisUpdateEnvelopeInput, SentimentAnalysisCreateInput>
    entities?: XOR<NamedEntityListUpdateEnvelopeInput, NamedEntityCreateInput> | NamedEntityCreateInput[]
    topics?: XOR<TopicAnalysisListUpdateEnvelopeInput, TopicAnalysisCreateInput> | TopicAnalysisCreateInput[]
    keywords?: XOR<KeywordListUpdateEnvelopeInput, KeywordCreateInput> | KeywordCreateInput[]
    readabilityScore?: XOR<ReadabilityMetricsUpdateEnvelopeInput, ReadabilityMetricsCreateInput>
    qualityMetrics?: XOR<ContentQualityUpdateEnvelopeInput, ContentQualityCreateInput>
    toxicity?: XOR<ToxicityAnalysisUpdateEnvelopeInput, ToxicityAnalysisCreateInput>
    originality?: XOR<OriginalityScoreUpdateEnvelopeInput, OriginalityScoreCreateInput>
    language?: XOR<LanguageAnalysisUpdateEnvelopeInput, LanguageAnalysisCreateInput>
    translation?: XOR<TranslationInfoUpdateEnvelopeInput, TranslationInfoCreateInput>
    grammarCheck?: XOR<GrammarAnalysisUpdateEnvelopeInput, GrammarAnalysisCreateInput>
    styleAnalysis?: XOR<StyleMetricsUpdateEnvelopeInput, StyleMetricsCreateInput>
    intentions?: XOR<IntentAnalysisListUpdateEnvelopeInput, IntentAnalysisCreateInput> | IntentAnalysisCreateInput[]
    emotions?: XOR<EmotionAnalysisUpdateEnvelopeInput, EmotionAnalysisCreateInput>
    bias?: XOR<BiasAnalysisUpdateEnvelopeInput, BiasAnalysisCreateInput>
    subjectivity?: FloatFieldUpdateOperationsInput | number
    imageAnalysis?: XOR<ImageAnalysisListUpdateEnvelopeInput, ImageAnalysisCreateInput> | ImageAnalysisCreateInput[]
    videoAnalysis?: XOR<VideoAnalysisListUpdateEnvelopeInput, VideoAnalysisCreateInput> | VideoAnalysisCreateInput[]
    audioAnalysis?: XOR<AudioAnalysisListUpdateEnvelopeInput, AudioAnalysisCreateInput> | AudioAnalysisCreateInput[]
    marketInsights?: XOR<MarketAnalysisUpdateEnvelopeInput, MarketAnalysisCreateInput>
    competitiveInfo?: XOR<CompetitiveAnalysisUpdateEnvelopeInput, CompetitiveAnalysisCreateInput>
    actionItems?: XOR<ActionItemListUpdateEnvelopeInput, ActionItemCreateInput> | ActionItemCreateInput[]
    processingTime?: IntFieldUpdateOperationsInput | number
    confidenceScore?: FloatFieldUpdateOperationsInput | number
    modelVersions?: XOR<ModelMetadataUpdateEnvelopeInput, ModelMetadataCreateInput>
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    processingCost?: FloatFieldUpdateOperationsInput | number
  }

  export type SearchMetadataUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: SearchMetadataUpdatekeywordsInput | string[]
    contentType?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    transcription?: NullableStringFieldUpdateOperationsInput | string | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    lastIndexed?: DateTimeFieldUpdateOperationsInput | Date | string
    searchScore?: FloatFieldUpdateOperationsInput | number
    aiTags?: SearchMetadataUpdateaiTagsInput | string[]
    classifications?: SearchMetadataUpdateclassificationsInput | string[]
    visibility?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    readingLevel?: NullableStringFieldUpdateOperationsInput | string | null
    locationData?: InputJsonValue | InputJsonValue | null
  }

  export type FileToPostUpdateWithoutPostInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileUpdateOneRequiredWithoutPostsNestedInput
  }

  export type FileToPostUncheckedUpdateWithoutPostInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileToPostUncheckedUpdateManyWithoutPostInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaUpdateOneWithoutCommentNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    notes?: NoteUpdateManyWithoutCommentNestedInput
    PollPost?: PollPostUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    pollPostId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoteUpdateWithoutPostInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaUpdateOneWithoutNoteNestedInput
    comment?: CommentUpdateOneWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutPostInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type NoteUncheckedUpdateManyWithoutPostInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type CommentCreateManyPollPostInput = {
    id?: string
    authorId: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentCreatementionsInput | string[]
    hashtags?: CommentCreatehashtagsInput | string[]
    postId: string
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    mediaId?: string | null
  }

  export type CommentUpdateWithoutPollPostInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaUpdateOneWithoutCommentNestedInput
    replies?: CommentReplyUpdateManyWithoutCommentNestedInput
    notes?: NoteUpdateManyWithoutCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutPollPostInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    postId?: StringFieldUpdateOperationsInput | string
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentReplyUncheckedUpdateManyWithoutCommentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPollPostInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentUpdatementionsInput | string[]
    hashtags?: CommentUpdatehashtagsInput | string[]
    postId?: StringFieldUpdateOperationsInput | string
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpaceMemberCreateManySpaceInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    status?: string
    permissions?: SpaceMemberCreatepermissionsInput | string[]
  }

  export type ChannelCreateManySpaceInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: string
    pinnedPosts?: ChannelCreatepinnedPostsInput | string[]
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
  }

  export type PostCreateManySpaceInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: string | null
    channelId?: string | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
  }

  export type FileCreateManySpaceInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: XOR<FileMetadataCreateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    channelId?: string | null
  }

  export type SpaceCreateManyParentSpaceInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SpaceType
    createdAt?: Date | string
    updatedAt?: Date | string
    spaceType: string
    status: string
    visibility: string
    isPrivate?: boolean
    metadata?: InputJsonValue | null
    settings?: InputJsonValue | null
    accessLevel?: $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceCreatetagsInput | string[]
  }

  export type SpaceMemberUpdateWithoutSpaceInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    permissions?: SpaceMemberUpdatepermissionsInput | string[]
  }

  export type SpaceMemberUncheckedUpdateWithoutSpaceInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    permissions?: SpaceMemberUpdatepermissionsInput | string[]
  }

  export type SpaceMemberUncheckedUpdateManyWithoutSpaceInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    permissions?: SpaceMemberUpdatepermissionsInput | string[]
  }

  export type ChannelUpdateWithoutSpaceInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    posts?: PostUpdateManyWithoutChannelNestedInput
    files?: FileUpdateManyWithoutChannelNestedInput
    members?: ChannelMemberUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateWithoutSpaceInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    posts?: PostUncheckedUpdateManyWithoutChannelNestedInput
    files?: FileUncheckedUpdateManyWithoutChannelNestedInput
    members?: ChannelMemberUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateManyWithoutSpaceInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pinnedPosts?: ChannelUpdatepinnedPostsInput | string[]
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
  }

  export type PostUpdateWithoutSpaceInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostNestedInput
    files?: FileToPostUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutSpaceInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
    files?: FileToPostUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutSpaceInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type FileUpdateWithoutSpaceInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: XOR<FileMetadataUpdateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    posts?: FileToPostUpdateManyWithoutFileNestedInput
    Channel?: ChannelUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutSpaceInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: XOR<FileMetadataUpdateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: FileToPostUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateManyWithoutSpaceInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: XOR<FileMetadataUpdateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpaceUpdateWithoutParentSpaceInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUpdateManyWithoutSpaceNestedInput
    posts?: PostUpdateManyWithoutSpaceNestedInput
    files?: FileUpdateManyWithoutSpaceNestedInput
    childSpaces?: SpaceUpdateManyWithoutParentSpaceNestedInput
  }

  export type SpaceUncheckedUpdateWithoutParentSpaceInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
    members?: SpaceMemberUncheckedUpdateManyWithoutSpaceNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutSpaceNestedInput
    posts?: PostUncheckedUpdateManyWithoutSpaceNestedInput
    files?: FileUncheckedUpdateManyWithoutSpaceNestedInput
    childSpaces?: SpaceUncheckedUpdateManyWithoutParentSpaceNestedInput
  }

  export type SpaceUncheckedUpdateManyWithoutParentSpaceInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSpaceTypeFieldUpdateOperationsInput | $Enums.SpaceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spaceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    metadata?: InputJsonValue | InputJsonValue | null
    settings?: InputJsonValue | InputJsonValue | null
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    tags?: SpaceUpdatetagsInput | string[]
  }

  export type PostCreateManyChannelInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: string | null
    spaceId?: string | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
  }

  export type FileCreateManyChannelInput = {
    id?: string
    name: string
    type: $Enums.MediaType
    url: string
    metadata: XOR<FileMetadataCreateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy: string
    uploadedAt?: Date | string
    size: number
    status?: string
    preview?: string | null
    thumbnail?: string | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    spaceId?: string | null
  }

  export type ChannelMemberCreateManyChannelInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    lastRead?: Date | string | null
  }

  export type PostUpdateWithoutChannelInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostNestedInput
    files?: FileToPostUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    thread?: ThreadUpdateOneWithoutPostsNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutChannelInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
    files?: FileToPostUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutChannelInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type FileUpdateWithoutChannelInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: XOR<FileMetadataUpdateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    posts?: FileToPostUpdateManyWithoutFileNestedInput
    Space?: SpaceUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutChannelInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: XOR<FileMetadataUpdateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: FileToPostUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateManyWithoutChannelInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    metadata?: XOR<FileMetadataUpdateEnvelopeInput, FileMetadataCreateInput>
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    size?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    preview?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChannelMemberUpdateWithoutChannelInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelMemberUncheckedUpdateWithoutChannelInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelMemberUncheckedUpdateManyWithoutChannelInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRead?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostCreateManyThreadInput = {
    id?: string
    authorId: string
    parentSpaceId?: string | null
    title?: string | null
    content: string
    description?: string | null
    status: string
    workflowStatus?: string | null
    assignedTo?: string | null
    contentFormat?: string
    createdAt: string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    postType: $Enums.PostType
    category?: $Enums.Category | null
    threadParticipantType?: $Enums.ThreadParticipantType | null
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    tags?: PostCreatetagsInput | string[]
    mentions?: PostCreatementionsInput | string[]
    hashtags?: PostCreatehashtagsInput | string[]
    topicName?: string | null
    mediaId?: string | null
    backgroundImageUrl?: string | null
    affinityScore: number
    qualityScore: number
    viewCount?: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    insights?: XOR<ContentInsightsNullableCreateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: string | null
    aiGeneratedQuestionResponse?: string | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    spaceId?: string | null
    channelId?: string | null
    extra?: InputJsonValue | null
    visibility?: string
    isPinned?: boolean
    isArchived?: boolean
    workflow?: InputJsonValue | null
    version?: number
  }

  export type PollPostCreateManyThreadInput = {
    id?: string
    createdAt: string
    action: $Enums.PostType
    content: string
    title?: string | null
    pollOptions?: PollPostCreatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | null
    pollEndDate: Date | string
    mentions?: PollPostCreatementionsInput | string[]
    hashtags?: PollPostCreatehashtagsInput | string[]
    tags?: PollPostCreatetagsInput | string[]
    topicName?: string | null
    backendPlatformUserId: string
    profileId: number
    mediaId?: string | null
    extra?: InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type PostUpdateWithoutThreadInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneWithoutPostNestedInput
    files?: FileToPostUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    notes?: NoteUpdateManyWithoutPostNestedInput
    space?: SpaceUpdateOneWithoutPostsNestedInput
    channel?: ChannelUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutThreadInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
    files?: FileToPostUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    notes?: NoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutThreadInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    parentSpaceId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    workflowStatus?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    contentFormat?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postType?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    category?: NullableEnumCategoryFieldUpdateOperationsInput | $Enums.Category | null
    threadParticipantType?: NullableEnumThreadParticipantTypeFieldUpdateOperationsInput | $Enums.ThreadParticipantType | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    tags?: PostUpdatetagsInput | string[]
    mentions?: PostUpdatementionsInput | string[]
    hashtags?: PostUpdatehashtagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    insights?: XOR<ContentInsightsNullableUpdateEnvelopeInput, ContentInsightsCreateInput> | null
    readingTime?: NullableStringFieldUpdateOperationsInput | string | null
    aiGeneratedQuestionResponse?: NullableStringFieldUpdateOperationsInput | string | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    spaceId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    visibility?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    workflow?: InputJsonValue | InputJsonValue | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type PollPostUpdateWithoutThreadInput = {
    createdAt?: StringFieldUpdateOperationsInput | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | InputJsonValue | null
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    extra?: InputJsonValue | InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaUpdateOneWithoutPollPostNestedInput
    comments?: CommentUpdateManyWithoutPollPostNestedInput
  }

  export type PollPostUncheckedUpdateWithoutThreadInput = {
    createdAt?: StringFieldUpdateOperationsInput | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | InputJsonValue | null
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    comments?: CommentUncheckedUpdateManyWithoutPollPostNestedInput
  }

  export type PollPostUncheckedUpdateManyWithoutThreadInput = {
    createdAt?: StringFieldUpdateOperationsInput | string
    action?: EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
    content?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    pollOptions?: PollPostUpdatepollOptionsInput | string[]
    pollDistribution?: InputJsonValue | InputJsonValue | null
    userIdToPollResponsesMap?: InputJsonValue | InputJsonValue | null
    pollEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    mentions?: PollPostUpdatementionsInput | string[]
    hashtags?: PollPostUpdatehashtagsInput | string[]
    tags?: PollPostUpdatetagsInput | string[]
    topicName?: NullableStringFieldUpdateOperationsInput | string | null
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type CommentReplyCreateManyCommentInput = {
    id?: string
    content: string
    createdAt: string
    backendPlatformUserId: string
    profileId: number
    authorUsername: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    affinityScore: number
    qualityScore: number
    userIdToAffinityScoreMap?: InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | null
    mentions?: CommentReplyCreatementionsInput | string[]
    hashtags?: CommentReplyCreatehashtagsInput | string[]
    mediaid?: string | null
    extra?: InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type NoteCreateManyCommentInput = {
    id?: string
    content: string
    createdAt: string
    authorId: string
    backendPlatformUserId: string
    profileId: number
    authorUserName: string
    authorProfileImage?: string | null
    authorAccountType: $Enums.AccountType
    mentions?: NoteCreatementionsInput | string[]
    hashtags?: NoteCreatehashtagsInput | string[]
    mediaId?: string | null
    postId: string
    searchMetadata?: XOR<SearchMetadataNullableCreateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableCreateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type CommentReplyUpdateWithoutCommentInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaUpdateOneWithoutCommentReplyNestedInput
  }

  export type CommentReplyUncheckedUpdateWithoutCommentInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    mediaid?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type CommentReplyUncheckedUpdateManyWithoutCommentInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUsername?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    affinityScore?: IntFieldUpdateOperationsInput | number
    qualityScore?: IntFieldUpdateOperationsInput | number
    userIdToAffinityScoreMap?: InputJsonValue | InputJsonValue | null
    userIdToReportsMap?: InputJsonValue | InputJsonValue | null
    userIdToReactionMap?: InputJsonValue | InputJsonValue | null
    mentions?: CommentReplyUpdatementionsInput | string[]
    hashtags?: CommentReplyUpdatehashtagsInput | string[]
    mediaid?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: InputJsonValue | InputJsonValue | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type NoteUpdateWithoutCommentInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
    media?: MediaUpdateOneWithoutNoteNestedInput
    post?: PostUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutCommentInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type NoteUncheckedUpdateManyWithoutCommentInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    backendPlatformUserId?: StringFieldUpdateOperationsInput | string
    profileId?: IntFieldUpdateOperationsInput | number
    authorUserName?: StringFieldUpdateOperationsInput | string
    authorProfileImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorAccountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    mentions?: NoteUpdatementionsInput | string[]
    hashtags?: NoteUpdatehashtagsInput | string[]
    mediaId?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: StringFieldUpdateOperationsInput | string
    searchMetadata?: XOR<SearchMetadataNullableUpdateEnvelopeInput, SearchMetadataCreateInput> | null
    aiAnalysis?: XOR<AIAnalysisNullableUpdateEnvelopeInput, AIAnalysisCreateInput> | null
  }

  export type FileToPostCreateManyFileInput = {
    id?: string
    postId: string
    createdAt?: Date | string
  }

  export type DimensionsNullableUpdateEnvelopeInput = {
    set?: DimensionsCreateInput | null
    upsert?: DimensionsUpsertInput
    unset?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type FileToPostUpdateWithoutFileInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutFilesNestedInput
  }

  export type FileToPostUncheckedUpdateWithoutFileInput = {
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileToPostUncheckedUpdateManyWithoutFileInput = {
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntitiesWhereInput = {
    AND?: EntitiesWhereInput | EntitiesWhereInput[]
    OR?: EntitiesWhereInput[]
    NOT?: EntitiesWhereInput | EntitiesWhereInput[]
    text?: StringFilter<"Entities"> | string
    label?: StringFilter<"Entities"> | string
    confidence?: FloatNullableFilter<"Entities"> | number | null
    startPos?: IntNullableFilter<"Entities"> | number | null
    endPos?: IntNullableFilter<"Entities"> | number | null
    metadata?: JsonNullableFilter<"Entities">
  }

  export type SentimentWhereInput = {
    AND?: SentimentWhereInput | SentimentWhereInput[]
    OR?: SentimentWhereInput[]
    NOT?: SentimentWhereInput | SentimentWhereInput[]
    negative?: FloatFilter<"Sentiment"> | number
    neutral?: FloatFilter<"Sentiment"> | number
    positive?: FloatFilter<"Sentiment"> | number
    compound?: FloatFilter<"Sentiment"> | number
    confidence?: FloatNullableFilter<"Sentiment"> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type SentimentAnalysisWhereInput = {
    AND?: SentimentAnalysisWhereInput | SentimentAnalysisWhereInput[]
    OR?: SentimentAnalysisWhereInput[]
    NOT?: SentimentAnalysisWhereInput | SentimentAnalysisWhereInput[]
    overall?: FloatFilter<"SentimentAnalysis"> | number
    compound?: FloatFilter<"SentimentAnalysis"> | number
    positive?: FloatFilter<"SentimentAnalysis"> | number
    negative?: FloatFilter<"SentimentAnalysis"> | number
    neutral?: FloatFilter<"SentimentAnalysis"> | number
    segments?: SentimentSegmentCompositeListFilter | SentimentSegmentObjectEqualityInput[]
    confidence?: FloatFilter<"SentimentAnalysis"> | number
  }

  export type NamedEntityWhereInput = {
    AND?: NamedEntityWhereInput | NamedEntityWhereInput[]
    OR?: NamedEntityWhereInput[]
    NOT?: NamedEntityWhereInput | NamedEntityWhereInput[]
    text?: StringFilter<"NamedEntity"> | string
    type?: StringFilter<"NamedEntity"> | string
    confidence?: FloatFilter<"NamedEntity"> | number
    startIndex?: IntFilter<"NamedEntity"> | number
    endIndex?: IntFilter<"NamedEntity"> | number
    metadata?: JsonNullableFilter<"NamedEntity">
    wikification?: XOR<WikiDataCompositeFilter, WikiDataObjectEqualityInput>
  }

  export type TopicAnalysisWhereInput = {
    AND?: TopicAnalysisWhereInput | TopicAnalysisWhereInput[]
    OR?: TopicAnalysisWhereInput[]
    NOT?: TopicAnalysisWhereInput | TopicAnalysisWhereInput[]
    topic?: StringFilter<"TopicAnalysis"> | string
    confidence?: FloatFilter<"TopicAnalysis"> | number
    subtopics?: StringNullableListFilter<"TopicAnalysis">
    relevance?: FloatFilter<"TopicAnalysis"> | number
    hierarchy?: StringNullableListFilter<"TopicAnalysis">
    context?: XOR<TopicContextCompositeFilter, TopicContextObjectEqualityInput>
  }

  export type KeywordWhereInput = {
    AND?: KeywordWhereInput | KeywordWhereInput[]
    OR?: KeywordWhereInput[]
    NOT?: KeywordWhereInput | KeywordWhereInput[]
    text?: StringFilter<"Keyword"> | string
    score?: FloatFilter<"Keyword"> | number
    frequency?: IntFilter<"Keyword"> | number
    type?: StringFilter<"Keyword"> | string
    related?: StringNullableListFilter<"Keyword">
    importance?: XOR<KeywordMetricsCompositeFilter, KeywordMetricsObjectEqualityInput>
  }

  export type ReadabilityMetricsWhereInput = {
    AND?: ReadabilityMetricsWhereInput | ReadabilityMetricsWhereInput[]
    OR?: ReadabilityMetricsWhereInput[]
    NOT?: ReadabilityMetricsWhereInput | ReadabilityMetricsWhereInput[]
    fleschKincaid?: FloatFilter<"ReadabilityMetrics"> | number
    gunningFog?: FloatFilter<"ReadabilityMetrics"> | number
    smog?: FloatFilter<"ReadabilityMetrics"> | number
    ari?: FloatFilter<"ReadabilityMetrics"> | number
    colemanLiau?: FloatFilter<"ReadabilityMetrics"> | number
    readingTime?: IntFilter<"ReadabilityMetrics"> | number
    grade?: StringFilter<"ReadabilityMetrics"> | string
    complexity?: XOR<ComplexityMetricsCompositeFilter, ComplexityMetricsObjectEqualityInput>
  }

  export type ContentQualityWhereInput = {
    AND?: ContentQualityWhereInput | ContentQualityWhereInput[]
    OR?: ContentQualityWhereInput[]
    NOT?: ContentQualityWhereInput | ContentQualityWhereInput[]
    clarity?: FloatFilter<"ContentQuality"> | number
    coherence?: FloatFilter<"ContentQuality"> | number
    engagement?: FloatFilter<"ContentQuality"> | number
    expertise?: FloatFilter<"ContentQuality"> | number
    factualAccuracy?: FloatFilter<"ContentQuality"> | number
    sources?: SourceValidationCompositeListFilter | SourceValidationObjectEqualityInput[]
    structure?: XOR<StructureAnalysisCompositeFilter, StructureAnalysisObjectEqualityInput>
    formatting?: XOR<FormattingAnalysisCompositeFilter, FormattingAnalysisObjectEqualityInput>
  }

  export type ToxicityAnalysisWhereInput = {
    AND?: ToxicityAnalysisWhereInput | ToxicityAnalysisWhereInput[]
    OR?: ToxicityAnalysisWhereInput[]
    NOT?: ToxicityAnalysisWhereInput | ToxicityAnalysisWhereInput[]
    overall?: FloatFilter<"ToxicityAnalysis"> | number
    categories?: XOR<ToxicityCategoriesCompositeFilter, ToxicityCategoriesObjectEqualityInput>
    threats?: ThreatDetectionCompositeListFilter | ThreatDetectionObjectEqualityInput[]
    moderation?: XOR<ModerationDecisionCompositeFilter, ModerationDecisionObjectEqualityInput>
    severity?: XOR<ToxicitySeverityCompositeFilter, ToxicitySeverityObjectEqualityInput>
  }

  export type OriginalityScoreWhereInput = {
    AND?: OriginalityScoreWhereInput | OriginalityScoreWhereInput[]
    OR?: OriginalityScoreWhereInput[]
    NOT?: OriginalityScoreWhereInput | OriginalityScoreWhereInput[]
    overall?: FloatFilter<"OriginalityScore"> | number
    uniqueness?: FloatFilter<"OriginalityScore"> | number
    similarities?: SimilarityMatchCompositeListFilter | SimilarityMatchObjectEqualityInput[]
    plagiarism?: XOR<PlagiarismMetricsCompositeFilter, PlagiarismMetricsObjectEqualityInput>
  }

  export type LanguageAnalysisWhereInput = {
    AND?: LanguageAnalysisWhereInput | LanguageAnalysisWhereInput[]
    OR?: LanguageAnalysisWhereInput[]
    NOT?: LanguageAnalysisWhereInput | LanguageAnalysisWhereInput[]
    detected?: StringFilter<"LanguageAnalysis"> | string
    confidence?: FloatFilter<"LanguageAnalysis"> | number
    alternatives?: LanguageAlternativeCompositeListFilter | LanguageAlternativeObjectEqualityInput[]
    dialects?: StringNullableListFilter<"LanguageAnalysis">
    scripts?: StringNullableListFilter<"LanguageAnalysis">
    languageFamily?: StringFilter<"LanguageAnalysis"> | string
  }

  export type TranslationInfoWhereInput = {
    AND?: TranslationInfoWhereInput | TranslationInfoWhereInput[]
    OR?: TranslationInfoWhereInput[]
    NOT?: TranslationInfoWhereInput | TranslationInfoWhereInput[]
    sourceLanguage?: StringFilter<"TranslationInfo"> | string
    targetLanguage?: StringFilter<"TranslationInfo"> | string
    quality?: FloatFilter<"TranslationInfo"> | number
    confidence?: FloatFilter<"TranslationInfo"> | number
    provider?: StringFilter<"TranslationInfo"> | string
  }

  export type GrammarAnalysisWhereInput = {
    AND?: GrammarAnalysisWhereInput | GrammarAnalysisWhereInput[]
    OR?: GrammarAnalysisWhereInput[]
    NOT?: GrammarAnalysisWhereInput | GrammarAnalysisWhereInput[]
    errors?: GrammarErrorCompositeListFilter | GrammarErrorObjectEqualityInput[]
    style?: StyleSuggestionCompositeListFilter | StyleSuggestionObjectEqualityInput[]
    overall?: FloatFilter<"GrammarAnalysis"> | number
    fluency?: FloatFilter<"GrammarAnalysis"> | number
  }

  export type StyleMetricsWhereInput = {
    AND?: StyleMetricsWhereInput | StyleMetricsWhereInput[]
    OR?: StyleMetricsWhereInput[]
    NOT?: StyleMetricsWhereInput | StyleMetricsWhereInput[]
    formality?: FloatFilter<"StyleMetrics"> | number
    tone?: StringFilter<"StyleMetrics"> | string
    vocabulary?: XOR<VocabularyMetricsCompositeFilter, VocabularyMetricsObjectEqualityInput>
    voice?: StringFilter<"StyleMetrics"> | string
  }

  export type IntentAnalysisWhereInput = {
    AND?: IntentAnalysisWhereInput | IntentAnalysisWhereInput[]
    OR?: IntentAnalysisWhereInput[]
    NOT?: IntentAnalysisWhereInput | IntentAnalysisWhereInput[]
    primary?: StringFilter<"IntentAnalysis"> | string
    confidence?: FloatFilter<"IntentAnalysis"> | number
    secondary?: StringNullableListFilter<"IntentAnalysis">
    context?: StringFilter<"IntentAnalysis"> | string
  }

  export type EmotionAnalysisWhereInput = {
    AND?: EmotionAnalysisWhereInput | EmotionAnalysisWhereInput[]
    OR?: EmotionAnalysisWhereInput[]
    NOT?: EmotionAnalysisWhereInput | EmotionAnalysisWhereInput[]
    primary?: StringFilter<"EmotionAnalysis"> | string
    secondary?: StringNullableListFilter<"EmotionAnalysis">
    intensity?: FloatFilter<"EmotionAnalysis"> | number
    confidence?: FloatFilter<"EmotionAnalysis"> | number
    spectrum?: XOR<EmotionSpectrumCompositeFilter, EmotionSpectrumObjectEqualityInput>
  }

  export type BiasAnalysisWhereInput = {
    AND?: BiasAnalysisWhereInput | BiasAnalysisWhereInput[]
    OR?: BiasAnalysisWhereInput[]
    NOT?: BiasAnalysisWhereInput | BiasAnalysisWhereInput[]
    overall?: FloatFilter<"BiasAnalysis"> | number
    types?: BiasTypeCompositeListFilter | BiasTypeObjectEqualityInput[]
    context?: StringFilter<"BiasAnalysis"> | string
    severity?: FloatFilter<"BiasAnalysis"> | number
  }

  export type ImageAnalysisWhereInput = {
    AND?: ImageAnalysisWhereInput | ImageAnalysisWhereInput[]
    OR?: ImageAnalysisWhereInput[]
    NOT?: ImageAnalysisWhereInput | ImageAnalysisWhereInput[]
    objects?: DetectedObjectCompositeListFilter | DetectedObjectObjectEqualityInput[]
    faces?: FaceAnalysisCompositeListFilter | FaceAnalysisObjectEqualityInput[]
    text?: StringNullableFilter<"ImageAnalysis"> | string | null
    labels?: LabelCompositeListFilter | LabelObjectEqualityInput[]
    colors?: XOR<ColorAnalysisCompositeFilter, ColorAnalysisObjectEqualityInput>
    nsfw?: XOR<NSFWAnalysisCompositeFilter, NSFWAnalysisObjectEqualityInput>
    quality?: XOR<ImageQualityCompositeFilter, ImageQualityObjectEqualityInput>
    composition?: XOR<ImageCompositionCompositeFilter, ImageCompositionObjectEqualityInput>
  }

  export type VideoAnalysisWhereInput = {
    AND?: VideoAnalysisWhereInput | VideoAnalysisWhereInput[]
    OR?: VideoAnalysisWhereInput[]
    NOT?: VideoAnalysisWhereInput | VideoAnalysisWhereInput[]
    scenes?: SceneCompositeListFilter | SceneObjectEqualityInput[]
    transcript?: StringNullableFilter<"VideoAnalysis"> | string | null
    keyFrames?: KeyFrameCompositeListFilter | KeyFrameObjectEqualityInput[]
    actions?: ActionCompositeListFilter | ActionObjectEqualityInput[]
    captions?: CaptionCompositeListFilter | CaptionObjectEqualityInput[]
    motion?: XOR<MotionAnalysisCompositeFilter, MotionAnalysisObjectEqualityInput>
  }

  export type AudioAnalysisWhereInput = {
    AND?: AudioAnalysisWhereInput | AudioAnalysisWhereInput[]
    OR?: AudioAnalysisWhereInput[]
    NOT?: AudioAnalysisWhereInput | AudioAnalysisWhereInput[]
    transcript?: StringNullableFilter<"AudioAnalysis"> | string | null
    speakers?: SpeakerCompositeListFilter | SpeakerObjectEqualityInput[]
    sentiment?: XOR<SentimentAnalysisCompositeFilter, SentimentAnalysisObjectEqualityInput>
    noise?: XOR<NoiseAnalysisCompositeFilter, NoiseAnalysisObjectEqualityInput>
    music?: XOR<MusicAnalysisCompositeFilter, MusicAnalysisObjectEqualityInput>
    clarity?: FloatFilter<"AudioAnalysis"> | number
  }

  export type MarketAnalysisWhereInput = {
    AND?: MarketAnalysisWhereInput | MarketAnalysisWhereInput[]
    OR?: MarketAnalysisWhereInput[]
    NOT?: MarketAnalysisWhereInput | MarketAnalysisWhereInput[]
    trends?: TrendCompositeListFilter | TrendObjectEqualityInput[]
    sentiment?: FloatFilter<"MarketAnalysis"> | number
    competition?: StringNullableListFilter<"MarketAnalysis">
    opportunities?: StringNullableListFilter<"MarketAnalysis">
  }

  export type CompetitiveAnalysisWhereInput = {
    AND?: CompetitiveAnalysisWhereInput | CompetitiveAnalysisWhereInput[]
    OR?: CompetitiveAnalysisWhereInput[]
    NOT?: CompetitiveAnalysisWhereInput | CompetitiveAnalysisWhereInput[]
    positioning?: FloatFilter<"CompetitiveAnalysis"> | number
    advantages?: StringNullableListFilter<"CompetitiveAnalysis">
    threats?: StringNullableListFilter<"CompetitiveAnalysis">
    recommendations?: StringNullableListFilter<"CompetitiveAnalysis">
  }

  export type ActionItemWhereInput = {
    AND?: ActionItemWhereInput | ActionItemWhereInput[]
    OR?: ActionItemWhereInput[]
    NOT?: ActionItemWhereInput | ActionItemWhereInput[]
    description?: StringFilter<"ActionItem"> | string
    priority?: FloatFilter<"ActionItem"> | number
    category?: StringFilter<"ActionItem"> | string
    deadline?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
  }

  export type ModelMetadataWhereInput = {
    AND?: ModelMetadataWhereInput | ModelMetadataWhereInput[]
    OR?: ModelMetadataWhereInput[]
    NOT?: ModelMetadataWhereInput | ModelMetadataWhereInput[]
    modelId?: StringFilter<"ModelMetadata"> | string
    version?: StringFilter<"ModelMetadata"> | string
    provider?: StringFilter<"ModelMetadata"> | string
    timestamp?: DateTimeFilter<"ModelMetadata"> | Date | string
    parameters?: JsonFilter<"ModelMetadata">
    performance?: XOR<ModelPerformanceCompositeFilter, ModelPerformanceObjectEqualityInput>
  }

  export type AspectSentimentObjectEqualityInput = {
    aspect: string
    sentiment: number
    confidence: number
  }

  export type KeywordLocationObjectEqualityInput = {
    startIndex: number
    endIndex: number
    context: string
  }

  export type CitationObjectEqualityInput = {
    text: string
    source: string
    page?: number | null
    confidence: number
  }

  export type BoundingBoxObjectEqualityInput = {
    x: number
    y: number
    width: number
    height: number
  }

  export type FaceAttributesObjectEqualityInput = {
    age?: number | null
    gender?: string | null
    expression?: string | null
    glasses: boolean
    features: InputJsonValue
  }

  export type FaceLandmarkObjectEqualityInput = {
    type: string
    position: PointObjectEqualityInput
    confidence: number
  }

  export type ColorObjectEqualityInput = {
    hex: string
    rgb: RGBObjectEqualityInput
    percentage: number
  }

  export type NSFWCategoriesObjectEqualityInput = {
    explicit: number
    suggestive: number
    violence: number
    disturbing: number
  }

  export type ResolutionObjectEqualityInput = {
    width: number
    height: number
    aspectRatio: number
  }

  export type TrackingDataObjectEqualityInput = {
    object: string
    path: InputJsonValue
    confidence: number
  }

  export type TimeSegmentObjectEqualityInput = {
    startTime: number
    endTime: number
    text: string
  }

  export type SpeakerCharacteristicsObjectEqualityInput = {
    gender?: string | null
    age?: string | null
    accent?: string | null
    emotion: EmotionAnalysisObjectEqualityInput
  }

  export type ResourceMetricsObjectEqualityInput = {
    cpuTime: number
    memoryUsage: number
    cost: number
  }

  export type ResourceMetricsOrderByInput = {
    cpuTime?: SortOrder
    memoryUsage?: SortOrder
    cost?: SortOrder
  }

  export type DimensionsWhereInput = {
    AND?: DimensionsWhereInput | DimensionsWhereInput[]
    OR?: DimensionsWhereInput[]
    NOT?: DimensionsWhereInput | DimensionsWhereInput[]
    width?: IntFilter<"Dimensions"> | number
    height?: IntFilter<"Dimensions"> | number
    depth?: IntNullableFilter<"Dimensions"> | number | null
    aspectRatio?: FloatNullableFilter<"Dimensions"> | number | null
    resolution?: StringNullableFilter<"Dimensions"> | string | null
  }

  export type AspectSentimentCreateInput = {
    aspect: string
    sentiment: number
    confidence: number
  }

  export type TopicContextCreateparentTopicsInput = {
    set: string[]
  }

  export type TopicContextCreaterelatedTopicsInput = {
    set: string[]
  }

  export type KeywordLocationCreateInput = {
    startIndex: number
    endIndex: number
    context: string
  }

  export type CitationCreateInput = {
    text: string
    source: string
    page?: number | null
    confidence: number
  }

  export type PlagiarismMetricsCreatesourcesInput = {
    set: string[]
  }

  export type BiasTypeCreateevidenceInput = {
    set: string[]
  }

  export type BoundingBoxCreateInput = {
    x: number
    y: number
    width: number
    height: number
  }

  export type FaceAttributesCreateInput = {
    age?: number | null
    gender?: string | null
    expression?: string | null
    glasses: boolean
    features: InputJsonValue
  }

  export type FaceLandmarkCreateInput = {
    type: string
    position: PointCreateInput
    confidence: number
  }

  export type LabelCreateparentsInput = {
    set: string[]
  }

  export type ColorCreateInput = {
    hex: string
    rgb: RGBCreateInput
    percentage: number
  }

  export type NSFWCategoriesCreateInput = {
    explicit: number
    suggestive: number
    violence: number
    disturbing: number
  }

  export type ResolutionCreateInput = {
    width: number
    height: number
    aspectRatio: number
  }

  export type TrackingDataCreateInput = {
    object: string
    path: InputJsonValue
    confidence: number
  }

  export type TimeSegmentCreateInput = {
    startTime: number
    endTime: number
    text: string
  }

  export type SpeakerCharacteristicsCreateInput = {
    gender?: string | null
    age?: string | null
    accent?: string | null
    emotion: EmotionAnalysisCreateInput
  }

  export type NoiseAnalysisCreatetypeInput = {
    set: string[]
  }

  export type MusicAnalysisCreategenreInput = {
    set: string[]
  }

  export type MusicAnalysisCreatemoodInput = {
    set: string[]
  }

  export type ResourceMetricsCreateInput = {
    cpuTime: number
    memoryUsage: number
    cost: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EntitiesListUpdateEnvelopeInput = {
    set?: EntitiesCreateInput | EntitiesCreateInput[]
    push?: EntitiesCreateInput | EntitiesCreateInput[]
    updateMany?: EntitiesUpdateManyInput
    deleteMany?: EntitiesDeleteManyInput
  }

  export type SentimentUpdateEnvelopeInput = {
    set?: SentimentCreateInput
    update?: SentimentUpdateInput
  }

  export type ContentInsightsUpdatetopicsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContentInsightsUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type AIAnalysisUpdatekeyPointsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SentimentAnalysisUpdateEnvelopeInput = {
    set?: SentimentAnalysisCreateInput
    update?: SentimentAnalysisUpdateInput
  }

  export type NamedEntityListUpdateEnvelopeInput = {
    set?: NamedEntityCreateInput | NamedEntityCreateInput[]
    push?: NamedEntityCreateInput | NamedEntityCreateInput[]
    updateMany?: NamedEntityUpdateManyInput
    deleteMany?: NamedEntityDeleteManyInput
  }

  export type TopicAnalysisListUpdateEnvelopeInput = {
    set?: TopicAnalysisCreateInput | TopicAnalysisCreateInput[]
    push?: TopicAnalysisCreateInput | TopicAnalysisCreateInput[]
    updateMany?: TopicAnalysisUpdateManyInput
    deleteMany?: TopicAnalysisDeleteManyInput
  }

  export type KeywordListUpdateEnvelopeInput = {
    set?: KeywordCreateInput | KeywordCreateInput[]
    push?: KeywordCreateInput | KeywordCreateInput[]
    updateMany?: KeywordUpdateManyInput
    deleteMany?: KeywordDeleteManyInput
  }

  export type ReadabilityMetricsUpdateEnvelopeInput = {
    set?: ReadabilityMetricsCreateInput
    update?: ReadabilityMetricsUpdateInput
  }

  export type ContentQualityUpdateEnvelopeInput = {
    set?: ContentQualityCreateInput
    update?: ContentQualityUpdateInput
  }

  export type ToxicityAnalysisUpdateEnvelopeInput = {
    set?: ToxicityAnalysisCreateInput
    update?: ToxicityAnalysisUpdateInput
  }

  export type OriginalityScoreUpdateEnvelopeInput = {
    set?: OriginalityScoreCreateInput
    update?: OriginalityScoreUpdateInput
  }

  export type LanguageAnalysisUpdateEnvelopeInput = {
    set?: LanguageAnalysisCreateInput
    update?: LanguageAnalysisUpdateInput
  }

  export type TranslationInfoUpdateEnvelopeInput = {
    set?: TranslationInfoCreateInput
    update?: TranslationInfoUpdateInput
  }

  export type GrammarAnalysisUpdateEnvelopeInput = {
    set?: GrammarAnalysisCreateInput
    update?: GrammarAnalysisUpdateInput
  }

  export type StyleMetricsUpdateEnvelopeInput = {
    set?: StyleMetricsCreateInput
    update?: StyleMetricsUpdateInput
  }

  export type IntentAnalysisListUpdateEnvelopeInput = {
    set?: IntentAnalysisCreateInput | IntentAnalysisCreateInput[]
    push?: IntentAnalysisCreateInput | IntentAnalysisCreateInput[]
    updateMany?: IntentAnalysisUpdateManyInput
    deleteMany?: IntentAnalysisDeleteManyInput
  }

  export type EmotionAnalysisUpdateEnvelopeInput = {
    set?: EmotionAnalysisCreateInput
    update?: EmotionAnalysisUpdateInput
  }

  export type BiasAnalysisUpdateEnvelopeInput = {
    set?: BiasAnalysisCreateInput
    update?: BiasAnalysisUpdateInput
  }

  export type ImageAnalysisListUpdateEnvelopeInput = {
    set?: ImageAnalysisCreateInput | ImageAnalysisCreateInput[]
    push?: ImageAnalysisCreateInput | ImageAnalysisCreateInput[]
    updateMany?: ImageAnalysisUpdateManyInput
    deleteMany?: ImageAnalysisDeleteManyInput
  }

  export type VideoAnalysisListUpdateEnvelopeInput = {
    set?: VideoAnalysisCreateInput | VideoAnalysisCreateInput[]
    push?: VideoAnalysisCreateInput | VideoAnalysisCreateInput[]
    updateMany?: VideoAnalysisUpdateManyInput
    deleteMany?: VideoAnalysisDeleteManyInput
  }

  export type AudioAnalysisListUpdateEnvelopeInput = {
    set?: AudioAnalysisCreateInput | AudioAnalysisCreateInput[]
    push?: AudioAnalysisCreateInput | AudioAnalysisCreateInput[]
    updateMany?: AudioAnalysisUpdateManyInput
    deleteMany?: AudioAnalysisDeleteManyInput
  }

  export type MarketAnalysisUpdateEnvelopeInput = {
    set?: MarketAnalysisCreateInput
    update?: MarketAnalysisUpdateInput
  }

  export type CompetitiveAnalysisUpdateEnvelopeInput = {
    set?: CompetitiveAnalysisCreateInput
    update?: CompetitiveAnalysisUpdateInput
  }

  export type ActionItemListUpdateEnvelopeInput = {
    set?: ActionItemCreateInput | ActionItemCreateInput[]
    push?: ActionItemCreateInput | ActionItemCreateInput[]
    updateMany?: ActionItemUpdateManyInput
    deleteMany?: ActionItemDeleteManyInput
  }

  export type ModelMetadataUpdateEnvelopeInput = {
    set?: ModelMetadataCreateInput
    update?: ModelMetadataUpdateInput
  }

  export type SearchMetadataUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SearchMetadataUpdateaiTagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SearchMetadataUpdateclassificationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DimensionsUpsertInput = {
    set: DimensionsCreateInput | null
    update: DimensionsUpdateInput
  }

  export type SentimentSegmentCompositeListFilter = {
    equals?: SentimentSegmentObjectEqualityInput[]
    every?: SentimentSegmentWhereInput
    some?: SentimentSegmentWhereInput
    none?: SentimentSegmentWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type WikiDataCompositeFilter = {
    equals?: WikiDataObjectEqualityInput
    is?: WikiDataWhereInput
    isNot?: WikiDataWhereInput
  }

  export type TopicContextCompositeFilter = {
    equals?: TopicContextObjectEqualityInput
    is?: TopicContextWhereInput
    isNot?: TopicContextWhereInput
  }

  export type KeywordMetricsCompositeFilter = {
    equals?: KeywordMetricsObjectEqualityInput
    is?: KeywordMetricsWhereInput
    isNot?: KeywordMetricsWhereInput
  }

  export type ComplexityMetricsCompositeFilter = {
    equals?: ComplexityMetricsObjectEqualityInput
    is?: ComplexityMetricsWhereInput
    isNot?: ComplexityMetricsWhereInput
  }

  export type SourceValidationCompositeListFilter = {
    equals?: SourceValidationObjectEqualityInput[]
    every?: SourceValidationWhereInput
    some?: SourceValidationWhereInput
    none?: SourceValidationWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type StructureAnalysisCompositeFilter = {
    equals?: StructureAnalysisObjectEqualityInput
    is?: StructureAnalysisWhereInput
    isNot?: StructureAnalysisWhereInput
  }

  export type FormattingAnalysisCompositeFilter = {
    equals?: FormattingAnalysisObjectEqualityInput
    is?: FormattingAnalysisWhereInput
    isNot?: FormattingAnalysisWhereInput
  }

  export type ToxicityCategoriesCompositeFilter = {
    equals?: ToxicityCategoriesObjectEqualityInput
    is?: ToxicityCategoriesWhereInput
    isNot?: ToxicityCategoriesWhereInput
  }

  export type ThreatDetectionCompositeListFilter = {
    equals?: ThreatDetectionObjectEqualityInput[]
    every?: ThreatDetectionWhereInput
    some?: ThreatDetectionWhereInput
    none?: ThreatDetectionWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ModerationDecisionCompositeFilter = {
    equals?: ModerationDecisionObjectEqualityInput
    is?: ModerationDecisionWhereInput
    isNot?: ModerationDecisionWhereInput
  }

  export type ToxicitySeverityCompositeFilter = {
    equals?: ToxicitySeverityObjectEqualityInput
    is?: ToxicitySeverityWhereInput
    isNot?: ToxicitySeverityWhereInput
  }

  export type SimilarityMatchCompositeListFilter = {
    equals?: SimilarityMatchObjectEqualityInput[]
    every?: SimilarityMatchWhereInput
    some?: SimilarityMatchWhereInput
    none?: SimilarityMatchWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type PlagiarismMetricsCompositeFilter = {
    equals?: PlagiarismMetricsObjectEqualityInput
    is?: PlagiarismMetricsWhereInput
    isNot?: PlagiarismMetricsWhereInput
  }

  export type LanguageAlternativeCompositeListFilter = {
    equals?: LanguageAlternativeObjectEqualityInput[]
    every?: LanguageAlternativeWhereInput
    some?: LanguageAlternativeWhereInput
    none?: LanguageAlternativeWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type GrammarErrorCompositeListFilter = {
    equals?: GrammarErrorObjectEqualityInput[]
    every?: GrammarErrorWhereInput
    some?: GrammarErrorWhereInput
    none?: GrammarErrorWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type StyleSuggestionCompositeListFilter = {
    equals?: StyleSuggestionObjectEqualityInput[]
    every?: StyleSuggestionWhereInput
    some?: StyleSuggestionWhereInput
    none?: StyleSuggestionWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type VocabularyMetricsCompositeFilter = {
    equals?: VocabularyMetricsObjectEqualityInput
    is?: VocabularyMetricsWhereInput
    isNot?: VocabularyMetricsWhereInput
  }

  export type EmotionSpectrumCompositeFilter = {
    equals?: EmotionSpectrumObjectEqualityInput
    is?: EmotionSpectrumWhereInput
    isNot?: EmotionSpectrumWhereInput
  }

  export type BiasTypeCompositeListFilter = {
    equals?: BiasTypeObjectEqualityInput[]
    every?: BiasTypeWhereInput
    some?: BiasTypeWhereInput
    none?: BiasTypeWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type DetectedObjectCompositeListFilter = {
    equals?: DetectedObjectObjectEqualityInput[]
    every?: DetectedObjectWhereInput
    some?: DetectedObjectWhereInput
    none?: DetectedObjectWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type FaceAnalysisCompositeListFilter = {
    equals?: FaceAnalysisObjectEqualityInput[]
    every?: FaceAnalysisWhereInput
    some?: FaceAnalysisWhereInput
    none?: FaceAnalysisWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type LabelCompositeListFilter = {
    equals?: LabelObjectEqualityInput[]
    every?: LabelWhereInput
    some?: LabelWhereInput
    none?: LabelWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ColorAnalysisCompositeFilter = {
    equals?: ColorAnalysisObjectEqualityInput
    is?: ColorAnalysisWhereInput
    isNot?: ColorAnalysisWhereInput
  }

  export type NSFWAnalysisCompositeFilter = {
    equals?: NSFWAnalysisObjectEqualityInput
    is?: NSFWAnalysisWhereInput
    isNot?: NSFWAnalysisWhereInput
  }

  export type ImageQualityCompositeFilter = {
    equals?: ImageQualityObjectEqualityInput
    is?: ImageQualityWhereInput
    isNot?: ImageQualityWhereInput
  }

  export type ImageCompositionCompositeFilter = {
    equals?: ImageCompositionObjectEqualityInput
    is?: ImageCompositionWhereInput
    isNot?: ImageCompositionWhereInput
  }

  export type SceneCompositeListFilter = {
    equals?: SceneObjectEqualityInput[]
    every?: SceneWhereInput
    some?: SceneWhereInput
    none?: SceneWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type KeyFrameCompositeListFilter = {
    equals?: KeyFrameObjectEqualityInput[]
    every?: KeyFrameWhereInput
    some?: KeyFrameWhereInput
    none?: KeyFrameWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ActionCompositeListFilter = {
    equals?: ActionObjectEqualityInput[]
    every?: ActionWhereInput
    some?: ActionWhereInput
    none?: ActionWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type CaptionCompositeListFilter = {
    equals?: CaptionObjectEqualityInput[]
    every?: CaptionWhereInput
    some?: CaptionWhereInput
    none?: CaptionWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type MotionAnalysisCompositeFilter = {
    equals?: MotionAnalysisObjectEqualityInput
    is?: MotionAnalysisWhereInput
    isNot?: MotionAnalysisWhereInput
  }

  export type SpeakerCompositeListFilter = {
    equals?: SpeakerObjectEqualityInput[]
    every?: SpeakerWhereInput
    some?: SpeakerWhereInput
    none?: SpeakerWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type NoiseAnalysisCompositeFilter = {
    equals?: NoiseAnalysisObjectEqualityInput
    is?: NoiseAnalysisWhereInput
    isNot?: NoiseAnalysisWhereInput
  }

  export type MusicAnalysisCompositeFilter = {
    equals?: MusicAnalysisObjectEqualityInput
    is?: MusicAnalysisWhereInput
    isNot?: MusicAnalysisWhereInput
  }

  export type TrendCompositeListFilter = {
    equals?: TrendObjectEqualityInput[]
    every?: TrendWhereInput
    some?: TrendWhereInput
    none?: TrendWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type ModelPerformanceCompositeFilter = {
    equals?: ModelPerformanceObjectEqualityInput
    is?: ModelPerformanceWhereInput
    isNot?: ModelPerformanceWhereInput
  }

  export type PointObjectEqualityInput = {
    x: number
    y: number
  }

  export type RGBObjectEqualityInput = {
    red: number
    green: number
    blue: number
  }

  export type PointCreateInput = {
    x: number
    y: number
  }

  export type RGBCreateInput = {
    red: number
    green: number
    blue: number
  }

  export type EntitiesUpdateManyInput = {
    where: EntitiesWhereInput
    data: EntitiesUpdateInput
  }

  export type EntitiesDeleteManyInput = {
    where: EntitiesWhereInput
  }

  export type SentimentUpdateInput = {
    negative?: FloatFieldUpdateOperationsInput | number
    neutral?: FloatFieldUpdateOperationsInput | number
    positive?: FloatFieldUpdateOperationsInput | number
    compound?: FloatFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SentimentAnalysisUpdateInput = {
    overall?: FloatFieldUpdateOperationsInput | number
    compound?: FloatFieldUpdateOperationsInput | number
    positive?: FloatFieldUpdateOperationsInput | number
    negative?: FloatFieldUpdateOperationsInput | number
    neutral?: FloatFieldUpdateOperationsInput | number
    segments?: XOR<SentimentSegmentListUpdateEnvelopeInput, SentimentSegmentCreateInput> | SentimentSegmentCreateInput[]
    confidence?: FloatFieldUpdateOperationsInput | number
  }

  export type NamedEntityUpdateManyInput = {
    where: NamedEntityWhereInput
    data: NamedEntityUpdateInput
  }

  export type NamedEntityDeleteManyInput = {
    where: NamedEntityWhereInput
  }

  export type TopicAnalysisUpdateManyInput = {
    where: TopicAnalysisWhereInput
    data: TopicAnalysisUpdateInput
  }

  export type TopicAnalysisDeleteManyInput = {
    where: TopicAnalysisWhereInput
  }

  export type KeywordUpdateManyInput = {
    where: KeywordWhereInput
    data: KeywordUpdateInput
  }

  export type KeywordDeleteManyInput = {
    where: KeywordWhereInput
  }

  export type ReadabilityMetricsUpdateInput = {
    fleschKincaid?: FloatFieldUpdateOperationsInput | number
    gunningFog?: FloatFieldUpdateOperationsInput | number
    smog?: FloatFieldUpdateOperationsInput | number
    ari?: FloatFieldUpdateOperationsInput | number
    colemanLiau?: FloatFieldUpdateOperationsInput | number
    readingTime?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    complexity?: XOR<ComplexityMetricsUpdateEnvelopeInput, ComplexityMetricsCreateInput>
  }

  export type ContentQualityUpdateInput = {
    clarity?: FloatFieldUpdateOperationsInput | number
    coherence?: FloatFieldUpdateOperationsInput | number
    engagement?: FloatFieldUpdateOperationsInput | number
    expertise?: FloatFieldUpdateOperationsInput | number
    factualAccuracy?: FloatFieldUpdateOperationsInput | number
    sources?: XOR<SourceValidationListUpdateEnvelopeInput, SourceValidationCreateInput> | SourceValidationCreateInput[]
    structure?: XOR<StructureAnalysisUpdateEnvelopeInput, StructureAnalysisCreateInput>
    formatting?: XOR<FormattingAnalysisUpdateEnvelopeInput, FormattingAnalysisCreateInput>
  }

  export type ToxicityAnalysisUpdateInput = {
    overall?: FloatFieldUpdateOperationsInput | number
    categories?: XOR<ToxicityCategoriesUpdateEnvelopeInput, ToxicityCategoriesCreateInput>
    threats?: XOR<ThreatDetectionListUpdateEnvelopeInput, ThreatDetectionCreateInput> | ThreatDetectionCreateInput[]
    moderation?: XOR<ModerationDecisionUpdateEnvelopeInput, ModerationDecisionCreateInput>
    severity?: XOR<ToxicitySeverityUpdateEnvelopeInput, ToxicitySeverityCreateInput>
  }

  export type OriginalityScoreUpdateInput = {
    overall?: FloatFieldUpdateOperationsInput | number
    uniqueness?: FloatFieldUpdateOperationsInput | number
    similarities?: XOR<SimilarityMatchListUpdateEnvelopeInput, SimilarityMatchCreateInput> | SimilarityMatchCreateInput[]
    plagiarism?: XOR<PlagiarismMetricsUpdateEnvelopeInput, PlagiarismMetricsCreateInput>
  }

  export type LanguageAnalysisUpdateInput = {
    detected?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    alternatives?: XOR<LanguageAlternativeListUpdateEnvelopeInput, LanguageAlternativeCreateInput> | LanguageAlternativeCreateInput[]
    dialects?: LanguageAnalysisUpdatedialectsInput | string[]
    scripts?: LanguageAnalysisUpdatescriptsInput | string[]
    languageFamily?: StringFieldUpdateOperationsInput | string
  }

  export type TranslationInfoUpdateInput = {
    sourceLanguage?: StringFieldUpdateOperationsInput | string
    targetLanguage?: StringFieldUpdateOperationsInput | string
    quality?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
  }

  export type GrammarAnalysisUpdateInput = {
    errors?: XOR<GrammarErrorListUpdateEnvelopeInput, GrammarErrorCreateInput> | GrammarErrorCreateInput[]
    style?: XOR<StyleSuggestionListUpdateEnvelopeInput, StyleSuggestionCreateInput> | StyleSuggestionCreateInput[]
    overall?: FloatFieldUpdateOperationsInput | number
    fluency?: FloatFieldUpdateOperationsInput | number
  }

  export type StyleMetricsUpdateInput = {
    formality?: FloatFieldUpdateOperationsInput | number
    tone?: StringFieldUpdateOperationsInput | string
    vocabulary?: XOR<VocabularyMetricsUpdateEnvelopeInput, VocabularyMetricsCreateInput>
    voice?: StringFieldUpdateOperationsInput | string
  }

  export type IntentAnalysisUpdateManyInput = {
    where: IntentAnalysisWhereInput
    data: IntentAnalysisUpdateInput
  }

  export type IntentAnalysisDeleteManyInput = {
    where: IntentAnalysisWhereInput
  }

  export type EmotionAnalysisUpdateInput = {
    primary?: StringFieldUpdateOperationsInput | string
    secondary?: EmotionAnalysisUpdatesecondaryInput | string[]
    intensity?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    spectrum?: XOR<EmotionSpectrumUpdateEnvelopeInput, EmotionSpectrumCreateInput>
  }

  export type BiasAnalysisUpdateInput = {
    overall?: FloatFieldUpdateOperationsInput | number
    types?: XOR<BiasTypeListUpdateEnvelopeInput, BiasTypeCreateInput> | BiasTypeCreateInput[]
    context?: StringFieldUpdateOperationsInput | string
    severity?: FloatFieldUpdateOperationsInput | number
  }

  export type ImageAnalysisUpdateManyInput = {
    where: ImageAnalysisWhereInput
    data: ImageAnalysisUpdateInput
  }

  export type ImageAnalysisDeleteManyInput = {
    where: ImageAnalysisWhereInput
  }

  export type VideoAnalysisUpdateManyInput = {
    where: VideoAnalysisWhereInput
    data: VideoAnalysisUpdateInput
  }

  export type VideoAnalysisDeleteManyInput = {
    where: VideoAnalysisWhereInput
  }

  export type AudioAnalysisUpdateManyInput = {
    where: AudioAnalysisWhereInput
    data: AudioAnalysisUpdateInput
  }

  export type AudioAnalysisDeleteManyInput = {
    where: AudioAnalysisWhereInput
  }

  export type MarketAnalysisUpdateInput = {
    trends?: XOR<TrendListUpdateEnvelopeInput, TrendCreateInput> | TrendCreateInput[]
    sentiment?: FloatFieldUpdateOperationsInput | number
    competition?: MarketAnalysisUpdatecompetitionInput | string[]
    opportunities?: MarketAnalysisUpdateopportunitiesInput | string[]
  }

  export type CompetitiveAnalysisUpdateInput = {
    positioning?: FloatFieldUpdateOperationsInput | number
    advantages?: CompetitiveAnalysisUpdateadvantagesInput | string[]
    threats?: CompetitiveAnalysisUpdatethreatsInput | string[]
    recommendations?: CompetitiveAnalysisUpdaterecommendationsInput | string[]
  }

  export type ActionItemUpdateManyInput = {
    where: ActionItemWhereInput
    data: ActionItemUpdateInput
  }

  export type ActionItemDeleteManyInput = {
    where: ActionItemWhereInput
  }

  export type ModelMetadataUpdateInput = {
    modelId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: InputJsonValue | InputJsonValue
    performance?: XOR<ModelPerformanceUpdateEnvelopeInput, ModelPerformanceCreateInput>
  }

  export type DimensionsUpdateInput = {
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    depth?: NullableIntFieldUpdateOperationsInput | number | null
    aspectRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SentimentSegmentWhereInput = {
    AND?: SentimentSegmentWhereInput | SentimentSegmentWhereInput[]
    OR?: SentimentSegmentWhereInput[]
    NOT?: SentimentSegmentWhereInput | SentimentSegmentWhereInput[]
    text?: StringFilter<"SentimentSegment"> | string
    sentiment?: FloatFilter<"SentimentSegment"> | number
    startIndex?: IntFilter<"SentimentSegment"> | number
    endIndex?: IntFilter<"SentimentSegment"> | number
    aspects?: AspectSentimentCompositeListFilter | AspectSentimentObjectEqualityInput[]
  }

  export type WikiDataWhereInput = {
    AND?: WikiDataWhereInput | WikiDataWhereInput[]
    OR?: WikiDataWhereInput[]
    NOT?: WikiDataWhereInput | WikiDataWhereInput[]
    entityId?: StringFilter<"WikiData"> | string
    url?: StringFilter<"WikiData"> | string
    confidence?: FloatFilter<"WikiData"> | number
    description?: StringNullableFilter<"WikiData"> | string | null
  }

  export type TopicContextWhereInput = {
    AND?: TopicContextWhereInput | TopicContextWhereInput[]
    OR?: TopicContextWhereInput[]
    NOT?: TopicContextWhereInput | TopicContextWhereInput[]
    domain?: StringFilter<"TopicContext"> | string
    category?: StringFilter<"TopicContext"> | string
    parentTopics?: StringNullableListFilter<"TopicContext">
    relatedTopics?: StringNullableListFilter<"TopicContext">
  }

  export type KeywordMetricsWhereInput = {
    AND?: KeywordMetricsWhereInput | KeywordMetricsWhereInput[]
    OR?: KeywordMetricsWhereInput[]
    NOT?: KeywordMetricsWhereInput | KeywordMetricsWhereInput[]
    tfIdf?: FloatFilter<"KeywordMetrics"> | number
    textRank?: FloatFilter<"KeywordMetrics"> | number
    prominence?: FloatFilter<"KeywordMetrics"> | number
    location?: KeywordLocationCompositeListFilter | KeywordLocationObjectEqualityInput[]
  }

  export type ComplexityMetricsWhereInput = {
    AND?: ComplexityMetricsWhereInput | ComplexityMetricsWhereInput[]
    OR?: ComplexityMetricsWhereInput[]
    NOT?: ComplexityMetricsWhereInput | ComplexityMetricsWhereInput[]
    sentenceComplexity?: FloatFilter<"ComplexityMetrics"> | number
    wordComplexity?: FloatFilter<"ComplexityMetrics"> | number
    technicalLevel?: StringFilter<"ComplexityMetrics"> | string
    vocabularyDiversity?: FloatFilter<"ComplexityMetrics"> | number
  }

  export type SourceValidationWhereInput = {
    AND?: SourceValidationWhereInput | SourceValidationWhereInput[]
    OR?: SourceValidationWhereInput[]
    NOT?: SourceValidationWhereInput | SourceValidationWhereInput[]
    url?: StringFilter<"SourceValidation"> | string
    credibility?: FloatFilter<"SourceValidation"> | number
    type?: StringFilter<"SourceValidation"> | string
    citations?: CitationCompositeListFilter | CitationObjectEqualityInput[]
  }

  export type StructureAnalysisWhereInput = {
    AND?: StructureAnalysisWhereInput | StructureAnalysisWhereInput[]
    OR?: StructureAnalysisWhereInput[]
    NOT?: StructureAnalysisWhereInput | StructureAnalysisWhereInput[]
    paragraphFlow?: FloatFilter<"StructureAnalysis"> | number
    transitionQuality?: FloatFilter<"StructureAnalysis"> | number
    logicalProgression?: FloatFilter<"StructureAnalysis"> | number
    sectioning?: FloatFilter<"StructureAnalysis"> | number
  }

  export type FormattingAnalysisWhereInput = {
    AND?: FormattingAnalysisWhereInput | FormattingAnalysisWhereInput[]
    OR?: FormattingAnalysisWhereInput[]
    NOT?: FormattingAnalysisWhereInput | FormattingAnalysisWhereInput[]
    consistency?: FloatFilter<"FormattingAnalysis"> | number
    readability?: FloatFilter<"FormattingAnalysis"> | number
    visualHierarchy?: FloatFilter<"FormattingAnalysis"> | number
    spacing?: FloatFilter<"FormattingAnalysis"> | number
  }

  export type ToxicityCategoriesWhereInput = {
    AND?: ToxicityCategoriesWhereInput | ToxicityCategoriesWhereInput[]
    OR?: ToxicityCategoriesWhereInput[]
    NOT?: ToxicityCategoriesWhereInput | ToxicityCategoriesWhereInput[]
    hate?: FloatFilter<"ToxicityCategories"> | number
    harassment?: FloatFilter<"ToxicityCategories"> | number
    profanity?: FloatFilter<"ToxicityCategories"> | number
    violence?: FloatFilter<"ToxicityCategories"> | number
    sexual?: FloatFilter<"ToxicityCategories"> | number
    spam?: FloatFilter<"ToxicityCategories"> | number
    misleading?: FloatFilter<"ToxicityCategories"> | number
    bias?: FloatFilter<"ToxicityCategories"> | number
  }

  export type ThreatDetectionWhereInput = {
    AND?: ThreatDetectionWhereInput | ThreatDetectionWhereInput[]
    OR?: ThreatDetectionWhereInput[]
    NOT?: ThreatDetectionWhereInput | ThreatDetectionWhereInput[]
    type?: StringFilter<"ThreatDetection"> | string
    severity?: FloatFilter<"ThreatDetection"> | number
    confidence?: FloatFilter<"ThreatDetection"> | number
    context?: StringFilter<"ThreatDetection"> | string
  }

  export type ModerationDecisionWhereInput = {
    AND?: ModerationDecisionWhereInput | ModerationDecisionWhereInput[]
    OR?: ModerationDecisionWhereInput[]
    NOT?: ModerationDecisionWhereInput | ModerationDecisionWhereInput[]
    action?: StringFilter<"ModerationDecision"> | string
    confidence?: FloatFilter<"ModerationDecision"> | number
    reason?: StringFilter<"ModerationDecision"> | string
    escalation?: BoolFilter<"ModerationDecision"> | boolean
  }

  export type ToxicitySeverityWhereInput = {
    AND?: ToxicitySeverityWhereInput | ToxicitySeverityWhereInput[]
    OR?: ToxicitySeverityWhereInput[]
    NOT?: ToxicitySeverityWhereInput | ToxicitySeverityWhereInput[]
    level?: StringFilter<"ToxicitySeverity"> | string
    score?: FloatFilter<"ToxicitySeverity"> | number
    recommendation?: StringFilter<"ToxicitySeverity"> | string
  }

  export type SimilarityMatchWhereInput = {
    AND?: SimilarityMatchWhereInput | SimilarityMatchWhereInput[]
    OR?: SimilarityMatchWhereInput[]
    NOT?: SimilarityMatchWhereInput | SimilarityMatchWhereInput[]
    text?: StringFilter<"SimilarityMatch"> | string
    source?: StringFilter<"SimilarityMatch"> | string
    confidence?: FloatFilter<"SimilarityMatch"> | number
    context?: StringFilter<"SimilarityMatch"> | string
  }

  export type PlagiarismMetricsWhereInput = {
    AND?: PlagiarismMetricsWhereInput | PlagiarismMetricsWhereInput[]
    OR?: PlagiarismMetricsWhereInput[]
    NOT?: PlagiarismMetricsWhereInput | PlagiarismMetricsWhereInput[]
    score?: FloatFilter<"PlagiarismMetrics"> | number
    matches?: IntFilter<"PlagiarismMetrics"> | number
    sources?: StringNullableListFilter<"PlagiarismMetrics">
    severity?: StringFilter<"PlagiarismMetrics"> | string
  }

  export type LanguageAlternativeWhereInput = {
    AND?: LanguageAlternativeWhereInput | LanguageAlternativeWhereInput[]
    OR?: LanguageAlternativeWhereInput[]
    NOT?: LanguageAlternativeWhereInput | LanguageAlternativeWhereInput[]
    language?: StringFilter<"LanguageAlternative"> | string
    confidence?: FloatFilter<"LanguageAlternative"> | number
    probability?: FloatFilter<"LanguageAlternative"> | number
  }

  export type GrammarErrorWhereInput = {
    AND?: GrammarErrorWhereInput | GrammarErrorWhereInput[]
    OR?: GrammarErrorWhereInput[]
    NOT?: GrammarErrorWhereInput | GrammarErrorWhereInput[]
    type?: StringFilter<"GrammarError"> | string
    suggestion?: StringFilter<"GrammarError"> | string
    context?: StringFilter<"GrammarError"> | string
    severity?: FloatFilter<"GrammarError"> | number
  }

  export type StyleSuggestionWhereInput = {
    AND?: StyleSuggestionWhereInput | StyleSuggestionWhereInput[]
    OR?: StyleSuggestionWhereInput[]
    NOT?: StyleSuggestionWhereInput | StyleSuggestionWhereInput[]
    type?: StringFilter<"StyleSuggestion"> | string
    suggestion?: StringFilter<"StyleSuggestion"> | string
    reason?: StringFilter<"StyleSuggestion"> | string
    importance?: FloatFilter<"StyleSuggestion"> | number
  }

  export type VocabularyMetricsWhereInput = {
    AND?: VocabularyMetricsWhereInput | VocabularyMetricsWhereInput[]
    OR?: VocabularyMetricsWhereInput[]
    NOT?: VocabularyMetricsWhereInput | VocabularyMetricsWhereInput[]
    diversity?: FloatFilter<"VocabularyMetrics"> | number
    sophistication?: FloatFilter<"VocabularyMetrics"> | number
    jargon?: FloatFilter<"VocabularyMetrics"> | number
    accessibility?: FloatFilter<"VocabularyMetrics"> | number
  }

  export type EmotionSpectrumWhereInput = {
    AND?: EmotionSpectrumWhereInput | EmotionSpectrumWhereInput[]
    OR?: EmotionSpectrumWhereInput[]
    NOT?: EmotionSpectrumWhereInput | EmotionSpectrumWhereInput[]
    joy?: FloatFilter<"EmotionSpectrum"> | number
    sadness?: FloatFilter<"EmotionSpectrum"> | number
    anger?: FloatFilter<"EmotionSpectrum"> | number
    fear?: FloatFilter<"EmotionSpectrum"> | number
    surprise?: FloatFilter<"EmotionSpectrum"> | number
    disgust?: FloatFilter<"EmotionSpectrum"> | number
  }

  export type BiasTypeWhereInput = {
    AND?: BiasTypeWhereInput | BiasTypeWhereInput[]
    OR?: BiasTypeWhereInput[]
    NOT?: BiasTypeWhereInput | BiasTypeWhereInput[]
    category?: StringFilter<"BiasType"> | string
    score?: FloatFilter<"BiasType"> | number
    evidence?: StringNullableListFilter<"BiasType">
  }

  export type DetectedObjectWhereInput = {
    AND?: DetectedObjectWhereInput | DetectedObjectWhereInput[]
    OR?: DetectedObjectWhereInput[]
    NOT?: DetectedObjectWhereInput | DetectedObjectWhereInput[]
    label?: StringFilter<"DetectedObject"> | string
    confidence?: FloatFilter<"DetectedObject"> | number
    boundingBox?: XOR<BoundingBoxCompositeFilter, BoundingBoxObjectEqualityInput>
    attributes?: JsonFilter<"DetectedObject">
  }

  export type FaceAnalysisWhereInput = {
    AND?: FaceAnalysisWhereInput | FaceAnalysisWhereInput[]
    OR?: FaceAnalysisWhereInput[]
    NOT?: FaceAnalysisWhereInput | FaceAnalysisWhereInput[]
    boundingBox?: XOR<BoundingBoxCompositeFilter, BoundingBoxObjectEqualityInput>
    emotions?: XOR<EmotionAnalysisCompositeFilter, EmotionAnalysisObjectEqualityInput>
    attributes?: XOR<FaceAttributesCompositeFilter, FaceAttributesObjectEqualityInput>
    landmarks?: FaceLandmarkCompositeListFilter | FaceLandmarkObjectEqualityInput[]
  }

  export type LabelWhereInput = {
    AND?: LabelWhereInput | LabelWhereInput[]
    OR?: LabelWhereInput[]
    NOT?: LabelWhereInput | LabelWhereInput[]
    name?: StringFilter<"Label"> | string
    confidence?: FloatFilter<"Label"> | number
    parents?: StringNullableListFilter<"Label">
  }

  export type ColorAnalysisWhereInput = {
    AND?: ColorAnalysisWhereInput | ColorAnalysisWhereInput[]
    OR?: ColorAnalysisWhereInput[]
    NOT?: ColorAnalysisWhereInput | ColorAnalysisWhereInput[]
    dominant?: ColorCompositeListFilter | ColorObjectEqualityInput[]
    palette?: ColorCompositeListFilter | ColorObjectEqualityInput[]
    brightness?: FloatFilter<"ColorAnalysis"> | number
    contrast?: FloatFilter<"ColorAnalysis"> | number
  }

  export type NSFWAnalysisWhereInput = {
    AND?: NSFWAnalysisWhereInput | NSFWAnalysisWhereInput[]
    OR?: NSFWAnalysisWhereInput[]
    NOT?: NSFWAnalysisWhereInput | NSFWAnalysisWhereInput[]
    score?: FloatFilter<"NSFWAnalysis"> | number
    categories?: XOR<NSFWCategoriesCompositeFilter, NSFWCategoriesObjectEqualityInput>
    confidence?: FloatFilter<"NSFWAnalysis"> | number
  }

  export type ImageQualityWhereInput = {
    AND?: ImageQualityWhereInput | ImageQualityWhereInput[]
    OR?: ImageQualityWhereInput[]
    NOT?: ImageQualityWhereInput | ImageQualityWhereInput[]
    resolution?: XOR<ResolutionCompositeFilter, ResolutionObjectEqualityInput>
    sharpness?: FloatFilter<"ImageQuality"> | number
    brightness?: FloatFilter<"ImageQuality"> | number
    noise?: FloatFilter<"ImageQuality"> | number
  }

  export type ImageCompositionWhereInput = {
    AND?: ImageCompositionWhereInput | ImageCompositionWhereInput[]
    OR?: ImageCompositionWhereInput[]
    NOT?: ImageCompositionWhereInput | ImageCompositionWhereInput[]
    balance?: FloatFilter<"ImageComposition"> | number
    symmetry?: FloatFilter<"ImageComposition"> | number
    focus?: FloatFilter<"ImageComposition"> | number
    aesthetic?: FloatFilter<"ImageComposition"> | number
  }

  export type SceneWhereInput = {
    AND?: SceneWhereInput | SceneWhereInput[]
    OR?: SceneWhereInput[]
    NOT?: SceneWhereInput | SceneWhereInput[]
    startTime?: FloatFilter<"Scene"> | number
    endTime?: FloatFilter<"Scene"> | number
    keyFrames?: KeyFrameCompositeListFilter | KeyFrameObjectEqualityInput[]
    description?: StringFilter<"Scene"> | string
  }

  export type KeyFrameWhereInput = {
    AND?: KeyFrameWhereInput | KeyFrameWhereInput[]
    OR?: KeyFrameWhereInput[]
    NOT?: KeyFrameWhereInput | KeyFrameWhereInput[]
    timestamp?: FloatFilter<"KeyFrame"> | number
    image?: XOR<ImageAnalysisCompositeFilter, ImageAnalysisObjectEqualityInput>
    importance?: FloatFilter<"KeyFrame"> | number
  }

  export type ActionWhereInput = {
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    type?: StringFilter<"Action"> | string
    confidence?: FloatFilter<"Action"> | number
    startTime?: FloatFilter<"Action"> | number
    endTime?: FloatFilter<"Action"> | number
  }

  export type CaptionWhereInput = {
    AND?: CaptionWhereInput | CaptionWhereInput[]
    OR?: CaptionWhereInput[]
    NOT?: CaptionWhereInput | CaptionWhereInput[]
    text?: StringFilter<"Caption"> | string
    timestamp?: FloatFilter<"Caption"> | number
    confidence?: FloatFilter<"Caption"> | number
  }

  export type MotionAnalysisWhereInput = {
    AND?: MotionAnalysisWhereInput | MotionAnalysisWhereInput[]
    OR?: MotionAnalysisWhereInput[]
    NOT?: MotionAnalysisWhereInput | MotionAnalysisWhereInput[]
    activity?: FloatFilter<"MotionAnalysis"> | number
    stability?: FloatFilter<"MotionAnalysis"> | number
    tracking?: TrackingDataCompositeListFilter | TrackingDataObjectEqualityInput[]
  }

  export type SpeakerWhereInput = {
    AND?: SpeakerWhereInput | SpeakerWhereInput[]
    OR?: SpeakerWhereInput[]
    NOT?: SpeakerWhereInput | SpeakerWhereInput[]
    id?: StringFilter<"Speaker"> | string
    segments?: TimeSegmentCompositeListFilter | TimeSegmentObjectEqualityInput[]
    confidence?: FloatFilter<"Speaker"> | number
    characteristics?: XOR<SpeakerCharacteristicsCompositeFilter, SpeakerCharacteristicsObjectEqualityInput>
  }

  export type NoiseAnalysisWhereInput = {
    AND?: NoiseAnalysisWhereInput | NoiseAnalysisWhereInput[]
    OR?: NoiseAnalysisWhereInput[]
    NOT?: NoiseAnalysisWhereInput | NoiseAnalysisWhereInput[]
    level?: FloatFilter<"NoiseAnalysis"> | number
    type?: StringNullableListFilter<"NoiseAnalysis">
    impact?: FloatFilter<"NoiseAnalysis"> | number
  }

  export type MusicAnalysisWhereInput = {
    AND?: MusicAnalysisWhereInput | MusicAnalysisWhereInput[]
    OR?: MusicAnalysisWhereInput[]
    NOT?: MusicAnalysisWhereInput | MusicAnalysisWhereInput[]
    present?: BoolFilter<"MusicAnalysis"> | boolean
    genre?: StringNullableListFilter<"MusicAnalysis">
    tempo?: FloatFilter<"MusicAnalysis"> | number
    mood?: StringNullableListFilter<"MusicAnalysis">
  }

  export type TrendWhereInput = {
    AND?: TrendWhereInput | TrendWhereInput[]
    OR?: TrendWhereInput[]
    NOT?: TrendWhereInput | TrendWhereInput[]
    name?: StringFilter<"Trend"> | string
    strength?: FloatFilter<"Trend"> | number
    direction?: StringFilter<"Trend"> | string
    timeframe?: StringFilter<"Trend"> | string
  }

  export type ModelPerformanceWhereInput = {
    AND?: ModelPerformanceWhereInput | ModelPerformanceWhereInput[]
    OR?: ModelPerformanceWhereInput[]
    NOT?: ModelPerformanceWhereInput | ModelPerformanceWhereInput[]
    latency?: FloatFilter<"ModelPerformance"> | number
    accuracy?: FloatFilter<"ModelPerformance"> | number
    confidence?: FloatFilter<"ModelPerformance"> | number
    resourceUsage?: XOR<ResourceMetricsCompositeFilter, ResourceMetricsObjectEqualityInput>
  }

  export type EntitiesUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    startPos?: NullableIntFieldUpdateOperationsInput | number | null
    endPos?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: InputJsonValue | InputJsonValue | null
  }

  export type SentimentSegmentListUpdateEnvelopeInput = {
    set?: SentimentSegmentCreateInput | SentimentSegmentCreateInput[]
    push?: SentimentSegmentCreateInput | SentimentSegmentCreateInput[]
    updateMany?: SentimentSegmentUpdateManyInput
    deleteMany?: SentimentSegmentDeleteManyInput
  }

  export type NamedEntityUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    startIndex?: IntFieldUpdateOperationsInput | number
    endIndex?: IntFieldUpdateOperationsInput | number
    metadata?: InputJsonValue | InputJsonValue | null
    wikification?: XOR<WikiDataUpdateEnvelopeInput, WikiDataCreateInput>
  }

  export type TopicAnalysisUpdateInput = {
    topic?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    subtopics?: TopicAnalysisUpdatesubtopicsInput | string[]
    relevance?: FloatFieldUpdateOperationsInput | number
    hierarchy?: TopicAnalysisUpdatehierarchyInput | string[]
    context?: XOR<TopicContextUpdateEnvelopeInput, TopicContextCreateInput>
  }

  export type KeywordUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    frequency?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    related?: KeywordUpdaterelatedInput | string[]
    importance?: XOR<KeywordMetricsUpdateEnvelopeInput, KeywordMetricsCreateInput>
  }

  export type ComplexityMetricsUpdateEnvelopeInput = {
    set?: ComplexityMetricsCreateInput
    update?: ComplexityMetricsUpdateInput
  }

  export type SourceValidationListUpdateEnvelopeInput = {
    set?: SourceValidationCreateInput | SourceValidationCreateInput[]
    push?: SourceValidationCreateInput | SourceValidationCreateInput[]
    updateMany?: SourceValidationUpdateManyInput
    deleteMany?: SourceValidationDeleteManyInput
  }

  export type StructureAnalysisUpdateEnvelopeInput = {
    set?: StructureAnalysisCreateInput
    update?: StructureAnalysisUpdateInput
  }

  export type FormattingAnalysisUpdateEnvelopeInput = {
    set?: FormattingAnalysisCreateInput
    update?: FormattingAnalysisUpdateInput
  }

  export type ToxicityCategoriesUpdateEnvelopeInput = {
    set?: ToxicityCategoriesCreateInput
    update?: ToxicityCategoriesUpdateInput
  }

  export type ThreatDetectionListUpdateEnvelopeInput = {
    set?: ThreatDetectionCreateInput | ThreatDetectionCreateInput[]
    push?: ThreatDetectionCreateInput | ThreatDetectionCreateInput[]
    updateMany?: ThreatDetectionUpdateManyInput
    deleteMany?: ThreatDetectionDeleteManyInput
  }

  export type ModerationDecisionUpdateEnvelopeInput = {
    set?: ModerationDecisionCreateInput
    update?: ModerationDecisionUpdateInput
  }

  export type ToxicitySeverityUpdateEnvelopeInput = {
    set?: ToxicitySeverityCreateInput
    update?: ToxicitySeverityUpdateInput
  }

  export type SimilarityMatchListUpdateEnvelopeInput = {
    set?: SimilarityMatchCreateInput | SimilarityMatchCreateInput[]
    push?: SimilarityMatchCreateInput | SimilarityMatchCreateInput[]
    updateMany?: SimilarityMatchUpdateManyInput
    deleteMany?: SimilarityMatchDeleteManyInput
  }

  export type PlagiarismMetricsUpdateEnvelopeInput = {
    set?: PlagiarismMetricsCreateInput
    update?: PlagiarismMetricsUpdateInput
  }

  export type LanguageAlternativeListUpdateEnvelopeInput = {
    set?: LanguageAlternativeCreateInput | LanguageAlternativeCreateInput[]
    push?: LanguageAlternativeCreateInput | LanguageAlternativeCreateInput[]
    updateMany?: LanguageAlternativeUpdateManyInput
    deleteMany?: LanguageAlternativeDeleteManyInput
  }

  export type LanguageAnalysisUpdatedialectsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LanguageAnalysisUpdatescriptsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GrammarErrorListUpdateEnvelopeInput = {
    set?: GrammarErrorCreateInput | GrammarErrorCreateInput[]
    push?: GrammarErrorCreateInput | GrammarErrorCreateInput[]
    updateMany?: GrammarErrorUpdateManyInput
    deleteMany?: GrammarErrorDeleteManyInput
  }

  export type StyleSuggestionListUpdateEnvelopeInput = {
    set?: StyleSuggestionCreateInput | StyleSuggestionCreateInput[]
    push?: StyleSuggestionCreateInput | StyleSuggestionCreateInput[]
    updateMany?: StyleSuggestionUpdateManyInput
    deleteMany?: StyleSuggestionDeleteManyInput
  }

  export type VocabularyMetricsUpdateEnvelopeInput = {
    set?: VocabularyMetricsCreateInput
    update?: VocabularyMetricsUpdateInput
  }

  export type IntentAnalysisUpdateInput = {
    primary?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    secondary?: IntentAnalysisUpdatesecondaryInput | string[]
    context?: StringFieldUpdateOperationsInput | string
  }

  export type EmotionAnalysisUpdatesecondaryInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmotionSpectrumUpdateEnvelopeInput = {
    set?: EmotionSpectrumCreateInput
    update?: EmotionSpectrumUpdateInput
  }

  export type BiasTypeListUpdateEnvelopeInput = {
    set?: BiasTypeCreateInput | BiasTypeCreateInput[]
    push?: BiasTypeCreateInput | BiasTypeCreateInput[]
    updateMany?: BiasTypeUpdateManyInput
    deleteMany?: BiasTypeDeleteManyInput
  }

  export type ImageAnalysisUpdateInput = {
    objects?: XOR<DetectedObjectListUpdateEnvelopeInput, DetectedObjectCreateInput> | DetectedObjectCreateInput[]
    faces?: XOR<FaceAnalysisListUpdateEnvelopeInput, FaceAnalysisCreateInput> | FaceAnalysisCreateInput[]
    text?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: XOR<LabelListUpdateEnvelopeInput, LabelCreateInput> | LabelCreateInput[]
    colors?: XOR<ColorAnalysisUpdateEnvelopeInput, ColorAnalysisCreateInput>
    nsfw?: XOR<NSFWAnalysisUpdateEnvelopeInput, NSFWAnalysisCreateInput>
    quality?: XOR<ImageQualityUpdateEnvelopeInput, ImageQualityCreateInput>
    composition?: XOR<ImageCompositionUpdateEnvelopeInput, ImageCompositionCreateInput>
  }

  export type VideoAnalysisUpdateInput = {
    scenes?: XOR<SceneListUpdateEnvelopeInput, SceneCreateInput> | SceneCreateInput[]
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    keyFrames?: XOR<KeyFrameListUpdateEnvelopeInput, KeyFrameCreateInput> | KeyFrameCreateInput[]
    actions?: XOR<ActionListUpdateEnvelopeInput, ActionCreateInput> | ActionCreateInput[]
    captions?: XOR<CaptionListUpdateEnvelopeInput, CaptionCreateInput> | CaptionCreateInput[]
    motion?: XOR<MotionAnalysisUpdateEnvelopeInput, MotionAnalysisCreateInput>
  }

  export type AudioAnalysisUpdateInput = {
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    speakers?: XOR<SpeakerListUpdateEnvelopeInput, SpeakerCreateInput> | SpeakerCreateInput[]
    sentiment?: XOR<SentimentAnalysisUpdateEnvelopeInput, SentimentAnalysisCreateInput>
    noise?: XOR<NoiseAnalysisUpdateEnvelopeInput, NoiseAnalysisCreateInput>
    music?: XOR<MusicAnalysisUpdateEnvelopeInput, MusicAnalysisCreateInput>
    clarity?: FloatFieldUpdateOperationsInput | number
  }

  export type TrendListUpdateEnvelopeInput = {
    set?: TrendCreateInput | TrendCreateInput[]
    push?: TrendCreateInput | TrendCreateInput[]
    updateMany?: TrendUpdateManyInput
    deleteMany?: TrendDeleteManyInput
  }

  export type MarketAnalysisUpdatecompetitionInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MarketAnalysisUpdateopportunitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CompetitiveAnalysisUpdateadvantagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CompetitiveAnalysisUpdatethreatsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CompetitiveAnalysisUpdaterecommendationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ActionItemUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    priority?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelPerformanceUpdateEnvelopeInput = {
    set?: ModelPerformanceCreateInput
    update?: ModelPerformanceUpdateInput
  }

  export type AspectSentimentCompositeListFilter = {
    equals?: AspectSentimentObjectEqualityInput[]
    every?: AspectSentimentWhereInput
    some?: AspectSentimentWhereInput
    none?: AspectSentimentWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type KeywordLocationCompositeListFilter = {
    equals?: KeywordLocationObjectEqualityInput[]
    every?: KeywordLocationWhereInput
    some?: KeywordLocationWhereInput
    none?: KeywordLocationWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type CitationCompositeListFilter = {
    equals?: CitationObjectEqualityInput[]
    every?: CitationWhereInput
    some?: CitationWhereInput
    none?: CitationWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type BoundingBoxCompositeFilter = {
    equals?: BoundingBoxObjectEqualityInput
    is?: BoundingBoxWhereInput
    isNot?: BoundingBoxWhereInput
  }

  export type FaceAttributesCompositeFilter = {
    equals?: FaceAttributesObjectEqualityInput
    is?: FaceAttributesWhereInput
    isNot?: FaceAttributesWhereInput
  }

  export type FaceLandmarkCompositeListFilter = {
    equals?: FaceLandmarkObjectEqualityInput[]
    every?: FaceLandmarkWhereInput
    some?: FaceLandmarkWhereInput
    none?: FaceLandmarkWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ColorCompositeListFilter = {
    equals?: ColorObjectEqualityInput[]
    every?: ColorWhereInput
    some?: ColorWhereInput
    none?: ColorWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type NSFWCategoriesCompositeFilter = {
    equals?: NSFWCategoriesObjectEqualityInput
    is?: NSFWCategoriesWhereInput
    isNot?: NSFWCategoriesWhereInput
  }

  export type ResolutionCompositeFilter = {
    equals?: ResolutionObjectEqualityInput
    is?: ResolutionWhereInput
    isNot?: ResolutionWhereInput
  }

  export type ImageAnalysisCompositeFilter = {
    equals?: ImageAnalysisObjectEqualityInput
    is?: ImageAnalysisWhereInput
    isNot?: ImageAnalysisWhereInput
  }

  export type TrackingDataCompositeListFilter = {
    equals?: TrackingDataObjectEqualityInput[]
    every?: TrackingDataWhereInput
    some?: TrackingDataWhereInput
    none?: TrackingDataWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type TimeSegmentCompositeListFilter = {
    equals?: TimeSegmentObjectEqualityInput[]
    every?: TimeSegmentWhereInput
    some?: TimeSegmentWhereInput
    none?: TimeSegmentWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type SpeakerCharacteristicsCompositeFilter = {
    equals?: SpeakerCharacteristicsObjectEqualityInput
    is?: SpeakerCharacteristicsWhereInput
    isNot?: SpeakerCharacteristicsWhereInput
  }

  export type ResourceMetricsCompositeFilter = {
    equals?: ResourceMetricsObjectEqualityInput
    is?: ResourceMetricsWhereInput
    isNot?: ResourceMetricsWhereInput
  }

  export type SentimentSegmentUpdateManyInput = {
    where: SentimentSegmentWhereInput
    data: SentimentSegmentUpdateInput
  }

  export type SentimentSegmentDeleteManyInput = {
    where: SentimentSegmentWhereInput
  }

  export type WikiDataUpdateEnvelopeInput = {
    set?: WikiDataCreateInput
    update?: WikiDataUpdateInput
  }

  export type TopicAnalysisUpdatesubtopicsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TopicAnalysisUpdatehierarchyInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TopicContextUpdateEnvelopeInput = {
    set?: TopicContextCreateInput
    update?: TopicContextUpdateInput
  }

  export type KeywordUpdaterelatedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type KeywordMetricsUpdateEnvelopeInput = {
    set?: KeywordMetricsCreateInput
    update?: KeywordMetricsUpdateInput
  }

  export type ComplexityMetricsUpdateInput = {
    sentenceComplexity?: FloatFieldUpdateOperationsInput | number
    wordComplexity?: FloatFieldUpdateOperationsInput | number
    technicalLevel?: StringFieldUpdateOperationsInput | string
    vocabularyDiversity?: FloatFieldUpdateOperationsInput | number
  }

  export type SourceValidationUpdateManyInput = {
    where: SourceValidationWhereInput
    data: SourceValidationUpdateInput
  }

  export type SourceValidationDeleteManyInput = {
    where: SourceValidationWhereInput
  }

  export type StructureAnalysisUpdateInput = {
    paragraphFlow?: FloatFieldUpdateOperationsInput | number
    transitionQuality?: FloatFieldUpdateOperationsInput | number
    logicalProgression?: FloatFieldUpdateOperationsInput | number
    sectioning?: FloatFieldUpdateOperationsInput | number
  }

  export type FormattingAnalysisUpdateInput = {
    consistency?: FloatFieldUpdateOperationsInput | number
    readability?: FloatFieldUpdateOperationsInput | number
    visualHierarchy?: FloatFieldUpdateOperationsInput | number
    spacing?: FloatFieldUpdateOperationsInput | number
  }

  export type ToxicityCategoriesUpdateInput = {
    hate?: FloatFieldUpdateOperationsInput | number
    harassment?: FloatFieldUpdateOperationsInput | number
    profanity?: FloatFieldUpdateOperationsInput | number
    violence?: FloatFieldUpdateOperationsInput | number
    sexual?: FloatFieldUpdateOperationsInput | number
    spam?: FloatFieldUpdateOperationsInput | number
    misleading?: FloatFieldUpdateOperationsInput | number
    bias?: FloatFieldUpdateOperationsInput | number
  }

  export type ThreatDetectionUpdateManyInput = {
    where: ThreatDetectionWhereInput
    data: ThreatDetectionUpdateInput
  }

  export type ThreatDetectionDeleteManyInput = {
    where: ThreatDetectionWhereInput
  }

  export type ModerationDecisionUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    escalation?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ToxicitySeverityUpdateInput = {
    level?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    recommendation?: StringFieldUpdateOperationsInput | string
  }

  export type SimilarityMatchUpdateManyInput = {
    where: SimilarityMatchWhereInput
    data: SimilarityMatchUpdateInput
  }

  export type SimilarityMatchDeleteManyInput = {
    where: SimilarityMatchWhereInput
  }

  export type PlagiarismMetricsUpdateInput = {
    score?: FloatFieldUpdateOperationsInput | number
    matches?: IntFieldUpdateOperationsInput | number
    sources?: PlagiarismMetricsUpdatesourcesInput | string[]
    severity?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageAlternativeUpdateManyInput = {
    where: LanguageAlternativeWhereInput
    data: LanguageAlternativeUpdateInput
  }

  export type LanguageAlternativeDeleteManyInput = {
    where: LanguageAlternativeWhereInput
  }

  export type GrammarErrorUpdateManyInput = {
    where: GrammarErrorWhereInput
    data: GrammarErrorUpdateInput
  }

  export type GrammarErrorDeleteManyInput = {
    where: GrammarErrorWhereInput
  }

  export type StyleSuggestionUpdateManyInput = {
    where: StyleSuggestionWhereInput
    data: StyleSuggestionUpdateInput
  }

  export type StyleSuggestionDeleteManyInput = {
    where: StyleSuggestionWhereInput
  }

  export type VocabularyMetricsUpdateInput = {
    diversity?: FloatFieldUpdateOperationsInput | number
    sophistication?: FloatFieldUpdateOperationsInput | number
    jargon?: FloatFieldUpdateOperationsInput | number
    accessibility?: FloatFieldUpdateOperationsInput | number
  }

  export type IntentAnalysisUpdatesecondaryInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmotionSpectrumUpdateInput = {
    joy?: FloatFieldUpdateOperationsInput | number
    sadness?: FloatFieldUpdateOperationsInput | number
    anger?: FloatFieldUpdateOperationsInput | number
    fear?: FloatFieldUpdateOperationsInput | number
    surprise?: FloatFieldUpdateOperationsInput | number
    disgust?: FloatFieldUpdateOperationsInput | number
  }

  export type BiasTypeUpdateManyInput = {
    where: BiasTypeWhereInput
    data: BiasTypeUpdateInput
  }

  export type BiasTypeDeleteManyInput = {
    where: BiasTypeWhereInput
  }

  export type DetectedObjectListUpdateEnvelopeInput = {
    set?: DetectedObjectCreateInput | DetectedObjectCreateInput[]
    push?: DetectedObjectCreateInput | DetectedObjectCreateInput[]
    updateMany?: DetectedObjectUpdateManyInput
    deleteMany?: DetectedObjectDeleteManyInput
  }

  export type FaceAnalysisListUpdateEnvelopeInput = {
    set?: FaceAnalysisCreateInput | FaceAnalysisCreateInput[]
    push?: FaceAnalysisCreateInput | FaceAnalysisCreateInput[]
    updateMany?: FaceAnalysisUpdateManyInput
    deleteMany?: FaceAnalysisDeleteManyInput
  }

  export type LabelListUpdateEnvelopeInput = {
    set?: LabelCreateInput | LabelCreateInput[]
    push?: LabelCreateInput | LabelCreateInput[]
    updateMany?: LabelUpdateManyInput
    deleteMany?: LabelDeleteManyInput
  }

  export type ColorAnalysisUpdateEnvelopeInput = {
    set?: ColorAnalysisCreateInput
    update?: ColorAnalysisUpdateInput
  }

  export type NSFWAnalysisUpdateEnvelopeInput = {
    set?: NSFWAnalysisCreateInput
    update?: NSFWAnalysisUpdateInput
  }

  export type ImageQualityUpdateEnvelopeInput = {
    set?: ImageQualityCreateInput
    update?: ImageQualityUpdateInput
  }

  export type ImageCompositionUpdateEnvelopeInput = {
    set?: ImageCompositionCreateInput
    update?: ImageCompositionUpdateInput
  }

  export type SceneListUpdateEnvelopeInput = {
    set?: SceneCreateInput | SceneCreateInput[]
    push?: SceneCreateInput | SceneCreateInput[]
    updateMany?: SceneUpdateManyInput
    deleteMany?: SceneDeleteManyInput
  }

  export type KeyFrameListUpdateEnvelopeInput = {
    set?: KeyFrameCreateInput | KeyFrameCreateInput[]
    push?: KeyFrameCreateInput | KeyFrameCreateInput[]
    updateMany?: KeyFrameUpdateManyInput
    deleteMany?: KeyFrameDeleteManyInput
  }

  export type ActionListUpdateEnvelopeInput = {
    set?: ActionCreateInput | ActionCreateInput[]
    push?: ActionCreateInput | ActionCreateInput[]
    updateMany?: ActionUpdateManyInput
    deleteMany?: ActionDeleteManyInput
  }

  export type CaptionListUpdateEnvelopeInput = {
    set?: CaptionCreateInput | CaptionCreateInput[]
    push?: CaptionCreateInput | CaptionCreateInput[]
    updateMany?: CaptionUpdateManyInput
    deleteMany?: CaptionDeleteManyInput
  }

  export type MotionAnalysisUpdateEnvelopeInput = {
    set?: MotionAnalysisCreateInput
    update?: MotionAnalysisUpdateInput
  }

  export type SpeakerListUpdateEnvelopeInput = {
    set?: SpeakerCreateInput | SpeakerCreateInput[]
    push?: SpeakerCreateInput | SpeakerCreateInput[]
    updateMany?: SpeakerUpdateManyInput
    deleteMany?: SpeakerDeleteManyInput
  }

  export type NoiseAnalysisUpdateEnvelopeInput = {
    set?: NoiseAnalysisCreateInput
    update?: NoiseAnalysisUpdateInput
  }

  export type MusicAnalysisUpdateEnvelopeInput = {
    set?: MusicAnalysisCreateInput
    update?: MusicAnalysisUpdateInput
  }

  export type TrendUpdateManyInput = {
    where: TrendWhereInput
    data: TrendUpdateInput
  }

  export type TrendDeleteManyInput = {
    where: TrendWhereInput
  }

  export type ModelPerformanceUpdateInput = {
    latency?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    resourceUsage?: XOR<ResourceMetricsUpdateEnvelopeInput, ResourceMetricsCreateInput>
  }

  export type AspectSentimentWhereInput = {
    AND?: AspectSentimentWhereInput | AspectSentimentWhereInput[]
    OR?: AspectSentimentWhereInput[]
    NOT?: AspectSentimentWhereInput | AspectSentimentWhereInput[]
    aspect?: StringFilter<"AspectSentiment"> | string
    sentiment?: FloatFilter<"AspectSentiment"> | number
    confidence?: FloatFilter<"AspectSentiment"> | number
  }

  export type KeywordLocationWhereInput = {
    AND?: KeywordLocationWhereInput | KeywordLocationWhereInput[]
    OR?: KeywordLocationWhereInput[]
    NOT?: KeywordLocationWhereInput | KeywordLocationWhereInput[]
    startIndex?: IntFilter<"KeywordLocation"> | number
    endIndex?: IntFilter<"KeywordLocation"> | number
    context?: StringFilter<"KeywordLocation"> | string
  }

  export type CitationWhereInput = {
    AND?: CitationWhereInput | CitationWhereInput[]
    OR?: CitationWhereInput[]
    NOT?: CitationWhereInput | CitationWhereInput[]
    text?: StringFilter<"Citation"> | string
    source?: StringFilter<"Citation"> | string
    page?: IntNullableFilter<"Citation"> | number | null
    confidence?: FloatFilter<"Citation"> | number
  }

  export type BoundingBoxWhereInput = {
    AND?: BoundingBoxWhereInput | BoundingBoxWhereInput[]
    OR?: BoundingBoxWhereInput[]
    NOT?: BoundingBoxWhereInput | BoundingBoxWhereInput[]
    x?: FloatFilter<"BoundingBox"> | number
    y?: FloatFilter<"BoundingBox"> | number
    width?: FloatFilter<"BoundingBox"> | number
    height?: FloatFilter<"BoundingBox"> | number
  }

  export type FaceAttributesWhereInput = {
    AND?: FaceAttributesWhereInput | FaceAttributesWhereInput[]
    OR?: FaceAttributesWhereInput[]
    NOT?: FaceAttributesWhereInput | FaceAttributesWhereInput[]
    age?: IntNullableFilter<"FaceAttributes"> | number | null
    gender?: StringNullableFilter<"FaceAttributes"> | string | null
    expression?: StringNullableFilter<"FaceAttributes"> | string | null
    glasses?: BoolFilter<"FaceAttributes"> | boolean
    features?: JsonFilter<"FaceAttributes">
  }

  export type FaceLandmarkWhereInput = {
    AND?: FaceLandmarkWhereInput | FaceLandmarkWhereInput[]
    OR?: FaceLandmarkWhereInput[]
    NOT?: FaceLandmarkWhereInput | FaceLandmarkWhereInput[]
    type?: StringFilter<"FaceLandmark"> | string
    position?: XOR<PointCompositeFilter, PointObjectEqualityInput>
    confidence?: FloatFilter<"FaceLandmark"> | number
  }

  export type ColorWhereInput = {
    AND?: ColorWhereInput | ColorWhereInput[]
    OR?: ColorWhereInput[]
    NOT?: ColorWhereInput | ColorWhereInput[]
    hex?: StringFilter<"Color"> | string
    rgb?: XOR<RGBCompositeFilter, RGBObjectEqualityInput>
    percentage?: FloatFilter<"Color"> | number
  }

  export type NSFWCategoriesWhereInput = {
    AND?: NSFWCategoriesWhereInput | NSFWCategoriesWhereInput[]
    OR?: NSFWCategoriesWhereInput[]
    NOT?: NSFWCategoriesWhereInput | NSFWCategoriesWhereInput[]
    explicit?: FloatFilter<"NSFWCategories"> | number
    suggestive?: FloatFilter<"NSFWCategories"> | number
    violence?: FloatFilter<"NSFWCategories"> | number
    disturbing?: FloatFilter<"NSFWCategories"> | number
  }

  export type ResolutionWhereInput = {
    AND?: ResolutionWhereInput | ResolutionWhereInput[]
    OR?: ResolutionWhereInput[]
    NOT?: ResolutionWhereInput | ResolutionWhereInput[]
    width?: IntFilter<"Resolution"> | number
    height?: IntFilter<"Resolution"> | number
    aspectRatio?: FloatFilter<"Resolution"> | number
  }

  export type TrackingDataWhereInput = {
    AND?: TrackingDataWhereInput | TrackingDataWhereInput[]
    OR?: TrackingDataWhereInput[]
    NOT?: TrackingDataWhereInput | TrackingDataWhereInput[]
    object?: StringFilter<"TrackingData"> | string
    path?: JsonFilter<"TrackingData">
    confidence?: FloatFilter<"TrackingData"> | number
  }

  export type TimeSegmentWhereInput = {
    AND?: TimeSegmentWhereInput | TimeSegmentWhereInput[]
    OR?: TimeSegmentWhereInput[]
    NOT?: TimeSegmentWhereInput | TimeSegmentWhereInput[]
    startTime?: FloatFilter<"TimeSegment"> | number
    endTime?: FloatFilter<"TimeSegment"> | number
    text?: StringFilter<"TimeSegment"> | string
  }

  export type SpeakerCharacteristicsWhereInput = {
    AND?: SpeakerCharacteristicsWhereInput | SpeakerCharacteristicsWhereInput[]
    OR?: SpeakerCharacteristicsWhereInput[]
    NOT?: SpeakerCharacteristicsWhereInput | SpeakerCharacteristicsWhereInput[]
    gender?: StringNullableFilter<"SpeakerCharacteristics"> | string | null
    age?: StringNullableFilter<"SpeakerCharacteristics"> | string | null
    accent?: StringNullableFilter<"SpeakerCharacteristics"> | string | null
    emotion?: XOR<EmotionAnalysisCompositeFilter, EmotionAnalysisObjectEqualityInput>
  }

  export type ResourceMetricsWhereInput = {
    AND?: ResourceMetricsWhereInput | ResourceMetricsWhereInput[]
    OR?: ResourceMetricsWhereInput[]
    NOT?: ResourceMetricsWhereInput | ResourceMetricsWhereInput[]
    cpuTime?: FloatFilter<"ResourceMetrics"> | number
    memoryUsage?: FloatFilter<"ResourceMetrics"> | number
    cost?: FloatFilter<"ResourceMetrics"> | number
  }

  export type SentimentSegmentUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    sentiment?: FloatFieldUpdateOperationsInput | number
    startIndex?: IntFieldUpdateOperationsInput | number
    endIndex?: IntFieldUpdateOperationsInput | number
    aspects?: XOR<AspectSentimentListUpdateEnvelopeInput, AspectSentimentCreateInput> | AspectSentimentCreateInput[]
  }

  export type WikiDataUpdateInput = {
    entityId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TopicContextUpdateInput = {
    domain?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    parentTopics?: TopicContextUpdateparentTopicsInput | string[]
    relatedTopics?: TopicContextUpdaterelatedTopicsInput | string[]
  }

  export type KeywordMetricsUpdateInput = {
    tfIdf?: FloatFieldUpdateOperationsInput | number
    textRank?: FloatFieldUpdateOperationsInput | number
    prominence?: FloatFieldUpdateOperationsInput | number
    location?: XOR<KeywordLocationListUpdateEnvelopeInput, KeywordLocationCreateInput> | KeywordLocationCreateInput[]
  }

  export type SourceValidationUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    credibility?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    citations?: XOR<CitationListUpdateEnvelopeInput, CitationCreateInput> | CitationCreateInput[]
  }

  export type ThreatDetectionUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    severity?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    context?: StringFieldUpdateOperationsInput | string
  }

  export type SimilarityMatchUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    context?: StringFieldUpdateOperationsInput | string
  }

  export type PlagiarismMetricsUpdatesourcesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LanguageAlternativeUpdateInput = {
    language?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
  }

  export type GrammarErrorUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    suggestion?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    severity?: FloatFieldUpdateOperationsInput | number
  }

  export type StyleSuggestionUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    suggestion?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    importance?: FloatFieldUpdateOperationsInput | number
  }

  export type BiasTypeUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    evidence?: BiasTypeUpdateevidenceInput | string[]
  }

  export type DetectedObjectUpdateManyInput = {
    where: DetectedObjectWhereInput
    data: DetectedObjectUpdateInput
  }

  export type DetectedObjectDeleteManyInput = {
    where: DetectedObjectWhereInput
  }

  export type FaceAnalysisUpdateManyInput = {
    where: FaceAnalysisWhereInput
    data: FaceAnalysisUpdateInput
  }

  export type FaceAnalysisDeleteManyInput = {
    where: FaceAnalysisWhereInput
  }

  export type LabelUpdateManyInput = {
    where: LabelWhereInput
    data: LabelUpdateInput
  }

  export type LabelDeleteManyInput = {
    where: LabelWhereInput
  }

  export type ColorAnalysisUpdateInput = {
    dominant?: XOR<ColorListUpdateEnvelopeInput, ColorCreateInput> | ColorCreateInput[]
    palette?: XOR<ColorListUpdateEnvelopeInput, ColorCreateInput> | ColorCreateInput[]
    brightness?: FloatFieldUpdateOperationsInput | number
    contrast?: FloatFieldUpdateOperationsInput | number
  }

  export type NSFWAnalysisUpdateInput = {
    score?: FloatFieldUpdateOperationsInput | number
    categories?: XOR<NSFWCategoriesUpdateEnvelopeInput, NSFWCategoriesCreateInput>
    confidence?: FloatFieldUpdateOperationsInput | number
  }

  export type ImageQualityUpdateInput = {
    resolution?: XOR<ResolutionUpdateEnvelopeInput, ResolutionCreateInput>
    sharpness?: FloatFieldUpdateOperationsInput | number
    brightness?: FloatFieldUpdateOperationsInput | number
    noise?: FloatFieldUpdateOperationsInput | number
  }

  export type ImageCompositionUpdateInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    symmetry?: FloatFieldUpdateOperationsInput | number
    focus?: FloatFieldUpdateOperationsInput | number
    aesthetic?: FloatFieldUpdateOperationsInput | number
  }

  export type SceneUpdateManyInput = {
    where: SceneWhereInput
    data: SceneUpdateInput
  }

  export type SceneDeleteManyInput = {
    where: SceneWhereInput
  }

  export type KeyFrameUpdateManyInput = {
    where: KeyFrameWhereInput
    data: KeyFrameUpdateInput
  }

  export type KeyFrameDeleteManyInput = {
    where: KeyFrameWhereInput
  }

  export type ActionUpdateManyInput = {
    where: ActionWhereInput
    data: ActionUpdateInput
  }

  export type ActionDeleteManyInput = {
    where: ActionWhereInput
  }

  export type CaptionUpdateManyInput = {
    where: CaptionWhereInput
    data: CaptionUpdateInput
  }

  export type CaptionDeleteManyInput = {
    where: CaptionWhereInput
  }

  export type MotionAnalysisUpdateInput = {
    activity?: FloatFieldUpdateOperationsInput | number
    stability?: FloatFieldUpdateOperationsInput | number
    tracking?: XOR<TrackingDataListUpdateEnvelopeInput, TrackingDataCreateInput> | TrackingDataCreateInput[]
  }

  export type SpeakerUpdateManyInput = {
    where: SpeakerWhereInput
    data: SpeakerUpdateInput
  }

  export type SpeakerDeleteManyInput = {
    where: SpeakerWhereInput
  }

  export type NoiseAnalysisUpdateInput = {
    level?: FloatFieldUpdateOperationsInput | number
    type?: NoiseAnalysisUpdatetypeInput | string[]
    impact?: FloatFieldUpdateOperationsInput | number
  }

  export type MusicAnalysisUpdateInput = {
    present?: BoolFieldUpdateOperationsInput | boolean
    genre?: MusicAnalysisUpdategenreInput | string[]
    tempo?: FloatFieldUpdateOperationsInput | number
    mood?: MusicAnalysisUpdatemoodInput | string[]
  }

  export type TrendUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    direction?: StringFieldUpdateOperationsInput | string
    timeframe?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceMetricsUpdateEnvelopeInput = {
    set?: ResourceMetricsCreateInput
    update?: ResourceMetricsUpdateInput
  }

  export type PointCompositeFilter = {
    equals?: PointObjectEqualityInput
    is?: PointWhereInput
    isNot?: PointWhereInput
  }

  export type RGBCompositeFilter = {
    equals?: RGBObjectEqualityInput
    is?: RGBWhereInput
    isNot?: RGBWhereInput
  }

  export type AspectSentimentListUpdateEnvelopeInput = {
    set?: AspectSentimentCreateInput | AspectSentimentCreateInput[]
    push?: AspectSentimentCreateInput | AspectSentimentCreateInput[]
    updateMany?: AspectSentimentUpdateManyInput
    deleteMany?: AspectSentimentDeleteManyInput
  }

  export type TopicContextUpdateparentTopicsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TopicContextUpdaterelatedTopicsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type KeywordLocationListUpdateEnvelopeInput = {
    set?: KeywordLocationCreateInput | KeywordLocationCreateInput[]
    push?: KeywordLocationCreateInput | KeywordLocationCreateInput[]
    updateMany?: KeywordLocationUpdateManyInput
    deleteMany?: KeywordLocationDeleteManyInput
  }

  export type CitationListUpdateEnvelopeInput = {
    set?: CitationCreateInput | CitationCreateInput[]
    push?: CitationCreateInput | CitationCreateInput[]
    updateMany?: CitationUpdateManyInput
    deleteMany?: CitationDeleteManyInput
  }

  export type BiasTypeUpdateevidenceInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DetectedObjectUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    boundingBox?: XOR<BoundingBoxUpdateEnvelopeInput, BoundingBoxCreateInput>
    attributes?: InputJsonValue | InputJsonValue
  }

  export type FaceAnalysisUpdateInput = {
    boundingBox?: XOR<BoundingBoxUpdateEnvelopeInput, BoundingBoxCreateInput>
    emotions?: XOR<EmotionAnalysisUpdateEnvelopeInput, EmotionAnalysisCreateInput>
    attributes?: XOR<FaceAttributesUpdateEnvelopeInput, FaceAttributesCreateInput>
    landmarks?: XOR<FaceLandmarkListUpdateEnvelopeInput, FaceLandmarkCreateInput> | FaceLandmarkCreateInput[]
  }

  export type LabelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    parents?: LabelUpdateparentsInput | string[]
  }

  export type ColorListUpdateEnvelopeInput = {
    set?: ColorCreateInput | ColorCreateInput[]
    push?: ColorCreateInput | ColorCreateInput[]
    updateMany?: ColorUpdateManyInput
    deleteMany?: ColorDeleteManyInput
  }

  export type NSFWCategoriesUpdateEnvelopeInput = {
    set?: NSFWCategoriesCreateInput
    update?: NSFWCategoriesUpdateInput
  }

  export type ResolutionUpdateEnvelopeInput = {
    set?: ResolutionCreateInput
    update?: ResolutionUpdateInput
  }

  export type SceneUpdateInput = {
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    keyFrames?: XOR<KeyFrameListUpdateEnvelopeInput, KeyFrameCreateInput> | KeyFrameCreateInput[]
    description?: StringFieldUpdateOperationsInput | string
  }

  export type KeyFrameUpdateInput = {
    timestamp?: FloatFieldUpdateOperationsInput | number
    image?: XOR<ImageAnalysisUpdateEnvelopeInput, ImageAnalysisCreateInput>
    importance?: FloatFieldUpdateOperationsInput | number
  }

  export type ActionUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
  }

  export type CaptionUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
  }

  export type TrackingDataListUpdateEnvelopeInput = {
    set?: TrackingDataCreateInput | TrackingDataCreateInput[]
    push?: TrackingDataCreateInput | TrackingDataCreateInput[]
    updateMany?: TrackingDataUpdateManyInput
    deleteMany?: TrackingDataDeleteManyInput
  }

  export type SpeakerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    segments?: XOR<TimeSegmentListUpdateEnvelopeInput, TimeSegmentCreateInput> | TimeSegmentCreateInput[]
    confidence?: FloatFieldUpdateOperationsInput | number
    characteristics?: XOR<SpeakerCharacteristicsUpdateEnvelopeInput, SpeakerCharacteristicsCreateInput>
  }

  export type NoiseAnalysisUpdatetypeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MusicAnalysisUpdategenreInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MusicAnalysisUpdatemoodInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ResourceMetricsUpdateInput = {
    cpuTime?: FloatFieldUpdateOperationsInput | number
    memoryUsage?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
  }

  export type PointWhereInput = {
    AND?: PointWhereInput | PointWhereInput[]
    OR?: PointWhereInput[]
    NOT?: PointWhereInput | PointWhereInput[]
    x?: FloatFilter<"Point"> | number
    y?: FloatFilter<"Point"> | number
  }

  export type RGBWhereInput = {
    AND?: RGBWhereInput | RGBWhereInput[]
    OR?: RGBWhereInput[]
    NOT?: RGBWhereInput | RGBWhereInput[]
    red?: IntFilter<"RGB"> | number
    green?: IntFilter<"RGB"> | number
    blue?: IntFilter<"RGB"> | number
  }

  export type AspectSentimentUpdateManyInput = {
    where: AspectSentimentWhereInput
    data: AspectSentimentUpdateInput
  }

  export type AspectSentimentDeleteManyInput = {
    where: AspectSentimentWhereInput
  }

  export type KeywordLocationUpdateManyInput = {
    where: KeywordLocationWhereInput
    data: KeywordLocationUpdateInput
  }

  export type KeywordLocationDeleteManyInput = {
    where: KeywordLocationWhereInput
  }

  export type CitationUpdateManyInput = {
    where: CitationWhereInput
    data: CitationUpdateInput
  }

  export type CitationDeleteManyInput = {
    where: CitationWhereInput
  }

  export type BoundingBoxUpdateEnvelopeInput = {
    set?: BoundingBoxCreateInput
    update?: BoundingBoxUpdateInput
  }

  export type FaceAttributesUpdateEnvelopeInput = {
    set?: FaceAttributesCreateInput
    update?: FaceAttributesUpdateInput
  }

  export type FaceLandmarkListUpdateEnvelopeInput = {
    set?: FaceLandmarkCreateInput | FaceLandmarkCreateInput[]
    push?: FaceLandmarkCreateInput | FaceLandmarkCreateInput[]
    updateMany?: FaceLandmarkUpdateManyInput
    deleteMany?: FaceLandmarkDeleteManyInput
  }

  export type LabelUpdateparentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ColorUpdateManyInput = {
    where: ColorWhereInput
    data: ColorUpdateInput
  }

  export type ColorDeleteManyInput = {
    where: ColorWhereInput
  }

  export type NSFWCategoriesUpdateInput = {
    explicit?: FloatFieldUpdateOperationsInput | number
    suggestive?: FloatFieldUpdateOperationsInput | number
    violence?: FloatFieldUpdateOperationsInput | number
    disturbing?: FloatFieldUpdateOperationsInput | number
  }

  export type ResolutionUpdateInput = {
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    aspectRatio?: FloatFieldUpdateOperationsInput | number
  }

  export type ImageAnalysisUpdateEnvelopeInput = {
    set?: ImageAnalysisCreateInput
    update?: ImageAnalysisUpdateInput
  }

  export type TrackingDataUpdateManyInput = {
    where: TrackingDataWhereInput
    data: TrackingDataUpdateInput
  }

  export type TrackingDataDeleteManyInput = {
    where: TrackingDataWhereInput
  }

  export type TimeSegmentListUpdateEnvelopeInput = {
    set?: TimeSegmentCreateInput | TimeSegmentCreateInput[]
    push?: TimeSegmentCreateInput | TimeSegmentCreateInput[]
    updateMany?: TimeSegmentUpdateManyInput
    deleteMany?: TimeSegmentDeleteManyInput
  }

  export type SpeakerCharacteristicsUpdateEnvelopeInput = {
    set?: SpeakerCharacteristicsCreateInput
    update?: SpeakerCharacteristicsUpdateInput
  }

  export type AspectSentimentUpdateInput = {
    aspect?: StringFieldUpdateOperationsInput | string
    sentiment?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
  }

  export type KeywordLocationUpdateInput = {
    startIndex?: IntFieldUpdateOperationsInput | number
    endIndex?: IntFieldUpdateOperationsInput | number
    context?: StringFieldUpdateOperationsInput | string
  }

  export type CitationUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    page?: NullableIntFieldUpdateOperationsInput | number | null
    confidence?: FloatFieldUpdateOperationsInput | number
  }

  export type BoundingBoxUpdateInput = {
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
  }

  export type FaceAttributesUpdateInput = {
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    expression?: NullableStringFieldUpdateOperationsInput | string | null
    glasses?: BoolFieldUpdateOperationsInput | boolean
    features?: InputJsonValue | InputJsonValue
  }

  export type FaceLandmarkUpdateManyInput = {
    where: FaceLandmarkWhereInput
    data: FaceLandmarkUpdateInput
  }

  export type FaceLandmarkDeleteManyInput = {
    where: FaceLandmarkWhereInput
  }

  export type ColorUpdateInput = {
    hex?: StringFieldUpdateOperationsInput | string
    rgb?: XOR<RGBUpdateEnvelopeInput, RGBCreateInput>
    percentage?: FloatFieldUpdateOperationsInput | number
  }

  export type TrackingDataUpdateInput = {
    object?: StringFieldUpdateOperationsInput | string
    path?: InputJsonValue | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
  }

  export type TimeSegmentUpdateManyInput = {
    where: TimeSegmentWhereInput
    data: TimeSegmentUpdateInput
  }

  export type TimeSegmentDeleteManyInput = {
    where: TimeSegmentWhereInput
  }

  export type SpeakerCharacteristicsUpdateInput = {
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableStringFieldUpdateOperationsInput | string | null
    accent?: NullableStringFieldUpdateOperationsInput | string | null
    emotion?: XOR<EmotionAnalysisUpdateEnvelopeInput, EmotionAnalysisCreateInput>
  }

  export type FaceLandmarkUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    position?: XOR<PointUpdateEnvelopeInput, PointCreateInput>
    confidence?: FloatFieldUpdateOperationsInput | number
  }

  export type RGBUpdateEnvelopeInput = {
    set?: RGBCreateInput
    update?: RGBUpdateInput
  }

  export type TimeSegmentUpdateInput = {
    startTime?: FloatFieldUpdateOperationsInput | number
    endTime?: FloatFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type PointUpdateEnvelopeInput = {
    set?: PointCreateInput
    update?: PointUpdateInput
  }

  export type RGBUpdateInput = {
    red?: IntFieldUpdateOperationsInput | number
    green?: IntFieldUpdateOperationsInput | number
    blue?: IntFieldUpdateOperationsInput | number
  }

  export type PointUpdateInput = {
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use MediaCountOutputTypeDefaultArgs instead
     */
    export type MediaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostCountOutputTypeDefaultArgs instead
     */
    export type PostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PollPostCountOutputTypeDefaultArgs instead
     */
    export type PollPostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PollPostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpaceCountOutputTypeDefaultArgs instead
     */
    export type SpaceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpaceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelCountOutputTypeDefaultArgs instead
     */
    export type ChannelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ThreadCountOutputTypeDefaultArgs instead
     */
    export type ThreadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ThreadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentCountOutputTypeDefaultArgs instead
     */
    export type CommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FileCountOutputTypeDefaultArgs instead
     */
    export type FileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntitiesDefaultArgs instead
     */
    export type EntitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntitiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SentimentDefaultArgs instead
     */
    export type SentimentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SentimentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContentInsightsDefaultArgs instead
     */
    export type ContentInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContentInsightsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SearchMetadataDefaultArgs instead
     */
    export type SearchMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SearchMetadataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FileMetadataDefaultArgs instead
     */
    export type FileMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FileMetadataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DimensionsDefaultArgs instead
     */
    export type DimensionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DimensionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AIAnalysisDefaultArgs instead
     */
    export type AIAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AIAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SentimentAnalysisDefaultArgs instead
     */
    export type SentimentAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SentimentAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SentimentSegmentDefaultArgs instead
     */
    export type SentimentSegmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SentimentSegmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AspectSentimentDefaultArgs instead
     */
    export type AspectSentimentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AspectSentimentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NamedEntityDefaultArgs instead
     */
    export type NamedEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NamedEntityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WikiDataDefaultArgs instead
     */
    export type WikiDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WikiDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TopicAnalysisDefaultArgs instead
     */
    export type TopicAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TopicAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TopicContextDefaultArgs instead
     */
    export type TopicContextArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TopicContextDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KeywordDefaultArgs instead
     */
    export type KeywordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KeywordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KeywordMetricsDefaultArgs instead
     */
    export type KeywordMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KeywordMetricsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KeywordLocationDefaultArgs instead
     */
    export type KeywordLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KeywordLocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReadabilityMetricsDefaultArgs instead
     */
    export type ReadabilityMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReadabilityMetricsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComplexityMetricsDefaultArgs instead
     */
    export type ComplexityMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComplexityMetricsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContentQualityDefaultArgs instead
     */
    export type ContentQualityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContentQualityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SourceValidationDefaultArgs instead
     */
    export type SourceValidationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SourceValidationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CitationDefaultArgs instead
     */
    export type CitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CitationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StructureAnalysisDefaultArgs instead
     */
    export type StructureAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StructureAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormattingAnalysisDefaultArgs instead
     */
    export type FormattingAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormattingAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ToxicityAnalysisDefaultArgs instead
     */
    export type ToxicityAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ToxicityAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ToxicityCategoriesDefaultArgs instead
     */
    export type ToxicityCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ToxicityCategoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ThreatDetectionDefaultArgs instead
     */
    export type ThreatDetectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ThreatDetectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModerationDecisionDefaultArgs instead
     */
    export type ModerationDecisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModerationDecisionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ToxicitySeverityDefaultArgs instead
     */
    export type ToxicitySeverityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ToxicitySeverityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OriginalityScoreDefaultArgs instead
     */
    export type OriginalityScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OriginalityScoreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SimilarityMatchDefaultArgs instead
     */
    export type SimilarityMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SimilarityMatchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlagiarismMetricsDefaultArgs instead
     */
    export type PlagiarismMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlagiarismMetricsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageAnalysisDefaultArgs instead
     */
    export type LanguageAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguageAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageAlternativeDefaultArgs instead
     */
    export type LanguageAlternativeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguageAlternativeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TranslationInfoDefaultArgs instead
     */
    export type TranslationInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TranslationInfoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GrammarAnalysisDefaultArgs instead
     */
    export type GrammarAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GrammarAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GrammarErrorDefaultArgs instead
     */
    export type GrammarErrorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GrammarErrorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StyleSuggestionDefaultArgs instead
     */
    export type StyleSuggestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StyleSuggestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StyleMetricsDefaultArgs instead
     */
    export type StyleMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StyleMetricsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VocabularyMetricsDefaultArgs instead
     */
    export type VocabularyMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VocabularyMetricsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntentAnalysisDefaultArgs instead
     */
    export type IntentAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntentAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmotionAnalysisDefaultArgs instead
     */
    export type EmotionAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmotionAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmotionSpectrumDefaultArgs instead
     */
    export type EmotionSpectrumArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmotionSpectrumDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BiasAnalysisDefaultArgs instead
     */
    export type BiasAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BiasAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BiasTypeDefaultArgs instead
     */
    export type BiasTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BiasTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImageAnalysisDefaultArgs instead
     */
    export type ImageAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImageAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DetectedObjectDefaultArgs instead
     */
    export type DetectedObjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DetectedObjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FaceAnalysisDefaultArgs instead
     */
    export type FaceAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FaceAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BoundingBoxDefaultArgs instead
     */
    export type BoundingBoxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BoundingBoxDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LabelDefaultArgs instead
     */
    export type LabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LabelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ColorAnalysisDefaultArgs instead
     */
    export type ColorAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ColorAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ColorDefaultArgs instead
     */
    export type ColorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ColorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RGBDefaultArgs instead
     */
    export type RGBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RGBDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NSFWAnalysisDefaultArgs instead
     */
    export type NSFWAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NSFWAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NSFWCategoriesDefaultArgs instead
     */
    export type NSFWCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NSFWCategoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImageQualityDefaultArgs instead
     */
    export type ImageQualityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImageQualityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResolutionDefaultArgs instead
     */
    export type ResolutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResolutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImageCompositionDefaultArgs instead
     */
    export type ImageCompositionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImageCompositionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoAnalysisDefaultArgs instead
     */
    export type VideoAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SceneDefaultArgs instead
     */
    export type SceneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SceneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KeyFrameDefaultArgs instead
     */
    export type KeyFrameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KeyFrameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActionDefaultArgs instead
     */
    export type ActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CaptionDefaultArgs instead
     */
    export type CaptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CaptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MotionAnalysisDefaultArgs instead
     */
    export type MotionAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MotionAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrackingDataDefaultArgs instead
     */
    export type TrackingDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrackingDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudioAnalysisDefaultArgs instead
     */
    export type AudioAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpeakerDefaultArgs instead
     */
    export type SpeakerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpeakerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimeSegmentDefaultArgs instead
     */
    export type TimeSegmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimeSegmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpeakerCharacteristicsDefaultArgs instead
     */
    export type SpeakerCharacteristicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpeakerCharacteristicsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NoiseAnalysisDefaultArgs instead
     */
    export type NoiseAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NoiseAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MusicAnalysisDefaultArgs instead
     */
    export type MusicAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MusicAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketAnalysisDefaultArgs instead
     */
    export type MarketAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrendDefaultArgs instead
     */
    export type TrendArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrendDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompetitiveAnalysisDefaultArgs instead
     */
    export type CompetitiveAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompetitiveAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActionItemDefaultArgs instead
     */
    export type ActionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActionItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModelMetadataDefaultArgs instead
     */
    export type ModelMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModelMetadataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModelPerformanceDefaultArgs instead
     */
    export type ModelPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModelPerformanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResourceMetricsDefaultArgs instead
     */
    export type ResourceMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResourceMetricsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FaceAttributesDefaultArgs instead
     */
    export type FaceAttributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FaceAttributesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FaceLandmarkDefaultArgs instead
     */
    export type FaceLandmarkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FaceLandmarkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PointDefaultArgs instead
     */
    export type PointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PointDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaDefaultArgs instead
     */
    export type MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostDefaultArgs instead
     */
    export type PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PollPostDefaultArgs instead
     */
    export type PollPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PollPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpaceDefaultArgs instead
     */
    export type SpaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelDefaultArgs instead
     */
    export type ChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ThreadDefaultArgs instead
     */
    export type ThreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ThreadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NoteDefaultArgs instead
     */
    export type NoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentReplyDefaultArgs instead
     */
    export type CommentReplyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentReplyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpaceMemberDefaultArgs instead
     */
    export type SpaceMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpaceMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelMemberDefaultArgs instead
     */
    export type ChannelMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FileDefaultArgs instead
     */
    export type FileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FileToPostDefaultArgs instead
     */
    export type FileToPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FileToPostDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}